{"version":3,"sources":["../../../src/common/internal/test_group.ts"],"names":["SkipTestCase","UnexpectedPassError","builderIterateCasesWithSubcases","kUnitCaseParamsBuilder","TestCaseRecorder","extractPublicParams","mergeParams","compareQueries","Ordering","TestQuerySingleCase","kPathSeparator","stringifyPublicParams","stringifyPublicParamsUniquely","validQueryPart","assert","unreachable","makeTestGroup","fixture","TestGroup","makeTestGroupForUnitTesting","seen","Set","tests","constructor","iterate","checkName","name","decodeURIComponent","has","add","test","testCreationStack","Error","parts","split","p","TestBuilder","push","validate","testCases","undefined","batchSize","testPath","isUnimplemented","desc","description","trim","specURL","url","beforeAllSubcases","fn","beforeFn","testFn","batch","b","unimplemented","testPathString","join","s","stack","caseParams","subcases","subcaseParams","params","testcaseString","testcaseStringUnique","cases","Function","paramsSimple","combineWithParams","paramsSubcasesOnly","beginSubcases","RunCaseSpecific","subcaseArray","Array","from","length","i","batch__","slice","Math","min","id","runTest","rec","sharedState","throwSkip","expectedStatus","beginSubCase","inst","init","finalize","ex","threw","endSubCase","message","warn","run","selfQuery","expectations","getExpectedStatus","selfQueryWithSubParams","didSeeFail","exp","ordering","query","Unordered","StrictSubset","expectation","start","MakeSharedState","postInit","allPreviousSubcasesFinalizedPromise","Promise","resolve","totalCount","skipCount","kMaxSubcasesInFlight","subcasesInFlight","resolvePromiseBlockingSubcase","subcaseFinishedCallback","subParams","subRec","Proxy","get","target","k","prop","prototype","args","then","rv","apply","info","subcaseQuery","suite","filePathParts","testPathParts","finalizePromise","catch","finally","skipped","finish"],"mappings":";AAAA;AACA,GADA;AAGEA,YAHF;;AAKEC,mBALF;AAMO,yBANP;AAOA;;AAEEC,+BAFF;AAGEC,sBAHF;;;AAMO,gCANP;;AAQA,SAASC,gBAAT,QAAiC,2CAAjC;AACA,SAASC,mBAAT,EAAsCC,WAAtC,QAAyD,6BAAzD;AACA,SAASC,cAAT,EAAyBC,QAAzB,QAAyC,8BAAzC;AACA,SAASC,mBAAT,QAA8D,4BAA9D;AACA,SAASC,cAAT,QAA+B,iCAA/B;AACA;AACEC,qBADF;AAEEC,6BAFF;AAGO,uCAHP;AAIA,SAASC,cAAT,QAA+B,qCAA/B;AACA,SAASC,MAAT,EAAiBC,WAAjB,QAAoC,iBAApC;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,OAAO,SAASC,aAAT;AACLC,OADK;AAEmB;AACxB,SAAO,IAAIC,SAAJ,CAAeD,OAAf,CAAP;AACD;;AAED;;;;;;;;;;;;AAYA,OAAO,SAASE,2BAAT;AACLF,OADK;AAE4B;AACjC,SAAO,IAAIC,SAAJ,CAAcD,OAAd,CAAP;AACD;;;;;;;;;;;;;;AAcD,OAAO,MAAMC;AACuB;;AAE1BE,EAAAA,IAAI,GAAgB,IAAIC,GAAJ,EAAhB;AACJC,EAAAA,KAAK,GAA6B,EAA7B;;AAEbC,EAAAA,WAAW,CAACN,OAAD,EAAwB;AACjC,SAAKA,OAAL,GAAeA,OAAf;AACD;;AAEDO,EAAAA,OAAO,GAA2B;AAChC,WAAO,KAAKF,KAAZ;AACD;;AAEOG,EAAAA,SAAS,CAACC,IAAD,EAAqB;AACpCZ,IAAAA,MAAM;AACJ;AACA;AACAY,IAAAA,IAAI,KAAKC,kBAAkB,CAACD,IAAD,CAHvB;AAIH,0CAAqCA,IAAK,QAAOC,kBAAkB,CAACD,IAAD,CAAO,EAJvE,CAAN;;AAMAZ,IAAAA,MAAM,CAAC,CAAC,KAAKM,IAAL,CAAUQ,GAAV,CAAcF,IAAd,CAAF,EAAwB,wBAAuBA,IAAK,EAApD,CAAN;;AAEA,SAAKN,IAAL,CAAUS,GAAV,CAAcH,IAAd;AACD;;AAEDI,EAAAA,IAAI,CAACJ,IAAD,EAA0C;AAC5C,UAAMK,iBAAiB,GAAG,IAAIC,KAAJ,CAAW,iBAAgBN,IAAK,EAAhC,CAA1B;;AAEA,SAAKD,SAAL,CAAeC,IAAf;;AAEA,UAAMO,KAAK,GAAGP,IAAI,CAACQ,KAAL,CAAWxB,cAAX,CAAd;AACA,SAAK,MAAMyB,CAAX,IAAgBF,KAAhB,EAAuB;AACrBnB,MAAAA,MAAM,CAACD,cAAc,CAACiB,IAAf,CAAoBK,CAApB,CAAD,EAA0B,0BAAyBA,CAAE,gBAAetB,cAAe,EAAnF,CAAN;AACD;;AAED,UAAMiB,IAAI,GAAG,IAAIM,WAAJ,CAAgBH,KAAhB,EAAuB,KAAKhB,OAA5B,EAAqCc,iBAArC,CAAb;AACA,SAAKT,KAAL,CAAWe,IAAX,CAAgBP,IAAhB;AACA,WAAQA,IAAR;AACD;;AAEDQ,EAAAA,QAAQ,GAAS;AACf,SAAK,MAAMR,IAAX,IAAmB,KAAKR,KAAxB,EAA+B;AAC7BQ,MAAAA,IAAI,CAACQ,QAAL;AACD;AACF,GA5CiC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoIpC,MAAMF,WAAN,CAAkE;;;;;;;;;AASxDG,EAAAA,SAAS,GAA+BC,SAA/B;AACTC,EAAAA,SAAS,GAAW,CAAX;;AAEjBlB,EAAAA,WAAW,CAACmB,QAAD,EAAqBzB,OAArB,EAA4Cc,iBAA5C,EAAsE;AAC/E,SAAKW,QAAL,GAAgBA,QAAhB;AACA,SAAKC,eAAL,GAAuB,KAAvB;AACA,SAAK1B,OAAL,GAAeA,OAAf;AACA,SAAKc,iBAAL,GAAyBA,iBAAzB;AACD;;AAEDa,EAAAA,IAAI,CAACC,WAAD,EAA4B;AAC9B,SAAKA,WAAL,GAAmBA,WAAW,CAACC,IAAZ,EAAnB;AACA,WAAO,IAAP;AACD;;AAEDC,EAAAA,OAAO,CAACC,GAAD,EAAoB;AACzB,WAAO,IAAP;AACD;;AAEDC,EAAAA,iBAAiB,CAACC,EAAD,EAAuD;AACtEpC,IAAAA,MAAM,CAAC,KAAKqC,QAAL,KAAkBX,SAAnB,CAAN;AACA,SAAKW,QAAL,GAAgBD,EAAhB;AACA,WAAO,IAAP;AACD;;AAEDA,EAAAA,EAAE,CAACA,EAAD,EAAgC;;AAEhC;AACA;AACA;AACApC,IAAAA,MAAM,CAAC,KAAKsC,MAAL,KAAgBZ,SAAjB,CAAN;AACA,SAAKY,MAAL,GAAcF,EAAd;AACD;;AAEDG,EAAAA,KAAK,CAACC,CAAD,EAAkB;AACrB,SAAKb,SAAL,GAAiBa,CAAjB;AACA,WAAO,IAAP;AACD;;AAEDC,EAAAA,aAAa,GAAS;AACpBzC,IAAAA,MAAM,CAAC,KAAKsC,MAAL,KAAgBZ,SAAjB,CAAN;;AAEA,SAAKK,WAAL;AACE,KAAC,KAAKA,WAAL,GAAmB,KAAKA,WAAL,GAAmB,MAAtC,GAA+C,EAAhD,IAAsD,wBADxD;AAEA,SAAKF,eAAL,GAAuB,IAAvB;;AAEA,SAAKS,MAAL,GAAc,MAAM;AAClB,YAAM,IAAIpD,YAAJ,CAAiB,oBAAjB,CAAN;AACD,KAFD;AAGD;;AAEDsC,EAAAA,QAAQ,GAAS;AACf,UAAMkB,cAAc,GAAG,KAAKd,QAAL,CAAce,IAAd,CAAmB/C,cAAnB,CAAvB;AACAI,IAAAA,MAAM,CAAC,KAAKsC,MAAL,KAAgBZ,SAAjB,EAA4B,MAAM;AACtC,UAAIkB,CAAC,GAAI,0BAAyBF,cAAe,EAAjD;AACA,UAAI,KAAKzB,iBAAL,CAAuB4B,KAA3B,EAAkC;AAChCD,QAAAA,CAAC,IAAK,0BAAyB,KAAK3B,iBAAL,CAAuB4B,KAAM,EAA5D;AACD;AACD,aAAOD,CAAP;AACD,KANK,CAAN;;AAQA,QAAI,KAAKnB,SAAL,KAAmBC,SAAvB,EAAkC;AAChC;AACD;;AAED,UAAMpB,IAAI,GAAG,IAAIC,GAAJ,EAAb;AACA,SAAK,MAAM,CAACuC,UAAD,EAAaC,QAAb,CAAX,IAAqC3D,+BAA+B,CAAC,KAAKqC,SAAN,CAApE,EAAsF;AACpF,WAAK,MAAMuB,aAAX,IAA4BD,QAAQ,IAAI,CAAC,EAAD,CAAxC,EAA8C;AAC5C,cAAME,MAAM,GAAGzD,WAAW,CAACsD,UAAD,EAAaE,aAAb,CAA1B;AACAhD,QAAAA,MAAM,CAAC,KAAK2B,SAAL,KAAmB,CAAnB,IAAwB,EAAE,aAAasB,MAAf,CAAzB,CAAN;;AAEA;AACA,cAAMC,cAAc,GAAGrD,qBAAqB,CAACoD,MAAD,CAA5C;;AAEA;AACA,cAAME,oBAAoB,GAAGrD,6BAA6B,CAACmD,MAAD,CAA1D;AACAjD,QAAAA,MAAM;AACJ,SAACM,IAAI,CAACQ,GAAL,CAASqC,oBAAT,CADG;AAEH,sDAA6CT,cAAe,KAAIQ,cAAe,EAF5E,CAAN;;AAIA5C,QAAAA,IAAI,CAACS,GAAL,CAASoC,oBAAT;AACD;AACF;AACF;;AAEDF,EAAAA,MAAM;AACJG,EAAAA,KADI;AAEe;AACnBpD,IAAAA,MAAM,CAAC,KAAKyB,SAAL,KAAmBC,SAApB,EAA+B,oCAA/B,CAAN;AACA,QAAI0B,KAAK,YAAYC,QAArB,EAA+B;AAC7B,WAAK5B,SAAL,GAAiB2B,KAAK,CAAC/D,sBAAD,CAAtB;AACD,KAFD,MAEO;AACL,WAAKoC,SAAL,GAAiB2B,KAAjB;AACD;AACD,WAAO,IAAP;AACD;;AAEDE,EAAAA,YAAY,CAACF,KAAD,EAAyC;AACnDpD,IAAAA,MAAM,CAAC,KAAKyB,SAAL,KAAmBC,SAApB,EAA+B,oCAA/B,CAAN;AACA,SAAKD,SAAL,GAAiBpC,sBAAsB,CAACkE,iBAAvB,CAAyCH,KAAzC,CAAjB;AACA,WAAO,IAAP;AACD;;AAEDI,EAAAA,kBAAkB;AAChBT,EAAAA,QADgB;AAEG;AACnB,QAAIA,QAAQ,YAAYM,QAAxB,EAAkC;AAChC,aAAO,KAAKJ,MAAL,CAAYF,QAAQ,CAAC1D,sBAAsB,CAACoE,aAAvB,EAAD,CAApB,CAAP;AACD,KAFD,MAEO;AACL,aAAO,KAAKR,MAAL,CAAY5D,sBAAsB,CAACoE,aAAvB,GAAuCF,iBAAvC,CAAyDR,QAAzD,CAAZ,CAAP;AACD;AACF;;AAEO,GAAPrC,OAAO,GAA8B;AACpCV,IAAAA,MAAM,CAAC,KAAKsC,MAAL,KAAgBZ,SAAjB,EAA4B,mCAA5B,CAAN;AACA,SAAKD,SAAL,KAAmBpC,sBAAnB;AACA,SAAK,MAAM,CAACyD,UAAD,EAAaC,QAAb,CAAX,IAAqC3D,+BAA+B,CAAC,KAAKqC,SAAN,CAApE,EAAsF;AACpF,UAAI,KAAKE,SAAL,KAAmB,CAAnB,IAAwBoB,QAAQ,KAAKrB,SAAzC,EAAoD;AAClD,cAAM,IAAIgC,eAAJ;AACJ,aAAK9B,QADD;AAEJkB,QAAAA,UAFI;AAGJ,aAAKjB,eAHD;AAIJkB,QAAAA,QAJI;AAKJ,aAAK5C,OALD;AAMJ,aAAKmC,MAND;AAOJ,aAAKD,QAPD;AAQJ,aAAKpB,iBARD,CAAN;;AAUD,OAXD,MAWO;AACL,cAAM0C,YAAY,GAAGC,KAAK,CAACC,IAAN,CAAWd,QAAX,CAArB;AACA,YAAIY,YAAY,CAACG,MAAb,IAAuB,KAAKnC,SAAhC,EAA2C;AACzC,gBAAM,IAAI+B,eAAJ;AACJ,eAAK9B,QADD;AAEJkB,UAAAA,UAFI;AAGJ,eAAKjB,eAHD;AAIJ8B,UAAAA,YAJI;AAKJ,eAAKxD,OALD;AAMJ,eAAKmC,MAND;AAOJ,eAAKD,QAPD;AAQJ,eAAKpB,iBARD,CAAN;;AAUD,SAXD,MAWO;AACL,eAAK,IAAI8C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,YAAY,CAACG,MAAjC,EAAyCC,CAAC,GAAGA,CAAC,GAAG,KAAKpC,SAAtD,EAAiE;AAC/D,kBAAM,IAAI+B,eAAJ;AACJ,iBAAK9B,QADD;AAEJ,cAAE,GAAGkB,UAAL,EAAiBkB,OAAO,EAAED,CAAC,GAAG,KAAKpC,SAAnC,EAFI;AAGJ,iBAAKE,eAHD;AAIJ8B,YAAAA,YAAY,CAACM,KAAb,CAAmBF,CAAnB,EAAsBG,IAAI,CAACC,GAAL,CAASR,YAAY,CAACG,MAAtB,EAA8BC,CAAC,GAAG,KAAKpC,SAAvC,CAAtB,CAJI;AAKJ,iBAAKxB,OALD;AAMJ,iBAAKmC,MAND;AAOJ,iBAAKD,QAPD;AAQJ,iBAAKpB,iBARD,CAAN;;AAUD;AACF;AACF;AACF;AACF,GAtK+D;;;AAyKlE,MAAMyC,eAAN,CAAyC;;;;;;;;;;;AAWvCjD,EAAAA,WAAW;AACTmB,EAAAA,QADS;AAETqB,EAAAA,MAFS;AAGTpB,EAAAA,eAHS;AAITkB,EAAAA,QAJS;AAKT5C,EAAAA,OALS;AAMTiC,EAAAA,EANS;AAOTC,EAAAA,QAPS;AAQTpB,EAAAA,iBARS;AAST;AACA,SAAKmD,EAAL,GAAU,EAAEpD,IAAI,EAAEY,QAAR,EAAkBqB,MAAM,EAAE1D,mBAAmB,CAAC0D,MAAD,CAA7C,EAAV;AACA,SAAKpB,eAAL,GAAuBA,eAAvB;AACA,SAAKoB,MAAL,GAAcA,MAAd;AACA,SAAKF,QAAL,GAAgBA,QAAhB;AACA,SAAK5C,OAAL,GAAeA,OAAf;AACA,SAAKiC,EAAL,GAAUA,EAAV;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKpB,iBAAL,GAAyBA,iBAAzB;AACD;;AAEY,QAAPoD,OAAO;AACXC,EAAAA,GADW;AAEXC,EAAAA,WAFW;AAGXtB,EAAAA,MAHW;AAIXuB,EAAAA,SAJW;AAKXC,EAAAA,cALW;AAMI;AACf,QAAI;AACFH,MAAAA,GAAG,CAACI,YAAJ;AACA,UAAID,cAAc,KAAK,MAAvB,EAA+B;AAC7B,cAAM,IAAIvF,YAAJ,CAAiB,yBAAjB,CAAN;AACD;;AAED,YAAMyF,IAAI,GAAG,IAAI,KAAKxE,OAAT,CAAiBoE,WAAjB,EAA8BD,GAA9B,EAAmCrB,MAAnC,CAAb;AACA,UAAI;AACF,cAAM0B,IAAI,CAACC,IAAL,EAAN;AACA,cAAM,KAAKxC,EAAL,CAAQuC,IAAR,CAAN;AACD,OAHD,SAGU;AACR;AACA,cAAMA,IAAI,CAACE,QAAL,EAAN;AACD;AACF,KAdD,CAcE,OAAOC,EAAP,EAAW;AACX;AACA;AACA;AACA;AACA,UAAIN,SAAS,IAAIM,EAAE,YAAY5F,YAA/B,EAA6C;AAC3C,cAAM4F,EAAN;AACD;AACDR,MAAAA,GAAG,CAACS,KAAJ,CAAUD,EAAV;AACD,KAvBD,SAuBU;AACR,UAAI;AACFR,QAAAA,GAAG,CAACU,UAAJ,CAAeP,cAAf;AACD,OAFD,CAEE,OAAOK,EAAP,EAAW;AACX9E,QAAAA,MAAM,CAAC8E,EAAE,YAAY3F,mBAAf,CAAN;AACA2F,QAAAA,EAAE,CAACG,OAAH,GAAc,+BAAd;AACAH,QAAAA,EAAE,CAACjC,KAAH,GAAW,KAAK5B,iBAAL,CAAuB4B,KAAlC;AACAyB,QAAAA,GAAG,CAACY,IAAJ,CAASJ,EAAT;AACD;AACF;AACF;;AAEQ,QAAHK,GAAG;AACPb,EAAAA,GADO;AAEPc,EAAAA,SAFO;AAGPC,EAAAA,YAHO;AAIQ;AACf,UAAMC,iBAAiB,GAAG,CAACC,sBAAD,KAAiD;AACzE,UAAIC,UAAU,GAAG,KAAjB;AACA,WAAK,MAAMC,GAAX,IAAkBJ,YAAlB,EAAgC;AAC9B,cAAMK,QAAQ,GAAGjG,cAAc,CAACgG,GAAG,CAACE,KAAL,EAAYJ,sBAAZ,CAA/B;AACA,YAAIG,QAAQ,KAAKhG,QAAQ,CAACkG,SAAtB,IAAmCF,QAAQ,KAAKhG,QAAQ,CAACmG,YAA7D,EAA2E;AACzE;AACD;;AAED,gBAAQJ,GAAG,CAACK,WAAZ;AACE;AACA;AACA,eAAK,MAAL;AACE,mBAAO,MAAP;AACF,eAAK,MAAL;AACE;AACAN,YAAAA,UAAU,GAAG,IAAb;AACA;AACF;AACEvF,YAAAA,WAAW,GAVf;;AAYD;AACD,aAAOuF,UAAU,GAAG,MAAH,GAAY,MAA7B;AACD,KAtBD;;AAwBA,QAAI;AACFlB,MAAAA,GAAG,CAACyB,KAAJ;AACA,YAAMxB,WAAW,GAAG,KAAKpE,OAAL,CAAa6F,eAAb,CAA6B,KAAK/C,MAAlC,CAApB;AACA,UAAI;AACF,cAAMsB,WAAW,CAACK,IAAZ,EAAN;AACA,YAAI,KAAKvC,QAAT,EAAmB;AACjB,gBAAM,KAAKA,QAAL,CAAckC,WAAd,CAAN;AACD;AACD,cAAMA,WAAW,CAAC0B,QAAZ,EAAN;;AAEA,YAAIC,mCAAkD,GAAGC,OAAO,CAACC,OAAR,EAAzD;AACA,YAAI,KAAKrD,QAAT,EAAmB;AACjB,cAAIsD,UAAU,GAAG,CAAjB;AACA,cAAIC,SAAS,GAAG,CAAhB;;AAEA;AACA;AACA;AACA,gBAAMC,oBAAoB,GAAG,GAA7B;AACA,cAAIC,gBAAgB,GAAG,CAAvB;AACA,cAAIC,6BAAuD,GAAG/E,SAA9D;AACA,gBAAMgF,uBAAuB,GAAG,MAAM;AACpCF,YAAAA,gBAAgB,IAAI,CAApB;AACA;AACA;AACA,gBAAIC,6BAAJ,EAAmC;AACjCA,cAAAA,6BAA6B;AAC7BA,cAAAA,6BAA6B,GAAG/E,SAAhC;AACD;AACF,WARD;;AAUA,eAAK,MAAMiF,SAAX,IAAwB,KAAK5D,QAA7B,EAAuC;AACrC;AACA;AACA;AACA,kBAAM6D,MAAM,GAAG,IAAIC,KAAJ,CAAUvC,GAAV,EAAe;AAC5BwC,cAAAA,GAAG,EAAE,CAACC,MAAD,EAASC,CAAT,KAAuC;AAC1C,sBAAMC,IAAI,GAAG3H,gBAAgB,CAAC4H,SAAjB,CAA2BF,CAA3B,CAAb;AACA,oBAAI,OAAOC,IAAP,KAAgB,UAApB,EAAgC;AAC9B,yBAAO,UAAU,GAAGE,IAAb,EAA4C;AACjD,yBAAKjB,mCAAmC,CAACkB,IAApC,CAAyC,MAAM;;AAElD,4BAAMC,EAAE,GAAIJ,IAAD,CAAcK,KAAd,CAAoBP,MAApB,EAA4BI,IAA5B,CAAX;AACA;AACA;AACAnH,sBAAAA,MAAM,CAACqH,EAAE,KAAK3F,SAAR,CAAN;AACD,qBANI,CAAL;AAOD,mBARD;AASD;AACD,uBAAOuF,IAAP;AACD,eAf2B,EAAf,CAAf;;;AAkBAL,YAAAA,MAAM,CAACW,IAAP,CAAY,IAAIrG,KAAJ,CAAU,cAAcrB,qBAAqB,CAAC8G,SAAD,CAA7C,CAAZ;;AAEA,kBAAM1D,MAAM,GAAGzD,WAAW,CAAC,KAAKyD,MAAN,EAAc0D,SAAd,CAA1B;AACA,kBAAMa,YAAY,GAAG,IAAI7H,mBAAJ;AACnByF,YAAAA,SAAS,CAACqC,KADS;AAEnBrC,YAAAA,SAAS,CAACsC,aAFS;AAGnBtC,YAAAA,SAAS,CAACuC,aAHS;AAInB1E,YAAAA,MAJmB,CAArB;;;AAOA;AACA,gBAAIuD,gBAAgB,IAAID,oBAAxB,EAA8C;AAC5C,oBAAM,IAAIJ,OAAJ,CAAkB,CAAAC,OAAO,KAAI;AACjC;AACApG,gBAAAA,MAAM,CAACyG,6BAA6B,KAAK/E,SAAnC,CAAN;AACA+E,gBAAAA,6BAA6B,GAAGL,OAAhC;AACD,eAJK,CAAN;AAKD;;AAEDI,YAAAA,gBAAgB,IAAI,CAApB;AACA;AACA;AACA,kBAAMoB,eAAe,GAAG,KAAKvD,OAAL;AACtBuC,YAAAA,MADsB;AAEtBrC,YAAAA,WAFsB;AAGtBtB,YAAAA,MAHsB;AAItB,2BAAgB,IAJM;AAKtBqC,YAAAA,iBAAiB,CAACkC,YAAD,CALK;;AAOrBK,YAAAA,KAPqB,CAOf,CAAA/C,EAAE,KAAI;AACX,kBAAIA,EAAE,YAAY5F,YAAlB,EAAgC;AAC9B;AACA4F,gBAAAA,EAAE,CAACG,OAAH,GAAa,sBAAsBH,EAAE,CAACG,OAAtC;AACA2B,gBAAAA,MAAM,CAACW,IAAP,CAAYzC,EAAZ;AACA,kBAAEwB,SAAF;AACD,eALD,MAKO;AACL;AACAM,gBAAAA,MAAM,CAAC7B,KAAP,CAAaD,EAAb;AACD;AACF,aAjBqB;AAkBrBgD,YAAAA,OAlBqB,CAkBbpB,uBAlBa,CAAxB;;AAoBAR,YAAAA,mCAAmC,GAAGA,mCAAmC,CAACkB,IAApC;AACpC,kBAAMQ,eAD8B,CAAtC;;AAGA,cAAEvB,UAAF;AACD;;AAED;AACA,gBAAMH,mCAAN;;AAEA,cAAII,SAAS,KAAKD,UAAlB,EAA8B;AAC5B/B,YAAAA,GAAG,CAACyD,OAAJ,CAAY,IAAI7I,YAAJ,CAAiB,2BAAjB,CAAZ;AACD;AACF,SAhGD,MAgGO;AACL,gBAAM,KAAKmF,OAAL;AACJC,UAAAA,GADI;AAEJC,UAAAA,WAFI;AAGJ,eAAKtB,MAHD;AAIJ,yBAAgB,KAJZ;AAKJqC,UAAAA,iBAAiB,CAACF,SAAD,CALb,CAAN;;AAOD;AACF,OAjHD,SAiHU;AACR;AACA,cAAMb,WAAW,CAACM,QAAZ,EAAN;AACD;AACF,KAxHD,CAwHE,OAAOC,EAAP,EAAW;AACX;AACA;AACA;AACA;AACAR,MAAAA,GAAG,CAACS,KAAJ,CAAUD,EAAV;AACD,KA9HD,SA8HU;AACRR,MAAAA,GAAG,CAAC0D,MAAJ;AACD;AACF,GAvOsC","sourcesContent":["import {\n  Fixture,\n  SubcaseBatchState,\n  SkipTestCase,\n  TestParams,\n  UnexpectedPassError,\n} from '../framework/fixture.js';\nimport {\n  CaseParamsBuilder,\n  builderIterateCasesWithSubcases,\n  kUnitCaseParamsBuilder,\n  ParamsBuilderBase,\n  SubcaseParamsBuilder,\n} from '../framework/params_builder.js';\nimport { Expectation } from '../internal/logging/result.js';\nimport { TestCaseRecorder } from '../internal/logging/test_case_recorder.js';\nimport { extractPublicParams, Merged, mergeParams } from '../internal/params_utils.js';\nimport { compareQueries, Ordering } from '../internal/query/compare.js';\nimport { TestQuerySingleCase, TestQueryWithExpectation } from '../internal/query/query.js';\nimport { kPathSeparator } from '../internal/query/separators.js';\nimport {\n  stringifyPublicParams,\n  stringifyPublicParamsUniquely,\n} from '../internal/query/stringify_params.js';\nimport { validQueryPart } from '../internal/query/validQueryPart.js';\nimport { assert, unreachable } from '../util/util.js';\n\nexport type RunFn = (\n  rec: TestCaseRecorder,\n  expectations?: TestQueryWithExpectation[]\n) => Promise<void>;\n\nexport interface TestCaseID {\n  readonly test: readonly string[];\n  readonly params: TestParams;\n}\n\nexport interface RunCase {\n  readonly id: TestCaseID;\n  readonly isUnimplemented: boolean;\n  run(\n    rec: TestCaseRecorder,\n    selfQuery: TestQuerySingleCase,\n    expectations: TestQueryWithExpectation[]\n  ): Promise<void>;\n}\n\n// Interface for defining tests\nexport interface TestGroupBuilder<S extends SubcaseBatchState, F extends Fixture<S>> {\n  test(name: string): TestBuilderWithName<S, F>;\n}\nexport function makeTestGroup<S extends SubcaseBatchState, F extends Fixture<S>>(\n  fixture: FixtureClass<S, F>\n): TestGroupBuilder<S, F> {\n  return new TestGroup((fixture as unknown) as FixtureClass);\n}\n\n// Interfaces for running tests\nexport interface IterableTestGroup {\n  iterate(): Iterable<IterableTest>;\n  validate(): void;\n}\nexport interface IterableTest {\n  testPath: string[];\n  description: string | undefined;\n  readonly testCreationStack: Error;\n  iterate(): Iterable<RunCase>;\n}\n\nexport function makeTestGroupForUnitTesting<F extends Fixture>(\n  fixture: FixtureClass<SubcaseBatchState, F>\n): TestGroup<SubcaseBatchState, F> {\n  return new TestGroup(fixture);\n}\n\nexport type FixtureClass<\n  S extends SubcaseBatchState = SubcaseBatchState,\n  F extends Fixture<S> = Fixture<S>\n> = {\n  new (sharedState: S, log: TestCaseRecorder, params: TestParams): F;\n  MakeSharedState(params: TestParams): S;\n};\ntype TestFn<F extends Fixture, P extends {}> = (t: F & { params: P }) => Promise<void> | void;\ntype BeforeAllSubcasesFn<S extends SubcaseBatchState, P extends {}> = (\n  s: S & { params: P }\n) => Promise<void> | void;\n\nexport class TestGroup<S extends SubcaseBatchState, F extends Fixture<S>>\n  implements TestGroupBuilder<S, F> {\n  private fixture: FixtureClass;\n  private seen: Set<string> = new Set();\n  private tests: Array<TestBuilder<S, F>> = [];\n\n  constructor(fixture: FixtureClass) {\n    this.fixture = fixture;\n  }\n\n  iterate(): Iterable<IterableTest> {\n    return this.tests;\n  }\n\n  private checkName(name: string): void {\n    assert(\n      // Shouldn't happen due to the rule above. Just makes sure that treating\n      // unencoded strings as encoded strings is OK.\n      name === decodeURIComponent(name),\n      `Not decodeURIComponent-idempotent: ${name} !== ${decodeURIComponent(name)}`\n    );\n    assert(!this.seen.has(name), `Duplicate test name: ${name}`);\n\n    this.seen.add(name);\n  }\n\n  test(name: string): TestBuilderWithName<S, F> {\n    const testCreationStack = new Error(`Test created: ${name}`);\n\n    this.checkName(name);\n\n    const parts = name.split(kPathSeparator);\n    for (const p of parts) {\n      assert(validQueryPart.test(p), `Invalid test name part ${p}; must match ${validQueryPart}`);\n    }\n\n    const test = new TestBuilder(parts, this.fixture, testCreationStack);\n    this.tests.push(test);\n    return (test as unknown) as TestBuilderWithName<S, F>;\n  }\n\n  validate(): void {\n    for (const test of this.tests) {\n      test.validate();\n    }\n  }\n}\n\ninterface TestBuilderWithName<S extends SubcaseBatchState, F extends Fixture<S>>\n  extends TestBuilderWithParams<S, F, {}, {}> {\n  desc(description: string): this;\n  /**\n   * A noop function to associate a test with the relevant part of the specification.\n   *\n   * @param url a link to the spec where test is extracted from.\n   */\n  specURL(url: string): this;\n  /**\n   * Parameterize the test, generating multiple cases, each possibly having subcases.\n   *\n   * The `unit` value passed to the `cases` callback is an immutable constant\n   * `CaseParamsBuilder<{}>` representing the \"unit\" builder `[ {} ]`,\n   * provided for convenience. The non-callback overload can be used if `unit` is not needed.\n   */\n  params<CaseP extends {}, SubcaseP extends {}>(\n    cases: (unit: CaseParamsBuilder<{}>) => ParamsBuilderBase<CaseP, SubcaseP>\n  ): TestBuilderWithParams<S, F, CaseP, SubcaseP>;\n  /**\n   * Parameterize the test, generating multiple cases, each possibly having subcases.\n   *\n   * Use the callback overload of this method if a \"unit\" builder is needed.\n   */\n  params<CaseP extends {}, SubcaseP extends {}>(\n    cases: ParamsBuilderBase<CaseP, SubcaseP>\n  ): TestBuilderWithParams<S, F, CaseP, SubcaseP>;\n\n  /**\n   * Parameterize the test, generating multiple cases, without subcases.\n   */\n  paramsSimple<P extends {}>(cases: Iterable<P>): TestBuilderWithParams<S, F, P, {}>;\n\n  /**\n   * Parameterize the test, generating one case with multiple subcases.\n   */\n  paramsSubcasesOnly<P extends {}>(subcases: Iterable<P>): TestBuilderWithParams<S, F, {}, P>;\n  /**\n   * Parameterize the test, generating one case with multiple subcases.\n   *\n   * The `unit` value passed to the `subcases` callback is an immutable constant\n   * `SubcaseParamsBuilder<{}>`, with one empty case `{}` and one empty subcase `{}`.\n   */\n  paramsSubcasesOnly<P extends {}>(\n    subcases: (unit: SubcaseParamsBuilder<{}, {}>) => SubcaseParamsBuilder<{}, P>\n  ): TestBuilderWithParams<S, F, {}, P>;\n}\n\ninterface TestBuilderWithParams<\n  S extends SubcaseBatchState,\n  F extends Fixture<S>,\n  CaseP extends {},\n  SubcaseP extends {}\n> {\n  /**\n   * Limit subcases to a maximum number of per testcase.\n   * @param b the maximum number of subcases per testcase.\n   *\n   * If the number of subcases exceeds `b`, add an internal\n   * numeric, incrementing `batch__` param to split subcases\n   * into groups of at most `b` subcases.\n   */\n  batch(b: number): this;\n  /**\n   * Run a function on shared subcase batch state before each\n   * batch of subcases.\n   * @param fn the function to run. It is called with the test\n   * fixture's shared subcase batch state.\n   *\n   * Generally, this function should be careful to avoid mutating\n   * any state on the shared subcase batch state which could result\n   * in unexpected order-dependent test behavior.\n   */\n  beforeAllSubcases(fn: BeforeAllSubcasesFn<S, CaseP>): this;\n  /**\n   * Set the test function.\n   * @param fn the test function.\n   */\n  fn(fn: TestFn<F, Merged<CaseP, SubcaseP>>): void;\n  /**\n   * Mark the test as unimplemented.\n   */\n  unimplemented(): void;\n}\n\nclass TestBuilder<S extends SubcaseBatchState, F extends Fixture> {\n  readonly testPath: string[];\n  isUnimplemented: boolean;\n  description: string | undefined;\n  readonly testCreationStack: Error;\n\n  private readonly fixture: FixtureClass;\n  private testFn: TestFn<Fixture, {}> | undefined;\n  private beforeFn: BeforeAllSubcasesFn<SubcaseBatchState, {}> | undefined;\n  private testCases?: ParamsBuilderBase<{}, {}> = undefined;\n  private batchSize: number = 0;\n\n  constructor(testPath: string[], fixture: FixtureClass, testCreationStack: Error) {\n    this.testPath = testPath;\n    this.isUnimplemented = false;\n    this.fixture = fixture;\n    this.testCreationStack = testCreationStack;\n  }\n\n  desc(description: string): this {\n    this.description = description.trim();\n    return this;\n  }\n\n  specURL(url: string): this {\n    return this;\n  }\n\n  beforeAllSubcases(fn: BeforeAllSubcasesFn<SubcaseBatchState, {}>): this {\n    assert(this.beforeFn === undefined);\n    this.beforeFn = fn;\n    return this;\n  }\n\n  fn(fn: TestFn<Fixture, {}>): void {\n    // eslint-disable-next-line no-warning-comments\n    // MAINTENANCE_TODO: add \"TODO\" if there's no description? (and make sure it only ends up on\n    // actual tests, not on test parents in the tree, which is what happens if you do it here, not\n    // sure why)\n    assert(this.testFn === undefined);\n    this.testFn = fn;\n  }\n\n  batch(b: number): this {\n    this.batchSize = b;\n    return this;\n  }\n\n  unimplemented(): void {\n    assert(this.testFn === undefined);\n\n    this.description =\n      (this.description ? this.description + '\\n\\n' : '') + 'TODO: .unimplemented()';\n    this.isUnimplemented = true;\n\n    this.testFn = () => {\n      throw new SkipTestCase('test unimplemented');\n    };\n  }\n\n  validate(): void {\n    const testPathString = this.testPath.join(kPathSeparator);\n    assert(this.testFn !== undefined, () => {\n      let s = `Test is missing .fn(): ${testPathString}`;\n      if (this.testCreationStack.stack) {\n        s += `\\n-> test created at:\\n${this.testCreationStack.stack}`;\n      }\n      return s;\n    });\n\n    if (this.testCases === undefined) {\n      return;\n    }\n\n    const seen = new Set<string>();\n    for (const [caseParams, subcases] of builderIterateCasesWithSubcases(this.testCases)) {\n      for (const subcaseParams of subcases ?? [{}]) {\n        const params = mergeParams(caseParams, subcaseParams);\n        assert(this.batchSize === 0 || !('batch__' in params));\n\n        // stringifyPublicParams also checks for invalid params values\n        const testcaseString = stringifyPublicParams(params);\n\n        // A (hopefully) unique representation of a params value.\n        const testcaseStringUnique = stringifyPublicParamsUniquely(params);\n        assert(\n          !seen.has(testcaseStringUnique),\n          `Duplicate public test case params for test ${testPathString}: ${testcaseString}`\n        );\n        seen.add(testcaseStringUnique);\n      }\n    }\n  }\n\n  params(\n    cases: ((unit: CaseParamsBuilder<{}>) => ParamsBuilderBase<{}, {}>) | ParamsBuilderBase<{}, {}>\n  ): TestBuilder<S, F> {\n    assert(this.testCases === undefined, 'test case is already parameterized');\n    if (cases instanceof Function) {\n      this.testCases = cases(kUnitCaseParamsBuilder);\n    } else {\n      this.testCases = cases;\n    }\n    return this;\n  }\n\n  paramsSimple(cases: Iterable<{}>): TestBuilder<S, F> {\n    assert(this.testCases === undefined, 'test case is already parameterized');\n    this.testCases = kUnitCaseParamsBuilder.combineWithParams(cases);\n    return this;\n  }\n\n  paramsSubcasesOnly(\n    subcases: Iterable<{}> | ((unit: SubcaseParamsBuilder<{}, {}>) => SubcaseParamsBuilder<{}, {}>)\n  ): TestBuilder<S, F> {\n    if (subcases instanceof Function) {\n      return this.params(subcases(kUnitCaseParamsBuilder.beginSubcases()));\n    } else {\n      return this.params(kUnitCaseParamsBuilder.beginSubcases().combineWithParams(subcases));\n    }\n  }\n\n  *iterate(): IterableIterator<RunCase> {\n    assert(this.testFn !== undefined, 'No test function (.fn()) for test');\n    this.testCases ??= kUnitCaseParamsBuilder;\n    for (const [caseParams, subcases] of builderIterateCasesWithSubcases(this.testCases)) {\n      if (this.batchSize === 0 || subcases === undefined) {\n        yield new RunCaseSpecific(\n          this.testPath,\n          caseParams,\n          this.isUnimplemented,\n          subcases,\n          this.fixture,\n          this.testFn,\n          this.beforeFn,\n          this.testCreationStack\n        );\n      } else {\n        const subcaseArray = Array.from(subcases);\n        if (subcaseArray.length <= this.batchSize) {\n          yield new RunCaseSpecific(\n            this.testPath,\n            caseParams,\n            this.isUnimplemented,\n            subcaseArray,\n            this.fixture,\n            this.testFn,\n            this.beforeFn,\n            this.testCreationStack\n          );\n        } else {\n          for (let i = 0; i < subcaseArray.length; i = i + this.batchSize) {\n            yield new RunCaseSpecific(\n              this.testPath,\n              { ...caseParams, batch__: i / this.batchSize },\n              this.isUnimplemented,\n              subcaseArray.slice(i, Math.min(subcaseArray.length, i + this.batchSize)),\n              this.fixture,\n              this.testFn,\n              this.beforeFn,\n              this.testCreationStack\n            );\n          }\n        }\n      }\n    }\n  }\n}\n\nclass RunCaseSpecific implements RunCase {\n  readonly id: TestCaseID;\n  readonly isUnimplemented: boolean;\n\n  private readonly params: {};\n  private readonly subcases: Iterable<{}> | undefined;\n  private readonly fixture: FixtureClass;\n  private readonly fn: TestFn<Fixture, {}>;\n  private readonly beforeFn?: BeforeAllSubcasesFn<SubcaseBatchState, {}>;\n  private readonly testCreationStack: Error;\n\n  constructor(\n    testPath: string[],\n    params: {},\n    isUnimplemented: boolean,\n    subcases: Iterable<{}> | undefined,\n    fixture: FixtureClass,\n    fn: TestFn<Fixture, {}>,\n    beforeFn: BeforeAllSubcasesFn<SubcaseBatchState, {}> | undefined,\n    testCreationStack: Error\n  ) {\n    this.id = { test: testPath, params: extractPublicParams(params) };\n    this.isUnimplemented = isUnimplemented;\n    this.params = params;\n    this.subcases = subcases;\n    this.fixture = fixture;\n    this.fn = fn;\n    this.beforeFn = beforeFn;\n    this.testCreationStack = testCreationStack;\n  }\n\n  async runTest(\n    rec: TestCaseRecorder,\n    sharedState: SubcaseBatchState,\n    params: TestParams,\n    throwSkip: boolean,\n    expectedStatus: Expectation\n  ): Promise<void> {\n    try {\n      rec.beginSubCase();\n      if (expectedStatus === 'skip') {\n        throw new SkipTestCase('Skipped by expectations');\n      }\n\n      const inst = new this.fixture(sharedState, rec, params);\n      try {\n        await inst.init();\n        await this.fn(inst as Fixture & { params: {} });\n      } finally {\n        // Runs as long as constructor succeeded, even if initialization or the test failed.\n        await inst.finalize();\n      }\n    } catch (ex) {\n      // There was an exception from constructor, init, test, or finalize.\n      // An error from init or test may have been a SkipTestCase.\n      // An error from finalize may have been an eventualAsyncExpectation failure\n      // or unexpected validation/OOM error from the GPUDevice.\n      if (throwSkip && ex instanceof SkipTestCase) {\n        throw ex;\n      }\n      rec.threw(ex);\n    } finally {\n      try {\n        rec.endSubCase(expectedStatus);\n      } catch (ex) {\n        assert(ex instanceof UnexpectedPassError);\n        ex.message = `Testcase passed unexpectedly.`;\n        ex.stack = this.testCreationStack.stack;\n        rec.warn(ex);\n      }\n    }\n  }\n\n  async run(\n    rec: TestCaseRecorder,\n    selfQuery: TestQuerySingleCase,\n    expectations: TestQueryWithExpectation[]\n  ): Promise<void> {\n    const getExpectedStatus = (selfQueryWithSubParams: TestQuerySingleCase) => {\n      let didSeeFail = false;\n      for (const exp of expectations) {\n        const ordering = compareQueries(exp.query, selfQueryWithSubParams);\n        if (ordering === Ordering.Unordered || ordering === Ordering.StrictSubset) {\n          continue;\n        }\n\n        switch (exp.expectation) {\n          // Skip takes precedence. If there is any expectation indicating a skip,\n          // signal it immediately.\n          case 'skip':\n            return 'skip';\n          case 'fail':\n            // Otherwise, indicate that we might expect a failure.\n            didSeeFail = true;\n            break;\n          default:\n            unreachable();\n        }\n      }\n      return didSeeFail ? 'fail' : 'pass';\n    };\n\n    try {\n      rec.start();\n      const sharedState = this.fixture.MakeSharedState(this.params);\n      try {\n        await sharedState.init();\n        if (this.beforeFn) {\n          await this.beforeFn(sharedState);\n        }\n        await sharedState.postInit();\n\n        let allPreviousSubcasesFinalizedPromise: Promise<void> = Promise.resolve();\n        if (this.subcases) {\n          let totalCount = 0;\n          let skipCount = 0;\n\n          // Maximum number of subcases in flight. If there are too many in flight,\n          // starting the next subcase will register `resolvePromiseBlockingSubcase`\n          // and wait until `subcaseFinishedCallback` is called.\n          const kMaxSubcasesInFlight = 500;\n          let subcasesInFlight = 0;\n          let resolvePromiseBlockingSubcase: (() => void) | undefined = undefined;\n          const subcaseFinishedCallback = () => {\n            subcasesInFlight -= 1;\n            // If there is any subcase waiting on a previous subcase to finish,\n            // unblock it now, and clear the resolve callback.\n            if (resolvePromiseBlockingSubcase) {\n              resolvePromiseBlockingSubcase();\n              resolvePromiseBlockingSubcase = undefined;\n            }\n          };\n\n          for (const subParams of this.subcases) {\n            // Make a recorder that will defer all calls until `allPreviousSubcasesFinalizedPromise`\n            // resolves. Waiting on `allPreviousSubcasesFinalizedPromise` ensures that\n            // logs from all the previous subcases have been flushed before flushing new logs.\n            const subRec = new Proxy(rec, {\n              get: (target, k: keyof TestCaseRecorder) => {\n                const prop = TestCaseRecorder.prototype[k];\n                if (typeof prop === 'function') {\n                  return function (...args: Parameters<typeof prop>) {\n                    void allPreviousSubcasesFinalizedPromise.then(() => {\n                      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                      const rv = (prop as any).apply(target, args);\n                      // Because this proxy executes functions in a deferred manner,\n                      // it should never be used for functions that need to return a value.\n                      assert(rv === undefined);\n                    });\n                  };\n                }\n                return prop;\n              },\n            });\n\n            subRec.info(new Error('subcase: ' + stringifyPublicParams(subParams)));\n\n            const params = mergeParams(this.params, subParams);\n            const subcaseQuery = new TestQuerySingleCase(\n              selfQuery.suite,\n              selfQuery.filePathParts,\n              selfQuery.testPathParts,\n              params\n            );\n\n            // Limit the maximum number of subcases in flight.\n            if (subcasesInFlight >= kMaxSubcasesInFlight) {\n              await new Promise<void>(resolve => {\n                // There should only be one subcase waiting at a time.\n                assert(resolvePromiseBlockingSubcase === undefined);\n                resolvePromiseBlockingSubcase = resolve;\n              });\n            }\n\n            subcasesInFlight += 1;\n            // Runs async without waiting so that subsequent subcases can start.\n            // All finalization steps will be waited on at the end of the testcase.\n            const finalizePromise = this.runTest(\n              subRec,\n              sharedState,\n              params,\n              /* throwSkip */ true,\n              getExpectedStatus(subcaseQuery)\n            )\n              .catch(ex => {\n                if (ex instanceof SkipTestCase) {\n                  // Convert SkipTestCase to info messages\n                  ex.message = 'subcase skipped: ' + ex.message;\n                  subRec.info(ex);\n                  ++skipCount;\n                } else {\n                  // Since we are catching all error inside runTest(), this should never happen\n                  subRec.threw(ex);\n                }\n              })\n              .finally(subcaseFinishedCallback);\n\n            allPreviousSubcasesFinalizedPromise = allPreviousSubcasesFinalizedPromise.then(\n              () => finalizePromise\n            );\n            ++totalCount;\n          }\n\n          // Wait for all subcases to finalize and report their results.\n          await allPreviousSubcasesFinalizedPromise;\n\n          if (skipCount === totalCount) {\n            rec.skipped(new SkipTestCase('all subcases were skipped'));\n          }\n        } else {\n          await this.runTest(\n            rec,\n            sharedState,\n            this.params,\n            /* throwSkip */ false,\n            getExpectedStatus(selfQuery)\n          );\n        }\n      } finally {\n        // Runs as long as the shared state constructor succeeded, even if initialization or a test failed.\n        await sharedState.finalize();\n      }\n    } catch (ex) {\n      // There was an exception from sharedState/fixture constructor, init, beforeFn, or test.\n      // An error from beforeFn may have been SkipTestCase.\n      // An error from finalize may have been an eventualAsyncExpectation failure\n      // or unexpected validation/OOM error from the GPUDevice.\n      rec.threw(ex);\n    } finally {\n      rec.finish();\n    }\n  }\n}\n"],"file":"test_group.js"}