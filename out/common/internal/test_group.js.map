{"version":3,"sources":["../../../src/common/internal/test_group.ts"],"names":["SkipTestCase","UnexpectedPassError","builderIterateCasesWithSubcases","kUnitCaseParamsBuilder","extractPublicParams","mergeParams","compareQueries","Ordering","TestQuerySingleCase","kPathSeparator","stringifyPublicParams","stringifyPublicParamsUniquely","validQueryPart","assert","unreachable","makeTestGroup","fixture","TestGroup","makeTestGroupForUnitTesting","seen","Set","tests","constructor","iterate","checkName","name","decodeURIComponent","has","add","test","testCreationStack","Error","parts","split","p","TestBuilder","push","validate","testCases","undefined","testPath","desc","description","trim","fn","testFn","unimplemented","testPathString","join","s","stack","caseParams","subcases","subcaseParams","params","testcaseString","testcaseStringUnique","cases","Function","paramsSimple","combineWithParams","paramsSubcasesOnly","beginSubcases","RunCaseSpecific","id","runTest","rec","throwSkip","expectedStatus","beginSubCase","inst","doInit","doFinalize","ex","threw","endSubCase","message","warn","run","selfQuery","expectations","getExpectedStatus","selfQueryWithSubParams","didSeeFail","exp","ordering","query","Unordered","StrictSubset","expectation","start","totalCount","skipCount","subParams","info","subcaseQuery","suite","filePathParts","testPathParts","skipped","finish"],"mappings":";AAAA;AACA,GADA,SAAkBA,YAAlB,EAA4CC,mBAA5C,QAAuE,yBAAvE,CACA;AAEEC,+BAFF;AAGEC,sBAHF;;;AAMO,gCANP;;;AASA,SAASC,mBAAT,EAAsCC,WAAtC,QAAyD,6BAAzD;AACA,SAASC,cAAT,EAAyBC,QAAzB,QAAyC,8BAAzC;AACA,SAASC,mBAAT,QAA8D,4BAA9D;AACA,SAASC,cAAT,QAA+B,iCAA/B;AACA;AACEC,qBADF;AAEEC,6BAFF;AAGO,uCAHP;AAIA,SAASC,cAAT,QAA+B,qCAA/B;AACA,SAASC,MAAT,EAAiBC,WAAjB,QAAoC,iBAApC;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,OAAO,SAASC,aAAT,CAA0CC,OAA1C,EAAyF;AAC9F,SAAO,IAAIC,SAAJ,CAAcD,OAAd,CAAP;AACD;;AAED;;;;;;;;;;;;AAYA,OAAO,SAASE,2BAAT;AACLF,OADK;AAES;AACd,SAAO,IAAIC,SAAJ,CAAcD,OAAd,CAAP;AACD;;;;;;;;AAQD,OAAO,MAAMC,SAAN,CAAkE;;AAE/DE,EAAAA,IAAR,GAA4B,IAAIC,GAAJ,EAA5B;AACQC,EAAAA,KAAR,GAAoC,EAApC;;AAEAC,EAAAA,WAAW,CAACN,OAAD,EAAwB;AACjC,SAAKA,OAAL,GAAeA,OAAf;AACD;;AAEDO,EAAAA,OAAO,GAA2B;AAChC,WAAO,KAAKF,KAAZ;AACD;;AAEOG,EAAAA,SAAR,CAAkBC,IAAlB,EAAsC;AACpCZ,IAAAA,MAAM;AACJ;AACA;AACAY,IAAAA,IAAI,KAAKC,kBAAkB,CAACD,IAAD,CAHvB;AAIH,0CAAqCA,IAAK,QAAOC,kBAAkB,CAACD,IAAD,CAAO,EAJvE,CAAN;;AAMAZ,IAAAA,MAAM,CAAC,CAAC,KAAKM,IAAL,CAAUQ,GAAV,CAAcF,IAAd,CAAF,EAAwB,wBAAuBA,IAAK,EAApD,CAAN;;AAEA,SAAKN,IAAL,CAAUS,GAAV,CAAcH,IAAd;AACD;;AAED;AACAI,EAAAA,IAAI,CAACJ,IAAD,EAAuC;AACzC,UAAMK,iBAAiB,GAAG,IAAIC,KAAJ,CAAW,iBAAgBN,IAAK,EAAhC,CAA1B;;AAEA,SAAKD,SAAL,CAAeC,IAAf;;AAEA,UAAMO,KAAK,GAAGP,IAAI,CAACQ,KAAL,CAAWxB,cAAX,CAAd;AACA,SAAK,MAAMyB,CAAX,IAAgBF,KAAhB,EAAuB;AACrBnB,MAAAA,MAAM,CAACD,cAAc,CAACiB,IAAf,CAAoBK,CAApB,CAAD,EAA0B,0BAAyBA,CAAE,gBAAetB,cAAe,EAAnF,CAAN;AACD;;AAED,UAAMiB,IAAI,GAAG,IAAIM,WAAJ,CAAgBH,KAAhB,EAAuB,KAAKhB,OAA5B,EAAqCc,iBAArC,CAAb;AACA,SAAKT,KAAL,CAAWe,IAAX,CAAgBP,IAAhB;AACA,WAAQA,IAAR;AACD;;AAEDQ,EAAAA,QAAQ,GAAS;AACf,SAAK,MAAMR,IAAX,IAAmB,KAAKR,KAAxB,EAA+B;AAC7BQ,MAAAA,IAAI,CAACQ,QAAL;AACD;AACF,GA7CsE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+FzE,MAAMF,WAAN,CAAkB;;;;;;;AAORG,EAAAA,SAAR,GAAgDC,SAAhD;;AAEAjB,EAAAA,WAAW,CAACkB,QAAD,EAAqBxB,OAArB,EAA4Cc,iBAA5C,EAAsE;AAC/E,SAAKU,QAAL,GAAgBA,QAAhB;AACA,SAAKxB,OAAL,GAAeA,OAAf;AACA,SAAKc,iBAAL,GAAyBA,iBAAzB;AACD;;AAEDW,EAAAA,IAAI,CAACC,WAAD,EAA4B;AAC9B,SAAKA,WAAL,GAAmBA,WAAW,CAACC,IAAZ,EAAnB;AACA,WAAO,IAAP;AACD;;AAEDC,EAAAA,EAAE,CAACA,EAAD,EAAgC;AAChC;AACA;AACA/B,IAAAA,MAAM,CAAC,KAAKgC,MAAL,KAAgBN,SAAjB,CAAN;AACA,SAAKM,MAAL,GAAcD,EAAd;AACD;;AAEDE,EAAAA,aAAa,GAAS;AACpBjC,IAAAA,MAAM,CAAC,KAAKgC,MAAL,KAAgBN,SAAjB,CAAN;;AAEA,SAAKG,WAAL;AACE,KAAC,KAAKA,WAAL,GAAmB,KAAKA,WAAL,GAAmB,MAAtC,GAA+C,EAAhD,IAAsD,wBADxD;;AAGA,SAAKG,MAAL,GAAc,MAAM;AAClB,YAAM,IAAI7C,YAAJ,CAAiB,oBAAjB,CAAN;AACD,KAFD;AAGD;;AAEDqC,EAAAA,QAAQ,GAAS;AACf,UAAMU,cAAc,GAAG,KAAKP,QAAL,CAAcQ,IAAd,CAAmBvC,cAAnB,CAAvB;AACAI,IAAAA,MAAM,CAAC,KAAKgC,MAAL,KAAgBN,SAAjB,EAA4B,MAAM;AACtC,UAAIU,CAAC,GAAI,0BAAyBF,cAAe,EAAjD;AACA,UAAI,KAAKjB,iBAAL,CAAuBoB,KAA3B,EAAkC;AAChCD,QAAAA,CAAC,IAAK,0BAAyB,KAAKnB,iBAAL,CAAuBoB,KAAM,EAA5D;AACD;AACD,aAAOD,CAAP;AACD,KANK,CAAN;;AAQA,QAAI,KAAKX,SAAL,KAAmBC,SAAvB,EAAkC;AAChC;AACD;;AAED,UAAMpB,IAAI,GAAG,IAAIC,GAAJ,EAAb;AACA,SAAK,MAAM,CAAC+B,UAAD,EAAaC,QAAb,CAAX,IAAqClD,+BAA+B,CAAC,KAAKoC,SAAN,CAApE,EAAsF;AACpF,WAAK,MAAMe,aAAX,IAA4BD,QAAQ,IAAI,CAAC,EAAD,CAAxC,EAA8C;AAC5C,cAAME,MAAM,GAAGjD,WAAW,CAAC8C,UAAD,EAAaE,aAAb,CAA1B;AACA;AACA,cAAME,cAAc,GAAG7C,qBAAqB,CAAC4C,MAAD,CAA5C;;AAEA;AACA,cAAME,oBAAoB,GAAG7C,6BAA6B,CAAC2C,MAAD,CAA1D;AACAzC,QAAAA,MAAM;AACJ,SAACM,IAAI,CAACQ,GAAL,CAAS6B,oBAAT,CADG;AAEH,sDAA6CT,cAAe,KAAIQ,cAAe,EAF5E,CAAN;;AAIApC,QAAAA,IAAI,CAACS,GAAL,CAAS4B,oBAAT;AACD;AACF;AACF;;AAEDF,EAAAA,MAAM;AACJG,EAAAA,KADI;AAES;AACb5C,IAAAA,MAAM,CAAC,KAAKyB,SAAL,KAAmBC,SAApB,EAA+B,oCAA/B,CAAN;AACA,QAAIkB,KAAK,YAAYC,QAArB,EAA+B;AAC7B,WAAKpB,SAAL,GAAiBmB,KAAK,CAACtD,sBAAD,CAAtB;AACD,KAFD,MAEO;AACL,WAAKmC,SAAL,GAAiBmB,KAAjB;AACD;AACD,WAAO,IAAP;AACD;;AAEDE,EAAAA,YAAY,CAACF,KAAD,EAAmC;AAC7C5C,IAAAA,MAAM,CAAC,KAAKyB,SAAL,KAAmBC,SAApB,EAA+B,oCAA/B,CAAN;AACA,SAAKD,SAAL,GAAiBnC,sBAAsB,CAACyD,iBAAvB,CAAyCH,KAAzC,CAAjB;AACA,WAAO,IAAP;AACD;;AAEDI,EAAAA,kBAAkB;AAChBT,EAAAA,QADgB;AAEH;AACb,QAAIA,QAAQ,YAAYM,QAAxB,EAAkC;AAChC,aAAO,KAAKJ,MAAL,CAAYF,QAAQ,CAACjD,sBAAsB,CAAC2D,aAAvB,EAAD,CAApB,CAAP;AACD,KAFD,MAEO;AACL,aAAO,KAAKR,MAAL,CAAYnD,sBAAsB,CAAC2D,aAAvB,GAAuCF,iBAAvC,CAAyDR,QAAzD,CAAZ,CAAP;AACD;AACF;;AAED,GAAC7B,OAAD,GAAsC;AACpCV,IAAAA,MAAM,CAAC,KAAKgC,MAAL,KAAgBN,SAAjB,EAA4B,mCAA5B,CAAN;AACA,SAAKD,SAAL,KAAmBnC,sBAAnB;AACA,SAAK,MAAM,CAACgD,UAAD,EAAaC,QAAb,CAAX,IAAqClD,+BAA+B,CAAC,KAAKoC,SAAN,CAApE,EAAsF;AACpF,YAAM,IAAIyB,eAAJ;AACJ,WAAKvB,QADD;AAEJW,MAAAA,UAFI;AAGJC,MAAAA,QAHI;AAIJ,WAAKpC,OAJD;AAKJ,WAAK6B,MALD;AAMJ,WAAKf,iBAND,CAAN;;AAQD;AACF,GA/Ge;;;AAkHlB,MAAMiC,eAAN,CAAyC;;;;;;;;;AASvCzC,EAAAA,WAAW;AACTkB,EAAAA,QADS;AAETc,EAAAA,MAFS;AAGTF,EAAAA,QAHS;AAITpC,EAAAA,OAJS;AAKT4B,EAAAA,EALS;AAMTd,EAAAA,iBANS;AAOT;AACA,SAAKkC,EAAL,GAAU,EAAEnC,IAAI,EAAEW,QAAR,EAAkBc,MAAM,EAAElD,mBAAmB,CAACkD,MAAD,CAA7C,EAAV;AACA,SAAKA,MAAL,GAAcA,MAAd;AACA,SAAKF,QAAL,GAAgBA,QAAhB;AACA,SAAKpC,OAAL,GAAeA,OAAf;AACA,SAAK4B,EAAL,GAAUA,EAAV;AACA,SAAKd,iBAAL,GAAyBA,iBAAzB;AACD;;AAED,QAAMmC,OAAN;AACEC,EAAAA,GADF;AAEEZ,EAAAA,MAFF;AAGEa,EAAAA,SAHF;AAIEC,EAAAA,cAJF;AAKiB;AACf,QAAI;AACFF,MAAAA,GAAG,CAACG,YAAJ;AACA,UAAID,cAAc,KAAK,MAAvB,EAA+B;AAC7B,cAAM,IAAIpE,YAAJ,CAAiB,yBAAjB,CAAN;AACD;AACD,YAAMsE,IAAI,GAAG,IAAI,KAAKtD,OAAT,CAAiBkD,GAAjB,EAAsBZ,MAAtB,CAAb;;AAEA,UAAI;AACF,cAAMgB,IAAI,CAACC,MAAL,EAAN;AACA,cAAM,KAAK3B,EAAL,CAAQ0B,IAAR,CAAN;AACD,OAHD,SAGU;AACR;AACA,cAAMA,IAAI,CAACE,UAAL,EAAN;AACD;AACF,KAdD,CAcE,OAAOC,EAAP,EAAW;AACX;AACA;AACA;AACA;AACA,UAAIN,SAAS,IAAIM,EAAE,YAAYzE,YAA/B,EAA6C;AAC3C,cAAMyE,EAAN;AACD;AACDP,MAAAA,GAAG,CAACQ,KAAJ,CAAUD,EAAV;AACD,KAvBD,SAuBU;AACR,UAAI;AACFP,QAAAA,GAAG,CAACS,UAAJ,CAAeP,cAAf;AACD,OAFD,CAEE,OAAOK,EAAP,EAAW;AACX5D,QAAAA,MAAM,CAAC4D,EAAE,YAAYxE,mBAAf,CAAN;AACAwE,QAAAA,EAAE,CAACG,OAAH,GAAc,+BAAd;AACAH,QAAAA,EAAE,CAACvB,KAAH,GAAW,KAAKpB,iBAAL,CAAuBoB,KAAlC;AACAgB,QAAAA,GAAG,CAACW,IAAJ,CAASJ,EAAT;AACD;AACF;AACF;;AAED,QAAMK,GAAN;AACEZ,EAAAA,GADF;AAEEa,EAAAA,SAFF;AAGEC,EAAAA,YAHF;AAIiB;AACf,UAAMC,iBAAiB,GAAIC,sBAAD,IAAiD;AACzE,UAAIC,UAAU,GAAG,KAAjB;AACA,WAAK,MAAMC,GAAX,IAAkBJ,YAAlB,EAAgC;AAC9B,cAAMK,QAAQ,GAAG/E,cAAc,CAAC8E,GAAG,CAACE,KAAL,EAAYJ,sBAAZ,CAA/B;AACA,YAAIG,QAAQ,KAAK9E,QAAQ,CAACgF,SAAtB,IAAmCF,QAAQ,KAAK9E,QAAQ,CAACiF,YAA7D,EAA2E;AACzE;AACD;;AAED,gBAAQJ,GAAG,CAACK,WAAZ;AACE;AACA;AACA,eAAK,MAAL;AACE,mBAAO,MAAP;AACF,eAAK,MAAL;AACE;AACAN,YAAAA,UAAU,GAAG,IAAb;AACA;AACF;AACErE,YAAAA,WAAW,GAVf;;AAYD;AACD,aAAOqE,UAAU,GAAG,MAAH,GAAY,MAA7B;AACD,KAtBD;;AAwBAjB,IAAAA,GAAG,CAACwB,KAAJ;AACA,QAAI,KAAKtC,QAAT,EAAmB;AACjB,UAAIuC,UAAU,GAAG,CAAjB;AACA,UAAIC,SAAS,GAAG,CAAhB;AACA,WAAK,MAAMC,SAAX,IAAwB,KAAKzC,QAA7B,EAAuC;AACrCc,QAAAA,GAAG,CAAC4B,IAAJ,CAAS,IAAI/D,KAAJ,CAAU,cAAcrB,qBAAqB,CAACmF,SAAD,CAA7C,CAAT;AACA,YAAI;AACF,gBAAMvC,MAAM,GAAGjD,WAAW,CAAC,KAAKiD,MAAN,EAAcuC,SAAd,CAA1B;AACA,gBAAME,YAAY,GAAG,IAAIvF,mBAAJ;AACnBuE,UAAAA,SAAS,CAACiB,KADS;AAEnBjB,UAAAA,SAAS,CAACkB,aAFS;AAGnBlB,UAAAA,SAAS,CAACmB,aAHS;AAInB5C,UAAAA,MAJmB,CAArB;;AAMA,gBAAM,KAAKW,OAAL,CAAaC,GAAb,EAAkBZ,MAAlB,EAA0B,IAA1B,EAAgC2B,iBAAiB,CAACc,YAAD,CAAjD,CAAN;AACD,SATD,CASE,OAAOtB,EAAP,EAAW;AACX,cAAIA,EAAE,YAAYzE,YAAlB,EAAgC;AAC9B;AACAyE,YAAAA,EAAE,CAACG,OAAH,GAAa,sBAAsBH,EAAE,CAACG,OAAtC;AACAV,YAAAA,GAAG,CAAC4B,IAAJ,CAASrB,EAAT;AACA,cAAEmB,SAAF;AACD,WALD,MAKO;AACL;AACA1B,YAAAA,GAAG,CAACQ,KAAJ,CAAUD,EAAV;AACD;AACF;AACD,UAAEkB,UAAF;AACD;AACD,UAAIC,SAAS,KAAKD,UAAlB,EAA8B;AAC5BzB,QAAAA,GAAG,CAACiC,OAAJ,CAAY,IAAInG,YAAJ,CAAiB,2BAAjB,CAAZ;AACD;AACF,KA9BD,MA8BO;AACL,YAAM,KAAKiE,OAAL,CAAaC,GAAb,EAAkB,KAAKZ,MAAvB,EAA+B,KAA/B,EAAsC2B,iBAAiB,CAACF,SAAD,CAAvD,CAAN;AACD;AACDb,IAAAA,GAAG,CAACkC,MAAJ;AACD,GAlIsC","sourcesContent":["import { Fixture, SkipTestCase, TestParams, UnexpectedPassError } from '../framework/fixture.js';\nimport {\n  CaseParamsBuilder,\n  builderIterateCasesWithSubcases,\n  kUnitCaseParamsBuilder,\n  ParamsBuilderBase,\n  SubcaseParamsBuilder,\n} from '../framework/params_builder.js';\nimport { Expectation } from '../internal/logging/result.js';\nimport { TestCaseRecorder } from '../internal/logging/test_case_recorder.js';\nimport { extractPublicParams, Merged, mergeParams } from '../internal/params_utils.js';\nimport { compareQueries, Ordering } from '../internal/query/compare.js';\nimport { TestQuerySingleCase, TestQueryWithExpectation } from '../internal/query/query.js';\nimport { kPathSeparator } from '../internal/query/separators.js';\nimport {\n  stringifyPublicParams,\n  stringifyPublicParamsUniquely,\n} from '../internal/query/stringify_params.js';\nimport { validQueryPart } from '../internal/query/validQueryPart.js';\nimport { assert, unreachable } from '../util/util.js';\n\nexport type RunFn = (\n  rec: TestCaseRecorder,\n  expectations?: TestQueryWithExpectation[]\n) => Promise<void>;\n\nexport interface TestCaseID {\n  readonly test: readonly string[];\n  readonly params: TestParams;\n}\n\nexport interface RunCase {\n  readonly id: TestCaseID;\n  run(\n    rec: TestCaseRecorder,\n    selfQuery: TestQuerySingleCase,\n    expectations: TestQueryWithExpectation[]\n  ): Promise<void>;\n}\n\n// Interface for defining tests\nexport interface TestGroupBuilder<F extends Fixture> {\n  test(name: string): TestBuilderWithName<F>;\n}\nexport function makeTestGroup<F extends Fixture>(fixture: FixtureClass<F>): TestGroupBuilder<F> {\n  return new TestGroup(fixture);\n}\n\n// Interfaces for running tests\nexport interface IterableTestGroup {\n  iterate(): Iterable<IterableTest>;\n  validate(): void;\n}\nexport interface IterableTest {\n  testPath: string[];\n  description: string | undefined;\n  readonly testCreationStack: Error;\n  iterate(): Iterable<RunCase>;\n}\n\nexport function makeTestGroupForUnitTesting<F extends Fixture>(\n  fixture: FixtureClass<F>\n): TestGroup<F> {\n  return new TestGroup(fixture);\n}\n\nexport type FixtureClass<F extends Fixture = Fixture> = new (\n  log: TestCaseRecorder,\n  params: TestParams\n) => F;\ntype TestFn<F extends Fixture, P extends {}> = (t: F & { params: P }) => Promise<void> | void;\n\nexport class TestGroup<F extends Fixture> implements TestGroupBuilder<F> {\n  private fixture: FixtureClass;\n  private seen: Set<string> = new Set();\n  private tests: Array<TestBuilder> = [];\n\n  constructor(fixture: FixtureClass) {\n    this.fixture = fixture;\n  }\n\n  iterate(): Iterable<IterableTest> {\n    return this.tests;\n  }\n\n  private checkName(name: string): void {\n    assert(\n      // Shouldn't happen due to the rule above. Just makes sure that treated\n      // unencoded strings as encoded strings is OK.\n      name === decodeURIComponent(name),\n      `Not decodeURIComponent-idempotent: ${name} !== ${decodeURIComponent(name)}`\n    );\n    assert(!this.seen.has(name), `Duplicate test name: ${name}`);\n\n    this.seen.add(name);\n  }\n\n  // TODO: This could take a fixture, too, to override the one for the group.\n  test(name: string): TestBuilderWithName<F> {\n    const testCreationStack = new Error(`Test created: ${name}`);\n\n    this.checkName(name);\n\n    const parts = name.split(kPathSeparator);\n    for (const p of parts) {\n      assert(validQueryPart.test(p), `Invalid test name part ${p}; must match ${validQueryPart}`);\n    }\n\n    const test = new TestBuilder(parts, this.fixture, testCreationStack);\n    this.tests.push(test);\n    return (test as unknown) as TestBuilderWithName<F>;\n  }\n\n  validate(): void {\n    for (const test of this.tests) {\n      test.validate();\n    }\n  }\n}\n\ninterface TestBuilderWithName<F extends Fixture> extends TestBuilderWithParams<F, {}> {\n  desc(description: string): this;\n\n  /**\n   * Parameterize the test, generating multiple cases, each possibly having subcases.\n   *\n   * The `unit` value passed to the `cases` callback is an immutable constant\n   * `CaseParamsBuilder<{}>` representing the \"unit\" builder `[ {} ]`,\n   * provided for convienience. The non-callback overload can be used if `unit` is not needed.\n   */\n  params<CaseP extends {}, SubcaseP extends {}>(\n    cases: (unit: CaseParamsBuilder<{}>) => ParamsBuilderBase<CaseP, SubcaseP>\n  ): TestBuilderWithParams<F, Merged<CaseP, SubcaseP>>;\n  /**\n   * Parameterize the test, generating multiple cases, each possibly having subcases.\n   *\n   * Use the callback overload of this method if a \"unit\" builder is needed.\n   */\n  params<CaseP extends {}, SubcaseP extends {}>(\n    cases: ParamsBuilderBase<CaseP, SubcaseP>\n  ): TestBuilderWithParams<F, Merged<CaseP, SubcaseP>>;\n\n  /**\n   * Parameterize the test, generating multiple cases, without subcases.\n   */\n  paramsSimple<P extends {}>(cases: Iterable<P>): TestBuilderWithParams<F, P>;\n\n  /**\n   * Parameterize the test, generating one case with multiple subcases.\n   */\n  paramsSubcasesOnly<P extends {}>(subcases: Iterable<P>): TestBuilderWithParams<F, P>;\n  /**\n   * Parameterize the test, generating one case with multiple subcases.\n   *\n   * The `unit` value passed to the `subcases` callback is an immutable constant\n   * `SubcaseParamsBuilder<{}>`, with one empty case `{}` and one empty subcase `{}`.\n   */\n  paramsSubcasesOnly<P extends {}>(\n    subcases: (unit: SubcaseParamsBuilder<{}, {}>) => SubcaseParamsBuilder<{}, P>\n  ): TestBuilderWithParams<F, P>;\n}\n\ninterface TestBuilderWithParams<F extends Fixture, P extends {}> {\n  fn(fn: TestFn<F, P>): void;\n  unimplemented(): void;\n}\n\nclass TestBuilder {\n  readonly testPath: string[];\n  description: string | undefined;\n  readonly testCreationStack: Error;\n\n  private readonly fixture: FixtureClass;\n  private testFn: TestFn<Fixture, {}> | undefined;\n  private testCases?: ParamsBuilderBase<{}, {}> = undefined;\n\n  constructor(testPath: string[], fixture: FixtureClass, testCreationStack: Error) {\n    this.testPath = testPath;\n    this.fixture = fixture;\n    this.testCreationStack = testCreationStack;\n  }\n\n  desc(description: string): this {\n    this.description = description.trim();\n    return this;\n  }\n\n  fn(fn: TestFn<Fixture, {}>): void {\n    // TODO: add TODO if there's no description? (and make sure it only ends up on actual tests,\n    // not on test parents in the tree, which is what happens if you do it here, not sure why)\n    assert(this.testFn === undefined);\n    this.testFn = fn;\n  }\n\n  unimplemented(): void {\n    assert(this.testFn === undefined);\n\n    this.description =\n      (this.description ? this.description + '\\n\\n' : '') + 'TODO: .unimplemented()';\n\n    this.testFn = () => {\n      throw new SkipTestCase('test unimplemented');\n    };\n  }\n\n  validate(): void {\n    const testPathString = this.testPath.join(kPathSeparator);\n    assert(this.testFn !== undefined, () => {\n      let s = `Test is missing .fn(): ${testPathString}`;\n      if (this.testCreationStack.stack) {\n        s += `\\n-> test created at:\\n${this.testCreationStack.stack}`;\n      }\n      return s;\n    });\n\n    if (this.testCases === undefined) {\n      return;\n    }\n\n    const seen = new Set<string>();\n    for (const [caseParams, subcases] of builderIterateCasesWithSubcases(this.testCases)) {\n      for (const subcaseParams of subcases ?? [{}]) {\n        const params = mergeParams(caseParams, subcaseParams);\n        // stringifyPublicParams also checks for invalid params values\n        const testcaseString = stringifyPublicParams(params);\n\n        // A (hopefully) unique representation of a params value.\n        const testcaseStringUnique = stringifyPublicParamsUniquely(params);\n        assert(\n          !seen.has(testcaseStringUnique),\n          `Duplicate public test case params for test ${testPathString}: ${testcaseString}`\n        );\n        seen.add(testcaseStringUnique);\n      }\n    }\n  }\n\n  params(\n    cases: ((unit: CaseParamsBuilder<{}>) => ParamsBuilderBase<{}, {}>) | ParamsBuilderBase<{}, {}>\n  ): TestBuilder {\n    assert(this.testCases === undefined, 'test case is already parameterized');\n    if (cases instanceof Function) {\n      this.testCases = cases(kUnitCaseParamsBuilder);\n    } else {\n      this.testCases = cases;\n    }\n    return this;\n  }\n\n  paramsSimple(cases: Iterable<{}>): TestBuilder {\n    assert(this.testCases === undefined, 'test case is already parameterized');\n    this.testCases = kUnitCaseParamsBuilder.combineWithParams(cases);\n    return this;\n  }\n\n  paramsSubcasesOnly(\n    subcases: Iterable<{}> | ((unit: SubcaseParamsBuilder<{}, {}>) => SubcaseParamsBuilder<{}, {}>)\n  ): TestBuilder {\n    if (subcases instanceof Function) {\n      return this.params(subcases(kUnitCaseParamsBuilder.beginSubcases()));\n    } else {\n      return this.params(kUnitCaseParamsBuilder.beginSubcases().combineWithParams(subcases));\n    }\n  }\n\n  *iterate(): IterableIterator<RunCase> {\n    assert(this.testFn !== undefined, 'No test function (.fn()) for test');\n    this.testCases ??= kUnitCaseParamsBuilder;\n    for (const [caseParams, subcases] of builderIterateCasesWithSubcases(this.testCases)) {\n      yield new RunCaseSpecific(\n        this.testPath,\n        caseParams,\n        subcases,\n        this.fixture,\n        this.testFn,\n        this.testCreationStack\n      );\n    }\n  }\n}\n\nclass RunCaseSpecific implements RunCase {\n  readonly id: TestCaseID;\n\n  private readonly params: {};\n  private readonly subcases: Iterable<{}> | undefined;\n  private readonly fixture: FixtureClass;\n  private readonly fn: TestFn<Fixture, {}>;\n  private readonly testCreationStack: Error;\n\n  constructor(\n    testPath: string[],\n    params: {},\n    subcases: Iterable<{}> | undefined,\n    fixture: FixtureClass,\n    fn: TestFn<Fixture, {}>,\n    testCreationStack: Error\n  ) {\n    this.id = { test: testPath, params: extractPublicParams(params) };\n    this.params = params;\n    this.subcases = subcases;\n    this.fixture = fixture;\n    this.fn = fn;\n    this.testCreationStack = testCreationStack;\n  }\n\n  async runTest(\n    rec: TestCaseRecorder,\n    params: {},\n    throwSkip: boolean,\n    expectedStatus: Expectation\n  ): Promise<void> {\n    try {\n      rec.beginSubCase();\n      if (expectedStatus === 'skip') {\n        throw new SkipTestCase('Skipped by expectations');\n      }\n      const inst = new this.fixture(rec, params);\n\n      try {\n        await inst.doInit();\n        await this.fn(inst as Fixture & { params: {} });\n      } finally {\n        // Runs as long as constructor succeeded, even if initialization or the test failed.\n        await inst.doFinalize();\n      }\n    } catch (ex) {\n      // There was an exception from constructor, init, test, or finalize.\n      // An error from init or test may have been a SkipTestCase.\n      // An error from finalize may have been an eventualAsyncExpectation failure\n      // or unexpected validation/OOM error from the GPUDevice.\n      if (throwSkip && ex instanceof SkipTestCase) {\n        throw ex;\n      }\n      rec.threw(ex);\n    } finally {\n      try {\n        rec.endSubCase(expectedStatus);\n      } catch (ex) {\n        assert(ex instanceof UnexpectedPassError);\n        ex.message = `Testcase passed unexpectedly.`;\n        ex.stack = this.testCreationStack.stack;\n        rec.warn(ex);\n      }\n    }\n  }\n\n  async run(\n    rec: TestCaseRecorder,\n    selfQuery: TestQuerySingleCase,\n    expectations: TestQueryWithExpectation[]\n  ): Promise<void> {\n    const getExpectedStatus = (selfQueryWithSubParams: TestQuerySingleCase) => {\n      let didSeeFail = false;\n      for (const exp of expectations) {\n        const ordering = compareQueries(exp.query, selfQueryWithSubParams);\n        if (ordering === Ordering.Unordered || ordering === Ordering.StrictSubset) {\n          continue;\n        }\n\n        switch (exp.expectation) {\n          // Skip takes precendence. If there is any expectation indicating a skip,\n          // signal it immediately.\n          case 'skip':\n            return 'skip';\n          case 'fail':\n            // Otherwise, indicate that we might expect a failure.\n            didSeeFail = true;\n            break;\n          default:\n            unreachable();\n        }\n      }\n      return didSeeFail ? 'fail' : 'pass';\n    };\n\n    rec.start();\n    if (this.subcases) {\n      let totalCount = 0;\n      let skipCount = 0;\n      for (const subParams of this.subcases) {\n        rec.info(new Error('subcase: ' + stringifyPublicParams(subParams)));\n        try {\n          const params = mergeParams(this.params, subParams);\n          const subcaseQuery = new TestQuerySingleCase(\n            selfQuery.suite,\n            selfQuery.filePathParts,\n            selfQuery.testPathParts,\n            params\n          );\n          await this.runTest(rec, params, true, getExpectedStatus(subcaseQuery));\n        } catch (ex) {\n          if (ex instanceof SkipTestCase) {\n            // Convert SkipTestCase to info messages\n            ex.message = 'subcase skipped: ' + ex.message;\n            rec.info(ex);\n            ++skipCount;\n          } else {\n            // Since we are catching all error inside runTest(), this should never happen\n            rec.threw(ex);\n          }\n        }\n        ++totalCount;\n      }\n      if (skipCount === totalCount) {\n        rec.skipped(new SkipTestCase('all subcases were skipped'));\n      }\n    } else {\n      await this.runTest(rec, this.params, false, getExpectedStatus(selfQuery));\n    }\n    rec.finish();\n  }\n}\n"],"file":"test_group.js"}