{"version":3,"sources":["../../../src/common/internal/tree.ts"],"names":["assert","compareQueries","Ordering","TestQueryMultiCase","TestQuerySingleCase","TestQueryMultiFile","TestQueryMultiTest","kBigSeparator","kWildcard","kPathSeparator","kParamSeparator","stringifySingleParam","StacklessError","TestTree","constructor","forQuery","root","propagateTODOs","query","level","depthInLevel","iterateCollapsedNodes","includeIntermediateNodes","includeEmptySubtrees","alwaysExpandThroughLevel","expandThroughLevel","Math","max","iterateSubtreeNodes","iterateLeaves","iterateSubtreeLeaves","dissolveSingleChildTrees","newRoot","toString","subtreeToString","subtree","opts","child","children","collapsible","size","subtreeHasTODOs","childHasTODOs","name","tree","indent","todo","undefined","s","JSON","stringify","description","loadTreeForQuery","loader","queryToLoad","subqueriesToExpand","suite","specs","listing","subqueriesToExpandEntries","Array","from","entries","seenSubqueriesToExpand","length","fill","isCollapsible","subquery","every","i","toExpand","ordering","Equal","StrictSubset","foundCase","subtreeL0","makeTreeForSuite","entry","file","setSubtreeDescription","readme","trim","queryL1","orderingL1","Unordered","readmeSubtree","addSubtreeForDirPath","spec","importSpecFile","subtreeL1","addSubtreeForFilePath","groupHasTests","t","g","iterate","queryL2","testPath","orderingL2","subtreeL2","addSubtreeForTestPath","testCreationStack","c","queryL3","id","test","params","orderingL3","StrictSuperset","addLeafForCase","sq","subquerySeen","indexOf","readableRelativeName","Map","subqueryFile","part","push","getOrInsertSubtree","filePathParts","subqueryTest","checkCollapsible","subqueryParams","k","v","Object","testPathParts","insertLeaf","key","parent","createSubtree","get","set","leaf","readableNameForCase","run","rec","expectations","has","shouldDissolveThisTree","newChild","paramsKeys","keys","lastKey"],"mappings":"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","sourcesContent":["import { RunCase, RunFn } from '../internal/test_group.js';\nimport { assert } from '../util/util.js';\n\nimport { TestFileLoader } from './file_loader.js';\nimport { TestParamsRW } from './params_utils.js';\nimport { compareQueries, Ordering } from './query/compare.js';\nimport {\n  TestQuery,\n  TestQueryMultiCase,\n  TestQuerySingleCase,\n  TestQueryMultiFile,\n  TestQueryMultiTest,\n} from './query/query.js';\nimport { kBigSeparator, kWildcard, kPathSeparator, kParamSeparator } from './query/separators.js';\nimport { stringifySingleParam } from './query/stringify_params.js';\nimport { StacklessError } from './util.js';\n\n// `loadTreeForQuery()` loads a TestTree for a given queryToLoad.\n// The resulting tree is a linked-list all the way from `suite:*` to queryToLoad,\n// and under queryToLoad is a tree containing every case matched by queryToLoad.\n//\n// `subqueriesToExpand` influences the `collapsible` flag on nodes in the resulting tree.\n// A node is considered \"collapsible\" if none of the subqueriesToExpand is a StrictSubset\n// of that node.\n//\n// In WebKit/Blink-style web_tests, an expectation file marks individual cts.https.html \"variants\n// as \"Failure\", \"Crash\", etc. By passing in the list of expectations as the subqueriesToExpand,\n// we can programmatically subdivide the cts.https.html \"variants\" list to be able to implement\n// arbitrarily-fine suppressions (instead of having to suppress entire test files, which would\n// lose a lot of coverage).\n//\n// `iterateCollapsedNodes()` produces the list of queries for the variants list.\n//\n// Though somewhat complicated, this system has important benefits:\n//   - Avoids having to suppress entire test files, which would cause large test coverage loss.\n//   - Minimizes the number of page loads needed for fine-grained suppressions.\n//     (In the naive case, we could do one page load per test case - but the test suite would\n//     take impossibly long to run.)\n//   - Enables developers to put any number of tests in one file as appropriate, without worrying\n//     about expectation granularity.\n\ninterface TestTreeNodeBase<T extends TestQuery> {\n  readonly query: T;\n  /**\n   * Readable \"relative\" name for display in standalone runner.\n   * Not always the exact relative name, because sometimes there isn't\n   * one (e.g. s:f:* relative to s:f,*), but something that is readable.\n   */\n  readonly readableRelativeName: string;\n  subtreeHasTODOs?: boolean;\n}\n\nexport interface TestSubtree<T extends TestQuery = TestQuery> extends TestTreeNodeBase<T> {\n  readonly children: Map<string, TestTreeNode>;\n  readonly collapsible: boolean;\n  description?: string;\n  readonly testCreationStack?: Error;\n}\n\nexport interface TestTreeLeaf extends TestTreeNodeBase<TestQuerySingleCase> {\n  readonly run: RunFn;\n  subtreeHasTODOs?: undefined;\n}\n\nexport type TestTreeNode = TestSubtree | TestTreeLeaf;\n\n/**\n * When iterating through \"collapsed\" tree nodes, indicates how many \"query levels\" to traverse\n * through before starting to collapse nodes.\n *\n * Corresponds with TestQueryLevel, but excludes 4 (SingleCase):\n * - 1 = MultiFile. Expands so every file is in the collapsed tree.\n * - 2 = MultiTest. Expands so every test is in the collapsed tree.\n * - 3 = MultiCase. Expands so every case is in the collapsed tree (i.e. collapsing disabled).\n */\nexport type ExpandThroughLevel = 1 | 2 | 3;\n\nexport class TestTree {\n  /**\n   * The `queryToLoad` that this test tree was created for.\n   * Test trees are always rooted at `suite:*`, but they only contain nodes that fit\n   * within `forQuery`.\n   *\n   * This is used for `iterateCollapsedNodes` which only starts collapsing at the next\n   * `TestQueryLevel` after `forQuery`.\n   */\n  readonly forQuery: TestQuery;\n  readonly root: TestSubtree;\n\n  constructor(forQuery: TestQuery, root: TestSubtree) {\n    this.forQuery = forQuery;\n    TestTree.propagateTODOs(root);\n    this.root = root;\n    assert(\n      root.query.level === 1 && root.query.depthInLevel === 0,\n      'TestTree root must be the root (suite:*)'\n    );\n  }\n\n  /**\n   * Iterate through the leaves of a version of the tree which has been pruned to exclude\n   * subtrees which:\n   * - are at a deeper `TestQueryLevel` than `this.forQuery`, and\n   * - were not a `Ordering.StrictSubset` of any of the `subqueriesToExpand` during tree creation.\n   */\n  iterateCollapsedNodes({\n    includeIntermediateNodes = false,\n    includeEmptySubtrees = false,\n    alwaysExpandThroughLevel,\n  }: {\n    /** Whether to include intermediate tree nodes or only collapsed-leaves. */\n    includeIntermediateNodes?: boolean;\n    /** Whether to include collapsed-leaves with no children. */\n    includeEmptySubtrees?: boolean;\n    /** Never collapse nodes up through this level. */\n    alwaysExpandThroughLevel: ExpandThroughLevel;\n  }): IterableIterator<Readonly<TestTreeNode>> {\n    const expandThroughLevel = Math.max(this.forQuery.level, alwaysExpandThroughLevel);\n    return TestTree.iterateSubtreeNodes(this.root, {\n      includeIntermediateNodes,\n      includeEmptySubtrees,\n      expandThroughLevel,\n    });\n  }\n\n  iterateLeaves(): IterableIterator<Readonly<TestTreeLeaf>> {\n    return TestTree.iterateSubtreeLeaves(this.root);\n  }\n\n  /**\n   * Dissolve nodes which have only one child, e.g.:\n   *   a,* { a,b,* { a,b:* { ... } } }\n   * collapses down into:\n   *   a,* { a,b:* { ... } }\n   * which is less needlessly verbose when displaying the tree in the standalone runner.\n   */\n  dissolveSingleChildTrees(): void {\n    const newRoot = dissolveSingleChildTrees(this.root);\n    assert(newRoot === this.root);\n  }\n\n  toString(): string {\n    return TestTree.subtreeToString('(root)', this.root, '');\n  }\n\n  static *iterateSubtreeNodes(\n    subtree: TestSubtree,\n    opts: {\n      includeIntermediateNodes: boolean;\n      includeEmptySubtrees: boolean;\n      expandThroughLevel: number;\n    }\n  ): IterableIterator<TestTreeNode> {\n    if (opts.includeIntermediateNodes) {\n      yield subtree;\n    }\n\n    for (const [, child] of subtree.children) {\n      if ('children' in child) {\n        // Is a subtree\n        const collapsible = child.collapsible && child.query.level > opts.expandThroughLevel;\n        if (child.children.size > 0 && !collapsible) {\n          yield* TestTree.iterateSubtreeNodes(child, opts);\n        } else if (child.children.size > 0 || opts.includeEmptySubtrees) {\n          // Don't yield empty subtrees (e.g. files with no tests) unless includeEmptySubtrees\n          yield child;\n        }\n      } else {\n        // Is a leaf\n        yield child;\n      }\n    }\n  }\n\n  static *iterateSubtreeLeaves(subtree: TestSubtree): IterableIterator<TestTreeLeaf> {\n    for (const [, child] of subtree.children) {\n      if ('children' in child) {\n        yield* TestTree.iterateSubtreeLeaves(child);\n      } else {\n        yield child;\n      }\n    }\n  }\n\n  /** Propagate the \"subtreeHasTODOs\" state upward from leaves to parent nodes. */\n  static propagateTODOs(subtree: TestSubtree): boolean {\n    subtree.subtreeHasTODOs ||= false;\n    for (const [, child] of subtree.children) {\n      if ('children' in child) {\n        const childHasTODOs = TestTree.propagateTODOs(child);\n        subtree.subtreeHasTODOs ||= childHasTODOs;\n      }\n    }\n    return subtree.subtreeHasTODOs;\n  }\n\n  static subtreeToString(name: string, tree: TestTreeNode, indent: string): string {\n    const collapsible = 'run' in tree ? '>' : tree.collapsible ? '+' : '-';\n    const todo = tree.subtreeHasTODOs === undefined ? '' : tree.subtreeHasTODOs ? ' TODO' : ' DONE';\n    let s = indent + `${collapsible}${todo} ${JSON.stringify(name)} => ${tree.query}`;\n    if ('children' in tree) {\n      if (tree.description !== undefined) {\n        s += `\\n${indent}  | ${JSON.stringify(tree.description)}`;\n      }\n\n      for (const [name, child] of tree.children) {\n        s += '\\n' + TestTree.subtreeToString(name, child, indent + '  ');\n      }\n    }\n    return s;\n  }\n}\n\n// MAINTENANCE_TODO: Consider having subqueriesToExpand actually impact the depth-order of params\n// in the tree.\nexport async function loadTreeForQuery(\n  loader: TestFileLoader,\n  queryToLoad: TestQuery,\n  subqueriesToExpand: TestQuery[]\n): Promise<TestTree> {\n  const suite = queryToLoad.suite;\n  const specs = await loader.listing(suite);\n\n  const subqueriesToExpandEntries = Array.from(subqueriesToExpand.entries());\n  const seenSubqueriesToExpand: boolean[] = new Array(subqueriesToExpand.length);\n  seenSubqueriesToExpand.fill(false);\n\n  const isCollapsible = (subquery: TestQuery) =>\n    subqueriesToExpandEntries.every(([i, toExpand]) => {\n      const ordering = compareQueries(toExpand, subquery);\n\n      // If toExpand == subquery, no expansion is needed (but it's still \"seen\").\n      if (ordering === Ordering.Equal) seenSubqueriesToExpand[i] = true;\n      return ordering !== Ordering.StrictSubset;\n    });\n\n  // L0 = suite-level, e.g. suite:*\n  // L1 =  file-level, e.g. suite:a,b:*\n  // L2 =  test-level, e.g. suite:a,b:c,d:*\n  // L3 =  case-level, e.g. suite:a,b:c,d:\n  let foundCase = false;\n  // L0 is suite:*\n  const subtreeL0 = makeTreeForSuite(suite, isCollapsible);\n  for (const entry of specs) {\n    if (entry.file.length === 0 && 'readme' in entry) {\n      // Suite-level readme.\n      setSubtreeDescription(subtreeL0, entry.readme.trim());\n      continue;\n    }\n\n    {\n      const queryL1 = new TestQueryMultiFile(suite, entry.file);\n      const orderingL1 = compareQueries(queryL1, queryToLoad);\n      if (orderingL1 === Ordering.Unordered) {\n        // File path is not matched by this query.\n        continue;\n      }\n    }\n\n    if ('readme' in entry) {\n      // Entry is a README that is an ancestor or descendant of the query.\n      // (It's included for display in the standalone runner.)\n\n      // readmeSubtree is suite:a,b,*\n      // (This is always going to dedup with a file path, if there are any test spec files under\n      // the directory that has the README).\n      const readmeSubtree: TestSubtree<TestQueryMultiFile> = addSubtreeForDirPath(\n        subtreeL0,\n        entry.file,\n        isCollapsible\n      );\n      setSubtreeDescription(readmeSubtree, entry.readme.trim());\n      continue;\n    }\n    // Entry is a spec file.\n\n    const spec = await loader.importSpecFile(queryToLoad.suite, entry.file);\n    // subtreeL1 is suite:a,b:*\n    const subtreeL1: TestSubtree<TestQueryMultiTest> = addSubtreeForFilePath(\n      subtreeL0,\n      entry.file,\n      isCollapsible\n    );\n    setSubtreeDescription(subtreeL1, spec.description.trim());\n\n    let groupHasTests = false;\n    for (const t of spec.g.iterate()) {\n      groupHasTests = true;\n      {\n        const queryL2 = new TestQueryMultiCase(suite, entry.file, t.testPath, {});\n        const orderingL2 = compareQueries(queryL2, queryToLoad);\n        if (orderingL2 === Ordering.Unordered) {\n          // Test path is not matched by this query.\n          continue;\n        }\n      }\n\n      // subtreeL2 is suite:a,b:c,d:*\n      const subtreeL2: TestSubtree<TestQueryMultiCase> = addSubtreeForTestPath(\n        subtreeL1,\n        t.testPath,\n        t.testCreationStack,\n        isCollapsible\n      );\n      if (t.description) setSubtreeDescription(subtreeL2, t.description.trim());\n\n      // MAINTENANCE_TODO: If tree generation gets too slow, avoid actually iterating the cases in a\n      // file if there's no need to (based on the subqueriesToExpand).\n      for (const c of t.iterate()) {\n        {\n          const queryL3 = new TestQuerySingleCase(suite, entry.file, c.id.test, c.id.params);\n          const orderingL3 = compareQueries(queryL3, queryToLoad);\n          if (orderingL3 === Ordering.Unordered || orderingL3 === Ordering.StrictSuperset) {\n            // Case is not matched by this query.\n            continue;\n          }\n        }\n\n        // Leaf for case is suite:a,b:c,d:x=1;y=2\n        addLeafForCase(subtreeL2, c, isCollapsible);\n\n        foundCase = true;\n      }\n    }\n    if (!groupHasTests && !subtreeL1.subtreeHasTODOs) {\n      throw new StacklessError(\n        `${subtreeL1.query} has no tests - it must have \"TODO\" in its description`\n      );\n    }\n  }\n\n  for (const [i, sq] of subqueriesToExpandEntries) {\n    const subquerySeen = seenSubqueriesToExpand[i];\n    if (!subquerySeen) {\n      throw new StacklessError(\n        `subqueriesToExpand entry did not match anything \\\n(could be wrong, or could be redundant with a previous subquery):\\n  ${sq.toString()}`\n      );\n    }\n  }\n  assert(foundCase, 'Query does not match any cases');\n\n  return new TestTree(queryToLoad, subtreeL0);\n}\n\nfunction setSubtreeDescription(subtree: TestSubtree<TestQueryMultiFile>, description: string) {\n  assert(subtree.description === undefined);\n  subtree.description = description;\n  if (subtree.description.indexOf('TODO') !== -1) {\n    subtree.subtreeHasTODOs = true;\n  }\n}\n\nfunction makeTreeForSuite(\n  suite: string,\n  isCollapsible: (sq: TestQuery) => boolean\n): TestSubtree<TestQueryMultiFile> {\n  const query = new TestQueryMultiFile(suite, []);\n  return {\n    readableRelativeName: suite + kBigSeparator,\n    query,\n    children: new Map(),\n    collapsible: isCollapsible(query),\n  };\n}\n\nfunction addSubtreeForDirPath(\n  tree: TestSubtree<TestQueryMultiFile>,\n  file: string[],\n  isCollapsible: (sq: TestQuery) => boolean\n): TestSubtree<TestQueryMultiFile> {\n  const subqueryFile: string[] = [];\n  // To start, tree is suite:*\n  // This loop goes from that -> suite:a,* -> suite:a,b,*\n  for (const part of file) {\n    subqueryFile.push(part);\n    tree = getOrInsertSubtree(part, tree, () => {\n      const query = new TestQueryMultiFile(tree.query.suite, subqueryFile);\n      return {\n        readableRelativeName: part + kPathSeparator + kWildcard,\n        query,\n        collapsible: isCollapsible(query),\n      };\n    });\n  }\n  return tree;\n}\n\nfunction addSubtreeForFilePath(\n  tree: TestSubtree<TestQueryMultiFile>,\n  file: string[],\n  isCollapsible: (sq: TestQuery) => boolean\n): TestSubtree<TestQueryMultiTest> {\n  // To start, tree is suite:*\n  // This goes from that -> suite:a,* -> suite:a,b,*\n  tree = addSubtreeForDirPath(tree, file, isCollapsible);\n  // This goes from that -> suite:a,b:*\n  const subtree = getOrInsertSubtree('', tree, () => {\n    const query = new TestQueryMultiTest(tree.query.suite, tree.query.filePathParts, []);\n    assert(file.length > 0, 'file path is empty');\n    return {\n      readableRelativeName: file[file.length - 1] + kBigSeparator + kWildcard,\n      query,\n      collapsible: isCollapsible(query),\n    };\n  });\n  return subtree;\n}\n\nfunction addSubtreeForTestPath(\n  tree: TestSubtree<TestQueryMultiTest>,\n  test: readonly string[],\n  testCreationStack: Error,\n  isCollapsible: (sq: TestQuery) => boolean\n): TestSubtree<TestQueryMultiCase> {\n  const subqueryTest: string[] = [];\n  // To start, tree is suite:a,b:*\n  // This loop goes from that -> suite:a,b:c,* -> suite:a,b:c,d,*\n  for (const part of test) {\n    subqueryTest.push(part);\n    tree = getOrInsertSubtree(part, tree, () => {\n      const query = new TestQueryMultiTest(\n        tree.query.suite,\n        tree.query.filePathParts,\n        subqueryTest\n      );\n      return {\n        readableRelativeName: part + kPathSeparator + kWildcard,\n        query,\n        collapsible: isCollapsible(query),\n      };\n    });\n  }\n  // This goes from that -> suite:a,b:c,d:*\n  return getOrInsertSubtree('', tree, () => {\n    const query = new TestQueryMultiCase(\n      tree.query.suite,\n      tree.query.filePathParts,\n      subqueryTest,\n      {}\n    );\n    assert(subqueryTest.length > 0, 'subqueryTest is empty');\n    return {\n      readableRelativeName: subqueryTest[subqueryTest.length - 1] + kBigSeparator + kWildcard,\n      kWildcard,\n      query,\n      testCreationStack,\n      collapsible: isCollapsible(query),\n    };\n  });\n}\n\nfunction addLeafForCase(\n  tree: TestSubtree<TestQueryMultiTest>,\n  t: RunCase,\n  checkCollapsible: (sq: TestQuery) => boolean\n): void {\n  const query = tree.query;\n  let name: string = '';\n  const subqueryParams: TestParamsRW = {};\n\n  // To start, tree is suite:a,b:c,d:*\n  // This loop goes from that -> suite:a,b:c,d:x=1;* -> suite:a,b:c,d:x=1;y=2;*\n  for (const [k, v] of Object.entries(t.id.params)) {\n    name = stringifySingleParam(k, v);\n    subqueryParams[k] = v;\n\n    tree = getOrInsertSubtree(name, tree, () => {\n      const subquery = new TestQueryMultiCase(\n        query.suite,\n        query.filePathParts,\n        query.testPathParts,\n        subqueryParams\n      );\n      return {\n        readableRelativeName: name + kParamSeparator + kWildcard,\n        query: subquery,\n        collapsible: checkCollapsible(subquery),\n      };\n    });\n  }\n\n  // This goes from that -> suite:a,b:c,d:x=1;y=2\n  const subquery = new TestQuerySingleCase(\n    query.suite,\n    query.filePathParts,\n    query.testPathParts,\n    subqueryParams\n  );\n  checkCollapsible(subquery); // mark seenSubqueriesToExpand\n  insertLeaf(tree, subquery, t);\n}\n\nfunction getOrInsertSubtree<T extends TestQuery>(\n  key: string,\n  parent: TestSubtree,\n  createSubtree: () => Omit<TestSubtree<T>, 'children'>\n): TestSubtree<T> {\n  let v: TestSubtree<T>;\n  const child = parent.children.get(key);\n  if (child !== undefined) {\n    assert('children' in child); // Make sure cached subtree is not actually a leaf\n    v = child as TestSubtree<T>;\n  } else {\n    v = { ...createSubtree(), children: new Map() };\n    parent.children.set(key, v);\n  }\n  return v;\n}\n\nfunction insertLeaf(parent: TestSubtree, query: TestQuerySingleCase, t: RunCase) {\n  const key = '';\n  const leaf: TestTreeLeaf = {\n    readableRelativeName: readableNameForCase(query),\n    query,\n    run: (rec, expectations) => t.run(rec, query, expectations || []),\n  };\n  assert(!parent.children.has(key));\n  parent.children.set(key, leaf);\n}\n\nfunction dissolveSingleChildTrees(tree: TestTreeNode): TestTreeNode {\n  if ('children' in tree) {\n    const shouldDissolveThisTree =\n      tree.children.size === 1 && tree.query.depthInLevel !== 0 && tree.description === undefined;\n    if (shouldDissolveThisTree) {\n      // Loops exactly once\n      for (const [, child] of tree.children) {\n        // Recurse on child\n        return dissolveSingleChildTrees(child);\n      }\n    }\n\n    for (const [k, child] of tree.children) {\n      // Recurse on each child\n      const newChild = dissolveSingleChildTrees(child);\n      if (newChild !== child) {\n        tree.children.set(k, newChild);\n      }\n    }\n  }\n  return tree;\n}\n\n/** Generate a readable relative name for a case (used in standalone). */\nfunction readableNameForCase(query: TestQuerySingleCase): string {\n  const paramsKeys = Object.keys(query.params);\n  if (paramsKeys.length === 0) {\n    return query.testPathParts[query.testPathParts.length - 1] + kBigSeparator;\n  } else {\n    const lastKey = paramsKeys[paramsKeys.length - 1];\n    return stringifySingleParam(lastKey, query.params[lastKey]);\n  }\n}\n"],"file":"tree.js"}