{"version":3,"sources":["../../../../src/common/internal/logging/test_case_recorder.ts"],"names":["SkipTestCase","UnexpectedPassError","now","assert","LogMessageWithStack","LogSeverity","kMaxLogStacks","kMinSeverityForStack","Warn","TestCaseRecorder","inSubCase","subCaseStatus","Pass","finalCaseStatus","hideStacksBelowSeverity","startTime","logs","logLinesAtCurrentSeverity","debugging","messagesForPreviouslySeenStacks","Map","constructor","result","start","finish","timeMilliseconds","timems","Math","ceil","status","Skip","beginSubCase","endSubCase","expectedStatus","injectResult","injectedResult","Object","assign","debug","ex","logImpl","info","skipped","warn","expectationFailed","ExpectFailed","validationFailed","ValidationFailed","threw","ThrewException","level","name","baseException","logMessage","stack","seen","get","incrementTimesSeen","set","log","setStackHidden","push"],"mappings":"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","sourcesContent":["import { SkipTestCase, UnexpectedPassError } from '../../framework/fixture.js';\nimport { now, assert } from '../../util/util.js';\n\nimport { LogMessageWithStack } from './log_message.js';\nimport { Expectation, LiveTestCaseResult } from './result.js';\n\nenum LogSeverity {\n  Pass = 0,\n  Skip = 1,\n  Warn = 2,\n  ExpectFailed = 3,\n  ValidationFailed = 4,\n  ThrewException = 5,\n}\n\nconst kMaxLogStacks = 2;\nconst kMinSeverityForStack = LogSeverity.Warn;\n\n/** Holds onto a LiveTestCaseResult owned by the Logger, and writes the results into it. */\nexport class TestCaseRecorder {\n  private result: LiveTestCaseResult;\n  private inSubCase: boolean = false;\n  private subCaseStatus = LogSeverity.Pass;\n  private finalCaseStatus = LogSeverity.Pass;\n  private hideStacksBelowSeverity = kMinSeverityForStack;\n  private startTime = -1;\n  private logs: LogMessageWithStack[] = [];\n  private logLinesAtCurrentSeverity = 0;\n  private debugging = false;\n  /** Used to dedup log messages which have identical stacks. */\n  private messagesForPreviouslySeenStacks = new Map<string, LogMessageWithStack>();\n\n  constructor(result: LiveTestCaseResult, debugging: boolean) {\n    this.result = result;\n    this.debugging = debugging;\n  }\n\n  start(): void {\n    assert(this.startTime < 0, 'TestCaseRecorder cannot be reused');\n    this.startTime = now();\n  }\n\n  finish(): void {\n    assert(this.startTime >= 0, 'finish() before start()');\n\n    const timeMilliseconds = now() - this.startTime;\n    // Round to next microsecond to avoid storing useless .xxxx00000000000002 in results.\n    this.result.timems = Math.ceil(timeMilliseconds * 1000) / 1000;\n\n    // Convert numeric enum back to string (but expose 'exception' as 'fail')\n    this.result.status =\n      this.finalCaseStatus === LogSeverity.Pass\n        ? 'pass'\n        : this.finalCaseStatus === LogSeverity.Skip\n        ? 'skip'\n        : this.finalCaseStatus === LogSeverity.Warn\n        ? 'warn'\n        : 'fail'; // Everything else is an error\n\n    this.result.logs = this.logs;\n  }\n\n  beginSubCase() {\n    this.subCaseStatus = LogSeverity.Pass;\n    this.inSubCase = true;\n  }\n\n  endSubCase(expectedStatus: Expectation) {\n    try {\n      if (expectedStatus === 'fail') {\n        if (this.subCaseStatus <= LogSeverity.Warn) {\n          throw new UnexpectedPassError();\n        } else {\n          this.subCaseStatus = LogSeverity.Pass;\n        }\n      }\n    } finally {\n      this.inSubCase = false;\n      if (this.subCaseStatus > this.finalCaseStatus) {\n        this.finalCaseStatus = this.subCaseStatus;\n      }\n    }\n  }\n\n  injectResult(injectedResult: LiveTestCaseResult): void {\n    Object.assign(this.result, injectedResult);\n  }\n\n  debug(ex: Error): void {\n    if (!this.debugging) return;\n    this.logImpl(LogSeverity.Pass, 'DEBUG', ex);\n  }\n\n  info(ex: Error): void {\n    this.logImpl(LogSeverity.Pass, 'INFO', ex);\n  }\n\n  skipped(ex: SkipTestCase): void {\n    this.logImpl(LogSeverity.Skip, 'SKIP', ex);\n  }\n\n  warn(ex: Error): void {\n    this.logImpl(LogSeverity.Warn, 'WARN', ex);\n  }\n\n  expectationFailed(ex: Error): void {\n    this.logImpl(LogSeverity.ExpectFailed, 'EXPECTATION FAILED', ex);\n  }\n\n  validationFailed(ex: Error): void {\n    this.logImpl(LogSeverity.ValidationFailed, 'VALIDATION FAILED', ex);\n  }\n\n  threw(ex: Error): void {\n    if (ex instanceof SkipTestCase) {\n      this.skipped(ex);\n      return;\n    }\n    this.logImpl(LogSeverity.ThrewException, 'EXCEPTION', ex);\n  }\n\n  private logImpl(level: LogSeverity, name: string, baseException: Error): void {\n    const logMessage = new LogMessageWithStack(name, baseException);\n\n    // Deduplicate errors with the exact same stack\n    if (!this.debugging && logMessage.stack) {\n      const seen = this.messagesForPreviouslySeenStacks.get(logMessage.stack);\n      if (seen) {\n        seen.incrementTimesSeen();\n        return;\n      }\n      this.messagesForPreviouslySeenStacks.set(logMessage.stack, logMessage);\n    }\n\n    // Final case status should be the \"worst\" of all log entries.\n    if (this.inSubCase) {\n      if (level > this.subCaseStatus) this.subCaseStatus = level;\n    } else {\n      if (level > this.finalCaseStatus) this.finalCaseStatus = level;\n    }\n\n    // setStackHidden for all logs except `kMaxLogStacks` stacks at the highest severity\n    if (level > this.hideStacksBelowSeverity) {\n      this.logLinesAtCurrentSeverity = 0;\n      this.hideStacksBelowSeverity = level;\n\n      // Go back and setStackHidden for everything of a lower log level\n      for (const log of this.logs) {\n        log.setStackHidden('stack hidden; lower-severity');\n      }\n    }\n    if (level === this.hideStacksBelowSeverity) {\n      this.logLinesAtCurrentSeverity++;\n    } else if (level < kMinSeverityForStack) {\n      logMessage.setStackHidden('');\n    } else if (level < this.hideStacksBelowSeverity) {\n      logMessage.setStackHidden('stack hidden; lower-severity');\n    }\n    if (this.logLinesAtCurrentSeverity > kMaxLogStacks) {\n      logMessage.setStackHidden(`only ${kMaxLogStacks} stacks are shown`);\n    }\n\n    this.logs.push(logMessage);\n  }\n}\n"],"file":"test_case_recorder.js"}