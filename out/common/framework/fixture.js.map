{"version":3,"sources":["../../../src/common/framework/fixture.ts"],"names":["TestCaseRecorder","assert","unreachable","SkipTestCase","Error","UnexpectedPassError","Fixture","eventualExpectations","numOutstandingAsyncExpectations","constructor","rec","params","_params","init","finalize","length","p","shift","ex","threw","doInit","doFinalize","debug","msg","skip","warn","fail","expectationFailed","immediateAsyncExpectation","fn","ret","eventualAsyncExpectation","promise","push","expectErrorValue","expectedName","niceStack","message","actualName","name","shouldResolve","m","shouldReject","shouldThrow","expect","cond","expectOK","error","mode","stack"],"mappings":"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","sourcesContent":["import { TestCaseRecorder } from '../internal/logging/test_case_recorder.js';\nimport { JSONWithUndefined } from '../internal/params_utils.js';\nimport { assert, unreachable } from '../util/util.js';\n\nexport class SkipTestCase extends Error {}\nexport class UnexpectedPassError extends Error {}\n\nexport { TestCaseRecorder } from '../internal/logging/test_case_recorder.js';\n\n/** The fully-general type for params passed to a test function invocation. */\nexport type TestParams = {\n  readonly [k: string]: JSONWithUndefined;\n};\n\n/**\n * A Fixture is a class used to instantiate each test sub/case at run time.\n * A new instance of the Fixture is created for every single test subcase\n * (i.e. every time the test function is run).\n */\nexport class Fixture {\n  private _params: unknown;\n  /**\n   * Interface for recording logs and test status.\n   *\n   * @internal\n   */\n  protected rec: TestCaseRecorder;\n  private eventualExpectations: Array<Promise<unknown>> = [];\n  private numOutstandingAsyncExpectations = 0;\n\n  /** @internal */\n  constructor(rec: TestCaseRecorder, params: TestParams) {\n    this.rec = rec;\n    this._params = params;\n  }\n\n  /**\n   * Returns the (case+subcase) parameters for this test function invocation.\n   */\n  get params(): unknown {\n    return this._params;\n  }\n\n  // This has to be a member function instead of an async `createFixture` function, because\n  // we need to be able to ergonomically override it in subclasses.\n  /**\n   * Override this to do additional pre-test-function work in a derived fixture.\n   */\n  protected async init(): Promise<void> {}\n\n  /**\n   * Override this to do additional post-test-function work in a derived fixture.\n   *\n   * Called even if init was unsuccessful.\n   */\n  protected async finalize(): Promise<void> {\n    assert(\n      this.numOutstandingAsyncExpectations === 0,\n      'there were outstanding immediateAsyncExpectations (e.g. expectUncapturedError) at the end of the test'\n    );\n\n    // Loop to exhaust the eventualExpectations in case they chain off each other.\n    while (this.eventualExpectations.length) {\n      const p = this.eventualExpectations.shift()!;\n      try {\n        await p;\n      } catch (ex) {\n        this.rec.threw(ex);\n      }\n    }\n  }\n\n  /** @internal */\n  doInit(): Promise<void> {\n    return this.init();\n  }\n\n  /** @internal */\n  doFinalize(): Promise<void> {\n    return this.finalize();\n  }\n\n  /** Log a debug message. */\n  debug(msg: string): void {\n    this.rec.debug(new Error(msg));\n  }\n\n  /** Throws an exception marking the subcase as skipped. */\n  skip(msg: string): never {\n    throw new SkipTestCase(msg);\n  }\n\n  /** Log a warning and increase the result status to \"Warn\". */\n  warn(msg?: string): void {\n    this.rec.warn(new Error(msg));\n  }\n\n  /** Log an error and increase the result status to \"ExpectFailed\". */\n  fail(msg?: string): void {\n    this.rec.expectationFailed(new Error(msg));\n  }\n\n  /**\n   * Wraps an async function. Tracks its status to fail if the test tries to report a test status\n   * before the async work has finished.\n   */\n  protected async immediateAsyncExpectation<T>(fn: () => Promise<T>): Promise<T> {\n    this.numOutstandingAsyncExpectations++;\n    const ret = await fn();\n    this.numOutstandingAsyncExpectations--;\n    return ret;\n  }\n\n  /**\n   * Wraps an async function, passing it an `Error` object recording the original stack trace.\n   * The async work will be implicitly waited upon before reporting a test status.\n   */\n  protected eventualAsyncExpectation<T>(fn: (niceStack: Error) => Promise<T>): Promise<T> {\n    const promise = fn(new Error());\n    this.eventualExpectations.push(promise);\n    return promise;\n  }\n\n  private expectErrorValue(expectedName: string, ex: unknown, niceStack: Error): void {\n    if (!(ex instanceof Error)) {\n      niceStack.message = `THREW non-error value, of type ${typeof ex}: ${ex}`;\n      this.rec.expectationFailed(niceStack);\n      return;\n    }\n    const actualName = ex.name;\n    if (actualName !== expectedName) {\n      niceStack.message = `THREW ${actualName}, instead of ${expectedName}: ${ex}`;\n      this.rec.expectationFailed(niceStack);\n    } else {\n      niceStack.message = `OK: threw ${actualName}: ${ex.message}`;\n      this.rec.debug(niceStack);\n    }\n  }\n\n  /** Expect that the provided promise resolves (fulfills). */\n  shouldResolve(p: Promise<unknown>, msg?: string): void {\n    this.eventualAsyncExpectation(async niceStack => {\n      const m = msg ? ': ' + msg : '';\n      try {\n        await p;\n        niceStack.message = 'resolved as expected' + m;\n      } catch (ex) {\n        niceStack.message = `REJECTED${m}\\n${ex.message}`;\n        this.rec.expectationFailed(niceStack);\n      }\n    });\n  }\n\n  /** Expect that the provided promise rejects, with the provided exception name. */\n  shouldReject(expectedName: string, p: Promise<unknown>, msg?: string): void {\n    this.eventualAsyncExpectation(async niceStack => {\n      const m = msg ? ': ' + msg : '';\n      try {\n        await p;\n        niceStack.message = 'DID NOT REJECT' + m;\n        this.rec.expectationFailed(niceStack);\n      } catch (ex) {\n        niceStack.message = 'rejected as expected' + m;\n        this.expectErrorValue(expectedName, ex, niceStack);\n      }\n    });\n  }\n\n  /** Expect that the provided function throws, with the provided exception name. */\n  shouldThrow(expectedName: string, fn: () => void, msg?: string): void {\n    const m = msg ? ': ' + msg : '';\n    try {\n      fn();\n      this.rec.expectationFailed(new Error('DID NOT THROW' + m));\n    } catch (ex) {\n      this.expectErrorValue(expectedName, ex, new Error(m));\n    }\n  }\n\n  /** Expect that a condition is true. */\n  expect(cond: boolean, msg?: string): boolean {\n    if (cond) {\n      const m = msg ? ': ' + msg : '';\n      this.rec.debug(new Error('expect OK' + m));\n    } else {\n      this.rec.expectationFailed(new Error(msg));\n    }\n    return cond;\n  }\n\n  /** If the argument is an Error, fail (or warn). Otherwise, no-op. */\n  expectOK(\n    error: Error | unknown,\n    { mode = 'fail', niceStack }: { mode?: 'fail' | 'warn'; niceStack?: Error } = {}\n  ): void {\n    if (error instanceof Error) {\n      if (niceStack) {\n        error.stack = niceStack.stack;\n      }\n      if (mode === 'fail') {\n        this.rec.expectationFailed(error);\n      } else if (mode === 'warn') {\n        this.rec.warn(error);\n      } else {\n        unreachable();\n      }\n    }\n  }\n}\n"],"file":"fixture.js"}