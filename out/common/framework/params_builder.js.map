{"version":3,"sources":["../../../src/common/framework/params_builder.ts"],"names":["mergeParams","stringifyPublicParams","assert","mapLazy","ParamsBuilderBase","constructor","cases","builderIterateCasesWithSubcases","builder","iterateCasesWithSubcases","CaseParamsBuilder","a","undefined","Symbol","iterator","expandWithParams","expander","newGenerator","expanderGenerator","expand","key","p","value","combineWithParams","newParams","assertNotGenerator","seenValues","Set","params","paramsStr","has","add","combine","values","mapped","v","filter","pred","filterGenerator","unless","x","beginSubcases","SubcaseParamsBuilder","kUnitCaseParamsBuilder","generator","subcases","caseP","Array","from","length","baseGenerator","base","b"],"mappings":"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","sourcesContent":["import { Merged, mergeParams } from '../internal/params_utils.js';\nimport { stringifyPublicParams } from '../internal/query/stringify_params.js';\nimport { assert, mapLazy } from '../util/util.js';\n\n// ================================================================\n// \"Public\" ParamsBuilder API / Documentation\n// ================================================================\n\n/**\n * Provides doc comments for the methods of CaseParamsBuilder and SubcaseParamsBuilder.\n * (Also enforces rough interface match between them.)\n */\nexport interface ParamsBuilder {\n  /**\n   * Expands each item in `this` into zero or more items.\n   * Each item has its parameters expanded with those returned by the `expander`.\n   *\n   * **Note:** When only a single key is being added, use the simpler `expand` for readability.\n   *\n   * ```text\n   *               this = [     a       ,      b     ,       c       ]\n   * this.map(expander) = [   f(a)           f(b)          f(c)      ]\n   *                    = [[a1, a2, a3] ,    [ b1 ]  ,       []      ]\n   *  merge and flatten = [ merge(a, a1), merge(a, a2), merge(a, a3), merge(b, b1) ]\n   * ```\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  expandWithParams(expander: (_: any) => any): any;\n\n  /**\n   * Expands each item in `this` into zero or more items. Each item has its parameters expanded\n   * with one new key, `key`, and the values returned by `expander`.\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  expand(key: string, expander: (_: any) => any): any;\n\n  /**\n   * Expands each item in `this` to multiple items, one for each item in `newParams`.\n   *\n   * In other words, takes the cartesian product of [ the items in `this` ] and `newParams`.\n   *\n   * **Note:** When only a single key is being added, use the simpler `combine` for readability.\n   *\n   * ```text\n   *                     this = [ {a:1}, {b:2} ]\n   *                newParams = [ {x:1}, {y:2} ]\n   * this.combineP(newParams) = [ {a:1,x:1}, {a:1,y:2}, {b:2,x:1}, {b:2,y:2} ]\n   * ```\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  combineWithParams(newParams: Iterable<any>): any;\n\n  /**\n   * Expands each item in `this` to multiple items with `{ [name]: value }` for each value.\n   *\n   * In other words, takes the cartesian product of [ the items in `this` ]\n   * and `[ {[name]: value} for each value in values ]`\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  combine(key: string, newParams: Iterable<any>): any;\n\n  /**\n   * Filters `this` to only items for which `pred` returns true.\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  filter(pred: (_: any) => boolean): any;\n\n  /**\n   * Filters `this` to only items for which `pred` returns false.\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  unless(pred: (_: any) => boolean): any;\n}\n\n/**\n * Determines the resulting parameter object type which would be generated by an object of\n * the given ParamsBuilder type.\n */\nexport type ParamTypeOf<\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  T extends ParamsBuilder\n> = T extends SubcaseParamsBuilder<infer CaseP, infer SubcaseP>\n  ? Merged<CaseP, SubcaseP>\n  : T extends CaseParamsBuilder<infer CaseP>\n  ? CaseP\n  : never;\n\n// ================================================================\n// Implementation\n// ================================================================\n\n/**\n * Iterable over pairs of either:\n * - `[case params, Iterable<subcase params>]` if there are subcases.\n * - `[case params, undefined]` if not.\n */\nexport type CaseSubcaseIterable<CaseP, SubcaseP> = Iterable<\n  readonly [CaseP, Iterable<SubcaseP> | undefined]\n>;\n\n/**\n * Base class for `CaseParamsBuilder` and `SubcaseParamsBuilder`.\n */\nexport abstract class ParamsBuilderBase<CaseP extends {}, SubcaseP extends {}> {\n  protected readonly cases: () => Generator<CaseP>;\n\n  constructor(cases: () => Generator<CaseP>) {\n    this.cases = cases;\n  }\n\n  /**\n   * Hidden from test files. Use `builderIterateCasesWithSubcases` to access this.\n   */\n  protected abstract iterateCasesWithSubcases(): CaseSubcaseIterable<CaseP, SubcaseP>;\n}\n\n/**\n * Calls the (normally hidden) `iterateCasesWithSubcases()` method.\n */\nexport function builderIterateCasesWithSubcases(builder: ParamsBuilderBase<{}, {}>) {\n  interface IterableParamsBuilder {\n    iterateCasesWithSubcases(): CaseSubcaseIterable<{}, {}>;\n  }\n\n  return ((builder as unknown) as IterableParamsBuilder).iterateCasesWithSubcases();\n}\n\n/**\n * Builder for combinatorial test **case** parameters.\n *\n * CaseParamsBuilder is immutable. Each method call returns a new, immutable object,\n * modifying the list of cases according to the method called.\n *\n * This means, for example, that the `unit` passed into `TestBuilder.params()` can be reused.\n */\nexport class CaseParamsBuilder<CaseP extends {}>\n  extends ParamsBuilderBase<CaseP, {}>\n  implements Iterable<CaseP>, ParamsBuilder {\n  *iterateCasesWithSubcases(): CaseSubcaseIterable<CaseP, {}> {\n    for (const a of this.cases()) {\n      yield [a, undefined];\n    }\n  }\n\n  [Symbol.iterator](): Iterator<CaseP> {\n    return this.cases();\n  }\n\n  /** @inheritdoc */\n  expandWithParams<NewP extends {}>(\n    expander: (_: Merged<{}, CaseP>) => Iterable<NewP>\n  ): CaseParamsBuilder<Merged<CaseP, NewP>> {\n    const newGenerator = expanderGenerator(this.cases, expander);\n    return new CaseParamsBuilder(() => newGenerator({}));\n  }\n\n  /** @inheritdoc */\n  expand<NewPKey extends string, NewPValue>(\n    key: NewPKey,\n    expander: (_: Merged<{}, CaseP>) => Iterable<NewPValue>\n  ): CaseParamsBuilder<Merged<CaseP, { [name in NewPKey]: NewPValue }>> {\n    return this.expandWithParams(function* (p) {\n      for (const value of expander(p)) {\n        yield { [key]: value } as { readonly [name in NewPKey]: NewPValue };\n      }\n    });\n  }\n\n  /** @inheritdoc */\n  combineWithParams<NewP extends {}>(\n    newParams: Iterable<NewP>\n  ): CaseParamsBuilder<Merged<CaseP, NewP>> {\n    assertNotGenerator(newParams);\n    const seenValues = new Set<string>();\n    for (const params of newParams) {\n      const paramsStr = stringifyPublicParams(params);\n      assert(!seenValues.has(paramsStr), `Duplicate entry in combine[WithParams]: ${paramsStr}`);\n      seenValues.add(paramsStr);\n    }\n\n    return this.expandWithParams(() => newParams);\n  }\n\n  /** @inheritdoc */\n  combine<NewPKey extends string, NewPValue>(\n    key: NewPKey,\n    values: Iterable<NewPValue>\n  ): CaseParamsBuilder<Merged<CaseP, { [name in NewPKey]: NewPValue }>> {\n    assertNotGenerator(values);\n    const mapped = mapLazy(values, v => ({ [key]: v } as { [name in NewPKey]: NewPValue }));\n    return this.combineWithParams(mapped);\n  }\n\n  /** @inheritdoc */\n  filter(pred: (_: Merged<{}, CaseP>) => boolean): CaseParamsBuilder<CaseP> {\n    const newGenerator = filterGenerator(this.cases, pred);\n    return new CaseParamsBuilder(() => newGenerator({}));\n  }\n\n  /** @inheritdoc */\n  unless(pred: (_: Merged<{}, CaseP>) => boolean): CaseParamsBuilder<CaseP> {\n    return this.filter(x => !pred(x));\n  }\n\n  /**\n   * \"Finalize\" the list of cases and begin defining subcases.\n   * Returns a new SubcaseParamsBuilder. Methods called on SubcaseParamsBuilder\n   * generate new subcases instead of new cases.\n   */\n  beginSubcases(): SubcaseParamsBuilder<CaseP, {}> {\n    return new SubcaseParamsBuilder(\n      () => this.cases(),\n      function* () {\n        yield {};\n      }\n    );\n  }\n}\n\n/**\n * The unit CaseParamsBuilder, representing a single case with no params: `[ {} ]`.\n *\n * `punit` is passed to every `.params()`/`.paramsSubcasesOnly()` call, so `kUnitCaseParamsBuilder`\n * is only explicitly needed if constructing a ParamsBuilder outside of a test builder.\n */\nexport const kUnitCaseParamsBuilder = new CaseParamsBuilder(function* () {\n  yield {};\n});\n\n/**\n * Builder for combinatorial test _subcase_ parameters.\n *\n * SubcaseParamsBuilder is immutable. Each method call returns a new, immutable object,\n * modifying the list of subcases according to the method called.\n */\nexport class SubcaseParamsBuilder<CaseP extends {}, SubcaseP extends {}>\n  extends ParamsBuilderBase<CaseP, SubcaseP>\n  implements ParamsBuilder {\n  protected readonly subcases: (_: CaseP) => Generator<SubcaseP>;\n\n  constructor(cases: () => Generator<CaseP>, generator: (_: CaseP) => Generator<SubcaseP>) {\n    super(cases);\n    this.subcases = generator;\n  }\n\n  *iterateCasesWithSubcases(): CaseSubcaseIterable<CaseP, SubcaseP> {\n    for (const caseP of this.cases()) {\n      const subcases = Array.from(this.subcases(caseP));\n      if (subcases.length) {\n        yield [caseP, subcases];\n      }\n    }\n  }\n\n  /** @inheritdoc */\n  expandWithParams<NewP extends {}>(\n    expander: (_: Merged<CaseP, SubcaseP>) => Iterable<NewP>\n  ): SubcaseParamsBuilder<CaseP, Merged<SubcaseP, NewP>> {\n    return new SubcaseParamsBuilder(this.cases, expanderGenerator(this.subcases, expander));\n  }\n\n  /** @inheritdoc */\n  expand<NewPKey extends string, NewPValue>(\n    key: NewPKey,\n    expander: (_: Merged<CaseP, SubcaseP>) => Iterable<NewPValue>\n  ): SubcaseParamsBuilder<CaseP, Merged<SubcaseP, { [name in NewPKey]: NewPValue }>> {\n    return this.expandWithParams(function* (p) {\n      for (const value of expander(p)) {\n        // TypeScript doesn't know here that NewPKey is always a single literal string type.\n        yield { [key]: value } as { [name in NewPKey]: NewPValue };\n      }\n    });\n  }\n\n  /** @inheritdoc */\n  combineWithParams<NewP extends {}>(\n    newParams: Iterable<NewP>\n  ): SubcaseParamsBuilder<CaseP, Merged<SubcaseP, NewP>> {\n    assertNotGenerator(newParams);\n    return this.expandWithParams(() => newParams);\n  }\n\n  /** @inheritdoc */\n  combine<NewPKey extends string, NewPValue>(\n    key: NewPKey,\n    values: Iterable<NewPValue>\n  ): SubcaseParamsBuilder<CaseP, Merged<SubcaseP, { [name in NewPKey]: NewPValue }>> {\n    assertNotGenerator(values);\n    return this.expand(key, () => values);\n  }\n\n  /** @inheritdoc */\n  filter(pred: (_: Merged<CaseP, SubcaseP>) => boolean): SubcaseParamsBuilder<CaseP, SubcaseP> {\n    return new SubcaseParamsBuilder(this.cases, filterGenerator(this.subcases, pred));\n  }\n\n  /** @inheritdoc */\n  unless(pred: (_: Merged<CaseP, SubcaseP>) => boolean): SubcaseParamsBuilder<CaseP, SubcaseP> {\n    return this.filter(x => !pred(x));\n  }\n}\n\nfunction expanderGenerator<Base, A, B>(\n  baseGenerator: (_: Base) => Generator<A>,\n  expander: (_: Merged<Base, A>) => Iterable<B>\n): (_: Base) => Generator<Merged<A, B>> {\n  return function* (base: Base) {\n    for (const a of baseGenerator(base)) {\n      for (const b of expander(mergeParams(base, a))) {\n        yield mergeParams(a, b);\n      }\n    }\n  };\n}\n\nfunction filterGenerator<Base, A>(\n  baseGenerator: (_: Base) => Generator<A>,\n  pred: (_: Merged<Base, A>) => boolean\n): (_: Base) => Generator<A> {\n  return function* (base: Base) {\n    for (const a of baseGenerator(base)) {\n      if (pred(mergeParams(base, a))) {\n        yield a;\n      }\n    }\n  };\n}\n\n/** Assert an object is not a Generator (a thing returned from a generator function). */\nfunction assertNotGenerator(x: object) {\n  if ('constructor' in x) {\n    assert(\n      x.constructor !== (function* () {})().constructor,\n      'Argument must not be a generator, as generators are not reusable'\n    );\n  }\n}\n"],"file":"params_builder.js"}