{"version":3,"sources":["../../../src/common/framework/test_group.ts"],"names":["SkipTestCase","extractPublicParams","kPathSeparator","stringifyPublicParams","stringifyPublicParamsUniquely","validQueryPart","assert","makeTestGroup","fixture","TestGroup","makeTestGroupForUnitTesting","seen","Set","tests","constructor","iterate","checkName","name","decodeURIComponent","has","add","test","testCreationStack","Error","parts","split","p","TestBuilder","push","validate","cases","undefined","testPath","desc","description","trim","fn","testFn","unimplemented","testPathString","join","s","stack","testcase","testcaseString","testcaseStringUnique","params","casesIterable","Array","from","RunCaseSpecific","id","run","rec","start","inst","init","finalize","ex","threw","finish"],"mappings":"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","sourcesContent":["import { Fixture, SkipTestCase } from './fixture.js';\nimport { TestCaseRecorder } from './logging/test_case_recorder.js';\nimport { CaseParams, CaseParamsIterable, extractPublicParams } from './params_utils.js';\nimport { kPathSeparator } from './query/separators.js';\nimport { stringifyPublicParams, stringifyPublicParamsUniquely } from './query/stringify_params.js';\nimport { validQueryPart } from './query/validQueryPart.js';\nimport { assert } from './util/util.js';\n\nexport type RunFn = (rec: TestCaseRecorder) => Promise<void>;\n\nexport interface TestCaseID {\n  readonly test: readonly string[];\n  readonly params: CaseParams;\n}\n\nexport interface RunCase {\n  readonly id: TestCaseID;\n  run: RunFn;\n}\n\n// Interface for defining tests\nexport interface TestGroupBuilder<F extends Fixture> {\n  test(name: string): TestBuilderWithName<F, never>;\n}\nexport function makeTestGroup<F extends Fixture>(fixture: FixtureClass<F>): TestGroupBuilder<F> {\n  return new TestGroup(fixture);\n}\n\n// Interfaces for running tests\nexport interface IterableTestGroup {\n  iterate(): Iterable<IterableTest>;\n  validate(): void;\n}\nexport interface IterableTest {\n  testPath: string[];\n  description: string | undefined;\n  iterate(): Iterable<RunCase>;\n}\n\nexport function makeTestGroupForUnitTesting<F extends Fixture>(\n  fixture: FixtureClass<F>\n): TestGroup<F> {\n  return new TestGroup(fixture);\n}\n\ntype FixtureClass<F extends Fixture> = new (log: TestCaseRecorder, params: CaseParams) => F;\ntype TestFn<F extends Fixture, P extends {}> = (t: F & { params: P }) => Promise<void> | void;\n\nclass TestGroup<F extends Fixture> implements TestGroupBuilder<F> {\n  private fixture: FixtureClass<F>;\n  private seen: Set<string> = new Set();\n  private tests: Array<TestBuilder<F, never>> = [];\n\n  constructor(fixture: FixtureClass<F>) {\n    this.fixture = fixture;\n  }\n\n  iterate(): Iterable<IterableTest> {\n    return this.tests;\n  }\n\n  private checkName(name: string): void {\n    assert(\n      // Shouldn't happen due to the rule above. Just makes sure that treated\n      // unencoded strings as encoded strings is OK.\n      name === decodeURIComponent(name),\n      `Not decodeURIComponent-idempotent: ${name} !== ${decodeURIComponent(name)}`\n    );\n    assert(!this.seen.has(name), `Duplicate test name: ${name}`);\n\n    this.seen.add(name);\n  }\n\n  // TODO: This could take a fixture, too, to override the one for the group.\n  test(name: string): TestBuilderWithName<F, never> {\n    const testCreationStack = new Error(`Test created: ${name}`);\n\n    this.checkName(name);\n\n    const parts = name.split(kPathSeparator);\n    for (const p of parts) {\n      assert(validQueryPart.test(p), `Invalid test name part ${p}; must match ${validQueryPart}`);\n    }\n\n    const test = new TestBuilder<F, never>(parts, this.fixture, testCreationStack);\n    this.tests.push(test);\n    return test;\n  }\n\n  validate(): void {\n    for (const test of this.tests) {\n      test.validate();\n    }\n  }\n}\n\ninterface TestBuilderWithName<F extends Fixture, P extends {}> extends TestBuilderWithParams<F, P> {\n  desc(description: string): this;\n  params<NewP extends {}>(specs: Iterable<NewP>): TestBuilderWithParams<F, NewP>;\n}\n\ninterface TestBuilderWithParams<F extends Fixture, P extends {}> {\n  fn(fn: TestFn<F, P>): void;\n  unimplemented(): void;\n}\n\nclass TestBuilder<F extends Fixture, P extends {}> {\n  readonly testPath: string[];\n  description: string | undefined;\n\n  private readonly fixture: FixtureClass<F>;\n  private testFn: TestFn<F, P> | undefined;\n  private cases?: CaseParamsIterable = undefined;\n  private testCreationStack: Error;\n\n  constructor(testPath: string[], fixture: FixtureClass<F>, testCreationStack: Error) {\n    this.testPath = testPath;\n    this.fixture = fixture;\n    this.testCreationStack = testCreationStack;\n  }\n\n  desc(description: string): this {\n    this.description = description.trim();\n    return this;\n  }\n\n  fn(fn: TestFn<F, P>): void {\n    assert(this.testFn === undefined);\n    this.testFn = fn;\n  }\n\n  unimplemented(): void {\n    assert(this.testFn === undefined);\n    this.testFn = () => {\n      throw new SkipTestCase('test unimplemented');\n    };\n  }\n\n  validate(): void {\n    const testPathString = this.testPath.join(kPathSeparator);\n    assert(this.testFn !== undefined, () => {\n      let s = `Test is missing .fn(): ${testPathString}`;\n      if (this.testCreationStack.stack) {\n        s += `\\n-> test created at:\\n${this.testCreationStack.stack}`;\n      }\n      return s;\n    });\n\n    if (this.cases === undefined) {\n      return;\n    }\n\n    const seen = new Set<string>();\n    for (const testcase of this.cases) {\n      // stringifyPublicParams also checks for invalid params values\n      const testcaseString = stringifyPublicParams(testcase);\n\n      // A (hopefully) unique representation of a params value.\n      const testcaseStringUnique = stringifyPublicParamsUniquely(testcase);\n      assert(\n        !seen.has(testcaseStringUnique),\n        `Duplicate public test case params for test ${testPathString}: ${testcaseString}`\n      );\n      seen.add(testcaseStringUnique);\n    }\n  }\n\n  params<NewP extends {}>(casesIterable: Iterable<NewP>): TestBuilderWithParams<F, NewP> {\n    assert(this.cases === undefined, 'test case is already parameterized');\n    this.cases = Array.from(casesIterable);\n\n    return (this as unknown) as TestBuilderWithParams<F, NewP>;\n  }\n\n  *iterate(): IterableIterator<RunCase> {\n    assert(this.testFn !== undefined, 'No test function (.fn()) for test');\n    for (const params of this.cases || [{}]) {\n      yield new RunCaseSpecific(this.testPath, params, this.fixture, this.testFn);\n    }\n  }\n}\n\nclass RunCaseSpecific<F extends Fixture> implements RunCase {\n  readonly id: TestCaseID;\n\n  private readonly params: CaseParams | null;\n  private readonly fixture: FixtureClass<F>;\n  private readonly fn: TestFn<F, never>;\n\n  constructor(\n    testPath: string[],\n    params: CaseParams,\n    fixture: FixtureClass<F>,\n    fn: TestFn<F, never>\n  ) {\n    this.id = { test: testPath, params: extractPublicParams(params) };\n    this.params = params;\n    this.fixture = fixture;\n    this.fn = fn;\n  }\n\n  async run(rec: TestCaseRecorder): Promise<void> {\n    rec.start();\n    try {\n      const inst = new this.fixture(rec, this.params || {});\n\n      try {\n        await inst.init();\n        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n        await this.fn(inst as any);\n      } finally {\n        // Runs as long as constructor succeeded, even if initialization or the test failed.\n        await inst.finalize();\n      }\n    } catch (ex) {\n      // There was an exception from constructor, init, test, or finalize.\n      // An error from init or test may have been a SkipTestCase.\n      // An error from finalize may have been an eventualAsyncExpectation failure\n      // or unexpected validation/OOM error from the GPUDevice.\n      rec.threw(ex);\n    }\n    rec.finish();\n  }\n}\n"],"file":"test_group.js"}