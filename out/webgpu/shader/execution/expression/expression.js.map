{"version":3,"file":"expression.js","names":["globalTestConfig","assert","compare","anyOf","ScalarType","Scalar","TypeVec","TypeU32","Vector","VectorType","f32","u32","F32Interval","cartesianProduct","quantizeToF32","isComparator","e","Array","toComparator","input","got","allInputSources","storageType","ty","kind","width","elementType","fromStorage","expr","toStorage","kValueStride","run","t","expressionBuilder","parameterTypes","returnType","cfg","inputSource","cases","vectorize","undefined","packed","packScalarsToVector","casesPerBatch","Math","floor","device","limits","maxUniformBufferBindingSize","length","maxStorageBufferBindingSize","checkResults","i","batchCases","slice","min","pushErrorScope","checkBatch","submitBatch","push","popErrorScope","then","error","fail","message","Promise","all","outputBufferSize","outputBuffer","createBuffer","size","usage","GPUBufferUsage","COPY_SRC","COPY_DST","STORAGE","pipeline","group","buildPipeline","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","testHeartbeatCallback","queue","submit","finish","checkExpectation","outputData","outputs","read","errs","caseIdx","c","cmp","expected","matched","join","Error","expectGPUBufferValuesPassCheck","type","Uint8Array","typedLength","ith","v","wgslStorageType","wgslOutputs","wgslValues","map","args","_","wgsl","source","module","createShaderModule","code","createComputePipeline","layout","compute","entryPoint","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","paramExpr","wgslInputVar","inputSize","inputData","caseStride","caseBase","paramIdx","offset","params","copyTo","inputBuffer","makeBufferWithContents","UNIFORM","vectorWidth","packedCases","packedParameterTypes","p","packedReturnType","clampCaseIdx","idx","packedInputs","inputElements","comparators","packedComparator","gElements","eElements","d","elements","makeUnaryToF32IntervalCase","param","filter","ops","intervals","o","some","isFinite","generateUnaryToF32IntervalCases","makeBinaryToF32IntervalCase","param0","param1","generateBinaryToF32IntervalCases","param0s","param1s","makeTernaryToF32IntervalCase","param2","generateTernaryToF32IntervalCases","param2s","makeVectorToF32IntervalCase","param_f32","generateVectorToF32IntervalCases","makeVectorPairToF32IntervalCase","param0_f32","param1_f32","generateVectorPairToF32IntervalCases","makeVectorToVectorCase","vectors","every","generateVectorToVectorCases","makeVectorPairToVectorCase","generateVectorPairToVectorCases","makeU32ToVectorCase","trunc","param_u32","generateU32ToVectorCases"],"sources":["../../../../../src/webgpu/shader/execution/expression/expression.ts"],"sourcesContent":["import { globalTestConfig } from '../../../../common/framework/test_config.js';\nimport { assert } from '../../../../common/util/util.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { compare, Comparator, anyOf } from '../../../util/compare.js';\nimport {\n  ScalarType,\n  Scalar,\n  Type,\n  TypeVec,\n  TypeU32,\n  Value,\n  Vector,\n  VectorType,\n  f32,\n  u32,\n} from '../../../util/conversion.js';\nimport {\n  BinaryToInterval,\n  F32Interval,\n  PointToInterval,\n  PointToVector,\n  TernaryToInterval,\n  VectorPairToInterval,\n  VectorPairToVector,\n  VectorToInterval,\n  VectorToVector,\n} from '../../../util/f32_interval.js';\nimport { cartesianProduct, quantizeToF32 } from '../../../util/math.js';\n\nexport type Expectation = Value | F32Interval | F32Interval[] | Comparator;\n\n/** Is this expectation actually a Comparator */\nfunction isComparator(e: Expectation): boolean {\n  return !(\n    e instanceof F32Interval ||\n    e instanceof Scalar ||\n    e instanceof Vector ||\n    e instanceof Array\n  );\n}\n\n/** Helper for converting Values to Comparators */\nexport function toComparator(input: Expectation): Comparator {\n  if (!isComparator(input)) {\n    return got => compare(got, input as Value);\n  }\n  return input as Comparator;\n}\n\n/** Case is a single expression test case. */\nexport type Case = {\n  // The input value(s)\n  input: Value | Array<Value>;\n  // The expected result, or function to check the result\n  expected: Expectation;\n};\n\n/** CaseList is a list of Cases */\nexport type CaseList = Array<Case>;\n\n/** The input value source */\nexport type InputSource =\n  | 'const' // Shader creation time constant values (@const)\n  | 'uniform' // Uniform buffer\n  | 'storage_r' // Read-only storage buffer\n  | 'storage_rw'; // Read-write storage buffer\n\n/** All possible input sources */\nexport const allInputSources: InputSource[] = ['const', 'uniform', 'storage_r', 'storage_rw'];\n\n/** Configuration for running a expression test */\nexport type Config = {\n  // Where the input values are read from\n  inputSource: InputSource;\n  // If defined, scalar test cases will be packed into vectors of the given\n  // width, which must be 2, 3 or 4.\n  // Requires that all parameters of the expression overload are of a scalar\n  // type, and the return type of the expression overload is also a scalar type.\n  // If the number of test cases is not a multiple of the vector width, then the\n  // last scalar value is repeated to fill the last vector value.\n  vectorize?: number;\n};\n\n// Helper for returning the WGSL storage type for the given Type.\nfunction storageType(ty: Type): Type {\n  if (ty instanceof ScalarType) {\n    if (ty.kind === 'bool') {\n      return TypeU32;\n    }\n  }\n  if (ty instanceof VectorType) {\n    return TypeVec(ty.width, storageType(ty.elementType) as ScalarType);\n  }\n  return ty;\n}\n\n// Helper for converting a value of the type 'ty' from the storage type.\nfunction fromStorage(ty: Type, expr: string): string {\n  if (ty instanceof ScalarType) {\n    if (ty.kind === 'bool') {\n      return `${expr} != 0u`;\n    }\n  }\n  if (ty instanceof VectorType) {\n    if (ty.elementType.kind === 'bool') {\n      return `${expr} != vec${ty.width}<u32>(0u)`;\n    }\n  }\n  return expr;\n}\n\n// Helper for converting a value of the type 'ty' to the storage type.\nfunction toStorage(ty: Type, expr: string): string {\n  if (ty instanceof ScalarType) {\n    if (ty.kind === 'bool') {\n      return `select(0u, 1u, ${expr})`;\n    }\n  }\n  if (ty instanceof VectorType) {\n    if (ty.elementType.kind === 'bool') {\n      return `select(vec${ty.width}<u32>(0u), vec${ty.width}<u32>(1u), ${expr})`;\n    }\n  }\n  return expr;\n}\n\n// Currently all values are packed into buffers of 16 byte strides\nconst kValueStride = 16;\n\n// ExpressionBuilder returns the WGSL used to test an expression.\nexport interface ExpressionBuilder {\n  (values: Array<string>): string;\n}\n\n/**\n * Runs the list of expression tests, possibly splitting the tests into multiple\n * dispatches to keep the input data within the buffer binding limits.\n * run() will pack the scalar test cases into smaller set of vectorized tests\n * if `cfg.vectorize` is defined.\n * @param t the GPUTest\n * @param expressionBuilder the expression builder function\n * @param parameterTypes the list of expression parameter types\n * @param returnType the return type for the expression overload\n * @param cfg test configuration values\n * @param cases list of test cases\n */\nexport async function run(\n  t: GPUTest,\n  expressionBuilder: ExpressionBuilder,\n  parameterTypes: Array<Type>,\n  returnType: Type,\n  cfg: Config = { inputSource: 'storage_r' },\n  cases: CaseList\n) {\n  // If the 'vectorize' config option was provided, pack the cases into vectors.\n  if (cfg.vectorize !== undefined) {\n    const packed = packScalarsToVector(parameterTypes, returnType, cases, cfg.vectorize);\n    cases = packed.cases;\n    parameterTypes = packed.parameterTypes;\n    returnType = packed.returnType;\n  }\n\n  // The size of the input buffer may exceed the maximum buffer binding size,\n  // so chunk the tests up into batches that fit into the limits.\n  const casesPerBatch = (function () {\n    switch (cfg.inputSource) {\n      case 'const':\n        return 64; // Arbitrary limit, to ensure shaders aren't too large\n      case 'uniform':\n        return Math.floor(\n          t.device.limits.maxUniformBufferBindingSize / (parameterTypes.length * kValueStride)\n        );\n      case 'storage_r':\n      case 'storage_rw':\n        return Math.floor(\n          t.device.limits.maxStorageBufferBindingSize / (parameterTypes.length * kValueStride)\n        );\n    }\n  })();\n\n  // Submit all the cases in batches, each in a separate error scope.\n  const checkResults: Array<Promise<void>> = [];\n  for (let i = 0; i < cases.length; i += casesPerBatch) {\n    const batchCases = cases.slice(i, Math.min(i + casesPerBatch, cases.length));\n\n    t.device.pushErrorScope('validation');\n\n    const checkBatch = submitBatch(\n      t,\n      expressionBuilder,\n      parameterTypes,\n      returnType,\n      batchCases,\n      cfg.inputSource\n    );\n\n    checkResults.push(\n      // Check GPU validation (shader compilation, pipeline creation, etc) before checking the batch results.\n      t.device.popErrorScope().then(error => {\n        if (error === null) {\n          checkBatch();\n        } else {\n          t.fail(error.message);\n        }\n      })\n    );\n  }\n\n  // Check the results\n  await Promise.all(checkResults);\n}\n\n/**\n * Submits the list of expression tests. The input data must fit within the\n * buffer binding limits of the given inputSource.\n * @param t the GPUTest\n * @param expressionBuilder the expression builder function\n * @param parameterTypes the list of expression parameter types\n * @param returnType the return type for the expression overload\n * @param cases list of test cases that fit within the binding limits of the device\n * @param inputSource the source of the input values\n * @returns a function that checks the results are as expected\n */\nfunction submitBatch(\n  t: GPUTest,\n  expressionBuilder: ExpressionBuilder,\n  parameterTypes: Array<Type>,\n  returnType: Type,\n  cases: CaseList,\n  inputSource: InputSource\n): () => void {\n  // Construct a buffer to hold the results of the expression tests\n  const outputBufferSize = cases.length * kValueStride;\n  const outputBuffer = t.device.createBuffer({\n    size: outputBufferSize,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n  });\n\n  const [pipeline, group] = buildPipeline(\n    t,\n    expressionBuilder,\n    parameterTypes,\n    returnType,\n    cases,\n    inputSource,\n    outputBuffer\n  );\n\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, group);\n  pass.dispatchWorkgroups(1);\n  pass.end();\n\n  // Heartbeat to ensure CTS runners know we're alive.\n  globalTestConfig.testHeartbeatCallback();\n\n  t.queue.submit([encoder.finish()]);\n\n  // Return a function that can check the results of the shader\n  return () => {\n    const checkExpectation = (outputData: Uint8Array) => {\n      // Read the outputs from the output buffer\n      const outputs = new Array<Value>(cases.length);\n      for (let i = 0; i < cases.length; i++) {\n        outputs[i] = returnType.read(outputData, i * kValueStride);\n      }\n\n      // The list of expectation failures\n      const errs: string[] = [];\n\n      // For each case...\n      for (let caseIdx = 0; caseIdx < cases.length; caseIdx++) {\n        const c = cases[caseIdx];\n        const got = outputs[caseIdx];\n        const cmp = toComparator(c.expected)(got);\n        if (!cmp.matched) {\n          errs.push(`(${c.input instanceof Array ? c.input.join(', ') : c.input})\n    returned: ${cmp.got}\n    expected: ${cmp.expected}`);\n        }\n      }\n\n      return errs.length > 0 ? new Error(errs.join('\\n\\n')) : undefined;\n    };\n\n    // Heartbeat to ensure CTS runners know we're alive.\n    globalTestConfig.testHeartbeatCallback();\n\n    t.expectGPUBufferValuesPassCheck(outputBuffer, checkExpectation, {\n      type: Uint8Array,\n      typedLength: outputBufferSize,\n    });\n  };\n}\n\n/**\n * @param v either an array of T or a single element of type T\n * @param i the value index to\n * @returns the i'th value of v, if v is an array, otherwise v (i must be 0)\n */\nfunction ith<T>(v: T | T[], i: number): T {\n  if (v instanceof Array) {\n    assert(i < v.length);\n    return v[i];\n  }\n  assert(i === 0);\n  return v;\n}\n\n/**\n * Constructs and returns a GPUComputePipeline and GPUBindGroup for running a\n * batch of test cases.\n * @param t the GPUTest\n * @param expressionBuilder the expression builder function\n * @param parameterTypes the list of expression parameter types\n * @param returnType the return type for the expression overload\n * @param cases list of test cases that fit within the binding limits of the device\n * @param inputSource the source of the input values\n * @param outputBuffer the buffer that will hold the output values of the tests\n */\nfunction buildPipeline(\n  t: GPUTest,\n  expressionBuilder: ExpressionBuilder,\n  parameterTypes: Array<Type>,\n  returnType: Type,\n  cases: CaseList,\n  inputSource: InputSource,\n  outputBuffer: GPUBuffer\n): [GPUComputePipeline, GPUBindGroup] {\n  // wgsl declaration of output buffer and binding\n  const wgslStorageType = storageType(returnType);\n  const wgslOutputs = `\nstruct Output {\n  @size(${kValueStride}) value : ${wgslStorageType}\n};\n@group(0) @binding(0) var<storage, read_write> outputs : array<Output, ${cases.length}>;\n`;\n\n  switch (inputSource) {\n    case 'const': {\n      //////////////////////////////////////////////////////////////////////////\n      // Input values are constant values in the WGSL shader\n      //////////////////////////////////////////////////////////////////////////\n      const wgslValues = cases.map(c => {\n        const args = parameterTypes.map((_, i) => `(${ith(c.input, i).wgsl()})`);\n        return `${toStorage(returnType, expressionBuilder(args))}`;\n      });\n\n      // the full WGSL shader source\n      const source = `\n${wgslOutputs}\n\nconst values = array<${wgslStorageType}, ${cases.length}>(\n  ${wgslValues.join(',\\n  ')}\n);\n\n@compute @workgroup_size(1)\nfn main() {\n  for (var i = 0u; i < ${cases.length}; i++) {\n    outputs[i].value = values[i];\n  }\n}\n`;\n\n      // build the shader module\n      const module = t.device.createShaderModule({ code: source });\n\n      // build the pipeline\n      const pipeline = t.device.createComputePipeline({\n        layout: 'auto',\n        compute: { module, entryPoint: 'main' },\n      });\n\n      // build the bind group\n      const group = t.device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [{ binding: 0, resource: { buffer: outputBuffer } }],\n      });\n\n      return [pipeline, group];\n    }\n\n    case 'uniform':\n    case 'storage_r':\n    case 'storage_rw': {\n      //////////////////////////////////////////////////////////////////////////\n      // Input values come from a uniform or storage buffer\n      //////////////////////////////////////////////////////////////////////////\n\n      // returns the WGSL expression to load the ith parameter of the given type from the input buffer\n      const paramExpr = (ty: Type, i: number) => fromStorage(ty, `inputs[i].param${i}`);\n\n      // resolves to the expression that calls the builtin\n      const expr = toStorage(returnType, expressionBuilder(parameterTypes.map(paramExpr)));\n\n      // input binding var<...> declaration\n      const wgslInputVar = (function () {\n        switch (inputSource) {\n          case 'storage_r':\n            return 'var<storage, read>';\n          case 'storage_rw':\n            return 'var<storage, read_write>';\n          case 'uniform':\n            return 'var<uniform>';\n        }\n      })();\n\n      // the full WGSL shader source\n      const source = `\nstruct Input {\n${parameterTypes\n  .map((ty, i) => `  @size(${kValueStride}) param${i} : ${storageType(ty)},`)\n  .join('\\n')}\n};\n\n${wgslOutputs}\n\n@group(0) @binding(1)\n${wgslInputVar} inputs : array<Input, ${cases.length}>;\n\n@compute @workgroup_size(1)\nfn main() {\n  for(var i = 0; i < ${cases.length}; i++) {\n    outputs[i].value = ${expr};\n  }\n}\n`;\n\n      // size in bytes of the input buffer\n      const inputSize = cases.length * parameterTypes.length * kValueStride;\n\n      // Holds all the parameter values for all cases\n      const inputData = new Uint8Array(inputSize);\n\n      // Pack all the input parameter values into the inputData buffer\n      {\n        const caseStride = kValueStride * parameterTypes.length;\n        for (let caseIdx = 0; caseIdx < cases.length; caseIdx++) {\n          const caseBase = caseIdx * caseStride;\n          for (let paramIdx = 0; paramIdx < parameterTypes.length; paramIdx++) {\n            const offset = caseBase + paramIdx * kValueStride;\n            const params = cases[caseIdx].input;\n            if (params instanceof Array) {\n              params[paramIdx].copyTo(inputData, offset);\n            } else {\n              params.copyTo(inputData, offset);\n            }\n          }\n        }\n      }\n\n      // build the input buffer\n      const inputBuffer = t.makeBufferWithContents(\n        inputData,\n        GPUBufferUsage.COPY_SRC |\n          (inputSource === 'uniform' ? GPUBufferUsage.UNIFORM : GPUBufferUsage.STORAGE)\n      );\n\n      // build the shader module\n      const module = t.device.createShaderModule({ code: source });\n\n      // build the pipeline\n      const pipeline = t.device.createComputePipeline({\n        layout: 'auto',\n        compute: { module, entryPoint: 'main' },\n      });\n\n      // build the bind group\n      const group = t.device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [\n          { binding: 0, resource: { buffer: outputBuffer } },\n          { binding: 1, resource: { buffer: inputBuffer } },\n        ],\n      });\n\n      return [pipeline, group];\n    }\n  }\n}\n\n/**\n * Packs a list of scalar test cases into a smaller list of vector cases.\n * Requires that all parameters of the expression overload are of a scalar type,\n * and the return type of the expression overload is also a scalar type.\n * If `cases.length` is not a multiple of `vectorWidth`, then the last scalar\n * test case value is repeated to fill the vector value.\n */\nfunction packScalarsToVector(\n  parameterTypes: Array<Type>,\n  returnType: Type,\n  cases: CaseList,\n  vectorWidth: number\n): { cases: CaseList; parameterTypes: Array<Type>; returnType: Type } {\n  // Validate that the parameters and return type are all vectorizable\n  for (let i = 0; i < parameterTypes.length; i++) {\n    const ty = parameterTypes[i];\n    if (!(ty instanceof ScalarType)) {\n      throw new Error(\n        `packScalarsToVector() can only be used on scalar parameter types, but the ${i}'th parameter type is a ${ty}'`\n      );\n    }\n  }\n  if (!(returnType instanceof ScalarType)) {\n    throw new Error(\n      `packScalarsToVector() can only be used with a scalar return type, but the return type is a ${returnType}'`\n    );\n  }\n\n  const packedCases: Array<Case> = [];\n  const packedParameterTypes = parameterTypes.map(p => TypeVec(vectorWidth, p as ScalarType));\n  const packedReturnType = new VectorType(vectorWidth, returnType);\n\n  const clampCaseIdx = (idx: number) => Math.min(idx, cases.length - 1);\n\n  let caseIdx = 0;\n  while (caseIdx < cases.length) {\n    // Construct the vectorized inputs from the scalar cases\n    const packedInputs = new Array<Vector>(parameterTypes.length);\n    for (let paramIdx = 0; paramIdx < parameterTypes.length; paramIdx++) {\n      const inputElements = new Array<Scalar>(vectorWidth);\n      for (let i = 0; i < vectorWidth; i++) {\n        const input = cases[clampCaseIdx(caseIdx + i)].input;\n        inputElements[i] = (input instanceof Array ? input[paramIdx] : input) as Scalar;\n      }\n      packedInputs[paramIdx] = new Vector(inputElements);\n    }\n\n    // Gather the comparators for the packed cases\n    const comparators = new Array<Comparator>(vectorWidth);\n    for (let i = 0; i < vectorWidth; i++) {\n      comparators[i] = toComparator(cases[clampCaseIdx(caseIdx + i)].expected);\n    }\n    const packedComparator = (got: Value) => {\n      let matched = true;\n      const gElements = new Array<string>(vectorWidth);\n      const eElements = new Array<string>(vectorWidth);\n      for (let i = 0; i < vectorWidth; i++) {\n        const d = comparators[i]((got as Vector).elements[i]);\n        matched = matched && d.matched;\n        gElements[i] = d.got;\n        eElements[i] = d.expected;\n      }\n      return {\n        matched,\n        got: `${packedReturnType}(${gElements.join(', ')})`,\n        expected: `${packedReturnType}(${eElements.join(', ')})`,\n      };\n    };\n\n    // Append the new packed case\n    packedCases.push({ input: packedInputs, expected: packedComparator });\n    caseIdx += vectorWidth;\n  }\n\n  return {\n    cases: packedCases,\n    parameterTypes: packedParameterTypes,\n    returnType: packedReturnType,\n  };\n}\n\n/**\n * Indicates bounds that acceptance intervals need to be within to avoid inputs\n * being filtered out. This is used for const-eval tests, since going OOB will\n * cause a validation error not an execution error.\n */\nexport type IntervalFilter =\n  | 'f32-only' // Expected to be f32 finite\n  | 'unfiltered'; // No expectations\n\n/**\n * @returns a Case for the param and unary interval generator provided\n * The Case will use use an interval comparator for matching results.\n * @param param the param to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for an\n *            unary operation\n */\nfunction makeUnaryToF32IntervalCase(\n  param: number,\n  filter: IntervalFilter,\n  ...ops: PointToInterval[]\n): Case | undefined {\n  param = quantizeToF32(param);\n\n  const intervals = ops.map(o => o(param));\n  if (filter === 'f32-only' && intervals.some(i => !i.isFinite())) {\n    return undefined;\n  }\n  return { input: [f32(param)], expected: anyOf(...intervals) };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param params array of inputs to try\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for an\n *            unary operation\n */\nexport function generateUnaryToF32IntervalCases(\n  params: number[],\n  filter: IntervalFilter,\n  ...ops: PointToInterval[]\n): Case[] {\n  return params\n    .map(e => makeUnaryToF32IntervalCase(e, filter, ...ops))\n    .filter((c): c is Case => c !== undefined);\n}\n\n/**\n * @returns a Case for the params and binary interval generator provided\n * The Case will use use an interval comparator for matching results.\n * @param param0 the first param or left hand side to pass in\n * @param param1 the second param or rhs hand side to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for a\n *            binary operation\n */\nfunction makeBinaryToF32IntervalCase(\n  param0: number,\n  param1: number,\n  filter: IntervalFilter,\n  ...ops: BinaryToInterval[]\n): Case | undefined {\n  param0 = quantizeToF32(param0);\n  param1 = quantizeToF32(param1);\n\n  const intervals = ops.map(o => o(param0, param1));\n  if (filter === 'f32-only' && intervals.some(i => !i.isFinite())) {\n    return undefined;\n  }\n  return { input: [f32(param0), f32(param1)], expected: anyOf(...intervals) };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for a\n *            binary operation\n */\nexport function generateBinaryToF32IntervalCases(\n  param0s: number[],\n  param1s: number[],\n  filter: IntervalFilter,\n  ...ops: BinaryToInterval[]\n): Case[] {\n  return cartesianProduct(param0s, param1s)\n    .map(e => makeBinaryToF32IntervalCase(e[0], e[1], filter, ...ops))\n    .filter((c): c is Case => c !== undefined);\n}\n\n/**\n * @returns a Case for the params and ternary interval generator provided\n * The Case will use use an interval comparator for matching results.\n * @param param0 the first param to pass in\n * @param param1 the second param to pass in\n * @param param2 the third param to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for a\n *            ternary operation.\n */\nfunction makeTernaryToF32IntervalCase(\n  param0: number,\n  param1: number,\n  param2: number,\n  filter: IntervalFilter,\n  ...ops: TernaryToInterval[]\n): Case | undefined {\n  param0 = quantizeToF32(param0);\n  param1 = quantizeToF32(param1);\n  param2 = quantizeToF32(param2);\n\n  const intervals = ops.map(o => o(param0, param1, param2));\n  if (filter === 'f32-only' && intervals.some(i => !i.isFinite())) {\n    return undefined;\n  }\n  return {\n    input: [f32(param0), f32(param1), f32(param2)],\n    expected: anyOf(...intervals),\n  };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param param2s array of inputs to try for the third param\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for a\n *            ternary operation.\n */\nexport function generateTernaryToF32IntervalCases(\n  param0s: number[],\n  param1s: number[],\n  param2s: number[],\n  filter: IntervalFilter,\n  ...ops: TernaryToInterval[]\n): Case[] {\n  return cartesianProduct(param0s, param1s, param2s)\n    .map(e => makeTernaryToF32IntervalCase(e[0], e[1], e[2], filter, ...ops))\n    .filter((c): c is Case => c !== undefined);\n}\n\n/**\n * @returns a Case for the param and vector interval generator provided\n * @param param the param to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for a\n *            vector.\n */\nfunction makeVectorToF32IntervalCase(\n  param: number[],\n  filter: IntervalFilter,\n  ...ops: VectorToInterval[]\n): Case | undefined {\n  param = param.map(quantizeToF32);\n  const param_f32 = param.map(f32);\n\n  const intervals = ops.map(o => o(param));\n  if (filter === 'f32-only' && intervals.some(i => !i.isFinite())) {\n    return undefined;\n  }\n  return {\n    input: [new Vector(param_f32)],\n    expected: anyOf(...intervals),\n  };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param params array of inputs to try\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for a\n *            vector.\n */\nexport function generateVectorToF32IntervalCases(\n  params: number[][],\n  filter: IntervalFilter,\n  ...ops: VectorToInterval[]\n): Case[] {\n  return params\n    .map(e => makeVectorToF32IntervalCase(e, filter, ...ops))\n    .filter((c): c is Case => c !== undefined);\n}\n\n/**\n * @returns a Case for the params and vector pair interval generator provided\n * @param param0 the first param to pass in\n * @param param1 the second param to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for a\n *            pair of vectors.\n */\nfunction makeVectorPairToF32IntervalCase(\n  param0: number[],\n  param1: number[],\n  filter: IntervalFilter,\n  ...ops: VectorPairToInterval[]\n): Case | undefined {\n  param0 = param0.map(quantizeToF32);\n  param1 = param1.map(quantizeToF32);\n  const param0_f32 = param0.map(f32);\n  const param1_f32 = param1.map(f32);\n\n  const intervals = ops.map(o => o(param0, param1));\n  if (filter === 'f32-only' && intervals.some(i => !i.isFinite())) {\n    return undefined;\n  }\n  return {\n    input: [new Vector(param0_f32), new Vector(param1_f32)],\n    expected: anyOf(...intervals),\n  };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first input\n * @param param1s array of inputs to try for the second input\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for a\n *            pair of vectors.\n */\nexport function generateVectorPairToF32IntervalCases(\n  param0s: number[][],\n  param1s: number[][],\n  filter: IntervalFilter,\n  ...ops: VectorPairToInterval[]\n): Case[] {\n  return cartesianProduct(param0s, param1s)\n    .map(e => makeVectorPairToF32IntervalCase(e[0], e[1], filter, ...ops))\n    .filter((c): c is Case => c !== undefined);\n}\n\n/**\n * @returns a Case for the param and vector of intervals generator provided\n * @param param the param to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an vector of acceptance\n *            intervals for a vector.\n */\nfunction makeVectorToVectorCase(\n  param: number[],\n  filter: IntervalFilter,\n  ...ops: VectorToVector[]\n): Case | undefined {\n  param = param.map(quantizeToF32);\n  const param_f32 = param.map(f32);\n\n  const vectors = ops.map(o => o(param));\n  if (filter === 'f32-only' && vectors.some(v => !v.every(e => e.isFinite()))) {\n    return undefined;\n  }\n  return {\n    input: [new Vector(param_f32)],\n    expected: anyOf(...vectors),\n  };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param params array of inputs to try\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an vector of acceptance\n *            intervals for a vector.\n */\nexport function generateVectorToVectorCases(\n  params: number[][],\n  filter: IntervalFilter,\n  ...ops: VectorToVector[]\n): Case[] {\n  return params\n    .map(e => makeVectorToVectorCase(e, filter, ...ops))\n    .filter((c): c is Case => c !== undefined);\n}\n\n/**\n * @returns a Case for the params and vector of intervals generator provided\n * @param param0 the first param to pass in\n * @param param1 the second param to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an vector of acceptance\n *            intervals for a pair of vectors.\n */\nfunction makeVectorPairToVectorCase(\n  param0: number[],\n  param1: number[],\n  filter: IntervalFilter,\n  ...ops: VectorPairToVector[]\n): Case | undefined {\n  param0 = param0.map(quantizeToF32);\n  param1 = param1.map(quantizeToF32);\n  const param0_f32 = param0.map(f32);\n  const param1_f32 = param1.map(f32);\n\n  const vectors = ops.map(o => o(param0, param1));\n  if (filter === 'f32-only' && vectors.some(v => !v.every(e => e.isFinite()))) {\n    return undefined;\n  }\n  return {\n    input: [new Vector(param0_f32), new Vector(param1_f32)],\n    expected: anyOf(...vectors),\n  };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first input\n * @param param1s array of inputs to try for the second input\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an vector of acceptance\n *            intervals for a pair of vectors.\n */\nexport function generateVectorPairToVectorCases(\n  param0s: number[][],\n  param1s: number[][],\n  filter: IntervalFilter,\n  ...ops: VectorPairToVector[]\n): Case[] {\n  return cartesianProduct(param0s, param1s)\n    .map(e => makeVectorPairToVectorCase(e[0], e[1], filter, ...ops))\n    .filter((c): c is Case => c !== undefined);\n}\n\n/**\n * @returns a Case for the param and vector of intervals generator provided\n * The input is treated as an unsigned int.\n * @param param the param to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance\n *            interval for an unsigned int.\n */\nfunction makeU32ToVectorCase(\n  param: number,\n  filter: IntervalFilter,\n  ...ops: PointToVector[]\n): Case | undefined {\n  param = Math.trunc(param);\n  const param_u32 = u32(param);\n\n  const vectors = ops.map(o => o(param));\n  if (filter === 'f32-only' && vectors.some(v => !v.every(e => e.isFinite()))) {\n    return undefined;\n  }\n  return {\n    input: param_u32,\n    expected: anyOf(...vectors),\n  };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * The input is treated as an unsigned int.\n * @param params array of inputs to try\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance\n *            interval for an unsigned int.\n */\nexport function generateU32ToVectorCases(\n  params: number[],\n  filter: IntervalFilter,\n  ...ops: PointToVector[]\n): Case[] {\n  return params\n    .map(e => makeU32ToVectorCase(e, filter, ...ops))\n    .filter((c): c is Case => c !== undefined);\n}\n"],"mappings":"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"}