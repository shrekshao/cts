{"version":3,"sources":["../../../../../src/webgpu/shader/execution/memory_model/coherence.spec.ts"],"names":["description","makeTestGroup","GPUTest","MemoryModelTester","buildTestShader","MemoryType","TestType","buildResultShader","ResultType","g","memoryModelTestParams","workgroupSize","testingWorkgroups","maxWorkgroups","shufflePct","barrierPct","memStressPct","memStressIterations","memStressStoreFirstPct","memStressStoreSecondPct","preStressPct","preStressIterations","preStressStoreFirstPct","preStressStoreSecondPct","scratchMemorySize","stressLineSize","stressTargetLines","stressStrategyBalancePct","permuteFirst","permuteSecond","memStride","aliasedMemory","numMemLocations","numReadOutputs","numBehaviors","storageMemoryCorrTestCode","workgroupMemoryCorrTestCode","test","desc","paramsSimple","memType","AtomicStorageClass","testType","InterWorkgroup","_testCode","IntraWorkgroup","AtomicWorkgroupClass","fn","t","resultCode","testShader","params","resultShader","FourBehavior","memModelTester","run"],"mappings":"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","sourcesContent":["export const description = `\nTests that all threads see a sequentially consistent view of the order of memory\naccesses to a single memory location. Uses a parallel testing strategy along with stressing\nthreads to increase coverage of possible bugs.`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\nimport {\n  MemoryModelTestParams,\n  MemoryModelTester,\n  buildTestShader,\n  MemoryType,\n  TestType,\n  buildResultShader,\n  ResultType,\n} from './memory_model_setup.js';\n\nexport const g = makeTestGroup(GPUTest);\n\n// A reasonable parameter set, determined heuristically.\nconst memoryModelTestParams: MemoryModelTestParams = {\n  workgroupSize: 256,\n  testingWorkgroups: 512,\n  maxWorkgroups: 1024,\n  shufflePct: 100,\n  barrierPct: 100,\n  memStressPct: 100,\n  memStressIterations: 1024,\n  memStressStoreFirstPct: 50,\n  memStressStoreSecondPct: 50,\n  preStressPct: 100,\n  preStressIterations: 1024,\n  preStressStoreFirstPct: 50,\n  preStressStoreSecondPct: 50,\n  scratchMemorySize: 2048,\n  stressLineSize: 64,\n  stressTargetLines: 2,\n  stressStrategyBalancePct: 50,\n  permuteFirst: 109,\n  permuteSecond: 1,\n  memStride: 4,\n  aliasedMemory: true,\n  numMemLocations: 1,\n  numReadOutputs: 2,\n  numBehaviors: 4,\n};\n\nconst storageMemoryCorrTestCode = `\n  atomicStore(&test_locations.value[x_0], 1u);\n  let r0 = atomicLoad(&test_locations.value[x_1]);\n  let r1 = atomicLoad(&test_locations.value[y_1]);\n  atomicStore(&results.value[id_1].r0, r0);\n  atomicStore(&results.value[id_1].r1, r1);\n`;\n\nconst workgroupMemoryCorrTestCode = `\n  atomicStore(&wg_test_locations[x_0], 1u);\n  let r0 = atomicLoad(&wg_test_locations[x_1]);\n  let r1 = atomicLoad(&wg_test_locations[y_1]);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r0, r0);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r1, r1);\n`;\n\ng.test('corr')\n  .desc(\n    `Ensures two reads on one thread cannot observe an inconsistent view of a write on a second thread.\n     The first thread writes the value 1 some location x, and the second thread reads x twice in a row.\n     If the first read returns 1 but the second read returns 0, then there has been a coherence violation.\n    `\n  )\n  .paramsSimple([\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryCorrTestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: storageMemoryCorrTestCode,\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryCorrTestCode,\n    },\n  ])\n  .fn(async t => {\n    const resultCode = `\n      if ((r0 == 0u && r1 == 0u)) {\n        atomicAdd(&test_results.seq0, 1u);\n      } else if ((r0 == 1u && r1 == 1u)) {\n        atomicAdd(&test_results.seq1, 1u);\n      } else if ((r0 == 0u && r1 == 1u)) {\n        atomicAdd(&test_results.interleaved, 1u);\n      } else if ((r0 == 1u && r1 == 0u)) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n    `;\n\n    const testShader = buildTestShader(t.params._testCode, t.params.memType, t.params.testType);\n    const resultShader = buildResultShader(\n      resultCode,\n      TestType.InterWorkgroup,\n      ResultType.FourBehavior\n    );\n    const memModelTester = new MemoryModelTester(\n      t,\n      memoryModelTestParams,\n      testShader,\n      resultShader\n    );\n    await memModelTester.run(20, 3);\n  });\n"],"file":"coherence.spec.js"}