{"version":3,"sources":["../../../../../src/webgpu/shader/execution/memory_model/coherence.spec.ts"],"names":["description","makeTestGroup","GPUTest","MemoryModelTester","buildTestShader","MemoryType","TestType","buildResultShader","ResultType","g","memoryModelTestParams","workgroupSize","testingWorkgroups","maxWorkgroups","shufflePct","barrierPct","memStressPct","memStressIterations","memStressStoreFirstPct","memStressStoreSecondPct","preStressPct","preStressIterations","preStressStoreFirstPct","preStressStoreSecondPct","scratchMemorySize","stressLineSize","stressTargetLines","stressStrategyBalancePct","permuteFirst","permuteSecond","memStride","aliasedMemory","numBehaviors","storageMemoryCorrTestCode","workgroupStorageMemoryCorrTestCode","storageMemoryCorrRMWTestCode","workgroupStorageMemoryCorrRMWTestCode","workgroupMemoryCorrTestCode","workgroupMemoryCorrRMWTestCode","test","desc","paramsSimple","memType","AtomicStorageClass","testType","InterWorkgroup","_testCode","extraFlags","IntraWorkgroup","AtomicWorkgroupClass","fn","t","resultCode","testShader","params","resultShader","FourBehavior","memModelTester","run","storageMemoryCowwTestCode","storageMemoryCowwRMWTestCode","workgroupMemoryCowwTestCode","workgroupMemoryCowwRMWTestCode","TwoBehavior","storageMemoryCowrTestCode","workgroupStorageMemoryCowrTestCode","storageMemoryCowrRMWTestCode","workgroupStorageMemoryCowrRMWTestCode","workgroupMemoryCowrTestCode","workgroupMemoryCowrRMWTestCode","storageMemoryCorw1TestCode","workgroupStorageMemoryCorw1TestCode","workgroupMemoryCorw1TestCode","storageMemoryCorw2TestCode","workgroupStorageMemoryCorw2TestCode","storageMemoryCorw2RMWTestCode","workgroupStorageMemoryCorw2RMWTestCode","workgroupMemoryCorw2TestCode","workgroupMemoryCorw2RMWTestCode"],"mappings":"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","sourcesContent":["export const description = `\nTests that all threads see a sequentially consistent view of the order of memory\naccesses to a single memory location. Uses a parallel testing strategy along with stressing\nthreads to increase coverage of possible bugs.`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\nimport {\n  MemoryModelTestParams,\n  MemoryModelTester,\n  buildTestShader,\n  MemoryType,\n  TestType,\n  buildResultShader,\n  ResultType,\n} from './memory_model_setup.js';\n\nexport const g = makeTestGroup(GPUTest);\n\n// A reasonable parameter set, determined heuristically.\nconst memoryModelTestParams: MemoryModelTestParams = {\n  workgroupSize: 256,\n  testingWorkgroups: 39,\n  maxWorkgroups: 952,\n  shufflePct: 0,\n  barrierPct: 0,\n  memStressPct: 0,\n  memStressIterations: 1024,\n  memStressStoreFirstPct: 50,\n  memStressStoreSecondPct: 50,\n  preStressPct: 0,\n  preStressIterations: 1024,\n  preStressStoreFirstPct: 50,\n  preStressStoreSecondPct: 50,\n  scratchMemorySize: 2048,\n  stressLineSize: 64,\n  stressTargetLines: 2,\n  stressStrategyBalancePct: 50,\n  permuteFirst: 109,\n  permuteSecond: 1,\n  memStride: 1,\n  aliasedMemory: true,\n  numBehaviors: 4,\n};\n\nconst storageMemoryCorrTestCode = `\n  atomicStore(&test_locations.value[x_0], 1u);\n  let r0 = atomicLoad(&test_locations.value[x_1]);\n  let r1 = atomicLoad(&test_locations.value[y_1]);\n  atomicStore(&results.value[id_1].r0, r0);\n  atomicStore(&results.value[id_1].r1, r1);\n`;\n\nconst workgroupStorageMemoryCorrTestCode = `\n  atomicStore(&test_locations.value[x_0], 1u);\n  let r0 = atomicLoad(&test_locations.value[x_1]);\n  let r1 = atomicLoad(&test_locations.value[y_1]);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r0, r0);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r1, r1);\n`;\n\nconst storageMemoryCorrRMWTestCode = `\n  atomicExchange(&test_locations.value[x_0], 1u);\n  let r0 = atomicLoad(&test_locations.value[x_1]);\n  let r1 = atomicAdd(&test_locations.value[y_1], 0u);\n  atomicStore(&results.value[id_1].r0, r0);\n  atomicStore(&results.value[id_1].r1, r1);\n`;\n\nconst workgroupStorageMemoryCorrRMWTestCode = `\n  atomicExchange(&test_locations.value[x_0], 1u);\n  let r0 = atomicLoad(&test_locations.value[x_1]);\n  let r1 = atomicAdd(&test_locations.value[y_1], 0u);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r0, r0);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r1, r1);\n`;\n\nconst workgroupMemoryCorrTestCode = `\n  atomicStore(&wg_test_locations[x_0], 1u);\n  let r0 = atomicLoad(&wg_test_locations[x_1]);\n  let r1 = atomicLoad(&wg_test_locations[y_1]);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r0, r0);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r1, r1);\n`;\n\nconst workgroupMemoryCorrRMWTestCode = `\n  atomicExchange(&wg_test_locations[x_0], 1u);\n  let r0 = atomicLoad(&wg_test_locations[x_1]);\n  let r1 = atomicAdd(&wg_test_locations[y_1], 0u);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r0, r0);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r1, r1);\n`;\n\ng.test('corr')\n  .desc(\n    `Ensures two reads on one thread cannot observe an inconsistent view of a write on a second thread.\n     The first thread writes the value 1 some location x, and the second thread reads x twice in a row.\n     If the first read returns 1 but the second read returns 0, then there has been a coherence violation.\n    `\n  )\n  .paramsSimple([\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryCorrTestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryCorrRMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupStorageMemoryCorrTestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupStorageMemoryCorrRMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryCorrTestCode,\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryCorrRMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n  ])\n  .fn(async t => {\n    const resultCode = `\n      if ((r0 == 0u && r1 == 0u)) {\n        atomicAdd(&test_results.seq0, 1u);\n      } else if ((r0 == 1u && r1 == 1u)) {\n        atomicAdd(&test_results.seq1, 1u);\n      } else if ((r0 == 0u && r1 == 1u)) {\n        atomicAdd(&test_results.interleaved, 1u);\n      } else if ((r0 == 1u && r1 == 0u)) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n    `;\n    const testShader = buildTestShader(t.params._testCode, t.params.memType, t.params.testType);\n    const resultShader = buildResultShader(resultCode, t.params.testType, ResultType.FourBehavior);\n    const memModelTester = new MemoryModelTester(\n      t,\n      memoryModelTestParams,\n      testShader,\n      resultShader\n    );\n    await memModelTester.run(60, 3);\n  });\n\nconst storageMemoryCowwTestCode = `\n  atomicStore(&test_locations.value[x_0], 1u);\n  atomicStore(&test_locations.value[y_0], 2u);\n`;\n\nconst storageMemoryCowwRMWTestCode = `\n  atomicExchange(&test_locations.value[x_0], 1u);\n  atomicStore(&test_locations.value[y_0], 2u);\n`;\n\nconst workgroupMemoryCowwTestCode = `\n  atomicStore(&wg_test_locations[x_0], 1u);\n  atomicStore(&wg_test_locations[y_0], 2u);\n  workgroupBarrier();\n  atomicStore(&test_locations.value[shuffled_workgroup * workgroupXSize * stress_params.mem_stride * 2u + x_0], atomicLoad(&wg_test_locations[x_0]));\n`;\n\nconst workgroupMemoryCowwRMWTestCode = `\n  atomicExchange(&wg_test_locations[x_0], 1u);\n  atomicStore(&wg_test_locations[y_0], 2u);\n  workgroupBarrier();\n  atomicStore(&test_locations.value[shuffled_workgroup * workgroupXSize * stress_params.mem_stride * 2u + x_0], atomicLoad(&wg_test_locations[x_0]));\n`;\n\ng.test('coww')\n  .desc(\n    `Ensures two writes on one thread do not lead to incoherent results. The thread first writes 1 to\n     some location x and then writes 2 to the same location. If the value in memory after the test finishes\n     is 1, then there has been a coherence violation.\n    `\n  )\n  .paramsSimple([\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryCowwTestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryCowwRMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: storageMemoryCowwTestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: storageMemoryCowwRMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryCowwTestCode,\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryCowwRMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n  ])\n  .fn(async t => {\n    const resultCode = `\n      if (mem_x_0 == 2u) {\n        atomicAdd(&test_results.seq, 1u);\n      } else if (mem_x_0 == 1u) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n    `;\n    const testShader = buildTestShader(t.params._testCode, t.params.memType, t.params.testType);\n    const resultShader = buildResultShader(resultCode, t.params.testType, ResultType.TwoBehavior);\n    const params = {\n      ...memoryModelTestParams,\n      numBehaviors: 2,\n    };\n    const memModelTester = new MemoryModelTester(t, params, testShader, resultShader);\n    await memModelTester.run(60, 1);\n  });\n\nconst storageMemoryCowrTestCode = `\n  atomicStore(&test_locations.value[x_0], 1u);\n  let r0 = atomicLoad(&test_locations.value[y_0]);\n  atomicStore(&test_locations.value[x_1], 2u);\n  atomicStore(&results.value[id_0].r0, r0);\n`;\n\nconst workgroupStorageMemoryCowrTestCode = `\n  atomicStore(&test_locations.value[x_0], 1u);\n  let r0 = atomicLoad(&test_locations.value[y_0]);\n  atomicStore(&test_locations.value[x_1], 2u);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n`;\n\nconst storageMemoryCowrRMWTestCode = `\n  atomicExchange(&test_locations.value[x_0], 1u);\n  let r0 = atomicAdd(&test_locations.value[y_0], 0u);\n  atomicExchange(&test_locations.value[x_1], 2u);\n  atomicStore(&results.value[id_0].r0, r0);\n`;\n\nconst workgroupStorageMemoryCowrRMWTestCode = `\n  atomicExchange(&test_locations.value[x_0], 1u);\n  let r0 = atomicAdd(&test_locations.value[y_0], 0u);\n  atomicExchange(&test_locations.value[x_1], 2u);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n`;\n\nconst workgroupMemoryCowrTestCode = `\n  atomicStore(&wg_test_locations[x_0], 1u);\n  let r0 = atomicLoad(&wg_test_locations[y_0]);\n  atomicStore(&wg_test_locations[x_1], 2u);\n  workgroupBarrier();\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n  atomicStore(&test_locations.value[shuffled_workgroup * workgroupXSize * stress_params.mem_stride * 2u + x_1], atomicLoad(&wg_test_locations[x_1]));\n`;\n\nconst workgroupMemoryCowrRMWTestCode = `\n  atomicExchange(&wg_test_locations[x_0], 1u);\n  let r0 = atomicAdd(&wg_test_locations[y_0], 0u);\n  atomicExchange(&wg_test_locations[x_1], 2u);\n  workgroupBarrier();\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n  atomicStore(&test_locations.value[shuffled_workgroup * workgroupXSize * stress_params.mem_stride * 2u + x_1], atomicLoad(&wg_test_locations[x_1]));\n`;\n\ng.test('cowr')\n  .desc(\n    `The first thread first writes 1 to some location x and then reads x. The second thread writes 2 to x.\n     If the first thread reads the value 2 and the value in memory at the end of the test is 1, then the read\n     and write on the first thread have been reordered, a coherence violation.\n    `\n  )\n  .paramsSimple([\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryCowrTestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryCowrRMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupStorageMemoryCowrTestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupStorageMemoryCowrRMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryCowrTestCode,\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryCowrRMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n  ])\n  .fn(async t => {\n    const resultCode = `\n      if ((r0 == 1u && mem_x_0 == 2u)) {\n        atomicAdd(&test_results.seq0, 1u);\n      } else if ((r0 == 1u && mem_x_0 == 1u)) {\n        atomicAdd(&test_results.seq1, 1u);\n      } else if ((r0 == 2u && mem_x_0 == 2u)) {\n        atomicAdd(&test_results.interleaved, 1u);\n      } else if ((r0 == 2u && mem_x_0 == 1u)) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n    `;\n    const testShader = buildTestShader(t.params._testCode, t.params.memType, t.params.testType);\n    const resultShader = buildResultShader(resultCode, t.params.testType, ResultType.FourBehavior);\n    const memModelTester = new MemoryModelTester(\n      t,\n      memoryModelTestParams,\n      testShader,\n      resultShader\n    );\n    await memModelTester.run(60, 3);\n  });\n\nconst storageMemoryCorw1TestCode = `\n  let r0 = atomicLoad(&test_locations.value[x_0]);\n  atomicStore(&test_locations.value[x_0], 1u);\n  workgroupBarrier();\n  atomicStore(&results.value[id_0].r0, r0);\n`;\n\nconst workgroupStorageMemoryCorw1TestCode = `\n  let r0 = atomicLoad(&test_locations.value[x_0]);\n  atomicStore(&test_locations.value[y_0], 1u);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n`;\n\nconst workgroupMemoryCorw1TestCode = `\n  let r0 = atomicLoad(&wg_test_locations[x_0]);\n  atomicStore(&wg_test_locations[y_0], 1u);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n`;\n\ng.test('corw1')\n  .desc(\n    `One thread first reads from a memory location x and then writes 1 to x. If the read observes the subsequent\n     write, there has been a coherence violation.\n    `\n  )\n  .paramsSimple([\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryCorw1TestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupStorageMemoryCorw1TestCode,\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryCorw1TestCode,\n    },\n  ])\n  .fn(async t => {\n    const resultCode = `\n      if (r0 == 0u) {\n        atomicAdd(&test_results.seq, 1u);\n      } else if (r0 == 1u) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n    `;\n    const testShader = buildTestShader(t.params._testCode, t.params.memType, t.params.testType);\n    const resultShader = buildResultShader(resultCode, t.params.testType, ResultType.TwoBehavior);\n    const params = {\n      ...memoryModelTestParams,\n      numBehaviors: 2,\n    };\n    const memModelTester = new MemoryModelTester(t, params, testShader, resultShader);\n    await memModelTester.run(60, 1);\n  });\n\nconst storageMemoryCorw2TestCode = `\n  let r0 = atomicLoad(&test_locations.value[x_0]);\n  atomicStore(&test_locations.value[y_0], 1u);\n  atomicStore(&test_locations.value[x_1], 2u);\n  atomicStore(&results.value[id_0].r0, r0);\n`;\n\nconst workgroupStorageMemoryCorw2TestCode = `\n  let r0 = atomicLoad(&test_locations.value[x_0]);\n  atomicStore(&test_locations.value[y_0], 1u);\n  atomicStore(&test_locations.value[x_1], 2u);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n`;\n\nconst storageMemoryCorw2RMWTestCode = `\n  let r0 = atomicLoad(&test_locations.value[x_0]);\n  atomicStore(&test_locations.value[y_0], 1u);\n  atomicExchange(&test_locations.value[x_1], 2u);\n  atomicStore(&results.value[id_0].r0, r0);\n`;\n\nconst workgroupStorageMemoryCorw2RMWTestCode = `\n  let r0 = atomicLoad(&test_locations.value[x_0]);\n  atomicStore(&test_locations.value[y_0], 1u);\n  atomicExchange(&test_locations.value[x_1], 2u);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n`;\n\nconst workgroupMemoryCorw2TestCode = `\n  let r0 = atomicLoad(&wg_test_locations[x_0]);\n  atomicStore(&wg_test_locations[y_0], 1u);\n  atomicStore(&wg_test_locations[x_1], 2u);\n  workgroupBarrier();\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n  atomicStore(&test_locations.value[shuffled_workgroup * workgroupXSize * stress_params.mem_stride * 2u + x_1], atomicLoad(&wg_test_locations[x_1]));\n`;\n\nconst workgroupMemoryCorw2RMWTestCode = `\n  let r0 = atomicLoad(&wg_test_locations[x_0]);\n  atomicStore(&wg_test_locations[y_0], 1u);\n  atomicExchange(&wg_test_locations[x_1], 2u);\n  workgroupBarrier();\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n  atomicStore(&test_locations.value[shuffled_workgroup * workgroupXSize * stress_params.mem_stride * 2u + x_1], atomicLoad(&wg_test_locations[x_1]));\n`;\n\ng.test('corw2')\n  .desc(\n    `The first thread reads from some memory location x, and then writes 1 to x. The second thread\n     writes 2 to x. If the first thread reads the value 2, but the value in memory after the test\n     completes is 1, then the instructions on the first thread have been re-ordered, leading to a \n     coherence violation.\n    `\n  )\n  .paramsSimple([\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryCorw2TestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryCorw2RMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupStorageMemoryCorw2TestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupStorageMemoryCorw2RMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryCorw2TestCode,\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryCorw2RMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n  ])\n  .fn(async t => {\n    const resultCode = `\n      if ((r0 == 0u && mem_x_0 == 2u)) {\n        atomicAdd(&test_results.seq0, 1u);\n      } else if ((r0 == 2u && mem_x_0 == 1u)) {\n        atomicAdd(&test_results.seq1, 1u);\n      } else if ((r0 == 0u && mem_x_0 == 1u)) {\n        atomicAdd(&test_results.interleaved, 1u);\n      } else if ((r0 == 2u && mem_x_0 == 2u)) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n    `;\n    const testShader = buildTestShader(t.params._testCode, t.params.memType, t.params.testType);\n    const resultShader = buildResultShader(resultCode, t.params.testType, ResultType.FourBehavior);\n    const memModelTester = new MemoryModelTester(\n      t,\n      memoryModelTestParams,\n      testShader,\n      resultShader\n    );\n    await memModelTester.run(60, 3);\n  });\n"],"file":"coherence.spec.js"}