{"version":3,"sources":["../../../../../src/webgpu/shader/execution/memory_model/memory_model_setup.ts"],"names":["checkElementsPassPredicate","numStressParams","barrierParamIndex","memStressIndex","memStressIterationsIndex","memStressPatternIndex","preStressIndex","preStressIterationsIndex","preStressPatternIndex","permuteFirstIndex","permuteSecondIndex","testingWorkgroupsIndex","memStrideIndex","memLocationOffsetIndex","bytesPerWord","MemoryModelTester","constructor","t","params","testShader","resultShader","test","testingThreads","workgroupSize","testingWorkgroups","testLocationsSize","numMemLocations","memStride","testLocationsBuffer","deviceBuf","device","createBuffer","size","usage","GPUBufferUsage","COPY_DST","STORAGE","srcBuf","makeBufferWithContents","Uint32Array","fill","COPY_SRC","readResultsSize","numReadOutputs","readResultsBuffer","testResultsSize","numBehaviors","testResultsBuffer","shuffledWorkgroupsSize","maxWorkgroups","shuffledWorkgroupsBuffer","MAP_WRITE","barrierSize","barrierBuffer","scratchpadSize","scratchMemorySize","scratchpadBuffer","scratchMemoryLocationsSize","scratchMemoryLocationsBuffer","stressParamsSize","stressParamsBuffer","UNIFORM","buffers","testLocations","readResults","testResults","shuffledWorkgroups","barrier","scratchpad","scratchMemoryLocations","stressParams","testLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","buffer","type","testPipeline","createComputePipeline","layout","createPipelineLayout","bindGroupLayouts","compute","module","createShaderModule","code","entryPoint","testBindGroup","createBindGroup","resource","resultLayout","resultPipeline","resultBindGroup","run","iterations","weakIndex","i","numWorkgroups","getRandomInRange","setShuffledWorkgroups","setScratchLocations","setStressParams","encoder","createCommandEncoder","copyBufferToBuffer","testPass","beginComputePass","setPipeline","setBindGroup","dispatch","end","resultPass","queue","submit","finish","expectGPUBufferValuesPassCheck","checkWeakIndex","typedLength","checkResult","resultPrinter","a","predicatePrinter","leftHeader","getValueForCell","v","getRandomInt","max","Math","floor","random","min","offset","shuffleArray","length","toSwap","temp","mapAsync","GPUMapMode","WRITE","getMappedRange","shuffledWorkgroupsArray","shufflePct","x","unmap","scratchLocationsArrayBuffer","scratchLocationsArray","scratchNumRegions","stressLineSize","scratchRegions","Array","keys","stressTargetLines","region","locInRegion","stressStrategyBalancePct","j","workgroupsPerLocation","stressParamsArrayBuffer","stressParamsArray","barrierPct","memStressPct","memStressIterations","memStressStoreFirst","memStressStoreFirstPct","memStressStoreSecond","memStressStoreSecondPct","memStressPattern","preStressPct","preStressIterations","preStressStoreFirst","preStressStoreFirstPct","preStressStoreSecond","preStressStoreSecondPct","preStressPattern","permuteFirst","permuteSecond","aliasedMemory","shaderMemStructures","fourBehaviorTestResultStructure","twoBehaviorTestResultStructure","commonTestShaderBindings","atomicTestShaderBindings","join","nonAtomicTestShaderBindings","resultShaderBindings","atomicWorkgroupMemory","nonAtomicWorkgroupMemory","memoryLocationFunctions","testShaderFunctions","shaderEntryPoint","testShaderCommonHeader","testShaderCommonCalculations","interWorkgroupTestShaderCode","intraWorkgroupTestShaderCode","testShaderCommonFooter","resultShaderCommonCalculations","interWorkgroupResultShaderCode","intraWorkgroupResultShaderCode","resultShaderCommonFooter","storageMemoryAtomicTestShaderCode","storageMemoryNonAtomicTestShaderCode","workgroupMemoryAtomicTestShaderCode","workgroupMemoryNonAtomicTestShaderCode","resultShaderCommonCode","MemoryType","TestType","ResultType","buildTestShader","testCode","memoryType","testType","memoryTypeCode","AtomicStorageClass","NonAtomicStorageClass","AtomicWorkgroupClass","NonAtomicWorkgroupClass","testTypeCode","InterWorkgroup","IntraWorkgroup","buildResultShader","resultCode","resultType","resultStructure","TwoBehavior","FourBehavior"],"mappings":"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;;AAib/B;AACA,MAAMkC,mBAAmB,GAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAhCA;;AAkCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,+BAA+B,GAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,CAPA;;AASA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,8BAA8B,GAAI;AACxC;AACA;AACA;AACA;AACA,CALA;;AAOA;AACA,MAAMC,wBAAwB,GAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,CAPA;;AASA;AACA,MAAMC,wBAAwB,GAAG;AAC9B;AACH;AACA,CAHiC;AAI/BD,wBAJ+B;AAK/BE,IAL+B,CAK1B,IAL0B,CAAjC;;AAOA;AACA,MAAMC,2BAA2B,GAAG;AACjC;AACH;AACA,CAHoC;AAIlCH,wBAJkC;AAKlCE,IALkC,CAK7B,IAL6B,CAApC;;AAOA;AACA,MAAME,oBAAoB,GAAI;AAC9B;AACA;AACA;AACA;AACA,CALA;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,qBAAqB,GAAI;AAC/B;AACA,CAFA;;AAIA;AACA;AACA;AACA;AACA,MAAMC,wBAAwB,GAAI;AAClC;AACA,CAFA;;AAIA;AACA;AACA;AACA;AACA;AACA,MAAMC,uBAAuB,GAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CARA;;AAUA;AACA,MAAMC,mBAAmB,GAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CApEA;;AAsEA;AACA;AACA;AACA;AACA,MAAMC,gBAAgB,GAAI;AAC1B;AACA;AACA;AACA;AACA;AACA,CANA;;AAQA;AACA,MAAMC,sBAAsB,GAAI;AAChC;AACA;AACA,CAHA;;AAKA;AACA;AACA;AACA;AACA,MAAMC,4BAA4B,GAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CARA;;AAUA;AACA;AACA;AACA;AACA,MAAMC,4BAA4B,GAAG;AAClC;AACH;AACA;AACA;AACA;AACA,CANqC;AAOnCD,4BAPmC;AAQlC;AACH;AACA;AACA;AACA,CAZqC;AAanCT,IAbmC,CAa9B,IAb8B,CAArC;;AAeA;AACA;AACA;AACA;AACA,MAAMW,4BAA4B,GAAG;AAClC;AACH;AACA;AACA;AACA,CALqC;AAMnCF,4BANmC;AAOlC;AACH;AACA;AACA;AACA,CAXqC;AAYnCT,IAZmC,CAY9B,IAZ8B,CAArC;;AAcA;AACA,MAAMY,sBAAsB,GAAI;AAChC;AACA;AACA;AACA;AACA,CALA;;AAOA;AACA;AACA;AACA;AACA,MAAMC,8BAA8B,GAAI;AACxC;AACA;AACA;AACA;AACA;AACA,CANA;;AAQA;AACA,MAAMC,8BAA8B,GAAG;AACrCD,8BADqC;AAEpC;AACH;AACA;AACA;AACA,CANuC;AAOrCb,IAPqC,CAOhC,IAPgC,CAAvC;;AASA;AACA,MAAMe,8BAA8B,GAAG;AACrCF,8BADqC;AAEpC;AACH;AACA;AACA;AACA,CANuC;AAOrCb,IAPqC,CAOhC,IAPgC,CAAvC;;AASA;AACA,MAAMgB,wBAAwB,GAAI;AAClC;AACA,CAFA;;AAIA;AACA,MAAMC,iCAAiC,GAAG;AACxCtB,mBADwC;AAExCI,wBAFwC;AAGxCM,uBAHwC;AAIxCC,mBAJwC;AAKxCC,gBALwC;AAMxCC,sBANwC;AAOxCR,IAPwC,CAOnC,IAPmC,CAA1C;;AASA;AACA,MAAMk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","sourcesContent":["import { GPUTest } from '../../../gpu_test';\nimport { checkElementsPassPredicate } from '../../../util/check_contents.js';\n\n/* All buffer sizes are counted in units of 4-byte words. */\n\n/* Parameter values are set heuristically, typically by a time-intensive search. */\nexport type MemoryModelTestParams = {\n  /* Number of invocations per workgroup. The workgroups are 1-dimensional. */\n  workgroupSize: number;\n  /** The number of workgroups to assign to running the test. */\n  testingWorkgroups: number;\n  /**\n   * Run no more than this many workgroups. Must be >= the number of testing workgroups. Non-testing workgroups are used\n   * to stress other memory locations.\n   */\n  maxWorkgroups: number;\n  /** The percentage of iterations to shuffle the workgroup ids. */\n  shufflePct: number;\n  /** The percentage of iterations to run the bounded spin-loop barrier. */\n  barrierPct: number;\n  /** The percentage of iterations to run memory stress using non-testing workgroups. */\n  memStressPct: number;\n  /** The number of iterations to run the memory stress pattern. */\n  memStressIterations: number;\n  /** The percentage of iterations the first instruction in the stress pattern should be a store. */\n  memStressStoreFirstPct: number;\n  /** The percentage of iterations the second instruction in the stress pattern should be a store. */\n  memStressStoreSecondPct: number;\n  /** The percentage of iterations for testing threads to run stress before running the test. */\n  preStressPct: number;\n  /** Same as for memStressIterations. */\n  preStressIterations: number;\n  /** The percentage of iterations the first instruction in the pre-stress pattern should be a store. */\n  preStressStoreFirstPct: number;\n  /** The percentage of iterations the second instruction in the pre-stress pattern should be a store. */\n  preStressStoreSecondPct: number;\n  /** The size of the scratch memory region, used for stressing threads. */\n  scratchMemorySize: number;\n  /** The size of each block of memory stressing threads access. */\n  stressLineSize: number;\n  /** The number of blocks of memory to assign stressing threads to. */\n  stressTargetLines: number;\n  /** How non-testing threads are assigned to stressing locations. 100 means all iterations use a round robin approach, 0 means all use a chunking approach. */\n  stressStrategyBalancePct: number;\n  /** Used to permute thread ids within a workgroup, so more random pairings are created between threads coordinating on a test. */\n  permuteFirst: number;\n  /** Used to create distance between memory locations used in a test. Set this to 1 for memory that should be aliased. */\n  permuteSecond: number;\n  /** The distance (in number of 4 byte intervals) between any two memory locations used for testing. */\n  memStride: number;\n  /** For tests that access one memory location, but use dynamic addresses to avoid compiler optimization, aliased memory should be set to true. */\n  aliasedMemory: boolean;\n  /** The number of memory locations accessed by this test. */\n  numMemLocations: number;\n  /** The number of read outputs per test that need to be analyzed in the result aggregation shader. */\n  numReadOutputs: number;\n  /** The number of possible behaviors that a test can have. */\n  numBehaviors: number;\n};\n\n/** Represents a device buffer and a utility buffer for resetting memory and copying parameters. */\ntype BufferWithSource = {\n  /** Buffer used by shader code. */\n  deviceBuf: GPUBuffer;\n  /** Buffer populated from the host size, data is copied to device buffer for use by shader. */\n  srcBuf: GPUBuffer;\n  /** Size in bytes of the buffer. */\n  size: number;\n};\n\n/** Specifies the buffers used during a memory model test. */\ntype MemoryModelBuffers = {\n  /** This is the memory region that testing threads read from and write to. */\n  testLocations: BufferWithSource;\n  /** This buffer collects the results of reads for analysis in the result aggregation shader. */\n  readResults: BufferWithSource;\n  /** This buffer is the aggregated results of every testing thread, and is used to check for test success/failure. */\n  testResults: BufferWithSource;\n  /** This buffer stores the shuffled workgroup ids for use during testing. Read-only in the shader. */\n  shuffledWorkgroups: BufferWithSource;\n  /** This is the bounded spin-loop barrier, used to temporally align testing threads. */\n  barrier: BufferWithSource;\n  /** Memory region for stressing threads to read to and write from. */\n  scratchpad: BufferWithSource;\n  /** The memory locations in the scratch region that stressing threads access. */\n  scratchMemoryLocations: BufferWithSource;\n  /** Parameters that are used by the shader to calculate memory locations and perform stress. */\n  stressParams: BufferWithSource;\n};\n\n/** The number of stress params to add to the stress params buffer. */\nconst numStressParams = 12;\nconst barrierParamIndex = 0;\nconst memStressIndex = 1;\nconst memStressIterationsIndex = 2;\nconst memStressPatternIndex = 3;\nconst preStressIndex = 4;\nconst preStressIterationsIndex = 5;\nconst preStressPatternIndex = 6;\nconst permuteFirstIndex = 7;\nconst permuteSecondIndex = 8;\nconst testingWorkgroupsIndex = 9;\nconst memStrideIndex = 10;\nconst memLocationOffsetIndex = 11;\n\n/**\n * All memory used in these consists of a four byte word, so this value is used to correctly set the byte size of buffers that\n * are read to/written from during tests and for storing test results.\n */\nconst bytesPerWord = 4;\n\n/**\n * Implements setup code necessary to run a memory model test. A test consists of two parts:\n *  1.) A test shader that runs a specified memory model litmus test and attempts to reveal a weak (disallowed) behavior.\n *      At a high level, a test shader consists of a set of testing workgroups where every invocation executes the litmus test\n *      on a set of test locations, and a set of stressing workgroups where every invocation accesses a specified memory location\n *      in a random pattern.\n *  2.) A result shader that takes the output of the test shader, which consists of the memory locations accessed during the test\n *      and the results of any reads made during the test, and aggregate the results based on the possible behaviors of the test.\n */\nexport class MemoryModelTester {\n  protected test: GPUTest;\n  protected params: MemoryModelTestParams;\n  protected buffers: MemoryModelBuffers;\n  protected testPipeline: GPUComputePipeline;\n  protected testBindGroup: GPUBindGroup;\n  protected resultPipeline: GPUComputePipeline;\n  protected resultBindGroup: GPUBindGroup;\n\n  /** Sets up a memory model test by initializing buffers and pipeline layouts. */\n  constructor(t: GPUTest, params: MemoryModelTestParams, testShader: string, resultShader: string) {\n    this.test = t;\n    this.params = params;\n\n    // set up buffers\n    const testingThreads = this.params.workgroupSize * this.params.testingWorkgroups;\n    const testLocationsSize =\n      testingThreads * this.params.numMemLocations * this.params.memStride * bytesPerWord;\n    const testLocationsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        size: testLocationsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n      }),\n      srcBuf: this.test.makeBufferWithContents(\n        new Uint32Array(testLocationsSize).fill(0),\n        GPUBufferUsage.COPY_SRC\n      ),\n      size: testLocationsSize,\n    };\n\n    const readResultsSize = testingThreads * this.params.numReadOutputs * bytesPerWord;\n    const readResultsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        size: readResultsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n      }),\n      srcBuf: this.test.makeBufferWithContents(\n        new Uint32Array(readResultsSize).fill(0),\n        GPUBufferUsage.COPY_SRC\n      ),\n      size: readResultsSize,\n    };\n\n    const testResultsSize = this.params.numBehaviors * bytesPerWord;\n    const testResultsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        size: testResultsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n      }),\n      srcBuf: this.test.makeBufferWithContents(\n        new Uint32Array(testResultsSize).fill(0),\n        GPUBufferUsage.COPY_SRC\n      ),\n      size: testResultsSize,\n    };\n\n    const shuffledWorkgroupsSize = this.params.maxWorkgroups * bytesPerWord;\n    const shuffledWorkgroupsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        size: shuffledWorkgroupsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n      }),\n      srcBuf: this.test.device.createBuffer({\n        size: shuffledWorkgroupsSize,\n        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE,\n      }),\n      size: shuffledWorkgroupsSize,\n    };\n\n    const barrierSize = bytesPerWord;\n    const barrierBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        size: barrierSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n      }),\n      srcBuf: this.test.makeBufferWithContents(\n        new Uint32Array(barrierSize).fill(0),\n        GPUBufferUsage.COPY_SRC\n      ),\n      size: barrierSize,\n    };\n\n    const scratchpadSize = this.params.scratchMemorySize * bytesPerWord;\n    const scratchpadBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        size: scratchpadSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n      }),\n      srcBuf: this.test.makeBufferWithContents(\n        new Uint32Array(scratchpadSize).fill(0),\n        GPUBufferUsage.COPY_SRC\n      ),\n      size: scratchpadSize,\n    };\n\n    const scratchMemoryLocationsSize = this.params.maxWorkgroups * bytesPerWord;\n    const scratchMemoryLocationsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        size: scratchMemoryLocationsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n      }),\n      srcBuf: this.test.device.createBuffer({\n        size: scratchMemoryLocationsSize,\n        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE,\n      }),\n      size: scratchMemoryLocationsSize,\n    };\n\n    const stressParamsSize = numStressParams * bytesPerWord;\n    const stressParamsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        size: stressParamsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n      }),\n      srcBuf: this.test.device.createBuffer({\n        size: stressParamsSize,\n        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE,\n      }),\n      size: stressParamsSize,\n    };\n\n    this.buffers = {\n      testLocations: testLocationsBuffer,\n      readResults: readResultsBuffer,\n      testResults: testResultsBuffer,\n      shuffledWorkgroups: shuffledWorkgroupsBuffer,\n      barrier: barrierBuffer,\n      scratchpad: scratchpadBuffer,\n      scratchMemoryLocations: scratchMemoryLocationsBuffer,\n      stressParams: stressParamsBuffer,\n    };\n\n    // set up pipeline layouts\n    const testLayout = this.test.device.createBindGroupLayout({\n      entries: [\n        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },\n        { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 5, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 6, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },\n      ],\n    });\n    this.testPipeline = this.test.device.createComputePipeline({\n      layout: this.test.device.createPipelineLayout({\n        bindGroupLayouts: [testLayout],\n      }),\n      compute: {\n        module: this.test.device.createShaderModule({\n          code: testShader,\n        }),\n        entryPoint: 'main',\n      },\n    });\n    this.testBindGroup = this.test.device.createBindGroup({\n      entries: [\n        { binding: 0, resource: { buffer: this.buffers.testLocations.deviceBuf } },\n        { binding: 1, resource: { buffer: this.buffers.readResults.deviceBuf } },\n        { binding: 2, resource: { buffer: this.buffers.shuffledWorkgroups.deviceBuf } },\n        { binding: 3, resource: { buffer: this.buffers.barrier.deviceBuf } },\n        { binding: 4, resource: { buffer: this.buffers.scratchpad.deviceBuf } },\n        { binding: 5, resource: { buffer: this.buffers.scratchMemoryLocations.deviceBuf } },\n        { binding: 6, resource: { buffer: this.buffers.stressParams.deviceBuf } },\n      ],\n      layout: testLayout,\n    });\n\n    const resultLayout = this.test.device.createBindGroupLayout({\n      entries: [\n        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },\n      ],\n    });\n    this.resultPipeline = this.test.device.createComputePipeline({\n      layout: this.test.device.createPipelineLayout({\n        bindGroupLayouts: [resultLayout],\n      }),\n      compute: {\n        module: this.test.device.createShaderModule({\n          code: resultShader,\n        }),\n        entryPoint: 'main',\n      },\n    });\n    this.resultBindGroup = this.test.device.createBindGroup({\n      entries: [\n        { binding: 0, resource: { buffer: this.buffers.testLocations.deviceBuf } },\n        { binding: 1, resource: { buffer: this.buffers.readResults.deviceBuf } },\n        { binding: 2, resource: { buffer: this.buffers.testResults.deviceBuf } },\n        { binding: 3, resource: { buffer: this.buffers.stressParams.deviceBuf } },\n      ],\n      layout: resultLayout,\n    });\n  }\n\n  /**\n   * Run the test for the specified number of iterations. Checks the testResults buffer on the weakIndex; if\n   * this value is not 0 then the test has failed.\n   */\n  async run(iterations: number, weakIndex: number): Promise<void> {\n    for (let i = 0; i < iterations; i++) {\n      const numWorkgroups = this.getRandomInRange(\n        this.params.testingWorkgroups,\n        this.params.maxWorkgroups\n      );\n      await this.setShuffledWorkgroups(numWorkgroups);\n      await this.setScratchLocations(numWorkgroups);\n      await this.setStressParams();\n      const encoder = this.test.device.createCommandEncoder();\n      this.copyBufferToBuffer(encoder, this.buffers.testLocations);\n      this.copyBufferToBuffer(encoder, this.buffers.readResults);\n      this.copyBufferToBuffer(encoder, this.buffers.testResults);\n      this.copyBufferToBuffer(encoder, this.buffers.barrier);\n      this.copyBufferToBuffer(encoder, this.buffers.shuffledWorkgroups);\n      this.copyBufferToBuffer(encoder, this.buffers.scratchpad);\n      this.copyBufferToBuffer(encoder, this.buffers.scratchMemoryLocations);\n      this.copyBufferToBuffer(encoder, this.buffers.stressParams);\n\n      const testPass = encoder.beginComputePass();\n      testPass.setPipeline(this.testPipeline);\n      testPass.setBindGroup(0, this.testBindGroup);\n      testPass.dispatch(numWorkgroups);\n      testPass.end();\n\n      const resultPass = encoder.beginComputePass();\n      resultPass.setPipeline(this.resultPipeline);\n      resultPass.setBindGroup(0, this.resultBindGroup);\n      resultPass.dispatch(this.params.testingWorkgroups);\n      resultPass.end();\n\n      this.test.device.queue.submit([encoder.finish()]);\n      this.test.expectGPUBufferValuesPassCheck(\n        this.buffers.testResults.deviceBuf,\n        this.checkWeakIndex(weakIndex),\n        {\n          type: Uint32Array,\n          typedLength: this.params.numBehaviors,\n        }\n      );\n    }\n  }\n\n  /** Returns a function that checks whether the test passes, given a weak index and the test results buffer. */\n  protected checkWeakIndex(weakIndex: number): (a: Uint32Array) => Error | undefined {\n    const checkResult = this.checkResult(weakIndex);\n    const resultPrinter = this.resultPrinter(weakIndex);\n    return function (a: Uint32Array): Error | undefined {\n      return checkElementsPassPredicate(a, checkResult, {\n        predicatePrinter: [{ leftHeader: 'expected ==', getValueForCell: resultPrinter }],\n      });\n    };\n  }\n\n  /**\n   * Returns a function that checks whether the specified weak index's value is not equal to 0.\n   * If the weak index's value is not 0, it means the test has observed a behavior disallowed by the memory model and\n   * is considered a test failure.\n   */\n  protected checkResult(weakIndex: number): (i: number, v: number) => boolean {\n    return function (i: number, v: number): boolean {\n      if (i === weakIndex && v > 0) {\n        return false;\n      }\n      return true;\n    };\n  }\n\n  /** Returns a printer function that visualizes the results of checking the test results. */\n  protected resultPrinter(weakIndex: number): (i: number) => string | number {\n    return function (i: number): string | number {\n      if (i === weakIndex) {\n        return 0;\n      } else {\n        return 'any value';\n      }\n    };\n  }\n\n  /** Utility method that simplifies copying source buffers to device buffers. */\n  protected copyBufferToBuffer(encoder: GPUCommandEncoder, buffer: BufferWithSource): void {\n    encoder.copyBufferToBuffer(buffer.srcBuf, 0, buffer.deviceBuf, 0, buffer.size);\n  }\n\n  /** Returns a random integer between 0 and the max. */\n  protected getRandomInt(max: number): number {\n    return Math.floor(Math.random() * max);\n  }\n\n  /** Returns a random number in between the min and max values. */\n  protected getRandomInRange(min: number, max: number): number {\n    if (min === max) {\n      return min;\n    } else {\n      const offset = this.getRandomInt(max - min);\n      return min + offset;\n    }\n  }\n\n  /** Returns a permuted array using a simple Fisher-Yates shuffle algorithm. */\n  protected shuffleArray(a: number[]): void {\n    for (let i = a.length - 1; i >= 0; i--) {\n      const toSwap = this.getRandomInt(i + 1);\n      const temp = a[toSwap];\n      a[toSwap] = a[i];\n      a[i] = temp;\n    }\n  }\n\n  /**\n   * Shuffles the order of workgroup ids, so that threads operating on the same memory location are not always in\n   * consecutive workgroups.\n   */\n  protected async setShuffledWorkgroups(numWorkgroups: number): Promise<void> {\n    await this.buffers.shuffledWorkgroups.srcBuf.mapAsync(GPUMapMode.WRITE);\n    const shuffledWorkgroupsBuffer = this.buffers.shuffledWorkgroups.srcBuf.getMappedRange();\n    const shuffledWorkgroupsArray = new Uint32Array(shuffledWorkgroupsBuffer);\n    for (let i = 0; i < numWorkgroups; i++) {\n      shuffledWorkgroupsArray[i] = i;\n    }\n    if (this.getRandomInt(100) < this.params.shufflePct) {\n      for (let i = numWorkgroups - 1; i > 0; i--) {\n        const x = this.getRandomInt(i + 1);\n        const temp = shuffledWorkgroupsArray[i];\n        shuffledWorkgroupsArray[i] = shuffledWorkgroupsArray[x];\n        shuffledWorkgroupsArray[x] = temp;\n      }\n    }\n    this.buffers.shuffledWorkgroups.srcBuf.unmap();\n  }\n\n  /** Sets the memory locations that stressing workgroups will access. Uses either a chunking or round robin assignment strategy. */\n  protected async setScratchLocations(numWorkgroups: number): Promise<void> {\n    await this.buffers.scratchMemoryLocations.srcBuf.mapAsync(GPUMapMode.WRITE);\n    const scratchLocationsArrayBuffer = this.buffers.scratchMemoryLocations.srcBuf.getMappedRange();\n    const scratchLocationsArray = new Uint32Array(scratchLocationsArrayBuffer);\n    const scratchNumRegions = this.params.scratchMemorySize / this.params.stressLineSize;\n    const scratchRegions = [...Array(scratchNumRegions).keys()];\n    this.shuffleArray(scratchRegions);\n    for (let i = 0; i < this.params.stressTargetLines; i++) {\n      const region = scratchRegions[i];\n      const locInRegion = this.getRandomInt(this.params.stressLineSize);\n      if (this.getRandomInt(100) < this.params.stressStrategyBalancePct) {\n        // In the round-robin case, the current scratch location is striped across all workgroups.\n        for (let j = i; j < numWorkgroups; j += this.params.stressTargetLines) {\n          scratchLocationsArray[j] = region * this.params.stressLineSize + locInRegion;\n        }\n      } else {\n        // In the chunking case, the current scratch location is assigned to a block of workgroups. The final scratch\n        // location may be assigned to more workgroups, if the number of scratch locations does not cleanly divide the\n        // number of workgroups.\n        const workgroupsPerLocation = numWorkgroups / this.params.stressTargetLines;\n        for (let j = 0; j < workgroupsPerLocation; j++) {\n          scratchLocationsArray[i * workgroupsPerLocation + j] =\n            region * this.params.stressLineSize + locInRegion;\n        }\n        if (\n          i === this.params.stressTargetLines - 1 &&\n          numWorkgroups % this.params.stressTargetLines !== 0\n        ) {\n          for (let j = 0; j < numWorkgroups % this.params.stressTargetLines; j++) {\n            scratchLocationsArray[numWorkgroups - j - 1] =\n              region * this.params.stressLineSize + locInRegion;\n          }\n        }\n      }\n    }\n    this.buffers.scratchMemoryLocations.srcBuf.unmap();\n  }\n\n  /** Sets the parameters that are used by the shader to calculate memory locations and perform stress. */\n  protected async setStressParams(): Promise<void> {\n    await this.buffers.stressParams.srcBuf.mapAsync(GPUMapMode.WRITE);\n    const stressParamsArrayBuffer = this.buffers.stressParams.srcBuf.getMappedRange();\n    const stressParamsArray = new Uint32Array(stressParamsArrayBuffer);\n    if (this.getRandomInt(100) < this.params.barrierPct) {\n      stressParamsArray[barrierParamIndex] = 1;\n    } else {\n      stressParamsArray[barrierParamIndex] = 0;\n    }\n    if (this.getRandomInt(100) < this.params.memStressPct) {\n      stressParamsArray[memStressIndex] = 1;\n    } else {\n      stressParamsArray[memStressIndex] = 0;\n    }\n    stressParamsArray[memStressIterationsIndex] = this.params.memStressIterations;\n    const memStressStoreFirst = this.getRandomInt(100) < this.params.memStressStoreFirstPct;\n    const memStressStoreSecond = this.getRandomInt(100) < this.params.memStressStoreSecondPct;\n    let memStressPattern;\n    if (memStressStoreFirst && memStressStoreSecond) {\n      memStressPattern = 0;\n    } else if (memStressStoreFirst && !memStressStoreSecond) {\n      memStressPattern = 1;\n    } else if (!memStressStoreFirst && memStressStoreSecond) {\n      memStressPattern = 2;\n    } else {\n      memStressPattern = 3;\n    }\n    stressParamsArray[memStressPatternIndex] = memStressPattern;\n    if (this.getRandomInt(100) < this.params.preStressPct) {\n      stressParamsArray[preStressIndex] = 1;\n    } else {\n      stressParamsArray[preStressIndex] = 0;\n    }\n    stressParamsArray[preStressIterationsIndex] = this.params.preStressIterations;\n    const preStressStoreFirst = this.getRandomInt(100) < this.params.preStressStoreFirstPct;\n    const preStressStoreSecond = this.getRandomInt(100) < this.params.preStressStoreSecondPct;\n    let preStressPattern;\n    if (preStressStoreFirst && preStressStoreSecond) {\n      preStressPattern = 0;\n    } else if (preStressStoreFirst && !preStressStoreSecond) {\n      preStressPattern = 1;\n    } else if (!preStressStoreFirst && preStressStoreSecond) {\n      preStressPattern = 2;\n    } else {\n      preStressPattern = 3;\n    }\n    stressParamsArray[preStressPatternIndex] = preStressPattern;\n    stressParamsArray[permuteFirstIndex] = this.params.permuteFirst;\n    stressParamsArray[permuteSecondIndex] = this.params.permuteSecond;\n    stressParamsArray[testingWorkgroupsIndex] = this.params.testingWorkgroups;\n    stressParamsArray[memStrideIndex] = this.params.memStride;\n    if (this.params.aliasedMemory) {\n      stressParamsArray[memLocationOffsetIndex] = 0;\n    } else {\n      stressParamsArray[memLocationOffsetIndex] = this.params.memStride;\n    }\n    this.buffers.stressParams.srcBuf.unmap();\n  }\n}\n\n/** Defines common data structures used in memory model test shaders. */\nconst shaderMemStructures = `\n  struct Memory {\n    value: array<u32>\n  };\n\n  struct AtomicMemory {\n    value: array<atomic<u32>>\n  };\n\n  struct ReadResult {\n    r0: atomic<u32>,\n    r1: atomic<u32>,\n  };\n\n  struct ReadResults {\n    value: array<ReadResult>\n  };\n\n  struct StressParamsMemory {\n    do_barrier: u32,\n    mem_stress: u32,\n    mem_stress_iterations: u32,\n    mem_stress_pattern: u32,\n    pre_stress: u32,\n    pre_stress_iterations: u32,\n    pre_stress_pattern: u32,\n    permute_first: u32,\n    permute_second: u32,\n    testing_workgroups: u32,\n    mem_stride: u32,\n    location_offset: u32,\n  };\n`;\n\n/**\n * Structure to hold the counts of occurrences of the possible behaviors of a two-thread, four-instruction test.\n * \"seq0\" means the first invocation's instructions are observed to have occurred before the second invocation's instructions.\n * \"seq1\" means the second invocation's instructions are observed to have occurred before the first invocation's instructions.\n * \"interleaved\" means there was an observation of some interleaving of instructions between the two invocations.\n * \"weak\" means there was an observation of some ordering of instructions that is inconsistent with the WebGPU memory model.\n */\nconst fourBehaviorTestResultStructure = `\n  struct TestResults {\n    seq0: atomic<u32>,\n    seq1: atomic<u32>,\n    interleaved: atomic<u32>,\n    weak: atomic<u32>,\n  };\n`;\n\n/**\n * Defines the possible behaviors of a two instruction test. Used to test the behavior of non-atomic memory with barriers and\n * one-thread coherence tests.\n * \"seq\" means that the expected, sequential behavior occurred.\n * \"weak\" means that an unexpected, inconsistent behavior occurred.\n */\nconst twoBehaviorTestResultStructure = `\n  struct TestResults {\n    seq: atomic<u32>,\n    weak: atomic<u32>,\n  };\n`;\n\n/** Common bindings used in the test shader phase of a test. */\nconst commonTestShaderBindings = `\n  @group(0) @binding(1) var<storage, read_write> results : ReadResults;\n  @group(0) @binding(2) var<storage, read> shuffled_workgroups : Memory;\n  @group(0) @binding(3) var<storage, read_write> barrier : AtomicMemory;\n  @group(0) @binding(4) var<storage, read_write> scratchpad : Memory;\n  @group(0) @binding(5) var<storage, read_write> scratch_locations : Memory;\n  @group(0) @binding(6) var<uniform> stress_params : StressParamsMemory;\n`;\n\n/** The combined bindings for a test on atomic memory. */\nconst atomicTestShaderBindings = [\n  `\n  @group(0) @binding(0) var<storage, read_write> test_locations : AtomicMemory;\n`,\n  commonTestShaderBindings,\n].join('\\n');\n\n/** The combined bindings for a test on non-atomic memory. */\nconst nonAtomicTestShaderBindings = [\n  `\n  @group(0) @binding(0) var<storage, read_write> test_locations : Memory;\n`,\n  commonTestShaderBindings,\n].join('\\n');\n\n/** Bindings used in the result aggregation phase of the test. */\nconst resultShaderBindings = `\n  @group(0) @binding(0) var<storage, read_write> test_locations : AtomicMemory;\n  @group(0) @binding(1) var<storage, read_write> read_results : ReadResults;\n  @group(0) @binding(2) var<storage, read_write> test_results : TestResults;\n  @group(0) @binding(3) var<uniform> stress_params : StressParamsMemory;\n`;\n\n/**\n * For tests that operate on workgroup memory, include this definition. 3584 memory locations is\n * large enough to accommodate the maximum memory size needed per workgroup for testing, which is\n * 256 invocations per workgroup x 2 memory locations x 7 (memStride, or max stride between successive memory locations).\n * Should change to a pipeline overridable constant when possible.\n */\nconst atomicWorkgroupMemory = `\n  var<workgroup> wg_test_locations: array<atomic<u32>, 3584>;\n`;\n\n/**\n * For tests that operate on non-atomic workgroup memory, include this definition. 3584 memory locations\n * is large enough to accommodate the maximum memory size needed per workgroup for testing.\n */\nconst nonAtomicWorkgroupMemory = `\n  var<workgroup> wg_test_locations: array<u32, 3584>;\n`;\n\n/**\n * Functions used to calculate memory locations for each invocation, for both testing and result aggregation.\n * The permute function ensures a random permutation based on multiplying and modding by coprime numbers. The stripe\n * workgroup function ensures that invocations coordinating on a test are spread out across different workgroups.\n */\nconst memoryLocationFunctions = `\n  fn permute_id(id: u32, factor: u32, mask: u32) -> u32 {\n    return (id * factor) % mask;\n  }\n\n  fn stripe_workgroup(workgroup_id: u32, local_id: u32) -> u32 {\n    return (workgroup_id + 1u + local_id % (stress_params.testing_workgroups - 1u)) % stress_params.testing_workgroups;\n  }\n`;\n\n/** Functions that help add stress to the test. */\nconst testShaderFunctions = `\n  //Force the invocations in the workgroup to wait for each other, but without the general memory ordering\n  // effects of a control barrier. The barrier spins until either all invocations have incremented the atomic\n  // variable or 1024 loops have occurred. 1024 was chosen because it gives more time for invocations to enter\n  // the barrier but does not overly reduce testing throughput.\n  fn spin(limit: u32) {\n    var i : u32 = 0u;\n    var bar_val : u32 = atomicAdd(&barrier.value[0], 1u);\n    loop {\n      if (i == 1024u || bar_val >= limit) {\n        break;\n      }\n      bar_val = atomicAdd(&barrier.value[0], 0u);\n      i = i + 1u;\n    }\n  }\n\n  // Perform iterations of stress, depending on the specified pattern. Pattern 0 is store-store, pattern 1 is store-load,\n  // pattern 2 is load-store, and pattern 3 is load-load. The extra if condition (if tmpX > 100000u), is used to avoid\n  // the compiler optimizing out unused loads, where 100,000 is larger than the maximum number of stress iterations used\n  // in any test.\n  fn do_stress(iterations: u32, pattern: u32, workgroup_id: u32) {\n    let addr = scratch_locations.value[workgroup_id];\n    switch(pattern) {\n      case 0u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          scratchpad.value[addr] = i;\n          scratchpad.value[addr] = i + 1u;\n        }\n      }\n      case 1u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          scratchpad.value[addr] = i;\n          let tmp1: u32 = scratchpad.value[addr];\n          if (tmp1 > 100000u) {\n            scratchpad.value[addr] = i;\n            break;\n          }\n        }\n      }\n      case 2u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          let tmp1: u32 = scratchpad.value[addr];\n          if (tmp1 > 100000u) {\n            scratchpad.value[addr] = i;\n            break;\n          }\n          scratchpad.value[addr] = i;\n        }\n      }\n      case 3u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          let tmp1: u32 = scratchpad.value[addr];\n          if (tmp1 > 100000u) {\n            scratchpad.value[addr] = i;\n            break;\n          }\n          let tmp2: u32 = scratchpad.value[addr];\n          if (tmp2 > 100000u) {\n            scratchpad.value[addr] = i;\n            break;\n          }\n        }\n      }\n      default: {\n      }\n    }\n  }\n`;\n\n/**\n * Entry point to both test and result shaders. One-dimensional workgroup size is hardcoded to 256, until\n * pipeline overridable constants are supported.\n */\nconst shaderEntryPoint = `\n  // Change to pipeline overridable constant when possible.\n  let workgroupXSize = 256u;\n  @stage(compute) @workgroup_size(workgroupXSize) fn main(\n    @builtin(local_invocation_id) local_invocation_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>) {\n`;\n\n/** All test shaders first calculate the shuffled workgroup. */\nconst testShaderCommonHeader = `\n    let shuffled_workgroup = shuffled_workgroups.value[workgroup_id[0]];\n    if (shuffled_workgroup < stress_params.testing_workgroups) {\n`;\n\n/**\n * All test shaders must calculate addresses for memory locations used in the test. Not all these addresses are\n * used in every test, but no test uses more than these addresses.\n */\nconst testShaderCommonCalculations = `\n  let x_0 = id_0 * stress_params.mem_stride * 2u;\n  let y_0 = permute_id(id_0, stress_params.permute_second, total_ids) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  let x_1 = id_1 * stress_params.mem_stride * 2u;\n  let y_1 = permute_id(id_1, stress_params.permute_second, total_ids) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  if (stress_params.pre_stress == 1u) {\n    do_stress(stress_params.pre_stress_iterations, stress_params.pre_stress_pattern, shuffled_workgroup);\n  }\n`;\n\n/**\n * An inter-workgroup test calculates two sets of memory locations that are guaranteed to be in separate workgroups.\n * If the bounded spin-loop barrier is called, it attempts to wait for all invocations in all workgroups.\n */\nconst interWorkgroupTestShaderCode = [\n  `\n  let total_ids = workgroupXSize * stress_params.testing_workgroups;\n  let id_0 = shuffled_workgroup * workgroupXSize + local_invocation_id[0];\n  let new_workgroup = stripe_workgroup(shuffled_workgroup, local_invocation_id[0]);\n  let id_1 = new_workgroup * workgroupXSize + permute_id(local_invocation_id[0], stress_params.permute_first, workgroupXSize);\n`,\n  testShaderCommonCalculations,\n  `\n  if (stress_params.do_barrier == 1u) {\n    spin(workgroupXSize * stress_params.testing_workgroups);\n  }\n`,\n].join('\\n');\n\n/**\n * An intra-workgroup test calculates two set of memory locations that are guaranteed to be in the same workgroup.\n * If the bounded spin-loop barrier is called, it attempts to wait for all invocations in the same workgroup.\n */\nconst intraWorkgroupTestShaderCode = [\n  `\n  let total_ids = workgroupXSize;\n  let id_0 = local_invocation_id[0];\n  let id_1 = permute_id(local_invocation_id[0], stress_params.permute_first, workgroupXSize);\n`,\n  testShaderCommonCalculations,\n  `\n  if (stress_params.do_barrier == 1u) {\n    spin(workgroupXSize);\n  }\n`,\n].join('\\n');\n\n/** All test shaders may perform stress with non-testing threads. */\nconst testShaderCommonFooter = `\n    } else if (stress_params.mem_stress == 1u) {\n      do_stress(stress_params.mem_stress_iterations, stress_params.mem_stress_pattern, shuffled_workgroup);\n    }\n  }\n`;\n\n/**\n * All result shaders must calculate memory locations used in the test. Not all these locations are\n * used in every result shader, but no result shader uses more than these locations.\n */\nconst resultShaderCommonCalculations = `\n  let id_0 = workgroup_id[0] * workgroupXSize + local_invocation_id[0];\n  let x_0 = id_0 * stress_params.mem_stride * 2u;\n  let mem_x_0 = atomicLoad(&test_locations.value[x_0]);\n  let r0 = atomicLoad(&read_results.value[id_0].r0);\n  let r1 = atomicLoad(&read_results.value[id_0].r1);\n`;\n\n/** Common result shader code for an inter-workgroup test. */\nconst interWorkgroupResultShaderCode = [\n  resultShaderCommonCalculations,\n  `\n  let total_ids = workgroupXSize * stress_params.testing_workgroups;\n  let y_0 = permute_id(id_0, stress_params.permute_second, total_ids) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  let mem_y_0 = atomicLoad(&test_locations.value[y_0]);\n`,\n].join('\\n');\n\n/** Common result shader code for an intra-workgroup test. */\nconst intraWorkgroupResultShaderCode = [\n  resultShaderCommonCalculations,\n  `\n  let total_ids = workgroupXSize;\n  let y_0 = (workgroup_id[0] * workgroupXSize + permute_id(local_invocation_id[0], stress_params.permute_second, total_ids)) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  let mem_y_0 = atomicLoad(&test_locations.value[y_0]);\n`,\n].join('\\n');\n\n/** Ending bracket for result shaders. */\nconst resultShaderCommonFooter = `\n}\n`;\n\n/** The common shader code for test shaders that perform atomic storage class memory litmus tests. */\nconst storageMemoryAtomicTestShaderCode = [\n  shaderMemStructures,\n  atomicTestShaderBindings,\n  memoryLocationFunctions,\n  testShaderFunctions,\n  shaderEntryPoint,\n  testShaderCommonHeader,\n].join('\\n');\n\n/** The common shader code for test shaders that perform non-atomic storage class memory litmus tests. */\nconst storageMemoryNonAtomicTestShaderCode = [\n  shaderMemStructures,\n  nonAtomicTestShaderBindings,\n  memoryLocationFunctions,\n  testShaderFunctions,\n  shaderEntryPoint,\n  testShaderCommonHeader,\n].join('\\n');\n\n/** The common shader code for test shaders that perform atomic workgroup class memory litmus tests. */\nconst workgroupMemoryAtomicTestShaderCode = [\n  shaderMemStructures,\n  atomicTestShaderBindings,\n  atomicWorkgroupMemory,\n  memoryLocationFunctions,\n  testShaderFunctions,\n  shaderEntryPoint,\n  testShaderCommonHeader,\n].join('\\n');\n\n/** The common shader code for test shaders that perform non-atomic workgroup class memory litmus tests. */\nconst workgroupMemoryNonAtomicTestShaderCode = [\n  shaderMemStructures,\n  nonAtomicTestShaderBindings,\n  nonAtomicWorkgroupMemory,\n  memoryLocationFunctions,\n  testShaderFunctions,\n  shaderEntryPoint,\n  testShaderCommonHeader,\n].join('\\n');\n\n/** The common shader code for all result shaders. */\nconst resultShaderCommonCode = [\n  shaderMemStructures,\n  resultShaderBindings,\n  memoryLocationFunctions,\n  shaderEntryPoint,\n].join('\\n');\n\n/**\n * Defines the types of possible memory a test is operating on. Used as part of the process of building shader code from\n * its composite parts.\n */\nexport enum MemoryType {\n  /** Atomic memory in the storage address space. */\n  AtomicStorageClass = 'atomic_storage',\n  /** Non-atomic memory in the storage address space. */\n  NonAtomicStorageClass = 'non_atomic_storage',\n  /** Atomic memory in the workgroup address space. */\n  AtomicWorkgroupClass = 'atomic_workgroup',\n  /** Non-atomic memory in the workgroup address space. */\n  NonAtomicWorkgroupClass = 'non_atomic_workgroup',\n}\n\n/**\n * Defines the relative positions of two invocations coordinating on a test. Used as part of the process of building shader\n * code from its composite parts.\n */\nexport enum TestType {\n  /** A test consists of two invocations in different workgroups. */\n  InterWorkgroup = 'inter_workgroup',\n  /** A test consists of two invocations in the same workgroup. */\n  IntraWorkgroup = 'intra_workgroup',\n}\n\n/** Defines the number of behaviors a test may have. */\nexport enum ResultType {\n  TwoBehavior,\n  FourBehavior,\n}\n\n/**\n * Given test code that performs the actual sequence of loads and stores, as well as a memory type and test type, returns\n * a complete test shader.\n */\nexport function buildTestShader(\n  testCode: string,\n  memoryType: MemoryType,\n  testType: TestType\n): string {\n  let memoryTypeCode;\n  switch (memoryType) {\n    case MemoryType.AtomicStorageClass:\n      memoryTypeCode = storageMemoryAtomicTestShaderCode;\n      break;\n    case MemoryType.NonAtomicStorageClass:\n      memoryTypeCode = storageMemoryNonAtomicTestShaderCode;\n      break;\n    case MemoryType.AtomicWorkgroupClass:\n      memoryTypeCode = workgroupMemoryAtomicTestShaderCode;\n      break;\n    case MemoryType.NonAtomicWorkgroupClass:\n      memoryTypeCode = workgroupMemoryNonAtomicTestShaderCode;\n  }\n  let testTypeCode;\n  switch (testType) {\n    case TestType.InterWorkgroup:\n      testTypeCode = interWorkgroupTestShaderCode;\n      break;\n    case TestType.IntraWorkgroup:\n      testTypeCode = intraWorkgroupTestShaderCode;\n  }\n  return [memoryTypeCode, testTypeCode, testCode, testShaderCommonFooter].join('\\n');\n}\n\n/**\n * Given result code that aggregates the possible behaviors of a test across all instances, as well as a test type and\n * number of behaviors, returns a complete result shader.\n */\nexport function buildResultShader(\n  resultCode: string,\n  testType: TestType,\n  resultType: ResultType\n): string {\n  let resultStructure;\n  switch (resultType) {\n    case ResultType.TwoBehavior:\n      resultStructure = twoBehaviorTestResultStructure;\n      break;\n    case ResultType.FourBehavior:\n      resultStructure = fourBehaviorTestResultStructure;\n  }\n  let testTypeCode;\n  switch (testType) {\n    case TestType.InterWorkgroup:\n      testTypeCode = interWorkgroupResultShaderCode;\n      break;\n    case TestType.IntraWorkgroup:\n      testTypeCode = intraWorkgroupResultShaderCode;\n  }\n  return [\n    resultStructure,\n    resultShaderCommonCode,\n    testTypeCode,\n    resultCode,\n    resultShaderCommonFooter,\n  ].join('\\n');\n}\n"],"file":"memory_model_setup.js"}