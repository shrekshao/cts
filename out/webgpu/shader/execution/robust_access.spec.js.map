{"version":3,"sources":["../../../../src/webgpu/shader/execution/robust_access.spec.ts"],"names":["description","makeTestGroup","assert","GPUTest","align","kScalarTypeInfo","kVectorContainerTypes","kVectorContainerTypeInfo","kMatrixContainerTypes","kMatrixContainerTypeInfo","kScalarTypes","g","kMaxU32","kMaxI32","kMinI32","runShaderTest","t","stage","testSource","testBindings","GPUShaderStage","COMPUTE","constantsBuffer","device","createBuffer","size","usage","GPUBufferUsage","UNIFORM","resultBuffer","COPY_SRC","STORAGE","source","debug","module","createShaderModule","code","pipeline","createComputePipeline","compute","entryPoint","group","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","buffer","testGroup","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatch","endPass","queue","submit","finish","expectGPUBufferValuesEqual","Uint32Array","testFillArrayBuffer","array","type","zeroByteStart","zeroByteCount","constructor","u32","i32","Int32Array","f32","Float32Array","BYTES_PER_ELEMENT","fill","kArrayLength","generateIndexableTypes","storageClass","baseType","atomic","scalarInfo","supportsAtomics","scalarType","vectorType","_typeInfo","elementBaseType","matrixType","matrixInfo","innerLength","arrayTypeInfo","arrayLength","alignment","arrayStride","undefined","elementLayout","supportedScalarTypes","p","info","isHostShared","storageMode","test","desc","params","u","combineWithParams","access","expand","beginSubcases","expandWithParams","fn","usesCanary","globalSource","testFunctionSource","testBufferSize","bufferBindingOffset","bufferBindingSize","structDecl","qualifiers","nextErrorReturnValue","errorReturnValue","toString","indexSigned","indicesToTest","indexTypeLiteral","indexTypeCast","exprIndexAddon","indexToTest","exprIndex","exprZeroElement","exprElement","exprLoadElement","condition","expectedData","ArrayBuffer","bufferBindingEnd","testBuffer","makeBufferWithContents","Uint8Array","COPY_DST","offset","expectedBytes","subarray","destroy"],"mappings":"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","sourcesContent":["export const description = `\nTests to check datatype clamping in shaders is correctly implemented for all indexable types\n(vectors, matrices, sized/unsized arrays) visible to shaders in various ways.\n\nTODO: add tests to check that textureLoad operations stay in-bounds.\n`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { assert } from '../../../common/util/util.js';\nimport { GPUTest } from '../../gpu_test.js';\nimport { align } from '../../util/math.js';\nimport {\n  ScalarType,\n  kScalarTypeInfo,\n  kVectorContainerTypes,\n  kVectorContainerTypeInfo,\n  kMatrixContainerTypes,\n  kMatrixContainerTypeInfo,\n  kScalarTypes,\n} from '../types.js';\n\nexport const g = makeTestGroup(GPUTest);\n\nconst kMaxU32 = 0xffff_ffff;\nconst kMaxI32 = 0x7fff_ffff;\nconst kMinI32 = -0x8000_0000;\n\n/**\n * Wraps the provided source into a harness that checks calling `runTest()` returns 0.\n *\n * Non-test bindings are in bind group 1, including:\n * - `constants.zero`: a dynamically-uniform `0u` value.\n */\nfunction runShaderTest(\n  t: GPUTest,\n  stage: GPUShaderStageFlags,\n  testSource: string,\n  testBindings: GPUBindGroupEntry[]\n): void {\n  assert(stage === GPUShaderStage.COMPUTE, 'Only know how to deal with compute for now');\n\n  // Contains just zero (for now).\n  const constantsBuffer = t.device.createBuffer({ size: 4, usage: GPUBufferUsage.UNIFORM });\n\n  const resultBuffer = t.device.createBuffer({\n    size: 4,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n  });\n\n  const source = `\n    [[block]] struct Constants {\n      zero: u32;\n    };\n    [[group(1), binding(0)]] var<uniform> constants: Constants;\n\n    [[block]] struct Result {\n      value: u32;\n    };\n    [[group(1), binding(1)]] var<storage, write> result: Result;\n\n    ${testSource}\n\n    [[stage(compute), workgroup_size(1)]]\n    fn main() {\n      ignore(constants.zero); // Ensure constants buffer is statically-accessed\n      result.value = runTest();\n    }`;\n\n  t.debug(source);\n  const module = t.device.createShaderModule({ code: source });\n  const pipeline = t.device.createComputePipeline({\n    compute: { module, entryPoint: 'main' },\n  });\n\n  const group = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(1),\n    entries: [\n      { binding: 0, resource: { buffer: constantsBuffer } },\n      { binding: 1, resource: { buffer: resultBuffer } },\n    ],\n  });\n\n  const testGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: testBindings,\n  });\n\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, testGroup);\n  pass.setBindGroup(1, group);\n  pass.dispatch(1);\n  pass.endPass();\n\n  t.queue.submit([encoder.finish()]);\n\n  t.expectGPUBufferValuesEqual(resultBuffer, new Uint32Array([0]));\n}\n\n/** Fill an ArrayBuffer with sentinel values, except clear a region to zero. */\nfunction testFillArrayBuffer(\n  array: ArrayBuffer,\n  type: 'u32' | 'i32' | 'f32',\n  { zeroByteStart, zeroByteCount }: { zeroByteStart: number; zeroByteCount: number }\n) {\n  const constructor = { u32: Uint32Array, i32: Int32Array, f32: Float32Array }[type];\n  assert(zeroByteCount % constructor.BYTES_PER_ELEMENT === 0);\n  new constructor(array).fill(42);\n  new constructor(array, zeroByteStart, zeroByteCount / constructor.BYTES_PER_ELEMENT).fill(0);\n}\n\nconst kArrayLength = 3;\n\n/**\n * Generate a bunch of indexable types (vec, mat, sized/unsized array) for testing.\n */\nfunction* generateIndexableTypes({\n  storageClass,\n  baseType,\n  atomic = false,\n}: {\n  /** Unsized array will only be generated for storageClass \"storage\". */\n  storageClass: string;\n  /** Base scalar type (i32/u32/f32/bool). */\n  baseType: ScalarType;\n  /** Whether to wrap the baseType in `atomic<>`. */\n  atomic?: boolean;\n}) {\n  const scalarInfo = kScalarTypeInfo[baseType];\n  if (atomic) assert(scalarInfo.supportsAtomics, 'type does not support atomics');\n  const scalarType = atomic ? `atomic<${baseType}>` : baseType;\n\n  // Don't generate vec2<atomic<i32>> etc.\n  if (!atomic) {\n    // Vector types\n    for (const vectorType of kVectorContainerTypes) {\n      yield {\n        type: `${vectorType}<${scalarType}>`,\n        _typeInfo: { elementBaseType: baseType, ...kVectorContainerTypeInfo[vectorType] },\n      };\n    }\n\n    // Matrices can only be f32.\n    if (baseType === 'f32') {\n      for (const matrixType of kMatrixContainerTypes) {\n        const matrixInfo = kMatrixContainerTypeInfo[matrixType];\n        yield {\n          type: `${matrixType}<${scalarType}>`,\n          _typeInfo: {\n            elementBaseType: `vec${matrixInfo.innerLength}<${scalarType}>`,\n            ...matrixInfo,\n          },\n        };\n      }\n    }\n  }\n\n  const arrayTypeInfo = {\n    elementBaseType: baseType,\n    arrayLength: kArrayLength,\n    layout: scalarInfo.layout\n      ? {\n          alignment: scalarInfo.layout.alignment,\n          size: kArrayLength * arrayStride(scalarInfo.layout),\n        }\n      : undefined,\n  };\n  // Sized array\n  yield { type: `array<${scalarType},${kArrayLength}>`, _typeInfo: arrayTypeInfo };\n  // Unsized array\n  if (storageClass === 'storage') {\n    yield { type: `array<${scalarType}>`, _typeInfo: arrayTypeInfo };\n  }\n}\n\nfunction arrayStride(elementLayout: { size: number; alignment: number }) {\n  return align(elementLayout.size, elementLayout.alignment);\n}\n\n/** Generates scalarTypes (i32/u32/f32/bool) that support the specified usage. */\nfunction* supportedScalarTypes(p: { atomic: boolean; storageClass: string }) {\n  for (const scalarType of kScalarTypes) {\n    const info = kScalarTypeInfo[scalarType];\n\n    // Test atomics only on supported scalar types.\n    if (p.atomic && !info.supportsAtomics) continue;\n\n    // Storage and uniform require host-sharable types.\n    const isHostShared = p.storageClass === 'storage' || p.storageClass === 'uniform';\n    if (isHostShared && info.layout === undefined) continue;\n\n    yield scalarType;\n  }\n}\n\n/** Atomic access requires atomic type and storage/workgroup memory. */\nfunction supportsAtomics(p: { storageClass: string; storageMode: string | undefined }) {\n  return (\n    (p.storageClass === 'storage' && p.storageMode === 'read_write') ||\n    p.storageClass === 'workgroup'\n  );\n}\n\ng.test('linear_memory')\n  .desc(\n    `For each indexable data type (vec, mat, sized/unsized array, of various scalar types), attempts\n    to access (read, write, atomic load/store) a region of memory (buffer or internal) at various\n    (signed/unsigned) indices. Checks that the accesses conform to robust access (OOB reads only\n    return bound memory, OOB writes don't write OOB).\n\n    TODO: Test in/out storage classes.\n    TODO: Test vertex and fragment stages.\n    TODO: Test using a dynamic offset instead of a static offset into uniform/storage bindings.\n    TODO: Test types like vec2<atomic<i32>>, if that's allowed.\n    TODO: Test exprIndexAddon as constexpr.\n    TODO: Test exprIndexAddon as pipeline-overridable constant expression.\n  `\n  )\n  .params(u =>\n    u\n      .combineWithParams([\n        { storageClass: 'storage', storageMode: 'read', access: 'read' },\n        { storageClass: 'storage', storageMode: 'write', access: 'write' },\n        { storageClass: 'storage', storageMode: 'read_write', access: 'read' },\n        { storageClass: 'storage', storageMode: 'read_write', access: 'write' },\n        { storageClass: 'uniform', access: 'read' },\n        { storageClass: 'private', access: 'read' },\n        { storageClass: 'private', access: 'write' },\n        { storageClass: 'function', access: 'read' },\n        { storageClass: 'function', access: 'write' },\n        { storageClass: 'workgroup', access: 'read' },\n        { storageClass: 'workgroup', access: 'write' },\n      ] as const)\n      .expand('atomic', p => (supportsAtomics(p) ? [false, true] : [false]))\n      .expand('baseType', supportedScalarTypes)\n      .beginSubcases()\n      .expandWithParams(generateIndexableTypes)\n  )\n  .fn(async t => {\n    const { storageClass, storageMode, access, atomic, baseType, type, _typeInfo } = t.params;\n\n    let usesCanary = false;\n    let globalSource = '';\n    let testFunctionSource = '';\n    const testBufferSize = 512;\n    const bufferBindingOffset = 256;\n    /** Undefined if no buffer binding is needed */\n    let bufferBindingSize: number | undefined = undefined;\n\n    // Declare the data that will be accessed to check robust access, as a buffer or a struct\n    // in the global scope or inside the test function itself.\n    const structDecl = `\n      struct S {\n        startCanary: array<u32, 10>;\n        data: ${type};\n        endCanary: array<u32, 10>;\n      };`;\n\n    switch (storageClass) {\n      case 'uniform':\n      case 'storage':\n        {\n          assert(_typeInfo.layout !== undefined);\n          const layout = _typeInfo.layout;\n          bufferBindingSize = layout.size;\n          const qualifiers = storageClass === 'storage' ? `storage, ${storageMode}` : storageClass;\n          globalSource += `\n          [[block]] struct TestData {\n            data: ${type};\n          };\n          [[group(0), binding(0)]] var<${qualifiers}> s: TestData;`;\n        }\n        break;\n\n      case 'private':\n      case 'workgroup':\n        usesCanary = true;\n        globalSource += structDecl;\n        globalSource += `var<${storageClass}> s: S;`;\n        break;\n\n      case 'function':\n        usesCanary = true;\n        globalSource += structDecl;\n        testFunctionSource += 'var s: S;';\n        break;\n    }\n\n    // Build the test function that will do the tests.\n\n    // If we use a local canary declared in the shader, initialize it.\n    if (usesCanary) {\n      testFunctionSource += `\n        for (var i = 0u; i < 10u; i = i + 1u) {\n          s.startCanary[i] = 0xFFFFFFFFu;\n          s.endCanary[i] = 0xFFFFFFFFu;\n        }`;\n    }\n\n    /** Returns a different number each time, kind of like a `__LINE__` to ID the failing check. */\n    const nextErrorReturnValue = (() => {\n      let errorReturnValue = 0x1000;\n      return () => {\n        ++errorReturnValue;\n        return `0x${errorReturnValue.toString(16)}u`;\n      };\n    })();\n\n    // This is here, instead of in subcases, so only a single shader is needed to test many modes.\n    for (const indexSigned of [false, true]) {\n      const indicesToTest = indexSigned\n        ? [\n            // Exactly in bounds (should be OK)\n            '0',\n            `${_typeInfo.arrayLength} - 1`,\n            // Exactly out of bounds\n            '-1',\n            `${_typeInfo.arrayLength}`,\n            // Far out of bounds\n            '-1000000',\n            '1000000',\n            `${kMinI32}`,\n            `${kMaxI32}`,\n          ]\n        : [\n            // Exactly in bounds (should be OK)\n            '0u',\n            `${_typeInfo.arrayLength}u - 1u`,\n            // Exactly out of bounds\n            `${_typeInfo.arrayLength}u`,\n            // Far out of bounds\n            '1000000u',\n            `${kMaxU32}u`,\n            `${kMaxI32}u`,\n          ];\n\n      const indexTypeLiteral = indexSigned ? '0' : '0u';\n      const indexTypeCast = indexSigned ? 'i32' : 'u32';\n      for (const exprIndexAddon of [\n        '', // No addon\n        ` + ${indexTypeLiteral}`, // Add a literal 0\n        ` + ${indexTypeCast}(constants.zero)`, // Add a uniform 0\n      ]) {\n        // Produce the accesses to the variable.\n        for (const indexToTest of indicesToTest) {\n          const exprIndex = `(${indexToTest})${exprIndexAddon}`;\n          const exprZeroElement = `${_typeInfo.elementBaseType}()`;\n          const exprElement = `s.data[${exprIndex}]`;\n\n          switch (access) {\n            case 'read':\n              {\n                const exprLoadElement = atomic ? `atomicLoad(&${exprElement})` : exprElement;\n                let condition = `${exprLoadElement} != ${exprZeroElement}`;\n                if ('innerLength' in _typeInfo) condition = `any(${condition})`;\n                testFunctionSource += `\n                  if (${condition}) { return ${nextErrorReturnValue()}; }`;\n              }\n              break;\n\n            case 'write':\n              if (atomic) {\n                testFunctionSource += `\n                  atomicStore(&s.data[${exprIndex}], ${exprZeroElement});`;\n              } else {\n                testFunctionSource += `\n                  s.data[${exprIndex}] = ${exprZeroElement};`;\n              }\n              break;\n          }\n        }\n        testFunctionSource += '\\n';\n      }\n    }\n\n    // Check that the canaries haven't been modified\n    if (usesCanary) {\n      testFunctionSource += `\n        for (var i = 0u; i < 10u; i = i + 1u) {\n          if (s.startCanary[i] != 0xFFFFFFFFu) {\n            return ${nextErrorReturnValue()};\n          }\n          if (s.endCanary[i] != 0xFFFFFFFFu) {\n            return ${nextErrorReturnValue()};\n          }\n        }`;\n    }\n\n    // Run the test\n\n    // First aggregate the test source\n    const testSource = `\n      ${globalSource}\n\n      fn runTest() -> u32 {\n        ${testFunctionSource}\n        return 0u;\n      }`;\n\n    // Run it.\n    if (bufferBindingSize !== undefined) {\n      assert(baseType !== 'bool', 'case should have been filtered out');\n\n      const expectedData = new ArrayBuffer(testBufferSize);\n      const bufferBindingEnd = bufferBindingOffset + bufferBindingSize;\n      testFillArrayBuffer(expectedData, baseType, {\n        zeroByteStart: bufferBindingOffset,\n        zeroByteCount: bufferBindingSize,\n      });\n\n      // Create a buffer that contains zeroes in the allowed access area, and 42s everywhere else.\n      const testBuffer = t.makeBufferWithContents(\n        new Uint8Array(expectedData),\n        GPUBufferUsage.COPY_SRC |\n          GPUBufferUsage.UNIFORM |\n          GPUBufferUsage.STORAGE |\n          GPUBufferUsage.COPY_DST\n      );\n\n      // Run the shader, accessing the buffer.\n      runShaderTest(t, GPUShaderStage.COMPUTE, testSource, [\n        {\n          binding: 0,\n          resource: { buffer: testBuffer, offset: bufferBindingOffset, size: bufferBindingSize },\n        },\n      ]);\n\n      // Check that content of the buffer outside of the allowed area didn't change.\n      const expectedBytes = new Uint8Array(expectedData);\n      t.expectGPUBufferValuesEqual(testBuffer, expectedBytes.subarray(0, bufferBindingOffset), 0);\n      t.expectGPUBufferValuesEqual(\n        testBuffer,\n        expectedBytes.subarray(bufferBindingEnd, testBufferSize),\n        bufferBindingEnd\n      );\n\n      testBuffer.destroy();\n    } else {\n      runShaderTest(t, GPUShaderStage.COMPUTE, testSource, []);\n    }\n  });\n"],"file":"robust_access.spec.js"}