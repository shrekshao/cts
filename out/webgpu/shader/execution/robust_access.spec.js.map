{"version":3,"sources":["../../../../src/webgpu/shader/execution/robust_access.spec.ts"],"names":["description","makeTestGroup","assert","GPUTest","generateTypes","supportedScalarTypes","supportsAtomics","g","kMaxU32","kMaxI32","kMinI32","runShaderTest","t","stage","testSource","testBindings","GPUShaderStage","COMPUTE","constantsBuffer","device","createBuffer","size","usage","GPUBufferUsage","UNIFORM","resultBuffer","COPY_SRC","STORAGE","source","debug","module","createShaderModule","code","pipeline","createComputePipeline","compute","entryPoint","group","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","buffer","testGroup","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatch","endPass","queue","submit","finish","expectGPUBufferValuesEqual","Uint32Array","testFillArrayBuffer","array","type","zeroByteStart","zeroByteCount","constructor","u32","i32","Int32Array","f32","Float32Array","BYTES_PER_ELEMENT","fill","test","desc","params","u","combineWithParams","storageClass","storageMode","access","containerType","expand","p","beginSubcases","expandWithParams","fn","isAtomic","baseType","_kTypeInfo","undefined","usesCanary","globalSource","testFunctionSource","testBufferSize","bufferBindingOffset","bufferBindingSize","structDecl","qualifiers","nextErrorReturnValue","errorReturnValue","toString","indexSigned","indicesToTest","arrayLength","indexTypeLiteral","indexTypeCast","exprIndexAddon","indexToTest","exprIndex","exprZeroElement","elementBaseType","exprElement","exprLoadElement","condition","expectedData","ArrayBuffer","bufferBindingEnd","testBuffer","makeBufferWithContents","Uint8Array","COPY_DST","offset","expectedBytes","subarray"],"mappings":";AAAA;AACA,GADA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA;AACA;AACA;AACA,CALO,CAOP,SAASC,aAAT,QAA8B,yCAA9B;AACA,SAASC,MAAT,QAAuB,8BAAvB;AACA,SAASC,OAAT,QAAwB,mBAAxB;AACA,SAASC,aAAT,EAAwBC,oBAAxB,EAA8CC,eAA9C,QAAqE,aAArE;;AAEA,OAAO,MAAMC,CAAC,GAAGN,aAAa,CAACE,OAAD,CAAvB;;AAEP,MAAMK,OAAO,GAAG,WAAhB;AACA,MAAMC,OAAO,GAAG,WAAhB;AACA,MAAMC,OAAO,GAAG,CAAC,WAAjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,aAAT;AACEC,CADF;AAEEC,KAFF;AAGEC,UAHF;AAIEC,YAJF;AAKQ;AACNb,EAAAA,MAAM,CAACW,KAAK,KAAKG,cAAc,CAACC,OAA1B,EAAmC,4CAAnC,CAAN;;AAEA;AACA,QAAMC,eAAe,GAAGN,CAAC,CAACO,MAAF,CAASC,YAAT,CAAsB,EAAEC,IAAI,EAAE,CAAR,EAAWC,KAAK,EAAEC,cAAc,CAACC,OAAjC,EAAtB,CAAxB;;AAEA,QAAMC,YAAY,GAAGb,CAAC,CAACO,MAAF,CAASC,YAAT,CAAsB;AACzCC,IAAAA,IAAI,EAAE,CADmC;AAEzCC,IAAAA,KAAK,EAAEC,cAAc,CAACG,QAAf,GAA0BH,cAAc,CAACI,OAFP,EAAtB,CAArB;;;AAKA,QAAMC,MAAM,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMd,UAAW;AACjB;AACA;AACA;AACA;AACA;AACA,MAjBE;;AAmBAF,EAAAA,CAAC,CAACiB,KAAF,CAAQD,MAAR;AACA,QAAME,MAAM,GAAGlB,CAAC,CAACO,MAAF,CAASY,kBAAT,CAA4B,EAAEC,IAAI,EAAEJ,MAAR,EAA5B,CAAf;AACA,QAAMK,QAAQ,GAAGrB,CAAC,CAACO,MAAF,CAASe,qBAAT,CAA+B;AAC9CC,IAAAA,OAAO,EAAE,EAAEL,MAAF,EAAUM,UAAU,EAAE,MAAtB,EADqC,EAA/B,CAAjB;;;AAIA,QAAMC,KAAK,GAAGzB,CAAC,CAACO,MAAF,CAASmB,eAAT,CAAyB;AACrCC,IAAAA,MAAM,EAAEN,QAAQ,CAACO,kBAAT,CAA4B,CAA5B,CAD6B;AAErCC,IAAAA,OAAO,EAAE;AACP,MAAEC,OAAO,EAAE,CAAX,EAAcC,QAAQ,EAAE,EAAEC,MAAM,EAAE1B,eAAV,EAAxB,EADO;AAEP,MAAEwB,OAAO,EAAE,CAAX,EAAcC,QAAQ,EAAE,EAAEC,MAAM,EAAEnB,YAAV,EAAxB,EAFO,CAF4B,EAAzB,CAAd;;;;AAQA,QAAMoB,SAAS,GAAGjC,CAAC,CAACO,MAAF,CAASmB,eAAT,CAAyB;AACzCC,IAAAA,MAAM,EAAEN,QAAQ,CAACO,kBAAT,CAA4B,CAA5B,CADiC;AAEzCC,IAAAA,OAAO,EAAE1B,YAFgC,EAAzB,CAAlB;;;AAKA,QAAM+B,OAAO,GAAGlC,CAAC,CAACO,MAAF,CAAS4B,oBAAT,EAAhB;AACA,QAAMC,IAAI,GAAGF,OAAO,CAACG,gBAAR,EAAb;AACAD,EAAAA,IAAI,CAACE,WAAL,CAAiBjB,QAAjB;AACAe,EAAAA,IAAI,CAACG,YAAL,CAAkB,CAAlB,EAAqBN,SAArB;AACAG,EAAAA,IAAI,CAACG,YAAL,CAAkB,CAAlB,EAAqBd,KAArB;AACAW,EAAAA,IAAI,CAACI,QAAL,CAAc,CAAd;AACAJ,EAAAA,IAAI,CAACK,OAAL;;AAEAzC,EAAAA,CAAC,CAAC0C,KAAF,CAAQC,MAAR,CAAe,CAACT,OAAO,CAACU,MAAR,EAAD,CAAf;;AAEA5C,EAAAA,CAAC,CAAC6C,0BAAF,CAA6BhC,YAA7B,EAA2C,IAAIiC,WAAJ,CAAgB,CAAC,CAAD,CAAhB,CAA3C;AACD;;AAED;AACA,SAASC,mBAAT;AACEC,KADF;AAEEC,IAFF;AAGE,EAAEC,aAAF,EAAiBC,aAAjB,EAHF;AAIE;AACA,QAAMC,WAAW,GAAG,EAAEC,GAAG,EAAEP,WAAP,EAAoBQ,GAAG,EAAEC,UAAzB,EAAqCC,GAAG,EAAEC,YAA1C,GAAyDR,IAAzD,CAApB;AACA3D,EAAAA,MAAM,CAAC6D,aAAa,GAAGC,WAAW,CAACM,iBAA5B,KAAkD,CAAnD,CAAN;AACA,MAAIN,WAAJ,CAAgBJ,KAAhB,EAAuBW,IAAvB,CAA4B,EAA5B;AACA,MAAIP,WAAJ,CAAgBJ,KAAhB,EAAuBE,aAAvB,EAAsCC,aAAa,GAAGC,WAAW,CAACM,iBAAlE,EAAqFC,IAArF,CAA0F,CAA1F;AACD;;AAED;AACA;AACA;;AAEAhE,CAAC,CAACiE,IAAF,CAAO,eAAP;AACGC,IADH;AAEK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAbA;;AAeGC,MAfH,CAeU,CAAAC,CAAC;AACPA,CAAC;AACEC,iBADH,CACqB;AACjB,EAAEC,YAAY,EAAE,SAAhB,EAA2BC,WAAW,EAAE,MAAxC,EAAgDC,MAAM,EAAE,MAAxD,EADiB;AAEjB,EAAEF,YAAY,EAAE,SAAhB,EAA2BC,WAAW,EAAE,OAAxC,EAAiDC,MAAM,EAAE,OAAzD,EAFiB;AAGjB,EAAEF,YAAY,EAAE,SAAhB,EAA2BC,WAAW,EAAE,YAAxC,EAAsDC,MAAM,EAAE,MAA9D,EAHiB;AAIjB,EAAEF,YAAY,EAAE,SAAhB,EAA2BC,WAAW,EAAE,YAAxC,EAAsDC,MAAM,EAAE,OAA9D,EAJiB;AAKjB,EAAEF,YAAY,EAAE,SAAhB,EAA2BE,MAAM,EAAE,MAAnC,EALiB;AAMjB,EAAEF,YAAY,EAAE,SAAhB,EAA2BE,MAAM,EAAE,MAAnC,EANiB;AAOjB,EAAEF,YAAY,EAAE,SAAhB,EAA2BE,MAAM,EAAE,OAAnC,EAPiB;AAQjB,EAAEF,YAAY,EAAE,UAAhB,EAA4BE,MAAM,EAAE,MAApC,EARiB;AASjB,EAAEF,YAAY,EAAE,UAAhB,EAA4BE,MAAM,EAAE,OAApC,EATiB;AAUjB,EAAEF,YAAY,EAAE,WAAhB,EAA6BE,MAAM,EAAE,MAArC,EAViB;AAWjB,EAAEF,YAAY,EAAE,WAAhB,EAA6BE,MAAM,EAAE,OAArC,EAXiB,CADrB;;AAcGH,iBAdH,CAcqB;AACjB,EAAEI,aAAa,EAAE,OAAjB,EADiB;AAEjB,EAAEA,aAAa,EAAE,QAAjB,EAFiB;AAGjB,EAAEA,aAAa,EAAE,QAAjB,EAHiB,CAdrB;;AAmBGC,MAnBH,CAmBU,UAnBV,EAmBsBC,CAAC,IAAK5E,eAAe,CAAC4E,CAAD,CAAf,GAAqB,CAAC,KAAD,EAAQ,IAAR,CAArB,GAAqC,CAAC,KAAD,CAnBjE;AAoBGC,aApBH;AAqBGF,MArBH,CAqBU,UArBV,EAqBsB5E,oBArBtB;AAsBG+E,gBAtBH,CAsBoBhF,aAtBpB,CAhBJ;;AAwCGiF,EAxCH,CAwCM,MAAMzE,CAAN,IAAW;AACb,QAAM;AACJiE,IAAAA,YADI;AAEJC,IAAAA,WAFI;AAGJC,IAAAA,MAHI;AAIJO,IAAAA,QAJI;AAKJN,IAAAA,aALI;AAMJO,IAAAA,QANI;AAOJ1B,IAAAA,IAPI;AAQJ2B,IAAAA,UARI;AASF5E,EAAAA,CAAC,CAAC8D,MATN;;AAWAxE,EAAAA,MAAM,CAACsF,UAAU,KAAKC,SAAhB,EAA2B,uBAA3B,CAAN;AACAvF,EAAAA,MAAM,CAAC,iBAAiBsF,UAAlB,CAAN;;AAEA,MAAIE,UAAU,GAAG,KAAjB;AACA,MAAIC,YAAY,GAAG,EAAnB;AACA,MAAIC,kBAAkB,GAAG,EAAzB;AACA,QAAMC,cAAc,GAAG,GAAvB;AACA,QAAMC,mBAAmB,GAAG,GAA5B;AACA;AACA,MAAIC,iBAAqC,GAAGN,SAA5C;;AAEA;AACA;AACA,QAAMO,UAAU,GAAI;AACxB;AACA;AACA,gBAAgBnC,IAAK;AACrB;AACA,SALI;;AAOA,UAAQgB,YAAR;AACE,SAAK,SAAL;AACA,SAAK,SAAL;AACE;AACE3E,QAAAA,MAAM,CAACsF,UAAU,CAACjD,MAAX,KAAsBkD,SAAvB,CAAN;AACA,cAAMlD,MAAM,GAAGiD,UAAU,CAACjD,MAA1B;AACAwD,QAAAA,iBAAiB,GAAGxD,MAAM,CAAClB,IAA3B;AACA,cAAM4E,UAAU,GAAGpB,YAAY,KAAK,SAAjB,GAA8B,YAAWC,WAAY,EAArD,GAAyDD,YAA5E;AACAc,QAAAA,YAAY,IAAK;AAC3B;AACA,oBAAoB9B,IAAK;AACzB;AACA,yCAAyCoC,UAAW,gBAJ1C;AAKD;AACD;;AAEF,SAAK,SAAL;AACA,SAAK,WAAL;AACEP,MAAAA,UAAU,GAAG,IAAb;AACAC,MAAAA,YAAY,IAAIK,UAAhB;AACAL,MAAAA,YAAY,IAAK,OAAMd,YAAa,SAApC;AACA;;AAEF,SAAK,UAAL;AACEa,MAAAA,UAAU,GAAG,IAAb;AACAC,MAAAA,YAAY,IAAIK,UAAhB;AACAJ,MAAAA,kBAAkB,IAAI,WAAtB;AACA,YA3BJ;;;AA8BA;;AAEA;AACA,MAAIF,UAAJ,EAAgB;AACdE,IAAAA,kBAAkB,IAAK;AAC7B;AACA;AACA;AACA,UAJM;AAKD;;AAED;AACA,QAAMM,oBAAoB,GAAG,CAAC,MAAM;AAClC,QAAIC,gBAAgB,GAAG,MAAvB;AACA,WAAO,MAAM;AACX,QAAEA,gBAAF;AACA,aAAQ,KAAIA,gBAAgB,CAACC,QAAjB,CAA0B,EAA1B,CAA8B,GAA1C;AACD,KAHD;AAID,GAN4B,GAA7B;;AAQA;AACA,OAAK,MAAMC,WAAX,IAA0B,CAAC,KAAD,EAAQ,IAAR,CAA1B,EAAyC;AACvC,UAAMC,aAAa,GAAGD,WAAW;AAC7B;AACE;AACA,OAFF;AAGG,OAAEb,UAAU,CAACe,WAAY,MAH5B;AAIE;AACA,QALF;AAMG,OAAEf,UAAU,CAACe,WAAY,EAN5B;AAOE;AACA,cARF;AASE,aATF;AAUG,OAAE7F,OAAQ,EAVb;AAWG,OAAED,OAAQ,EAXb,CAD6B;;AAc7B;AACE;AACA,QAFF;AAGG,OAAE+E,UAAU,CAACe,WAAY,QAH5B;AAIE;AACC,OAAEf,UAAU,CAACe,WAAY,GAL5B;AAME;AACA,cAPF;AAQG,OAAE/F,OAAQ,GARb;AASG,OAAEC,OAAQ,GATb,CAdJ;;;AA0BA,UAAM+F,gBAAgB,GAAGH,WAAW,GAAG,GAAH,GAAS,IAA7C;AACA,UAAMI,aAAa,GAAGJ,WAAW,GAAG,KAAH,GAAW,KAA5C;AACA,SAAK,MAAMK,cAAX,IAA6B;AAC3B,MAD2B,EACvB;AACH,UAAKF,gBAAiB,EAFI,EAED;AACzB,UAAKC,aAAc,kBAHO,CAGY;AAHZ,KAA7B,EAIG;AACD;AACA,WAAK,MAAME,WAAX,IAA0BL,aAA1B,EAAyC;AACvC,cAAMM,SAAS,GAAI,IAAGD,WAAY,IAAGD,cAAe,EAApD;AACA,cAAMG,eAAe,GAAI,GAAErB,UAAU,CAACsB,eAAgB,IAAtD;AACA,cAAMC,WAAW,GAAI,UAASH,SAAU,GAAxC;;AAEA,gBAAQ7B,MAAR;AACE,eAAK,MAAL;AACE;AACE,oBAAMiC,eAAe,GAAG1B,QAAQ,GAAI,eAAcyB,WAAY,GAA9B,GAAmCA,WAAnE;AACA,kBAAIE,SAAS,GAAI,GAAED,eAAgB,OAAMH,eAAgB,EAAzD;AACA,kBAAI7B,aAAa,KAAK,QAAtB,EAAgCiC,SAAS,GAAI,OAAMA,SAAU,GAA7B;AAChCrB,cAAAA,kBAAkB,IAAK;AACvC,wBAAwBqB,SAAU,cAAaf,oBAAoB,EAAG,KADtD;AAED;AACD;;AAEF,eAAK,OAAL;AACE,gBAAIZ,QAAJ,EAAc;AACZM,cAAAA,kBAAkB,IAAK;AACvC,wCAAwCgB,SAAU,MAAKC,eAAgB,IADvD;AAED,aAHD,MAGO;AACLjB,cAAAA,kBAAkB,IAAK;AACvC,2BAA2BgB,SAAU,OAAMC,eAAgB,GAD3C;AAED;AACD,kBAnBJ;;AAqBD;AACDjB,MAAAA,kBAAkB,IAAI,IAAtB;AACD;AACF;;AAED;AACA,MAAIF,UAAJ,EAAgB;AACdE,IAAAA,kBAAkB,IAAK;AAC7B;AACA;AACA,qBAAqBM,oBAAoB,EAAG;AAC5C;AACA;AACA,qBAAqBA,oBAAoB,EAAG;AAC5C;AACA,UARM;AASD;;AAED;;AAEA;AACA,QAAMpF,UAAU,GAAI;AACxB,QAAQ6E,YAAa;AACrB;AACA;AACA,UAAUC,kBAAmB;AAC7B;AACA,QANI;;AAQA;AACA,MAAIG,iBAAiB,KAAKN,SAAtB,IAAmCF,QAAQ,KAAK,MAApD,EAA4D;AAC1D,UAAM2B,YAAY,GAAG,IAAIC,WAAJ,CAAgBtB,cAAhB,CAArB;AACA,UAAMuB,gBAAgB,GAAGtB,mBAAmB,GAAGC,iBAA/C;AACApC,IAAAA,mBAAmB,CAACuD,YAAD,EAAe3B,QAAf,EAAyB;AAC1CzB,MAAAA,aAAa,EAAEgC,mBAD2B;AAE1C/B,MAAAA,aAAa,EAAEgC,iBAF2B,EAAzB,CAAnB;;;AAKA;AACA,UAAMsB,UAAU,GAAGzG,CAAC,CAAC0G,sBAAF;AACjB,QAAIC,UAAJ,CAAeL,YAAf,CADiB;AAEjB3F,IAAAA,cAAc,CAACG,QAAf;AACEH,IAAAA,cAAc,CAACC,OADjB;AAEED,IAAAA,cAAc,CAACI,OAFjB;AAGEJ,IAAAA,cAAc,CAACiG,QALA,CAAnB;;;AAQA;AACA7G,IAAAA,aAAa,CAACC,CAAD,EAAII,cAAc,CAACC,OAAnB,EAA4BH,UAA5B,EAAwC;AACnD;AACE4B,MAAAA,OAAO,EAAE,CADX;AAEEC,MAAAA,QAAQ,EAAE,EAAEC,MAAM,EAAEyE,UAAV,EAAsBI,MAAM,EAAE3B,mBAA9B,EAAmDzE,IAAI,EAAE0E,iBAAzD,EAFZ,EADmD,CAAxC,CAAb;;;;AAOA;AACA,UAAM2B,aAAa,GAAG,IAAIH,UAAJ,CAAeL,YAAf,CAAtB;AACAtG,IAAAA,CAAC,CAAC6C,0BAAF,CAA6B4D,UAA7B,EAAyCK,aAAa,CAACC,QAAd,CAAuB,CAAvB,EAA0B7B,mBAA1B,CAAzC,EAAyF,CAAzF;AACAlF,IAAAA,CAAC,CAAC6C,0BAAF;AACE4D,IAAAA,UADF;AAEEK,IAAAA,aAAa,CAACC,QAAd,CAAuBP,gBAAvB,EAAyCvB,cAAzC,CAFF;AAGEuB,IAAAA,gBAHF;;AAKD,GAjCD,MAiCO;AACLzG,IAAAA,aAAa,CAACC,CAAD,EAAII,cAAc,CAACC,OAAnB,EAA4BH,UAA5B,EAAwC,EAAxC,CAAb;AACD;AACF,CA1PH","sourcesContent":["export const description = `\nTests to check datatype clamping in shaders is correctly implemented for all indexable types\n(vectors, matrices, sized/unsized arrays) visible to shaders in various ways.\n\nTODO: add tests to check that textureLoad operations stay in-bounds.\n`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { assert } from '../../../common/util/util.js';\nimport { GPUTest } from '../../gpu_test.js';\nimport { generateTypes, supportedScalarTypes, supportsAtomics } from '../types.js';\n\nexport const g = makeTestGroup(GPUTest);\n\nconst kMaxU32 = 0xffff_ffff;\nconst kMaxI32 = 0x7fff_ffff;\nconst kMinI32 = -0x8000_0000;\n\n/**\n * Wraps the provided source into a harness that checks calling `runTest()` returns 0.\n *\n * Non-test bindings are in bind group 1, including:\n * - `constants.zero`: a dynamically-uniform `0u` value.\n */\nfunction runShaderTest(\n  t: GPUTest,\n  stage: GPUShaderStageFlags,\n  testSource: string,\n  testBindings: GPUBindGroupEntry[]\n): void {\n  assert(stage === GPUShaderStage.COMPUTE, 'Only know how to deal with compute for now');\n\n  // Contains just zero (for now).\n  const constantsBuffer = t.device.createBuffer({ size: 4, usage: GPUBufferUsage.UNIFORM });\n\n  const resultBuffer = t.device.createBuffer({\n    size: 4,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n  });\n\n  const source = `\n    [[block]] struct Constants {\n      zero: u32;\n    };\n    [[group(1), binding(0)]] var<uniform> constants: Constants;\n\n    [[block]] struct Result {\n      value: u32;\n    };\n    [[group(1), binding(1)]] var<storage, write> result: Result;\n\n    ${testSource}\n\n    [[stage(compute), workgroup_size(1)]]\n    fn main() {\n      ignore(constants.zero); // Ensure constants buffer is statically-accessed\n      result.value = runTest();\n    }`;\n\n  t.debug(source);\n  const module = t.device.createShaderModule({ code: source });\n  const pipeline = t.device.createComputePipeline({\n    compute: { module, entryPoint: 'main' },\n  });\n\n  const group = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(1),\n    entries: [\n      { binding: 0, resource: { buffer: constantsBuffer } },\n      { binding: 1, resource: { buffer: resultBuffer } },\n    ],\n  });\n\n  const testGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: testBindings,\n  });\n\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, testGroup);\n  pass.setBindGroup(1, group);\n  pass.dispatch(1);\n  pass.endPass();\n\n  t.queue.submit([encoder.finish()]);\n\n  t.expectGPUBufferValuesEqual(resultBuffer, new Uint32Array([0]));\n}\n\n/** Fill an ArrayBuffer with sentinel values, except clear a region to zero. */\nfunction testFillArrayBuffer(\n  array: ArrayBuffer,\n  type: 'u32' | 'i32' | 'f32',\n  { zeroByteStart, zeroByteCount }: { zeroByteStart: number; zeroByteCount: number }\n) {\n  const constructor = { u32: Uint32Array, i32: Int32Array, f32: Float32Array }[type];\n  assert(zeroByteCount % constructor.BYTES_PER_ELEMENT === 0);\n  new constructor(array).fill(42);\n  new constructor(array, zeroByteStart, zeroByteCount / constructor.BYTES_PER_ELEMENT).fill(0);\n}\n\n/**\n * Generate a bunch of indexable types (vec, mat, sized/unsized array) for testing.\n */\n\ng.test('linear_memory')\n  .desc(\n    `For each indexable data type (vec, mat, sized/unsized array, of various scalar types), attempts\n    to access (read, write, atomic load/store) a region of memory (buffer or internal) at various\n    (signed/unsigned) indices. Checks that the accesses conform to robust access (OOB reads only\n    return bound memory, OOB writes don't write OOB).\n\n    TODO: Test in/out storage classes.\n    TODO: Test vertex and fragment stages.\n    TODO: Test using a dynamic offset instead of a static offset into uniform/storage bindings.\n    TODO: Test types like vec2<atomic<i32>>, if that's allowed.\n    TODO: Test exprIndexAddon as constexpr.\n    TODO: Test exprIndexAddon as pipeline-overridable constant expression.\n  `\n  )\n  .params(u =>\n    u\n      .combineWithParams([\n        { storageClass: 'storage', storageMode: 'read', access: 'read' },\n        { storageClass: 'storage', storageMode: 'write', access: 'write' },\n        { storageClass: 'storage', storageMode: 'read_write', access: 'read' },\n        { storageClass: 'storage', storageMode: 'read_write', access: 'write' },\n        { storageClass: 'uniform', access: 'read' },\n        { storageClass: 'private', access: 'read' },\n        { storageClass: 'private', access: 'write' },\n        { storageClass: 'function', access: 'read' },\n        { storageClass: 'function', access: 'write' },\n        { storageClass: 'workgroup', access: 'read' },\n        { storageClass: 'workgroup', access: 'write' },\n      ] as const)\n      .combineWithParams([\n        { containerType: 'array' },\n        { containerType: 'matrix' },\n        { containerType: 'vector' },\n      ] as const)\n      .expand('isAtomic', p => (supportsAtomics(p) ? [false, true] : [false]))\n      .beginSubcases()\n      .expand('baseType', supportedScalarTypes)\n      .expandWithParams(generateTypes)\n  )\n  .fn(async t => {\n    const {\n      storageClass,\n      storageMode,\n      access,\n      isAtomic,\n      containerType,\n      baseType,\n      type,\n      _kTypeInfo,\n    } = t.params;\n\n    assert(_kTypeInfo !== undefined, 'not an indexable type');\n    assert('arrayLength' in _kTypeInfo);\n\n    let usesCanary = false;\n    let globalSource = '';\n    let testFunctionSource = '';\n    const testBufferSize = 512;\n    const bufferBindingOffset = 256;\n    /** Undefined if no buffer binding is needed */\n    let bufferBindingSize: number | undefined = undefined;\n\n    // Declare the data that will be accessed to check robust access, as a buffer or a struct\n    // in the global scope or inside the test function itself.\n    const structDecl = `\n      struct S {\n        startCanary: array<u32, 10>;\n        data: ${type};\n        endCanary: array<u32, 10>;\n      };`;\n\n    switch (storageClass) {\n      case 'uniform':\n      case 'storage':\n        {\n          assert(_kTypeInfo.layout !== undefined);\n          const layout = _kTypeInfo.layout;\n          bufferBindingSize = layout.size;\n          const qualifiers = storageClass === 'storage' ? `storage, ${storageMode}` : storageClass;\n          globalSource += `\n          [[block]] struct TestData {\n            data: ${type};\n          };\n          [[group(0), binding(0)]] var<${qualifiers}> s: TestData;`;\n        }\n        break;\n\n      case 'private':\n      case 'workgroup':\n        usesCanary = true;\n        globalSource += structDecl;\n        globalSource += `var<${storageClass}> s: S;`;\n        break;\n\n      case 'function':\n        usesCanary = true;\n        globalSource += structDecl;\n        testFunctionSource += 'var s: S;';\n        break;\n    }\n\n    // Build the test function that will do the tests.\n\n    // If we use a local canary declared in the shader, initialize it.\n    if (usesCanary) {\n      testFunctionSource += `\n        for (var i = 0u; i < 10u; i = i + 1u) {\n          s.startCanary[i] = 0xFFFFFFFFu;\n          s.endCanary[i] = 0xFFFFFFFFu;\n        }`;\n    }\n\n    /** Returns a different number each time, kind of like a `__LINE__` to ID the failing check. */\n    const nextErrorReturnValue = (() => {\n      let errorReturnValue = 0x1000;\n      return () => {\n        ++errorReturnValue;\n        return `0x${errorReturnValue.toString(16)}u`;\n      };\n    })();\n\n    // This is here, instead of in subcases, so only a single shader is needed to test many modes.\n    for (const indexSigned of [false, true]) {\n      const indicesToTest = indexSigned\n        ? [\n            // Exactly in bounds (should be OK)\n            '0',\n            `${_kTypeInfo.arrayLength} - 1`,\n            // Exactly out of bounds\n            '-1',\n            `${_kTypeInfo.arrayLength}`,\n            // Far out of bounds\n            '-1000000',\n            '1000000',\n            `${kMinI32}`,\n            `${kMaxI32}`,\n          ]\n        : [\n            // Exactly in bounds (should be OK)\n            '0u',\n            `${_kTypeInfo.arrayLength}u - 1u`,\n            // Exactly out of bounds\n            `${_kTypeInfo.arrayLength}u`,\n            // Far out of bounds\n            '1000000u',\n            `${kMaxU32}u`,\n            `${kMaxI32}u`,\n          ];\n\n      const indexTypeLiteral = indexSigned ? '0' : '0u';\n      const indexTypeCast = indexSigned ? 'i32' : 'u32';\n      for (const exprIndexAddon of [\n        '', // No addon\n        ` + ${indexTypeLiteral}`, // Add a literal 0\n        ` + ${indexTypeCast}(constants.zero)`, // Add a uniform 0\n      ]) {\n        // Produce the accesses to the variable.\n        for (const indexToTest of indicesToTest) {\n          const exprIndex = `(${indexToTest})${exprIndexAddon}`;\n          const exprZeroElement = `${_kTypeInfo.elementBaseType}()`;\n          const exprElement = `s.data[${exprIndex}]`;\n\n          switch (access) {\n            case 'read':\n              {\n                const exprLoadElement = isAtomic ? `atomicLoad(&${exprElement})` : exprElement;\n                let condition = `${exprLoadElement} != ${exprZeroElement}`;\n                if (containerType === 'matrix') condition = `any(${condition})`;\n                testFunctionSource += `\n                  if (${condition}) { return ${nextErrorReturnValue()}; }`;\n              }\n              break;\n\n            case 'write':\n              if (isAtomic) {\n                testFunctionSource += `\n                  atomicStore(&s.data[${exprIndex}], ${exprZeroElement});`;\n              } else {\n                testFunctionSource += `\n                  s.data[${exprIndex}] = ${exprZeroElement};`;\n              }\n              break;\n          }\n        }\n        testFunctionSource += '\\n';\n      }\n    }\n\n    // Check that the canaries haven't been modified\n    if (usesCanary) {\n      testFunctionSource += `\n        for (var i = 0u; i < 10u; i = i + 1u) {\n          if (s.startCanary[i] != 0xFFFFFFFFu) {\n            return ${nextErrorReturnValue()};\n          }\n          if (s.endCanary[i] != 0xFFFFFFFFu) {\n            return ${nextErrorReturnValue()};\n          }\n        }`;\n    }\n\n    // Run the test\n\n    // First aggregate the test source\n    const testSource = `\n      ${globalSource}\n\n      fn runTest() -> u32 {\n        ${testFunctionSource}\n        return 0u;\n      }`;\n\n    // Run it.\n    if (bufferBindingSize !== undefined && baseType !== 'bool') {\n      const expectedData = new ArrayBuffer(testBufferSize);\n      const bufferBindingEnd = bufferBindingOffset + bufferBindingSize;\n      testFillArrayBuffer(expectedData, baseType, {\n        zeroByteStart: bufferBindingOffset,\n        zeroByteCount: bufferBindingSize,\n      });\n\n      // Create a buffer that contains zeroes in the allowed access area, and 42s everywhere else.\n      const testBuffer = t.makeBufferWithContents(\n        new Uint8Array(expectedData),\n        GPUBufferUsage.COPY_SRC |\n          GPUBufferUsage.UNIFORM |\n          GPUBufferUsage.STORAGE |\n          GPUBufferUsage.COPY_DST\n      );\n\n      // Run the shader, accessing the buffer.\n      runShaderTest(t, GPUShaderStage.COMPUTE, testSource, [\n        {\n          binding: 0,\n          resource: { buffer: testBuffer, offset: bufferBindingOffset, size: bufferBindingSize },\n        },\n      ]);\n\n      // Check that content of the buffer outside of the allowed area didn't change.\n      const expectedBytes = new Uint8Array(expectedData);\n      t.expectGPUBufferValuesEqual(testBuffer, expectedBytes.subarray(0, bufferBindingOffset), 0);\n      t.expectGPUBufferValuesEqual(\n        testBuffer,\n        expectedBytes.subarray(bufferBindingEnd, testBufferSize),\n        bufferBindingEnd\n      );\n    } else {\n      runShaderTest(t, GPUShaderStage.COMPUTE, testSource, []);\n    }\n  });\n"],"file":"robust_access.spec.js"}