{"version":3,"sources":["../../../../src/webgpu/shader/execution/robust_access.spec.ts"],"names":["description","makeTestGroup","assert","GPUTest","generateTypes","supportedScalarTypes","supportsAtomics","g","kMaxU32","kMaxI32","kMinI32","runShaderTest","t","stage","testSource","layout","testBindings","dynamicOffsets","GPUShaderStage","COMPUTE","constantsBuffer","device","createBuffer","size","usage","GPUBufferUsage","UNIFORM","resultBuffer","COPY_SRC","STORAGE","source","debug","module","createShaderModule","code","pipeline","createComputePipeline","compute","entryPoint","group","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","testGroup","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatch","endPass","queue","submit","finish","expectGPUBufferValuesEqual","Uint32Array","testFillArrayBuffer","array","type","zeroByteStart","zeroByteCount","constructor","u32","i32","Int32Array","f32","Float32Array","BYTES_PER_ELEMENT","fill","test","desc","params","u","combineWithParams","storageClass","storageMode","access","dynamicOffset","containerType","expand","p","beginSubcases","expandWithParams","fn","isAtomic","baseType","_kTypeInfo","undefined","usesCanary","globalSource","testFunctionSource","testBufferSize","bufferBindingOffset","bufferBindingSize","structDecl","testGroupBGLEntires","qualifiers","push","visibility","hasDynamicOffset","nextErrorReturnValue","errorReturnValue","toString","indexSigned","indicesToTest","arrayLength","indexTypeLiteral","indexTypeCast","exprIndexAddon","indexToTest","exprIndex","exprZeroElement","elementBaseType","exprElement","exprLoadElement","condition","createPipelineLayout","bindGroupLayouts","createBindGroupLayout","expectedData","ArrayBuffer","bufferBindingEnd","testBuffer","makeBufferWithContents","Uint8Array","COPY_DST","offset","expectedBytes","subarray"],"mappings":"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","sourcesContent":["export const description = `\nTests to check datatype clamping in shaders is correctly implemented for all indexable types\n(vectors, matrices, sized/unsized arrays) visible to shaders in various ways.\n\nTODO: add tests to check that textureLoad operations stay in-bounds.\n`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { assert } from '../../../common/util/util.js';\nimport { GPUTest } from '../../gpu_test.js';\nimport { generateTypes, supportedScalarTypes, supportsAtomics } from '../types.js';\n\nexport const g = makeTestGroup(GPUTest);\n\nconst kMaxU32 = 0xffff_ffff;\nconst kMaxI32 = 0x7fff_ffff;\nconst kMinI32 = -0x8000_0000;\n\n/**\n * Wraps the provided source into a harness that checks calling `runTest()` returns 0.\n *\n * Non-test bindings are in bind group 1, including:\n * - `constants.zero`: a dynamically-uniform `0u` value.\n */\nfunction runShaderTest(\n  t: GPUTest,\n  stage: GPUShaderStageFlags,\n  testSource: string,\n  layout: GPUPipelineLayout,\n  testBindings: GPUBindGroupEntry[],\n  dynamicOffsets?: number[]\n): void {\n  assert(stage === GPUShaderStage.COMPUTE, 'Only know how to deal with compute for now');\n\n  // Contains just zero (for now).\n  const constantsBuffer = t.device.createBuffer({ size: 4, usage: GPUBufferUsage.UNIFORM });\n\n  const resultBuffer = t.device.createBuffer({\n    size: 4,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n  });\n\n  const source = `\n    struct Constants {\n      zero: u32;\n    };\n    @group(1) @binding(0) var<uniform> constants: Constants;\n\n    struct Result {\n      value: u32;\n    };\n    @group(1) @binding(1) var<storage, write> result: Result;\n\n    ${testSource}\n\n    @stage(compute) @workgroup_size(1)\n    fn main() {\n      _ = constants.zero; // Ensure constants buffer is statically-accessed\n      result.value = runTest();\n    }`;\n\n  t.debug(source);\n  const module = t.device.createShaderModule({ code: source });\n  const pipeline = t.device.createComputePipeline({\n    layout,\n    compute: { module, entryPoint: 'main' },\n  });\n\n  const group = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(1),\n    entries: [\n      { binding: 0, resource: { buffer: constantsBuffer } },\n      { binding: 1, resource: { buffer: resultBuffer } },\n    ],\n  });\n\n  const testGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: testBindings,\n  });\n\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, testGroup, dynamicOffsets);\n  pass.setBindGroup(1, group);\n  pass.dispatch(1);\n  pass.endPass();\n\n  t.queue.submit([encoder.finish()]);\n\n  t.expectGPUBufferValuesEqual(resultBuffer, new Uint32Array([0]));\n}\n\n/** Fill an ArrayBuffer with sentinel values, except clear a region to zero. */\nfunction testFillArrayBuffer(\n  array: ArrayBuffer,\n  type: 'u32' | 'i32' | 'f32',\n  { zeroByteStart, zeroByteCount }: { zeroByteStart: number; zeroByteCount: number }\n) {\n  const constructor = { u32: Uint32Array, i32: Int32Array, f32: Float32Array }[type];\n  assert(zeroByteCount % constructor.BYTES_PER_ELEMENT === 0);\n  new constructor(array).fill(42);\n  new constructor(array, zeroByteStart, zeroByteCount / constructor.BYTES_PER_ELEMENT).fill(0);\n}\n\n/**\n * Generate a bunch of indexable types (vec, mat, sized/unsized array) for testing.\n */\n\ng.test('linear_memory')\n  .desc(\n    `For each indexable data type (vec, mat, sized/unsized array, of various scalar types), attempts\n    to access (read, write, atomic load/store) a region of memory (buffer or internal) at various\n    (signed/unsigned) indices. Checks that the accesses conform to robust access (OOB reads only\n    return bound memory, OOB writes don't write OOB).\n\n    TODO: Test in/out storage classes.\n    TODO: Test vertex and fragment stages.\n    TODO: Test using a dynamic offset instead of a static offset into uniform/storage bindings.\n    TODO: Test types like vec2<atomic<i32>>, if that's allowed.\n    TODO: Test exprIndexAddon as constexpr.\n    TODO: Test exprIndexAddon as pipeline-overridable constant expression.\n  `\n  )\n  .params(u =>\n    u\n      .combineWithParams([\n        { storageClass: 'storage', storageMode: 'read', access: 'read', dynamicOffset: false },\n        { storageClass: 'storage', storageMode: 'write', access: 'write', dynamicOffset: false },\n        {\n          storageClass: 'storage',\n          storageMode: 'read_write',\n          access: 'read',\n          dynamicOffset: false,\n        },\n        {\n          storageClass: 'storage',\n          storageMode: 'read_write',\n          access: 'write',\n          dynamicOffset: false,\n        },\n        { storageClass: 'storage', storageMode: 'read', access: 'read', dynamicOffset: true },\n        { storageClass: 'storage', storageMode: 'write', access: 'write', dynamicOffset: true },\n        { storageClass: 'storage', storageMode: 'read_write', access: 'read', dynamicOffset: true },\n        {\n          storageClass: 'storage',\n          storageMode: 'read_write',\n          access: 'write',\n          dynamicOffset: true,\n        },\n        { storageClass: 'uniform', access: 'read', dynamicOffset: false },\n        { storageClass: 'uniform', access: 'read', dynamicOffset: true },\n        { storageClass: 'private', access: 'read' },\n        { storageClass: 'private', access: 'write' },\n        { storageClass: 'function', access: 'read' },\n        { storageClass: 'function', access: 'write' },\n        { storageClass: 'workgroup', access: 'read' },\n        { storageClass: 'workgroup', access: 'write' },\n      ] as const)\n      .combineWithParams([\n        { containerType: 'array' },\n        { containerType: 'matrix' },\n        { containerType: 'vector' },\n      ] as const)\n      .expand('isAtomic', p => (supportsAtomics(p) ? [false, true] : [false]))\n      .beginSubcases()\n      .expand('baseType', supportedScalarTypes)\n      .expandWithParams(generateTypes)\n  )\n  .fn(async t => {\n    const {\n      storageClass,\n      storageMode,\n      access,\n      dynamicOffset,\n      isAtomic,\n      containerType,\n      baseType,\n      type,\n      _kTypeInfo,\n    } = t.params;\n\n    assert(_kTypeInfo !== undefined, 'not an indexable type');\n    assert('arrayLength' in _kTypeInfo);\n\n    let usesCanary = false;\n    let globalSource = '';\n    let testFunctionSource = '';\n    const testBufferSize = 512;\n    const bufferBindingOffset = 256;\n    /** Undefined if no buffer binding is needed */\n    let bufferBindingSize: number | undefined = undefined;\n\n    // Declare the data that will be accessed to check robust access, as a buffer or a struct\n    // in the global scope or inside the test function itself.\n    const structDecl = `\n      struct S {\n        startCanary: array<u32, 10>;\n        data: ${type};\n        endCanary: array<u32, 10>;\n      };`;\n\n    const testGroupBGLEntires: GPUBindGroupLayoutEntry[] = [];\n    switch (storageClass) {\n      case 'uniform':\n      case 'storage':\n        {\n          assert(_kTypeInfo.layout !== undefined);\n          const layout = _kTypeInfo.layout;\n          bufferBindingSize = layout.size;\n          const qualifiers = storageClass === 'storage' ? `storage, ${storageMode}` : storageClass;\n          globalSource += `\n          struct TestData {\n            data: ${type};\n          };\n          @group(0) @binding(0) var<${qualifiers}> s: TestData;`;\n\n          testGroupBGLEntires.push({\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type:\n                storageClass === 'uniform'\n                  ? 'uniform'\n                  : storageMode === 'read'\n                  ? 'read-only-storage'\n                  : 'storage',\n              hasDynamicOffset: dynamicOffset,\n            },\n          });\n        }\n        break;\n\n      case 'private':\n      case 'workgroup':\n        usesCanary = true;\n        globalSource += structDecl;\n        globalSource += `var<${storageClass}> s: S;`;\n        break;\n\n      case 'function':\n        usesCanary = true;\n        globalSource += structDecl;\n        testFunctionSource += 'var s: S;';\n        break;\n    }\n\n    // Build the test function that will do the tests.\n\n    // If we use a local canary declared in the shader, initialize it.\n    if (usesCanary) {\n      testFunctionSource += `\n        for (var i = 0u; i < 10u; i = i + 1u) {\n          s.startCanary[i] = 0xFFFFFFFFu;\n          s.endCanary[i] = 0xFFFFFFFFu;\n        }`;\n    }\n\n    /** Returns a different number each time, kind of like a `__LINE__` to ID the failing check. */\n    const nextErrorReturnValue = (() => {\n      let errorReturnValue = 0x1000;\n      return () => {\n        ++errorReturnValue;\n        return `0x${errorReturnValue.toString(16)}u`;\n      };\n    })();\n\n    // This is here, instead of in subcases, so only a single shader is needed to test many modes.\n    for (const indexSigned of [false, true]) {\n      const indicesToTest = indexSigned\n        ? [\n            // Exactly in bounds (should be OK)\n            '0',\n            `${_kTypeInfo.arrayLength} - 1`,\n            // Exactly out of bounds\n            '-1',\n            `${_kTypeInfo.arrayLength}`,\n            // Far out of bounds\n            '-1000000',\n            '1000000',\n            `${kMinI32}`,\n            `${kMaxI32}`,\n          ]\n        : [\n            // Exactly in bounds (should be OK)\n            '0u',\n            `${_kTypeInfo.arrayLength}u - 1u`,\n            // Exactly out of bounds\n            `${_kTypeInfo.arrayLength}u`,\n            // Far out of bounds\n            '1000000u',\n            `${kMaxU32}u`,\n            `${kMaxI32}u`,\n          ];\n\n      const indexTypeLiteral = indexSigned ? '0' : '0u';\n      const indexTypeCast = indexSigned ? 'i32' : 'u32';\n      for (const exprIndexAddon of [\n        '', // No addon\n        ` + ${indexTypeLiteral}`, // Add a literal 0\n        ` + ${indexTypeCast}(constants.zero)`, // Add a uniform 0\n      ]) {\n        // Produce the accesses to the variable.\n        for (const indexToTest of indicesToTest) {\n          const exprIndex = `(${indexToTest})${exprIndexAddon}`;\n          const exprZeroElement = `${_kTypeInfo.elementBaseType}()`;\n          const exprElement = `s.data[${exprIndex}]`;\n\n          switch (access) {\n            case 'read':\n              {\n                const exprLoadElement = isAtomic ? `atomicLoad(&${exprElement})` : exprElement;\n                let condition = `${exprLoadElement} != ${exprZeroElement}`;\n                if (containerType === 'matrix') condition = `any(${condition})`;\n                testFunctionSource += `\n                  if (${condition}) { return ${nextErrorReturnValue()}; }`;\n              }\n              break;\n\n            case 'write':\n              if (isAtomic) {\n                testFunctionSource += `\n                  atomicStore(&s.data[${exprIndex}], ${exprZeroElement});`;\n              } else {\n                testFunctionSource += `\n                  s.data[${exprIndex}] = ${exprZeroElement};`;\n              }\n              break;\n          }\n        }\n        testFunctionSource += '\\n';\n      }\n    }\n\n    // Check that the canaries haven't been modified\n    if (usesCanary) {\n      testFunctionSource += `\n        for (var i = 0u; i < 10u; i = i + 1u) {\n          if (s.startCanary[i] != 0xFFFFFFFFu) {\n            return ${nextErrorReturnValue()};\n          }\n          if (s.endCanary[i] != 0xFFFFFFFFu) {\n            return ${nextErrorReturnValue()};\n          }\n        }`;\n    }\n\n    // Run the test\n\n    // First aggregate the test source\n    const testSource = `\n      ${globalSource}\n\n      fn runTest() -> u32 {\n        ${testFunctionSource}\n        return 0u;\n      }`;\n\n    const layout = t.device.createPipelineLayout({\n      bindGroupLayouts: [\n        t.device.createBindGroupLayout({\n          entries: testGroupBGLEntires,\n        }),\n        t.device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.COMPUTE,\n              buffer: {\n                type: 'uniform',\n              },\n            },\n            {\n              binding: 1,\n              visibility: GPUShaderStage.COMPUTE,\n              buffer: {\n                type: 'storage',\n              },\n            },\n          ],\n        }),\n      ],\n    });\n\n    // Run it.\n    if (bufferBindingSize !== undefined && baseType !== 'bool') {\n      const expectedData = new ArrayBuffer(testBufferSize);\n      const bufferBindingEnd = bufferBindingOffset + bufferBindingSize;\n      testFillArrayBuffer(expectedData, baseType, {\n        zeroByteStart: bufferBindingOffset,\n        zeroByteCount: bufferBindingSize,\n      });\n\n      // Create a buffer that contains zeroes in the allowed access area, and 42s everywhere else.\n      const testBuffer = t.makeBufferWithContents(\n        new Uint8Array(expectedData),\n        GPUBufferUsage.COPY_SRC |\n          GPUBufferUsage.UNIFORM |\n          GPUBufferUsage.STORAGE |\n          GPUBufferUsage.COPY_DST\n      );\n\n      // Run the shader, accessing the buffer.\n      runShaderTest(\n        t,\n        GPUShaderStage.COMPUTE,\n        testSource,\n        layout,\n        [\n          {\n            binding: 0,\n            resource: {\n              buffer: testBuffer,\n              offset: dynamicOffset ? 0 : bufferBindingOffset,\n              size: bufferBindingSize,\n            },\n          },\n        ],\n        dynamicOffset ? [bufferBindingOffset] : undefined\n      );\n\n      // Check that content of the buffer outside of the allowed area didn't change.\n      const expectedBytes = new Uint8Array(expectedData);\n      t.expectGPUBufferValuesEqual(testBuffer, expectedBytes.subarray(0, bufferBindingOffset), 0);\n      t.expectGPUBufferValuesEqual(\n        testBuffer,\n        expectedBytes.subarray(bufferBindingEnd, testBufferSize),\n        bufferBindingEnd\n      );\n    } else {\n      runShaderTest(t, GPUShaderStage.COMPUTE, testSource, layout, []);\n    }\n  });\n"],"file":"robust_access.spec.js"}