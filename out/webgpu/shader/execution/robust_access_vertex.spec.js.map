{"version":3,"sources":["../../../../src/webgpu/shader/execution/robust_access_vertex.spec.ts"],"names":["description","makeTestGroup","GPUTest","g","DrawCall","constructor","device","vertexArrays","vertexCount","partialLastNumber","offsetVertexBuffer","vertexBuffers","map","v","generateVertexBuffer","indexArray","Uint16Array","fill","_","i","indexBuffer","generateIndexBuffer","firstVertex","indexCount","firstIndex","baseVertex","instanceCount","firstInstance","insertInto","pass","indexed","indirect","drawIndexedIndirect","drawIndexed","drawIndirect","draw","bindVertexBuffers","setIndexBuffer","generateIndirectBuffer","generateIndexedIndirectBuffer","currSlot","length","setVertexBuffer","vertexArray","size","byteLength","vertexBuffer","createBuffer","usage","GPUBufferUsage","VERTEX","COPY_DST","queue","writeBuffer","INDEX","indirectArray","Int32Array","indirectBuffer","mappedAtCreation","INDIRECT","getMappedRange","set","unmap","typeInfoMap","float","wgslType","validationFunc","float2","float3","float4","test","params","u","combine","expand","p","beginSubcases","Object","keys","fn","t","typeInfo","type","numVertices","attributesPerBuffer","Float32Array","arbitraryValues","validValues","bufferContents","additionalBuffers","push","layoutStr","attributeNames","currAttribute","j","buffers","arrayStride","stepMode","attributes","Array","shaderLocation","offset","format","vertexIndexOffset","drawCallTestParameter","errorScale","pipeline","createRenderPipeline","vertex","module","createShaderModule","code","join","a","entryPoint","fragment","targets","primitive","topology","colorAttachment","createTexture","width","height","depthOrArrayLayers","GPUTextureUsage","COPY_SRC","RENDER_ATTACHMENT","colorAttachmentView","createView","encoder","createCommandEncoder","beginRenderPass","colorAttachments","view","storeOp","loadValue","r","b","setPipeline","endPass","submit","finish","expectSinglePixelIn2DTexture","x","y","exp","Uint8Array","layout","mipLevel"],"mappings":"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","sourcesContent":["export const description = `\nTest vertex attributes behave correctly (no crash / data leak) when accessed out of bounds\n\nTest coverage:\n\nThe following will be parameterized (all combinations tested):\n\n1) Draw call indexed? (false / true)\n  - Run the draw call using an index buffer\n\n2) Draw call indirect? (false / true)\n  - Run the draw call using an indirect buffer\n\n3) Draw call parameter (vertexCount, firstVertex, indexCount, firstIndex, baseVertex, instanceCount,\n  firstInstance)\n  - The parameter which will go out of bounds. Filtered depending on if the draw call is indexed.\n\n4) Attribute type (float, vec2, vec3, vec4)\n  - The input attribute type in the vertex shader\n\n5) Error scale (1, 4, 10^2, 10^4, 10^6)\n  - Offset to add to the correct draw call parameter\n\n6) Additional vertex buffers (0, +4)\n  - Tests that no OOB occurs if more vertex buffers are used\n\nThe tests will also have another vertex buffer bound for an instanced attribute, to make sure\ninstanceCount / firstInstance are tested.\n\nThe tests will include multiple attributes per vertex buffer.\n\nThe vertex buffers will be filled by repeating a few chosen values until the end of the buffer.\n\nThe test will run a render pipeline which verifies the following:\n1) All vertex attribute values occur in the buffer or are zero\n2) All gl_VertexIndex values are within the index buffer or 0\n\nTODO:\n\nA suppression may be needed for d3d12 on tests that have non-zero baseVertex, since d3d12 counts\nfrom 0 instead of from baseVertex (will fail check for gl_VertexIndex).\n\nVertex buffer contents could be randomized to prevent the case where a previous test creates\na similar buffer to ours and the OOB-read seems valid. This should be deterministic, which adds\nmore complexity that we may not need.`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { GPUTest } from '../../gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\n// Encapsulates a draw call (either indexed or non-indexed)\nclass DrawCall {\n  private device: GPUDevice;\n  private vertexBuffers: GPUBuffer[];\n  private indexBuffer: GPUBuffer;\n\n  // Add a float offset when binding vertex buffer\n  private offsetVertexBuffer: boolean;\n\n  // Draw\n  public vertexCount: number;\n  public firstVertex: number;\n\n  // DrawIndexed\n  public indexCount: number;\n  public firstIndex: number;\n  public baseVertex: number;\n\n  // Both Draw and DrawIndexed\n  public instanceCount: number;\n  public firstInstance: number;\n\n  constructor(\n    device: GPUDevice,\n    vertexArrays: Float32Array[],\n    vertexCount: number,\n    partialLastNumber: boolean,\n    offsetVertexBuffer: boolean\n  ) {\n    this.device = device;\n    this.vertexBuffers = vertexArrays.map(v => this.generateVertexBuffer(v, partialLastNumber));\n\n    const indexArray = new Uint16Array(vertexCount).fill(0).map((_, i) => i);\n    this.indexBuffer = this.generateIndexBuffer(indexArray);\n\n    // Default arguments (valid call)\n    this.vertexCount = vertexCount;\n    this.firstVertex = 0;\n    this.indexCount = vertexCount;\n    this.firstIndex = 0;\n    this.baseVertex = 0;\n    this.instanceCount = vertexCount;\n    this.firstInstance = 0;\n\n    this.offsetVertexBuffer = offsetVertexBuffer;\n  }\n\n  // Insert a draw call into |pass| with specified type\n  public insertInto(pass: GPURenderPassEncoder, indexed: boolean, indirect: boolean) {\n    if (indexed) {\n      if (indirect) {\n        this.drawIndexedIndirect(pass);\n      } else {\n        this.drawIndexed(pass);\n      }\n    } else {\n      if (indirect) {\n        this.drawIndirect(pass);\n      } else {\n        this.draw(pass);\n      }\n    }\n  }\n\n  // Insert a draw call into |pass|\n  public draw(pass: GPURenderPassEncoder) {\n    this.bindVertexBuffers(pass);\n    pass.draw(this.vertexCount, this.instanceCount, this.firstVertex, this.firstInstance);\n  }\n\n  // Insert an indexed draw call into |pass|\n  public drawIndexed(pass: GPURenderPassEncoder) {\n    this.bindVertexBuffers(pass);\n    pass.setIndexBuffer(this.indexBuffer, 'uint16');\n    pass.drawIndexed(\n      this.indexCount,\n      this.instanceCount,\n      this.firstIndex,\n      this.baseVertex,\n      this.firstInstance\n    );\n  }\n\n  // Insert an indirect draw call into |pass|\n  public drawIndirect(pass: GPURenderPassEncoder) {\n    this.bindVertexBuffers(pass);\n    pass.drawIndirect(this.generateIndirectBuffer(), 0);\n  }\n\n  // Insert an indexed indirect draw call into |pass|\n  public drawIndexedIndirect(pass: GPURenderPassEncoder) {\n    this.bindVertexBuffers(pass);\n    pass.setIndexBuffer(this.indexBuffer, 'uint16');\n    pass.drawIndexedIndirect(this.generateIndexedIndirectBuffer(), 0);\n  }\n\n  // Bind all vertex buffers generated\n  private bindVertexBuffers(pass: GPURenderPassEncoder) {\n    let currSlot = 0;\n    for (let i = 0; i < this.vertexBuffers.length; i++) {\n      pass.setVertexBuffer(currSlot++, this.vertexBuffers[i], this.offsetVertexBuffer ? 4 : 0);\n    }\n  }\n\n  // Create a vertex buffer from |vertexArray|\n  // If |partialLastNumber| is true, delete one byte off the end\n  private generateVertexBuffer(vertexArray: Float32Array, partialLastNumber: boolean): GPUBuffer {\n    let size = vertexArray.byteLength;\n    if (partialLastNumber) {\n      size -= 1;\n    }\n    const vertexBuffer = this.device.createBuffer({\n      size,\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n    });\n    if (partialLastNumber) {\n      size -= 3;\n    }\n    this.device.queue.writeBuffer(vertexBuffer, 0, vertexArray, size);\n    return vertexBuffer;\n  }\n\n  // Create an index buffer from |indexArray|\n  private generateIndexBuffer(indexArray: Uint16Array): GPUBuffer {\n    const indexBuffer = this.device.createBuffer({\n      size: indexArray.byteLength,\n      usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,\n    });\n    this.device.queue.writeBuffer(indexBuffer, 0, indexArray);\n    return indexBuffer;\n  }\n\n  // Create an indirect buffer containing draw call values\n  private generateIndirectBuffer(): GPUBuffer {\n    const indirectArray = new Int32Array([\n      this.vertexCount,\n      this.instanceCount,\n      this.firstVertex,\n      this.firstInstance,\n    ]);\n    const indirectBuffer = this.device.createBuffer({\n      mappedAtCreation: true,\n      size: indirectArray.byteLength,\n      usage: GPUBufferUsage.INDIRECT,\n    });\n    new Int32Array(indirectBuffer.getMappedRange()).set(indirectArray);\n    indirectBuffer.unmap();\n    return indirectBuffer;\n  }\n\n  // Create an indirect buffer containing indexed draw call values\n  private generateIndexedIndirectBuffer(): GPUBuffer {\n    const indirectArray = new Int32Array([\n      this.indexCount,\n      this.instanceCount,\n      this.firstVertex,\n      this.baseVertex,\n      this.firstInstance,\n    ]);\n    const indirectBuffer = this.device.createBuffer({\n      mappedAtCreation: true,\n      size: indirectArray.byteLength,\n      usage: GPUBufferUsage.INDIRECT,\n    });\n    new Int32Array(indirectBuffer.getMappedRange()).set(indirectArray);\n    indirectBuffer.unmap();\n    return indirectBuffer;\n  }\n}\n\n// Parameterize different sized types\ninterface VertexInfo {\n  wgslType: string;\n  size: number;\n  validationFunc: string;\n}\n\nconst typeInfoMap: { [k: string]: VertexInfo } = {\n  float: {\n    wgslType: 'f32',\n    size: 4,\n    validationFunc: 'return valid(v);',\n  },\n  float2: {\n    wgslType: 'vec2<f32>',\n    size: 8,\n    validationFunc: 'return valid(v.x) && valid(v.y);',\n  },\n  float3: {\n    wgslType: 'vec3<f32>',\n    size: 12,\n    validationFunc: 'return valid(v.x) && valid(v.y) && valid(v.z);',\n  },\n  float4: {\n    wgslType: 'vec4<f32>',\n    size: 16,\n    validationFunc: `return valid(v.x) && valid(v.y) && valid(v.z) && valid(v.w) ||\n                            v.x == 0.0 && v.y == 0.0 && v.z == 0.0 && (v.w == 0.0 || v.w == 1.0);`,\n  },\n};\n\ng.test('vertexAccess')\n  .params(u =>\n    u\n      .combine('indexed', [false, true])\n      .combine('indirect', [false, true])\n      .expand('drawCallTestParameter', p =>\n        p.indexed\n          ? (['indexCount', 'instanceCount', 'firstIndex', 'baseVertex', 'firstInstance'] as const)\n          : (['vertexCount', 'instanceCount', 'firstVertex', 'firstInstance'] as const)\n      )\n      .beginSubcases()\n      .combine('type', Object.keys(typeInfoMap))\n      .combine('additionalBuffers', [0, 4])\n      .combine('partialLastNumber', [false, true])\n      .combine('offsetVertexBuffer', [false, true])\n      .combine('errorScale', [1, 4, 10 ** 2, 10 ** 4, 10 ** 6])\n  )\n  .fn(async t => {\n    const p = t.params;\n    const typeInfo = typeInfoMap[p.type];\n\n    // Number of vertices to draw, odd so that uint16 index buffers are aligned to size 4\n    const numVertices = 4;\n    // Each buffer will be bound to this many attributes (2 would mean 2 attributes per buffer)\n    const attributesPerBuffer = 2;\n    // Make an array big enough for the vertices, attributes, and size of each element\n    const vertexArray = new Float32Array(numVertices * attributesPerBuffer * (typeInfo.size / 4));\n\n    // Sufficiently unusual values to fill our buffer with to avoid collisions with other tests\n    const arbitraryValues = [759, 329, 908];\n    for (let i = 0; i < vertexArray.length; ++i) {\n      vertexArray[i] = arbitraryValues[i % arbitraryValues.length];\n    }\n    // A valid value is 0 or one in the buffer\n    const validValues = [0, ...arbitraryValues];\n\n    // Instance step mode buffer, vertex step mode buffer\n    const bufferContents = [vertexArray, vertexArray];\n    // Additional buffers (vertex step mode)\n    for (let i = 0; i < p.additionalBuffers; i++) {\n      bufferContents.push(vertexArray);\n    }\n\n    // Mutable draw call\n    const draw = new DrawCall(\n      t.device,\n      bufferContents,\n      numVertices,\n      p.partialLastNumber,\n      p.offsetVertexBuffer\n    );\n\n    // Create attributes listing\n    let layoutStr = 'struct Attributes {';\n    const attributeNames = [];\n    {\n      let currAttribute = 0;\n      for (let i = 0; i < bufferContents.length; i++) {\n        for (let j = 0; j < attributesPerBuffer; j++) {\n          layoutStr += `[[location(${currAttribute})]] a_${currAttribute} : ${typeInfo.wgslType};\\n`;\n          attributeNames.push(`a_${currAttribute}`);\n          currAttribute++;\n        }\n      }\n    }\n    layoutStr += '};';\n\n    // Vertex buffer descriptors\n    const buffers: GPUVertexBufferLayout[] = [];\n    {\n      let currAttribute = 0;\n      for (let i = 0; i < bufferContents.length; i++) {\n        buffers.push({\n          arrayStride: attributesPerBuffer * typeInfo.size,\n          stepMode: i === 0 ? 'instance' : 'vertex',\n          attributes: Array(attributesPerBuffer)\n            .fill(0)\n            .map((_, i) => ({\n              shaderLocation: currAttribute++,\n              offset: i * typeInfo.size,\n              format: p.type as GPUVertexFormat,\n            })),\n        });\n      }\n    }\n\n    // Offset the range checks for gl_VertexIndex in the shader if we use BaseVertex\n    let vertexIndexOffset = 0;\n    if (p.drawCallTestParameter === 'baseVertex') {\n      vertexIndexOffset += p.errorScale;\n    }\n\n    const pipeline = t.device.createRenderPipeline({\n      vertex: {\n        module: t.device.createShaderModule({\n          code: `\n            ${layoutStr}\n\n            fn valid(f : f32) -> bool {\n              return ${validValues.map(v => `f == ${v}.0`).join(' || ')};\n            }\n\n            fn validationFunc(v : ${typeInfo.wgslType}) -> bool {\n              ${typeInfo.validationFunc}\n            }\n\n            [[stage(vertex)]] fn main(\n              [[builtin(vertex_index)]] VertexIndex : u32,\n              attributes : Attributes\n              ) -> [[builtin(position)]] vec4<f32> {\n              var attributesInBounds : bool = ${attributeNames\n                .map(a => `validationFunc(attributes.${a})`)\n                .join(' && ')};\n              var indexInBounds : bool = VertexIndex == 0u ||\n                  (VertexIndex >= ${vertexIndexOffset}u &&\n                   VertexIndex < ${vertexIndexOffset + numVertices}u);\n\n              var Position : vec4<f32>;\n              if (attributesInBounds && (${!p.indexed} || indexInBounds)) {\n                // Success case, move the vertex out of the viewport\n                Position = vec4<f32>(-1.0, 0.0, 0.0, 1.0);\n              } else {\n                // Failure case, move the vertex inside the viewport\n                Position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n              }\n              return Position;\n            }`,\n        }),\n        entryPoint: 'main',\n        buffers,\n      },\n      fragment: {\n        module: t.device.createShaderModule({\n          code: `\n            [[stage(fragment)]] fn main() -> [[location(0)]] vec4<f32> {\n              return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'point-list' },\n    });\n\n    // Pipeline setup, texture setup\n    const colorAttachment = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    const colorAttachmentView = colorAttachment.createView();\n\n    // Offset the draw call parameter we are testing by |errorScale|\n    draw[p.drawCallTestParameter] += p.errorScale;\n\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: colorAttachmentView,\n          storeOp: 'store',\n          loadValue: { r: 0.0, g: 1.0, b: 0.0, a: 1.0 },\n        },\n      ],\n    });\n    pass.setPipeline(pipeline);\n\n    // Run the draw variant\n    draw.insertInto(pass, p.indexed, p.indirect);\n\n    pass.endPass();\n    t.device.queue.submit([encoder.finish()]);\n\n    // Validate we see green instead of red, meaning no fragment ended up on-screen\n    t.expectSinglePixelIn2DTexture(\n      colorAttachment,\n      'rgba8unorm',\n      { x: 0, y: 0 },\n      { exp: new Uint8Array([0x00, 0xff, 0x00, 0xff]), layout: { mipLevel: 0 } }\n    );\n  });\n"],"file":"robust_access_vertex.spec.js"}