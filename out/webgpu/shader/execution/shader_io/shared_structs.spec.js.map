{"version":3,"sources":["../../../../../src/webgpu/shader/execution/shader_io/shared_structs.spec.ts"],"names":["description","makeTestGroup","GPUTest","checkElementsEqual","g","test","desc","fn","t","wgsize","Uint32Array","numGroups","targetLocalIndex","targetGroup","wgsl","pipeline","device","createComputePipeline","compute","module","createShaderModule","code","entryPoint","bufferNumElements","outputBuffer","createBuffer","size","BYTES_PER_ELEMENT","usage","GPUBufferUsage","STORAGE","COPY_SRC","bindGroup","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","buffer","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatch","endPass","queue","submit","finish","checkOutput","outputs","slice","Error","undefined","expectGPUBufferValuesPassCheck","outputData","type","typedLength","createRenderPipeline","vertex","fragment","targets","format","renderTarget","createTexture","GPUTextureUsage","RENDER_ATTACHMENT","beginRenderPass","colorAttachments","view","createView","loadValue","storeOp","draw","redPixel","Uint8Array","greenPixel","p","x","y","expectSinglePixelIn2DTexture","exp","blackPixel","buffers","attributes","shaderLocation","offset","arrayStride","Float32Array","vertexBuffer","makeBufferWithContents","VERTEX","setVertexBuffer"],"mappings":"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","sourcesContent":["export const description = `Test the shared use of structures containing entry point IO attributes`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { checkElementsEqual } from '../../../util/check_contents.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('shared_with_buffer')\n  .desc(\n    `Test sharing an entry point IO struct with a buffer.\n\n     This test defines a structure that contains both builtin attributes and layout attributes,\n     and uses that structure as both an entry point input and the store type of a storage buffer.\n     The builtin attributes should be ignored when used for the storage buffer, and the layout\n     attributes should be ignored when used as an entry point IO parameter.\n    `\n  )\n  .fn(async t => {\n    // Set the dispatch parameters such that we get some interesting (non-zero) built-in variables.\n    const wgsize = new Uint32Array([8, 4, 2]);\n    const numGroups = new Uint32Array([4, 2, 8]);\n\n    // Pick a single invocation to copy the input structure to the output buffer.\n    const targetLocalIndex = 13;\n    const targetGroup = new Uint32Array([2, 1, 5]);\n\n    // The test shader defines a structure that contains members decorated with built-in variable\n    // attributes, and also layout attributes for the storage buffer.\n    const wgsl = `\n      struct S {\n        /* byte offset:  0 */ @size(32)  @builtin(workgroup_id) group_id : vec3<u32>;\n        /* byte offset: 32 */            @builtin(local_invocation_index) local_index : u32;\n        /* byte offset: 64 */ @align(64) @builtin(num_workgroups) numGroups : vec3<u32>;\n      };\n\n      @group(0) @binding(0)\n      var<storage, read_write> outputs : S;\n\n      @stage(compute) @workgroup_size(${wgsize[0]}, ${wgsize[1]}, ${wgsize[2]})\n      fn main(inputs : S) {\n        if (inputs.group_id.x == ${targetGroup[0]}u &&\n            inputs.group_id.y == ${targetGroup[1]}u &&\n            inputs.group_id.z == ${targetGroup[2]}u &&\n            inputs.local_index == ${targetLocalIndex}u) {\n          outputs = inputs;\n        }\n      }\n    `;\n\n    const pipeline = t.device.createComputePipeline({\n      compute: {\n        module: t.device.createShaderModule({ code: wgsl }),\n        entryPoint: 'main',\n      },\n    });\n\n    // Allocate a buffer to hold the output structure.\n    const bufferNumElements = 32;\n    const outputBuffer = t.device.createBuffer({\n      size: bufferNumElements * Uint32Array.BYTES_PER_ELEMENT,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n    const bindGroup = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: outputBuffer } }],\n    });\n\n    // Run the shader.\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatch(numGroups[0], numGroups[1], numGroups[2]);\n    pass.endPass();\n    t.queue.submit([encoder.finish()]);\n\n    // Check the output values.\n    const checkOutput = (outputs: Uint32Array) => {\n      if (checkElementsEqual(outputs.slice(0, 3), targetGroup)) {\n        return new Error(\n          `group_id comparison failed\\n` +\n            `    expected: ${targetGroup}\\n` +\n            `    got:      ${outputs.slice(0, 3)}`\n        );\n      }\n      if (outputs[8] !== targetLocalIndex) {\n        return new Error(\n          `local_index comparison failed\\n` +\n            `    expected: ${targetLocalIndex}\\n` +\n            `    got:      ${outputs[8]}`\n        );\n      }\n      if (checkElementsEqual(outputs.slice(16, 19), numGroups)) {\n        return new Error(\n          `numGroups comparison failed\\n` +\n            `    expected: ${numGroups}\\n` +\n            `    got:      ${outputs.slice(16, 19)}`\n        );\n      }\n      return undefined;\n    };\n    t.expectGPUBufferValuesPassCheck(outputBuffer, outputData => checkOutput(outputData), {\n      type: Uint32Array,\n      typedLength: bufferNumElements,\n    });\n  });\n\ng.test('shared_between_stages')\n  .desc(\n    `Test sharing an entry point IO struct between different pipeline stages.\n\n     This test defines an entry point IO structure, and uses it as both the output of a vertex\n     shader and the input to a fragment shader.\n    `\n  )\n  .fn(async t => {\n    const size = [31, 31];\n    const wgsl = `\n      struct Interface {\n        @builtin(position) position : vec4<f32>;\n        @location(0) color : f32;\n      };\n\n      var<private> vertices : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n        vec2<f32>(-0.7, -0.7),\n        vec2<f32>( 0.0,  0.7),\n        vec2<f32>( 0.7, -0.7),\n      );\n\n      @stage(vertex)\n      fn vert_main(@builtin(vertex_index) index : u32) -> Interface {\n        return Interface(vec4<f32>(vertices[index], 0.0, 1.0), 1.0);\n      }\n\n      @stage(fragment)\n      fn frag_main(inputs : Interface) -> @location(0) vec4<f32> {\n        // Toggle red vs green based on the x position.\n        var color = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n        if (inputs.position.x > f32(${size[0] / 2})) {\n          color.r = inputs.color;\n        } else {\n          color.g = inputs.color;\n        }\n        return color;\n      }\n    `;\n\n    // Set up the render pipeline.\n    const module = t.device.createShaderModule({ code: wgsl });\n    const pipeline = t.device.createRenderPipeline({\n      vertex: {\n        module,\n        entryPoint: 'vert_main',\n      },\n      fragment: {\n        module,\n        entryPoint: 'frag_main',\n        targets: [\n          {\n            format: 'rgba8unorm',\n          },\n        ],\n      },\n    });\n\n    // Draw a red triangle.\n    const renderTarget = t.device.createTexture({\n      size,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n    });\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          loadValue: [0, 0, 0, 0],\n          storeOp: 'store',\n        },\n      ],\n    });\n    pass.setPipeline(pipeline);\n    pass.draw(3);\n    pass.endPass();\n    t.queue.submit([encoder.finish()]);\n\n    // Test a few points to make sure we rendered a half-red/half-green triangle.\n    const redPixel = new Uint8Array([255, 0, 0, 255]);\n    const greenPixel = new Uint8Array([0, 255, 0, 255]);\n    for (const p of [\n      { x: 16, y: 15 },\n      { x: 16, y: 15 },\n      { x: 22, y: 20 },\n    ]) {\n      t.expectSinglePixelIn2DTexture(renderTarget, 'rgba8unorm', p, {\n        exp: redPixel,\n      });\n    }\n    for (const p of [\n      { x: 14, y: 15 },\n      { x: 14, y: 8 },\n      { x: 8, y: 20 },\n    ]) {\n      t.expectSinglePixelIn2DTexture(renderTarget, 'rgba8unorm', p, {\n        exp: greenPixel,\n      });\n    }\n    const blackPixel = new Uint8Array([0, 0, 0, 0]);\n    for (const p of [\n      { x: 2, y: 2 },\n      { x: 2, y: 28 },\n      { x: 28, y: 2 },\n      { x: 28, y: 28 },\n    ]) {\n      t.expectSinglePixelIn2DTexture(renderTarget, 'rgba8unorm', p, {\n        exp: blackPixel,\n      });\n    }\n  });\n\ng.test('shared_with_non_entry_point_function')\n  .desc(\n    `Test sharing an entry point IO struct with a non entry point function.\n\n     This test defines structures that contain builtin and location attributes, and uses those\n     structures as parameter and return types for entry point functions and regular functions.\n    `\n  )\n  .fn(async t => {\n    // The test shader defines structures that contain members decorated with built-in variable\n    // attributes and user-defined IO. These structures are passed to and returned from regular\n    // functions.\n    const wgsl = `\n      struct Inputs {\n        @builtin(vertex_index) index : u32;\n        @location(0) color : vec4<f32>;\n      };\n      struct Outputs {\n        @builtin(position) position : vec4<f32>;\n        @location(0) color : vec4<f32>;\n      };\n\n      var<private> vertices : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n        vec2<f32>(-0.7, -0.7),\n        vec2<f32>( 0.0,  0.7),\n        vec2<f32>( 0.7, -0.7),\n      );\n\n      fn process(in : Inputs) -> Outputs {\n        var out : Outputs;\n        out.position = vec4<f32>(vertices[in.index], 0.0, 1.0);\n        out.color = in.color;\n        return out;\n      }\n\n      @stage(vertex)\n      fn vert_main(inputs : Inputs) -> Outputs {\n        return process(inputs);\n      }\n\n      @stage(fragment)\n      fn frag_main(@location(0) color : vec4<f32>) -> @location(0) vec4<f32> {\n        return color;\n      }\n    `;\n\n    // Set up the render pipeline.\n    const module = t.device.createShaderModule({ code: wgsl });\n    const pipeline = t.device.createRenderPipeline({\n      vertex: {\n        module,\n        entryPoint: 'vert_main',\n        buffers: [\n          {\n            attributes: [\n              {\n                shaderLocation: 0,\n                format: 'float32x4',\n                offset: 0,\n              },\n            ],\n            arrayStride: 4 * Float32Array.BYTES_PER_ELEMENT,\n          },\n        ],\n      },\n      fragment: {\n        module,\n        entryPoint: 'frag_main',\n        targets: [\n          {\n            format: 'rgba8unorm',\n          },\n        ],\n      },\n    });\n\n    // Draw a triangle.\n    // The vertex buffer contains the vertex colors (all red).\n    const vertexBuffer = t.makeBufferWithContents(\n      new Float32Array([1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0]),\n      GPUBufferUsage.VERTEX\n    );\n    const renderTarget = t.device.createTexture({\n      size: [31, 31],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n    });\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          loadValue: [0, 0, 0, 0],\n          storeOp: 'store',\n        },\n      ],\n    });\n    pass.setPipeline(pipeline);\n    pass.setVertexBuffer(0, vertexBuffer);\n    pass.draw(3);\n    pass.endPass();\n    t.queue.submit([encoder.finish()]);\n\n    // Test a few points to make sure we rendered a red triangle.\n    const redPixel = new Uint8Array([255, 0, 0, 255]);\n    for (const p of [\n      { x: 15, y: 15 },\n      { x: 15, y: 8 },\n      { x: 8, y: 20 },\n      { x: 22, y: 20 },\n    ]) {\n      t.expectSinglePixelIn2DTexture(renderTarget, 'rgba8unorm', p, {\n        exp: redPixel,\n      });\n    }\n    const blackPixel = new Uint8Array([0, 0, 0, 0]);\n    for (const p of [\n      { x: 2, y: 2 },\n      { x: 2, y: 28 },\n      { x: 28, y: 2 },\n      { x: 28, y: 28 },\n    ]) {\n      t.expectSinglePixelIn2DTexture(renderTarget, 'rgba8unorm', p, {\n        exp: blackPixel,\n      });\n    }\n  });\n"],"file":"shared_structs.spec.js"}