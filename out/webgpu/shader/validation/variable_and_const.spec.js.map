{"version":3,"sources":["../../../../src/webgpu/shader/validation/variable_and_const.spec.ts"],"names":["description","makeTestGroup","ShaderValidationTest","g","kTestTypes","test","desc","params","u","combine","beginSubcases","fn","t","variableOrConstant","lhsType","rhsType","code","expectation","expectCompileResult","storageClass","type","indexOf","startsWith"],"mappings":"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","sourcesContent":["export const description = `\nPositive and negative validation tests for variable and const.\n\nTODO: Find a better way to test arrays than using a single arbitrary size. [1]\n`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\n\nimport { ShaderValidationTest } from './shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\nconst kTestTypes = [\n  'f32',\n  'i32',\n  'u32',\n  'bool',\n  'vec2<f32>',\n  'vec2<i32>',\n  'vec2<u32>',\n  'vec2<bool>',\n  'vec3<f32>',\n  'vec3<i32>',\n  'vec3<u32>',\n  'vec3<bool>',\n  'vec4<f32>',\n  'vec4<i32>',\n  'vec4<u32>',\n  'vec4<bool>',\n  'mat2x2<f32>',\n  'mat2x3<f32>',\n  'mat2x4<f32>',\n  'mat3x2<f32>',\n  'mat3x3<f32>',\n  'mat3x4<f32>',\n  'mat4x2<f32>',\n  'mat4x3<f32>',\n  'mat4x4<f32>',\n  // [1]: 12 is a random number here. find a solution to replace it.\n  'array<f32, 12>',\n  'array<i32, 12>',\n  'array<u32, 12>',\n  'array<bool, 12>',\n] as const;\n\ng.test('initializer_type')\n  .desc(\n    `\n  If present, the initializer's type must match the store type of the variable.\n  Testing scalars, vectors, and matrices of every dimension and type.\n  TODO: add test for: structs - arrays of vectors and matrices - arrays of different length\n`\n  )\n  .params(u =>\n    u\n      .combine('variableOrConstant', ['var', 'let'])\n      .beginSubcases()\n      .combine('lhsType', kTestTypes)\n      .combine('rhsType', kTestTypes)\n  )\n  .fn(t => {\n    const { variableOrConstant, lhsType, rhsType } = t.params;\n\n    const code = `\n      @stage(fragment)\n      fn main() {\n        ${variableOrConstant} a : ${lhsType} = ${rhsType}();\n      }\n    `;\n\n    const expectation = lhsType === rhsType;\n    t.expectCompileResult(expectation, code);\n  });\n\ng.test('io_shareable_type')\n  .desc(\n    `\n  The following types are IO-shareable:\n  - numeric scalar types\n  - numeric vector types\n  - Matrix Types\n  - Array Types if its element type is IO-shareable, and the array is not runtime-sized\n  - Structure Types if all its members are IO-shareable\n\n  As a result these are not IO-shareable:\n  - boolean\n  - vector of booleans\n  - array of booleans\n  - matrix of booleans\n  - array runtime sized -> cannot be used outside of a struct, so no cts for this\n  - struct with bool component\n  - struct with runtime array\n\n  Control case: 'private' is used to make sure when only the storage class changes, the shader\n  becomes invalid and nothing else is wrong.\n  TODO: add test for structs:\n  - struct with bool component\n  - struct with runtime array`\n  )\n  .params(u => u.combine('storageClass', ['in', 'out', 'private']).combine('type', kTestTypes))\n  .fn(t => {\n    const { storageClass, type } = t.params;\n\n    let code;\n    if (`${storageClass}` === 'in') {\n      code = `\n        struct MyInputs {\n          @location(0) @interpolate(flat) a : ${type};\n        };\n\n        @stage(fragment)\n        fn main(inputs : MyInputs) {\n        }\n      `;\n    } else if (`${storageClass}` === 'out') {\n      code = `\n        struct MyOutputs {\n          @location(0) a : ${type};\n        };\n\n        @stage(fragment)\n        fn main() -> MyOutputs {\n          return MyOutputs();\n        }\n      `;\n    } else {\n      code = `\n      var<${storageClass}> a : ${type} = ${type}();\n\n      @stage(fragment)\n      fn main() {\n      }\n      `;\n    }\n\n    const expectation =\n      storageClass === 'private' ||\n      (type.indexOf('bool') === -1 && !type.startsWith('mat') && !type.startsWith('array'));\n    t.expectCompileResult(expectation, code);\n  });\n"],"file":"variable_and_const.spec.js"}