{"version":3,"sources":["../../../../../src/webgpu/shader/validation/shader_io/util.ts"],"names":["generateShader","attribute","type","stage","io","use_struct","code","includes","param","retType","retVal"],"mappings":";AAAA;AACA,G,CADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACA,OAAO,SAASA,cAAT,CAAwB,EAC7BC,SAD6B;AAE7BC,EAAAA,IAF6B;AAG7BC,EAAAA,KAH6B;AAI7BC,EAAAA,EAJ6B;AAK7BC,EAAAA,UAL6B,EAAxB;;;;;;;AAYJ;AACD,MAAIC,IAAI,GAAG,EAAX;;AAEA,MAAID,UAAJ,EAAgB;AACd;AACAC,IAAAA,IAAI,IAAI,cAAR;AACAA,IAAAA,IAAI,IAAK,KAAIL,SAAU,YAAWC,IAAK,KAAvC;AACA,QAAIC,KAAK,KAAK,QAAV,IAAsBC,EAAE,KAAK,KAA7B,IAAsC,CAACH,SAAS,CAACM,QAAV,CAAmB,mBAAnB,CAA3C,EAAoF;AAClF;AACAD,MAAAA,IAAI,IAAK,8CAAT;AACD;AACDA,IAAAA,IAAI,IAAI,QAAR;AACD;;AAED,MAAIH,KAAK,KAAK,EAAd,EAAkB;AAChB;AACAG,IAAAA,IAAI,IAAK,UAASH,KAAM,GAAxB;AACA,QAAIA,KAAK,KAAK,SAAd,EAAyB;AACvBG,MAAAA,IAAI,IAAI,qBAAR;AACD;AACF;;AAED;AACA,MAAIE,KAAK,GAAG,EAAZ;AACA,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIN,EAAE,KAAK,IAAX,EAAiB;AACf,QAAIC,UAAJ,EAAgB;AACdG,MAAAA,KAAK,GAAI,QAAT;AACD,KAFD,MAEO;AACLA,MAAAA,KAAK,GAAI,GAAEP,SAAU,YAAWC,IAAK,EAArC;AACD;;AAED;AACA,QAAIC,KAAK,KAAK,QAAd,EAAwB;AACtBM,MAAAA,OAAO,GAAI,iCAAX;AACAC,MAAAA,MAAM,GAAI,qBAAV;AACD;AACF,GAZD,MAYO,IAAIN,EAAE,KAAK,KAAX,EAAkB;AACvB,QAAIC,UAAJ,EAAgB;AACdI,MAAAA,OAAO,GAAG,MAAV;AACAC,MAAAA,MAAM,GAAI,aAAV;AACD,KAHD,MAGO;AACLD,MAAAA,OAAO,GAAI,MAAKR,SAAU,IAAGC,IAAK,EAAlC;AACAQ,MAAAA,MAAM,GAAI,UAASR,IAAK,KAAxB;AACD;AACF;;AAEDI,EAAAA,IAAI,IAAK;AACX,cAAcE,KAAM,KAAIC,OAAQ;AAChC,QAAQC,MAAO;AACf;AACA,GAJE;;AAMA,SAAOJ,IAAP;AACD","sourcesContent":["/**\n * Generate an entry point that uses an entry point IO variable.\n *\n * @param {Object} params\n * @param params.attribute The entry point IO attribute.\n * @param params.type The type to use for the entry point IO variable.\n * @param params.stage The shader stage.\n * @param params.io An \"in|out\" string specifying whether the entry point IO is an input or an output.\n * @param params.use_struct True to wrap the entry point IO in a struct.\n * @returns The generated shader code.\n */\nexport function generateShader({\n  attribute,\n  type,\n  stage,\n  io,\n  use_struct,\n}: {\n  attribute: string;\n  type: string;\n  stage: string;\n  io: string;\n  use_struct: boolean;\n}) {\n  let code = '';\n\n  if (use_struct) {\n    // Generate a struct that wraps the entry point IO variable.\n    code += 'struct S {\\n';\n    code += `  ${attribute} value : ${type};\\n`;\n    if (stage === 'vertex' && io === 'out' && !attribute.includes('builtin(position)')) {\n      // Add position builtin for vertex outputs.\n      code += `  @builtin(position) position : vec4<f32>;\\n`;\n    }\n    code += '};\\n\\n';\n  }\n\n  if (stage !== '') {\n    // Generate the entry point attributes.\n    code += `@stage(${stage})`;\n    if (stage === 'compute') {\n      code += ' @workgroup_size(1)';\n    }\n  }\n\n  // Generate the entry point parameter and return type.\n  let param = '';\n  let retType = '';\n  let retVal = '';\n  if (io === 'in') {\n    if (use_struct) {\n      param = `in : S`;\n    } else {\n      param = `${attribute} value : ${type}`;\n    }\n\n    // Vertex shaders must always return `builtin(position)`.\n    if (stage === 'vertex') {\n      retType = `-> @builtin(position) vec4<f32>`;\n      retVal = `return vec4<f32>();`;\n    }\n  } else if (io === 'out') {\n    if (use_struct) {\n      retType = '-> S';\n      retVal = `return S();`;\n    } else {\n      retType = `-> ${attribute} ${type}`;\n      retVal = `return ${type}();`;\n    }\n  }\n\n  code += `\n    fn main(${param}) ${retType} {\n      ${retVal}\n    }\n  `;\n\n  return code;\n}\n"],"file":"util.js"}