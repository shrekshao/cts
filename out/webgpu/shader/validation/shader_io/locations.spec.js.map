{"version":3,"sources":["../../../../../src/webgpu/shader/validation/shader_io/locations.spec.ts"],"names":["description","makeTestGroup","ShaderValidationTest","generateShader","g","kTestTypes","type","_valid","test","desc","params","u","combine","beginSubcases","fn","t","code","attribute","stage","target_stage","io","target_io","use_struct","expectation","expectCompileResult","combineWithParams","p1","first","p2","second","s1a","s1b","s2a","s2b","ra","rb","firstIsRet","secondIsRet"],"mappings":"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","sourcesContent":["export const description = `Validation tests for entry point user-defined IO`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nimport { generateShader } from './util.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\n// List of types to test against.\nconst kTestTypes = [\n  { type: 'bool', _valid: false },\n  { type: 'u32', _valid: true },\n  { type: 'i32', _valid: true },\n  { type: 'f32', _valid: true },\n  { type: 'vec2<bool>', _valid: false },\n  { type: 'vec2<u32>', _valid: true },\n  { type: 'vec2<i32>', _valid: true },\n  { type: 'vec2<f32>', _valid: true },\n  { type: 'vec3<bool>', _valid: false },\n  { type: 'vec3<u32>', _valid: true },\n  { type: 'vec3<i32>', _valid: true },\n  { type: 'vec3<f32>', _valid: true },\n  { type: 'vec4<bool>', _valid: false },\n  { type: 'vec4<u32>', _valid: true },\n  { type: 'vec4<i32>', _valid: true },\n  { type: 'vec4<f32>', _valid: true },\n  { type: 'mat2x2<f32>', _valid: false },\n  { type: 'mat2x3<f32>', _valid: false },\n  { type: 'mat2x4<f32>', _valid: false },\n  { type: 'mat3x2<f32>', _valid: false },\n  { type: 'mat3x3<f32>', _valid: false },\n  { type: 'mat3x4<f32>', _valid: false },\n  { type: 'mat4x2<f32>', _valid: false },\n  { type: 'mat4x3<f32>', _valid: false },\n  { type: 'mat4x4<f32>', _valid: false },\n  { type: 'atomic<u32>', _valid: false },\n  { type: 'atomic<i32>', _valid: false },\n  { type: 'array<bool,4>', _valid: false },\n  { type: 'array<u32,4>', _valid: false },\n  { type: 'array<i32,4>', _valid: false },\n  { type: 'array<f32,4>', _valid: false },\n  { type: 'MyStruct', _valid: false },\n] as const;\n\ng.test('stage_inout')\n  .desc(`Test validation of user-defined IO stage and in/out usage`)\n  .params(u =>\n    u\n      .combine('use_struct', [true, false] as const)\n      .combine('target_stage', ['vertex', 'fragment', 'compute'] as const)\n      .combine('target_io', ['in', 'out'] as const)\n      .beginSubcases()\n  )\n  .fn(t => {\n    const code = generateShader({\n      attribute: '@location(0)',\n      type: 'f32',\n      stage: t.params.target_stage,\n      io: t.params.target_io,\n      use_struct: t.params.use_struct,\n    });\n\n    // Expect to fail for compute shaders or when used as a non-struct vertex output (since the\n    // position built-in must also be specified).\n    const expectation =\n      t.params.target_stage === 'fragment' ||\n      (t.params.target_stage === 'vertex' && (t.params.target_io === 'in' || t.params.use_struct));\n    t.expectCompileResult(expectation, code);\n  });\n\ng.test('type')\n  .desc(`Test validation of user-defined IO types`)\n  .params(u =>\n    u\n      .combine('use_struct', [true, false] as const)\n      .combineWithParams(kTestTypes)\n      .beginSubcases()\n  )\n  .fn(t => {\n    let code = '';\n\n    if (t.params.type === 'MyStruct') {\n      // Generate a struct that contains a valid type.\n      code += 'struct MyStruct {\\n';\n      code += `  value : f32;\\n`;\n      code += '};\\n\\n';\n    }\n\n    code += generateShader({\n      attribute: '@location(0) @interpolate(flat)',\n      type: t.params.type,\n      stage: 'fragment',\n      io: 'in',\n      use_struct: t.params.use_struct,\n    });\n\n    // Expect to pass iff a valid type is used.\n    t.expectCompileResult(t.params._valid, code);\n  });\n\ng.test('nesting')\n  .desc(`Test validation of nested user-defined IO`)\n  .params(u =>\n    u\n      .combine('target_stage', ['vertex', 'fragment', ''] as const)\n      .combine('target_io', ['in', 'out'] as const)\n      .beginSubcases()\n  )\n  .fn(t => {\n    let code = '';\n\n    // Generate a struct that contains a valid type.\n    code += 'struct Inner {\\n';\n    code += `  @location(0) value : f32;\\n`;\n    code += '};\\n\\n';\n    code += 'struct Outer {\\n';\n    code += `  inner : Inner;\\n`;\n    code += '};\\n\\n';\n\n    code += generateShader({\n      attribute: '',\n      type: 'Outer',\n      stage: t.params.target_stage,\n      io: t.params.target_io,\n      use_struct: false,\n    });\n\n    // Expect to pass only if the struct is not used for entry point IO.\n    t.expectCompileResult(t.params.target_stage === '', code);\n  });\n\ng.test('duplicates')\n  .desc(`Test that duplicated user-defined IO attributes are validated.`)\n  .params(u =>\n    u\n      // Place two @location(0) attributes onto the entry point function.\n      // The function:\n      // - has two non-struct parameters (`p1` and `p2`)\n      // - has two struct parameters each with two members (`s1{a,b}` and `s2{a,b}`)\n      // - returns a struct with two members (`ra` and `rb`)\n      // By default, all of these user-defined IO variables will have unique location attributes.\n      .combine('first', ['p1', 's1a', 's2a', 'ra'] as const)\n      .combine('second', ['p2', 's1b', 's2b', 'rb'] as const)\n      .beginSubcases()\n  )\n  .fn(t => {\n    const p1 = t.params.first === 'p1' ? '0' : '1';\n    const p2 = t.params.second === 'p2' ? '0' : '2';\n    const s1a = t.params.first === 's1a' ? '0' : '3';\n    const s1b = t.params.second === 's1b' ? '0' : '4';\n    const s2a = t.params.first === 's2a' ? '0' : '5';\n    const s2b = t.params.second === 's2b' ? '0' : '6';\n    const ra = t.params.first === 'ra' ? '0' : '1';\n    const rb = t.params.second === 'rb' ? '0' : '2';\n    const code = `\n    struct S1 {\n      @location(${s1a}) a : f32;\n      @location(${s1b}) b : f32;\n    };\n    struct S2 {\n      @location(${s2a}) a : f32;\n      @location(${s2b}) b : f32;\n    };\n    struct R {\n      @location(${ra}) a : f32;\n      @location(${rb}) b : f32;\n    };\n    @stage(fragment)\n    fn main(@location(${p1}) p1 : f32,\n            @location(${p2}) p2 : f32,\n            s1 : S1,\n            s2 : S2,\n            ) -> R {\n      return R();\n    }\n    `;\n\n    // The test should fail if both @location(0) attributes are on the input parameters or\n    // structures, or it they are both on the output struct. Otherwise it should pass.\n    const firstIsRet = t.params.first === 'ra';\n    const secondIsRet = t.params.second === 'rb';\n    const expectation = firstIsRet !== secondIsRet;\n    t.expectCompileResult(expectation, code);\n  });\n"],"file":"locations.spec.js"}