{"version":3,"sources":["../../../../../src/webgpu/shader/validation/shader_io/invariant.spec.ts"],"names":["description","makeTestGroup","ShaderValidationTest","kBuiltins","generateShader","g","test","desc","params","u","combineWithParams","combine","beginSubcases","fn","t","code","attribute","name","type","stage","io","use_struct","expectCompileResult","invariant","use_invariant","suffix","skip","attr"],"mappings":"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","sourcesContent":["export const description = `Validation tests for the invariant attribute`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nimport { kBuiltins } from './builtins.spec.js';\nimport { generateShader } from './util.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\ng.test('valid_only_with_vertex_position_builtin')\n  .desc(`Test that the invariant attribute is only accepted with the vertex position builtin`)\n  .params(u =>\n    u\n      .combineWithParams(kBuiltins)\n      .combine('use_struct', [true, false] as const)\n      .beginSubcases()\n  )\n  .fn(t => {\n    const code = generateShader({\n      attribute: `@builtin(${t.params.name}) @invariant`,\n      type: t.params.type,\n      stage: t.params.stage,\n      io: t.params.io,\n      use_struct: t.params.use_struct,\n    });\n\n    t.expectCompileResult(t.params.name === 'position', code);\n  });\n\ng.test('not_valid_on_user_defined_io')\n  .desc(`Test that the invariant attribute is not accepted on user-defined IO attributes.`)\n  .params(u => u.combine('use_invariant', [true, false] as const).beginSubcases())\n  .fn(t => {\n    const invariant = t.params.use_invariant ? '@invariant' : '';\n    const code = `\n    struct VertexOut {\n      @location(0) ${invariant} loc0 : vec4<f32>,\n      @builtin(position) position : vec4<f32>,\n    };\n    @vertex\n    fn main() -> VertexOut {\n      return VertexOut();\n    }\n    `;\n    t.expectCompileResult(!t.params.use_invariant, code);\n  });\n\ng.test('invalid_use_of_parameters')\n  .desc(`Test that no parameters are accepted for the invariant attribute`)\n  .params(u => u.combine('suffix', ['', '()', '(0)'] as const).beginSubcases())\n  .fn(t => {\n    const code = `\n    struct VertexOut {\n      @builtin(position) @invariant${t.params.suffix} position : vec4<f32>\n    };\n    @vertex\n    fn main() -> VertexOut {\n      return VertexOut();\n    }\n    `;\n    t.expectCompileResult(t.params.suffix === '', code);\n  });\n\ng.test('duplicate')\n  .desc(`Test that the invariant attribute can only be applied once.`)\n  .params(u =>\n    u\n      .combineWithParams(kBuiltins)\n      .combine('use_struct', [true, false] as const)\n      .combine('attr', ['', '@invariant'] as const)\n      .beginSubcases()\n  )\n  .fn(t => {\n    if (t.params.name !== 'position') {\n      t.skip('only valid with position');\n    }\n\n    const code = generateShader({\n      attribute: `@builtin(${t.params.name}) @invariant ${t.params.attr}`,\n      type: t.params.type,\n      stage: t.params.stage,\n      io: t.params.io,\n      use_struct: t.params.use_struct,\n    });\n\n    t.expectCompileResult(t.params.attr === '', code);\n  });\n"],"file":"invariant.spec.js"}