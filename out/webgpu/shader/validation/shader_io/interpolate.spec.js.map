{"version":3,"sources":["../../../../../src/webgpu/shader/validation/shader_io/interpolate.spec.ts"],"names":["description","makeTestGroup","ShaderValidationTest","generateShader","g","kValidInterpolationAttributes","Set","test","desc","params","u","combine","beginSubcases","fn","t","stage","use_struct","skip","interpolate","type","sampling","code","attribute","io","expectCompileResult","has","includes","attr"],"mappings":"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","sourcesContent":["export const description = `Validation tests for the interpolate attribute`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nimport { generateShader } from './util.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\n// List of valid interpolation attributes.\nconst kValidInterpolationAttributes = new Set([\n  '',\n  '@interpolate(flat)',\n  '@interpolate(perspective)',\n  '@interpolate(perspective, center)',\n  '@interpolate(perspective, centroid)',\n  '@interpolate(perspective, sample)',\n  '@interpolate(linear)',\n  '@interpolate(linear, center)',\n  '@interpolate(linear, centroid)',\n  '@interpolate(linear, sample)',\n]);\n\ng.test('type_and_sampling')\n  .desc(`Test that all combinations of interpolation type and sampling are validated correctly.`)\n  .params(u =>\n    u\n      .combine('stage', ['vertex', 'fragment'] as const)\n      .combine('io', ['in', 'out'] as const)\n      .combine('use_struct', [true, false] as const)\n      .combine('type', [\n        '',\n        'flat',\n        'perspective',\n        'linear',\n        'center', // Invalid as first param\n        'centroid', // Invalid as first param\n        'sample', // Invalid as first param\n      ] as const)\n      .combine('sampling', [\n        '',\n        'center',\n        'centroid',\n        'sample',\n        'flat', // Invalid as second param\n        'perspective', // Invalid as second param\n        'linear', // Invalid as second param\n      ] as const)\n      .beginSubcases()\n  )\n  .fn(t => {\n    if (t.params.stage === 'vertex' && t.params.use_struct === false) {\n      t.skip('vertex output must include a position builtin, so must use a struct');\n    }\n\n    let interpolate = '';\n    if (t.params.type !== '' || t.params.sampling !== '') {\n      interpolate = '@interpolate(';\n      if (t.params.type !== '') {\n        interpolate += `${t.params.type}`;\n      }\n      if (t.params.sampling !== '') {\n        interpolate += `, ${t.params.sampling}`;\n      }\n      interpolate += `)`;\n    }\n    const code = generateShader({\n      attribute: '@location(0)' + interpolate,\n      type: 'f32',\n      stage: t.params.stage,\n      io: t.params.io,\n      use_struct: t.params.use_struct,\n    });\n\n    t.expectCompileResult(kValidInterpolationAttributes.has(interpolate), code);\n  });\n\ng.test('require_location')\n  .desc(`Test that the interpolate attribute is only accepted with user-defined IO.`)\n  .params(u =>\n    u\n      .combine('stage', ['vertex', 'fragment'] as const)\n      .combine('attribute', ['@location(0)', '@builtin(position)'] as const)\n      .combine('use_struct', [true, false] as const)\n      .beginSubcases()\n  )\n  .fn(t => {\n    if (\n      t.params.stage === 'vertex' &&\n      t.params.use_struct === false &&\n      !t.params.attribute.includes('position')\n    ) {\n      t.skip('vertex output must include a position builtin, so must use a struct');\n    }\n\n    const code = generateShader({\n      attribute: t.params.attribute + `@interpolate(flat)`,\n      type: 'vec4<f32>',\n      stage: t.params.stage,\n      io: t.params.stage === 'fragment' ? 'in' : 'out',\n      use_struct: t.params.use_struct,\n    });\n    t.expectCompileResult(t.params.attribute === '@location(0)', code);\n  });\n\ng.test('integral_types')\n  .desc(`Test that the implementation requires @interpolate(flat) for integral user-defined IO.`)\n  .params(u =>\n    u\n      .combine('stage', ['vertex', 'fragment'] as const)\n      .combine('type', ['i32', 'u32', 'vec2<i32>', 'vec4<u32>'] as const)\n      .combine('use_struct', [true, false] as const)\n      .combine('attribute', kValidInterpolationAttributes)\n      .beginSubcases()\n  )\n  .fn(t => {\n    if (t.params.stage === 'vertex' && t.params.use_struct === false) {\n      t.skip('vertex output must include a position builtin, so must use a struct');\n    }\n\n    const code = generateShader({\n      attribute: '@location(0)' + t.params.attribute,\n      type: t.params.type,\n      stage: t.params.stage,\n      io: t.params.stage === 'vertex' ? 'out' : 'in',\n      use_struct: t.params.use_struct,\n    });\n\n    t.expectCompileResult(t.params.attribute === '@interpolate(flat)', code);\n  });\n\ng.test('duplicate')\n  .desc(`Test that the interpolate attribute can only be applied once.`)\n  .params(u => u.combine('attr', ['', '@interpolate(flat)'] as const))\n  .fn(t => {\n    const code = generateShader({\n      attribute: `@location(0) @interpolate(flat) ${t.params.attr}`,\n      type: 'vec4<f32>',\n      stage: 'fragment',\n      io: 'in',\n      use_struct: false,\n    });\n    t.expectCompileResult(t.params.attr === '', code);\n  });\n"],"file":"interpolate.spec.js"}