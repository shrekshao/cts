{"version":3,"sources":["../../../../../src/webgpu/shader/validation/parse/literal.spec.ts"],"names":["description","makeTestGroup","ShaderValidationTest","g","test","desc","params","u","combine","beginSubcases","fn","t","code","val","expectCompileResult","wrapInEntryPoint","kAbstractInt","Set","kI32","kU32","kValidIntegers","kInvalidIntegers","has","kValidI32","kInvalidI32","kValidU32","kInvalidU32","kF32","kF16","kAbstractFloat","kValidFloats","kInvalidFloats","kValidF32","kInvalidF32","kValidF16","kInvalidF16","unimplemented"],"mappings":";AAAA;AACA,GADA,OAAO,MAAMA,WAAW,GAAI,+BAArB,CAEP,SAASC,aAAT,QAA8B,4CAA9B;AACA,SAASC,oBAAT,QAAqC,8BAArC;;AAEA,OAAO,MAAMC,CAAC,GAAGF,aAAa,CAACC,oBAAD,CAAvB;;AAEPC,CAAC,CAACC,IAAF,CAAO,OAAP;AACGC,IADH,CACS,qCADT;AAEGC,MAFH,CAEU,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAF,CAAU,KAAV,EAAiB,CAAC,MAAD,EAAS,OAAT,CAAjB,EAAoCC,aAApC,EAFf;AAGGC,EAHH,CAGM,CAAAC,CAAC,KAAI;AACP,QAAMC,IAAI,GAAI,cAAaD,CAAC,CAACL,MAAF,CAASO,GAAI,GAAxC;AACAF,EAAAA,CAAC,CAACG,mBAAF,CAAsB,IAAtB,EAA4BH,CAAC,CAACI,gBAAF,CAAmBH,IAAnB,CAA5B;AACD,CANH;;AAQA,MAAMI,YAAY,GAAG,IAAIC,GAAJ,CAAQ;AAC3B,OAD2B,EAClB;AACT,KAF2B,EAEpB;AACP,GAH2B,EAGtB;AACL,MAJ2B,EAInB;AACR,YAL2B,EAKb;AACd,aAN2B,CAMZ;AANY,CAAR,CAArB;;AASA,MAAMC,IAAI,GAAG,IAAID,GAAJ,CAAQ;AACnB,KADmB,EACZ;AACP,aAFmB,EAEJ;AACf,cAHmB,CAGH;AAHG,CAAR,CAAb;;AAMA,MAAME,IAAI,GAAG,IAAIF,GAAJ,CAAQ;AACnB,KADmB,EACZ;AACP,IAFmB,EAEb;AACN,aAHmB,CAGJ;AAHI,CAAR,CAAb;;AAMA;AACE,QAAMG,cAAc,GAAG,IAAIH,GAAJ,CAAQ,CAAC,GAAGD,YAAJ,EAAkB,GAAGE,IAArB,EAA2B,GAAGC,IAA9B,CAAR,CAAvB;AACA,QAAME,gBAAgB,GAAG,IAAIJ,GAAJ,CAAQ;AAC/B,QAD+B,EACvB;AACR,eAF+B,EAEhB;AACf,gBAH+B,EAGf;AAChB,cAJ+B,EAIjB;AACd,eAL+B,EAKhB;AACf,eAN+B,EAMhB;AACf,OAP+B,CAOxB;AAPwB,GAAR,CAAzB;AASAd,EAAAA,CAAC,CAACC,IAAF,CAAO,cAAP;AACGC,EAAAA,IADH,CACS,2EADT;AAEGC,EAAAA,MAFH,CAEU,CAAAC,CAAC;AACPA,EAAAA,CAAC,CAACC,OAAF,CAAU,KAAV,EAAiB,IAAIS,GAAJ,CAAQ,CAAC,GAAGG,cAAJ,EAAoB,GAAGC,gBAAvB,CAAR,CAAjB,EAAoEZ,aAApE,EAHJ;;AAKGC,EAAAA,EALH,CAKM,CAAAC,CAAC,KAAI;AACP,UAAMC,IAAI,GAAI,cAAaD,CAAC,CAACL,MAAF,CAASO,GAAI,GAAxC;AACAF,IAAAA,CAAC,CAACG,mBAAF,CAAsBM,cAAc,CAACE,GAAf,CAAmBX,CAAC,CAACL,MAAF,CAASO,GAA5B,CAAtB,EAAwDF,CAAC,CAACI,gBAAF,CAAmBH,IAAnB,CAAxD;AACD,GARH;AASD;;AAED;AACE,QAAMW,SAAS,GAAG,IAAIN,GAAJ,CAAQ,CAAC,GAAGD,YAAJ,EAAkB,GAAGE,IAArB,CAAR,CAAlB;AACA,QAAMM,WAAW,GAAG,IAAIP,GAAJ,CAAQ;AAC1B,KAAGE,IADuB;AAE1B,cAF0B,EAEZ;AACd,eAH0B,EAGX;AACf,eAJ0B,EAIX;AACf,gBAL0B,EAKV;AAChB,OAN0B,EAMnB;AACP,QAP0B,EAOlB;AACR,QAR0B,CAQlB;AARkB,GAAR,CAApB;AAUAhB,EAAAA,CAAC,CAACC,IAAF,CAAO,KAAP;AACGC,EAAAA,IADH,CACS,yFADT;AAEGC,EAAAA,MAFH,CAEU,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAF,CAAU,KAAV,EAAiB,IAAIS,GAAJ,CAAQ,CAAC,GAAGM,SAAJ,EAAe,GAAGC,WAAlB,CAAR,CAAjB,EAA0Df,aAA1D,EAFf;AAGGC,EAAAA,EAHH,CAGM,CAAAC,CAAC,KAAI;AACP,UAAMC,IAAI,GAAI,mBAAkBD,CAAC,CAACL,MAAF,CAASO,GAAI,GAA7C;AACAF,IAAAA,CAAC,CAACG,mBAAF,CAAsBS,SAAS,CAACD,GAAV,CAAcX,CAAC,CAACL,MAAF,CAASO,GAAvB,CAAtB,EAAmDF,CAAC,CAACI,gBAAF,CAAmBH,IAAnB,CAAnD;AACD,GANH;AAOD;;AAED;AACE,QAAMa,SAAS,GAAG,IAAIR,GAAJ,CAAQ;AACxB,KAAGD,YADqB;AAExB,KAAGG,IAFqB;AAGxB,cAHwB,CAGV;AAHU,GAAR,CAAlB;AAKA,QAAMO,WAAW,GAAG,IAAIT,GAAJ,CAAQ;AAC1B,KAAGC,IADuB;AAE1B,cAF0B,EAEZ;AACd,eAH0B,EAGX;AACf,MAJ0B,EAIpB;AACN,OAL0B,EAKnB;AACP,QAN0B,EAMlB;AACR,QAP0B,CAOlB;AAPkB,GAAR,CAApB;AASAf,EAAAA,CAAC,CAACC,IAAF,CAAO,KAAP;AACGC,EAAAA,IADH;AAEK,+FAFL;;AAIGC,EAAAA,MAJH,CAIU,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAF,CAAU,KAAV,EAAiB,IAAIS,GAAJ,CAAQ,CAAC,GAAGQ,SAAJ,EAAe,GAAGC,WAAlB,CAAR,CAAjB,EAA0DjB,aAA1D,EAJf;AAKGC,EAAAA,EALH,CAKM,CAAAC,CAAC,KAAI;AACP,UAAMC,IAAI,GAAI,mBAAkBD,CAAC,CAACL,MAAF,CAASO,GAAI,GAA7C;AACAF,IAAAA,CAAC,CAACG,mBAAF,CAAsBW,SAAS,CAACH,GAAV,CAAcX,CAAC,CAACL,MAAF,CAASO,GAAvB,CAAtB,EAAmDF,CAAC,CAACI,gBAAF,CAAmBH,IAAnB,CAAnD;AACD,GARH;AASD;;AAED,MAAMe,IAAI,GAAG,IAAIV,GAAJ,CAAQ;AACnB,IADmB,EACb;AACN,MAFmB,EAEX;AACR,SAHmB,EAGR;AACX,MAJmB,EAIX;AACR,MALmB,EAKX;AACR,SANmB,EAMR;AACX,SAPmB,EAOR;AACX,QARmB,EAQT;AACV,OATmB,EASV;AACT,SAVmB,CAUR;AAVQ,CAAR,CAAb;;AAaA,MAAMW,IAAI,GAAG,IAAIX,GAAJ,CAAQ;AACnB,IADmB,EACb;AACN,IAFmB,EAEb;AACN,KAHmB,EAGZ;AACP,QAJmB,EAIT;AACV,SALmB,EAKR;AACX,SANmB,EAMR;AACX,MAPmB,EAOX;AACR,QARmB,EAQT;AACV,SATmB,EASR;AACX,SAVmB,EAUR;AACX,WAXmB,CAWN;AAXM,CAAR,CAAb;;AAcA,MAAMY,cAAc,GAAG,IAAIZ,GAAJ,CAAQ;AAC7B,KAD6B,EACtB;AACP,IAF6B,EAEvB;AACN,KAH6B,EAGtB;AACP,QAJ6B,EAInB;AACV,KAL6B,EAKtB;AACP,OAN6B,EAMpB;AACT,OAP6B,EAOpB;AACT,QAR6B,EAQnB;AACV,QAT6B,EASnB;AACV,OAV6B,EAUpB;AACT,MAX6B,EAWrB;AACR,MAZ6B,EAYrB;AACR,UAb6B,EAajB;AACZ,UAd6B,EAcjB;AACZ,UAf6B,EAejB;AACZ,UAhB6B,CAgBjB;AAhBiB,CAAR,CAAvB;;AAmBA;AACE,QAAMa,YAAY,GAAG,IAAIb,GAAJ,CAAQ,CAAC,GAAGU,IAAJ,EAAU,GAAGC,IAAb,EAAmB,GAAGC,cAAtB,CAAR,CAArB;AACA,QAAME,cAAc,GAAG,IAAId,GAAJ,CAAQ;AAC7B,MAD6B,EACvB;AACN,QAF6B,EAErB;AACR,UAH6B,EAGnB;AACV,QAJ6B,EAIrB;AACR,SAL6B,EAKpB;AACT,SAN6B,EAMpB;AACT,QAP6B,EAOrB;AACR,SAR6B,EAQpB;AACT,QAT6B,EASrB;AACR,sBAV6B,EAUP;AACtB,wBAX6B,EAWL;AACxB,mBAZ6B,EAYV;AACnB,SAb6B,EAapB;AACT,WAd6B,EAclB;AACX,UAf6B,EAenB;AACV,gBAhB6B,EAgBb;AAChB,kBAjB6B,CAiBX;AAjBW,GAAR,CAAvB;;AAoBAd,EAAAA,CAAC,CAACC,IAAF,CAAO,gBAAP;AACGC,EAAAA,IADH,CACS,sEADT;AAEGC,EAAAA,MAFH,CAEU,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAF,CAAU,KAAV,EAAiB,IAAIS,GAAJ,CAAQ,CAAC,GAAGa,YAAJ,EAAkB,GAAGC,cAArB,CAAR,CAAjB,EAAgEtB,aAAhE,EAFf;AAGGC,EAAAA,EAHH,CAGM,CAAAC,CAAC,KAAI;AACP,UAAMC,IAAI,GAAI,cAAaD,CAAC,CAACL,MAAF,CAASO,GAAI,GAAxC;AACAF,IAAAA,CAAC,CAACG,mBAAF,CAAsBgB,YAAY,CAACR,GAAb,CAAiBX,CAAC,CAACL,MAAF,CAASO,GAA1B,CAAtB,EAAsDF,CAAC,CAACI,gBAAF,CAAmBH,IAAnB,CAAtD;AACD,GANH;AAOD;;AAED;AACE,QAAMoB,SAAS,GAAG,IAAIf,GAAJ,CAAQ;AACxB,KAAGU,IADqB;AAExB,KAAGE,cAFqB;AAGxB,KAHwB,EAGnB;AACL,MAJwB,CAIlB;AAJkB,GAAR,CAAlB;AAMA,QAAMI,WAAW,GAAG,IAAIhB,GAAJ,CAAQ;AAC1B,KAAGW,IADuB,EACjB;AACT,MAF0B,EAEpB;AACN,MAH0B,EAGpB;AACN,MAJ0B,EAIpB;AACN,MAL0B,EAKpB;AACN,QAN0B,EAMlB;AACR,UAP0B,EAOhB;AACV,QAR0B,EAQlB;AACR,SAT0B,EASjB;AACT,SAV0B,EAUjB;AACT,QAX0B,EAWlB;AACR,SAZ0B,EAYjB;AACT,sBAb0B,EAaJ;AACtB,wBAd0B,EAcF;AACxB,mBAf0B,CAeP;AAfO,GAAR,CAApB;;AAkBAzB,EAAAA,CAAC,CAACC,IAAF,CAAO,KAAP;AACGC,EAAAA,IADH,CACS,sEADT;AAEGC,EAAAA,MAFH,CAEU,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAF,CAAU,KAAV,EAAiB,IAAIS,GAAJ,CAAQ,CAAC,GAAGe,SAAJ,EAAe,GAAGC,WAAlB,CAAR,CAAjB,EAA0DxB,aAA1D,EAFf;AAGGC,EAAAA,EAHH,CAGM,CAAAC,CAAC,KAAI;AACP,UAAMC,IAAI,GAAI,mBAAkBD,CAAC,CAACL,MAAF,CAASO,GAAI,GAA7C;AACAF,IAAAA,CAAC,CAACG,mBAAF,CAAsBkB,SAAS,CAACV,GAAV,CAAcX,CAAC,CAACL,MAAF,CAASO,GAAvB,CAAtB,EAAmDF,CAAC,CAACI,gBAAF,CAAmBH,IAAnB,CAAnD;AACD,GANH;AAOD;;AAED;AACE,QAAMsB,SAAS,GAAG,IAAIjB,GAAJ,CAAQ;AACxB,KAAGW,IADqB;AAExB,KAAGC,cAFqB;AAGxB,KAHwB,EAGnB;AACL,MAJwB,CAIlB;AAJkB,GAAR,CAAlB;AAMA,QAAMM,WAAW,GAAG,IAAIlB,GAAJ,CAAQ;AAC1B,KAAGU,IADuB;AAE1B,MAF0B,EAEpB;AACN,MAH0B,EAGpB;AACN,MAJ0B,EAIpB;AACN,SAL0B,EAKjB;AACT,WAN0B,EAMf;AACX,UAP0B,EAOhB;AACV,gBAR0B,EAQV;AAChB,kBAT0B,CASR;AATQ,GAAR,CAApB;;AAYAxB,EAAAA,CAAC,CAACC,IAAF,CAAO,KAAP;AACGC,EAAAA,IADH;AAEK;AACP;AACA;AACA;AACA,CANE;;AAQGC,EAAAA,MARH,CAQU,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAF,CAAU,KAAV,EAAiB,IAAIS,GAAJ,CAAQ,CAAC,GAAGiB,SAAJ,EAAe,GAAGC,WAAlB,CAAR,CAAjB,EAA0D1B,aAA1D,EARf;AASG2B,EAAAA,aATH;AAUD","sourcesContent":["export const description = `Validation tests for literals`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\ng.test('bools')\n  .desc(`Test that valid bools are accepted.`)\n  .params(u => u.combine('val', ['true', 'false']).beginSubcases())\n  .fn(t => {\n    const code = `var test = ${t.params.val};`;\n    t.expectCompileResult(true, t.wrapInEntryPoint(code));\n  });\n\nconst kAbstractInt = new Set([\n  '0x123', // hex number\n  '123', // signed number, no suffix\n  '0', // zero\n  '0x3f', // hex with 'f' as last character\n  '2147483647', // max signed int\n  '-2147483648', // min signed int\n]);\n\nconst kI32 = new Set([\n  '94i', // signed number\n  '2147483647i', // max signed int\n  '-2147483648i', // min signed int\n]);\n\nconst kU32 = new Set([\n  '42u', // unsigned number\n  '0u', // min unsigned int\n  '4294967295u', // max unsigned int\n]);\n\n{\n  const kValidIntegers = new Set([...kAbstractInt, ...kI32, ...kU32]);\n  const kInvalidIntegers = new Set([\n    '0123', // Integer does not start with zero\n    '2147483648i', // max signed int + 1\n    '-2147483649i', // min signed int - 1\n    '4294967295', // a untyped lhs will be i32, so this is too big\n    '4294967295i', // max unsigned int with i suffix\n    '4294967296u', // max unsigned int + 1\n    '-1u', // negative unsigned\n  ]);\n  g.test('abstract_int')\n    .desc(`Test that valid integers are accepted, and invalid integers are rejected.`)\n    .params(u =>\n      u.combine('val', new Set([...kValidIntegers, ...kInvalidIntegers])).beginSubcases()\n    )\n    .fn(t => {\n      const code = `var test = ${t.params.val};`;\n      t.expectCompileResult(kValidIntegers.has(t.params.val), t.wrapInEntryPoint(code));\n    });\n}\n\n{\n  const kValidI32 = new Set([...kAbstractInt, ...kI32]);\n  const kInvalidI32 = new Set([\n    ...kU32,\n    '2147483648', // max signed int + 1\n    '2147483648i', // max signed int + 1\n    '-2147483649', // min signed int - 1\n    '-2147483649i', // min signed int - 1\n    '1.0', // no conversion from float\n    '1.0f', // no conversion from float\n    '1.0h', // no conversion from float\n  ]);\n  g.test('i32')\n    .desc(`Test that valid signed integers are accepted, and invalid signed integers are rejected.`)\n    .params(u => u.combine('val', new Set([...kValidI32, ...kInvalidI32])).beginSubcases())\n    .fn(t => {\n      const code = `var test: i32 = ${t.params.val};`;\n      t.expectCompileResult(kValidI32.has(t.params.val), t.wrapInEntryPoint(code));\n    });\n}\n\n{\n  const kValidU32 = new Set([\n    ...kAbstractInt,\n    ...kU32,\n    '4294967295', // max unsigned\n  ]);\n  const kInvalidU32 = new Set([\n    ...kI32,\n    '4294967296', // max unsigned int + 1\n    '4294967296u', // min unsigned int - 1\n    '-1', // min unsigned int - 1\n    '1.0', // no conversion from float\n    '1.0f', // no conversion from float\n    '1.0h', // no conversion from float\n  ]);\n  g.test('u32')\n    .desc(\n      `Test that valid unsigned integers are accepted, and invalid unsigned integers are rejected.`\n    )\n    .params(u => u.combine('val', new Set([...kValidU32, ...kInvalidU32])).beginSubcases())\n    .fn(t => {\n      const code = `var test: u32 = ${t.params.val};`;\n      t.expectCompileResult(kValidU32.has(t.params.val), t.wrapInEntryPoint(code));\n    });\n}\n\nconst kF32 = new Set([\n  '0f', // Zero float\n  '0.0f', // Zero float\n  '12.223f', // float value\n  '12.f', // .f\n  '.12f', // No leading number with a f\n  '2.4e+4f', // Positive exponent with f suffix\n  '2.4e-2f', // Negative exponent with f suffix\n  '2.e+4f', // Exponent without decimals\n  '1e-4f', // Exponennt without decimal point\n  '0x1P+4f', // Hex float no decimal\n]);\n\nconst kF16 = new Set([\n  '0h', // Zero half\n  '1h', // Half no decimal\n  '.1h', // Half no leading value\n  '1.1e2h', // Exponent half no sign\n  '1.1E+2h', // Exponent half, plus (uppercase E)\n  '2.4e-2h', // Exponent half, negative\n  '0X3h', // Hexfloat half no exponent\n  '0xep2h', // Hexfloat half lower case p\n  '0xEp-2h', // Hexfloat uppcase hex value\n  '0x3p+2h', // Hex float half positive exponent\n  '0x3.2p+2h', // Hex float with decimal half\n]);\n\nconst kAbstractFloat = new Set([\n  '0.0', // Zero float without suffix\n  '.0', // Zero float without leading value\n  '12.', // No decimal points\n  '00012.', // Leading zeros allowed\n  '.12', // No leading digits\n  '1.2e2', // Exponent without sign (lowercase e)\n  '1.2E2', // Exponent without sign (uppercase e)\n  '1.2e+2', // positive exponent\n  '2.4e-2', // Negative exponent\n  '.1e-2', // Exponent without leading number\n  '0x.3', // Hex float, lowercase X\n  '0X.3', // Hex float, uppercase X\n  '0xa.fp+2', // Hex float, lowercase p\n  '0xa.fP+2', // Hex float, uppercase p\n  '0xE.fp+2', // Uppercase E (as hex, but matches non hex exponent char)\n  '0X1.fp-4', // Hex float negative exponent\n]);\n\n{\n  const kValidFloats = new Set([...kF32, ...kF16, ...kAbstractFloat]);\n  const kInvalidFloats = new Set([\n    '.f', // Must have a number\n    '.e-2', // Exponent without leading values\n    '1.e&2f', // Exponent invalid sign\n    '1.ef', // Exponent without value\n    '1.e+f', // Exponent sign no value\n    '0x.p2', // Hex float no value\n    '0x1p', // Hex float missing exponent\n    '0x1p^', // Hex float invalid exponent\n    '1.2h', // fp16 extension not enabled, so this is an error\n    '1.0e+999999999999f', // Too big\n    '0x1.0p+999999999999f', // Too big hex\n    '0x1.00000001pf0', // Mantissa too big\n    '1.1eh', // Missing exponent value\n    '1.1e%2h', // Invalid exponent sign\n    '1.1e+h', // Missing exponent with sign\n    '1.0e+999999h', // Too large\n    '0x1.0p+999999h', // Too large hex\n  ]);\n\n  g.test('abstract_float')\n    .desc(`Test that valid floats are accepted, and invalid floats are rejected`)\n    .params(u => u.combine('val', new Set([...kValidFloats, ...kInvalidFloats])).beginSubcases())\n    .fn(t => {\n      const code = `var test = ${t.params.val};`;\n      t.expectCompileResult(kValidFloats.has(t.params.val), t.wrapInEntryPoint(code));\n    });\n}\n\n{\n  const kValidF32 = new Set([\n    ...kF32,\n    ...kAbstractFloat,\n    '1', // AbstractInt\n    '-1', // AbstractInt\n  ]);\n  const kInvalidF32 = new Set([\n    ...kF16, // no conversion\n    '1u', // unsigned\n    '1i', // signed\n    '1h', // half float\n    '.f', // Must have a number\n    '.e-2', // Exponent without leading values\n    '1.e&2f', // Exponent invalid sign\n    '1.ef', // Exponent without value\n    '1.e+f', // Exponent sign no value\n    '0x.p2', // Hex float no value\n    '0x1p', // Hex float missing exponent\n    '0x1p^', // Hex float invalid exponent\n    '1.0e+999999999999f', // Too big\n    '0x1.0p+999999999999f', // Too big hex\n    '0x1.00000001pf0', // Mantissa too big\n  ]);\n\n  g.test('f32')\n    .desc(`Test that valid floats are accepted, and invalid floats are rejected`)\n    .params(u => u.combine('val', new Set([...kValidF32, ...kInvalidF32])).beginSubcases())\n    .fn(t => {\n      const code = `var test: f32 = ${t.params.val};`;\n      t.expectCompileResult(kValidF32.has(t.params.val), t.wrapInEntryPoint(code));\n    });\n}\n\n{\n  const kValidF16 = new Set([\n    ...kF16,\n    ...kAbstractFloat,\n    '1', // AbstractInt\n    '-1', // AbstractInt\n  ]);\n  const kInvalidF16 = new Set([\n    ...kF32,\n    '1i', // signed int\n    '1u', // unsigned int\n    '1f', // no conversion from f32 to f16\n    '1.1eh', // Missing exponent value\n    '1.1e%2h', // Invalid exponent sign\n    '1.1e+h', // Missing exponent with sign\n    '1.0e+999999h', // Too large\n    '0x1.0p+999999h', // Too large hex\n  ]);\n\n  g.test('f16')\n    .desc(\n      `\nTest that valid half floats are accepted, and invalid half floats are rejected\n\nTODO: Need to inject the 'enable fp16' into the shader to enable the parsing.\n`\n    )\n    .params(u => u.combine('val', new Set([...kValidF16, ...kInvalidF16])).beginSubcases())\n    .unimplemented();\n}\n"],"file":"literal.spec.js"}