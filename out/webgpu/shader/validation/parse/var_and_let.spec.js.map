{"version":3,"sources":["../../../../../src/webgpu/shader/validation/parse/var_and_let.spec.ts"],"names":["description","makeTestGroup","ShaderValidationTest","g","kTestTypes","test","desc","params","u","combine","beginSubcases","fn","t","variableOrConstant","lhsType","rhsType","code","expectation","expectCompileResult"],"mappings":";AAAA;AACA,GADA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA;AACA;AACA,CAJO,CAMP,SAASC,aAAT,QAA8B,4CAA9B;AACA,SAASC,oBAAT,QAAqC,8BAArC;;AAEA,OAAO,MAAMC,CAAC,GAAGF,aAAa,CAACC,oBAAD,CAAvB;;AAEP,MAAME,UAAU,GAAG;AACjB,KADiB;AAEjB,KAFiB;AAGjB,KAHiB;AAIjB,MAJiB;AAKjB,WALiB;AAMjB,WANiB;AAOjB,WAPiB;AAQjB,YARiB;AASjB,WATiB;AAUjB,WAViB;AAWjB,WAXiB;AAYjB,YAZiB;AAajB,WAbiB;AAcjB,WAdiB;AAejB,WAfiB;AAgBjB,YAhBiB;AAiBjB,aAjBiB;AAkBjB,aAlBiB;AAmBjB,aAnBiB;AAoBjB,aApBiB;AAqBjB,aArBiB;AAsBjB,aAtBiB;AAuBjB,aAvBiB;AAwBjB,aAxBiB;AAyBjB,aAzBiB;AA0BjB;AACA,gBA3BiB;AA4BjB,gBA5BiB;AA6BjB,gBA7BiB;AA8BjB,iBA9BiB,CAAnB;;;AAiCAD,CAAC,CAACE,IAAF,CAAO,kBAAP;AACGC,IADH;AAEK;AACL;AACA;AACA;AACA,CANA;;AAQGC,MARH,CAQU,CAAAC,CAAC;AACPA,CAAC;AACEC,OADH,CACW,oBADX,EACiC,CAAC,KAAD,EAAQ,KAAR,CADjC;AAEGC,aAFH;AAGGD,OAHH,CAGW,SAHX,EAGsBL,UAHtB;AAIGK,OAJH,CAIW,SAJX,EAIsBL,UAJtB,CATJ;;AAeGO,EAfH,CAeM,CAAAC,CAAC,KAAI;AACP,QAAM,EAAEC,kBAAF,EAAsBC,OAAtB,EAA+BC,OAA/B,KAA2CH,CAAC,CAACL,MAAnD;;AAEA,QAAMS,IAAI,GAAI;AAClB;AACA;AACA,UAAUH,kBAAmB,QAAOC,OAAQ,MAAKC,OAAQ;AACzD;AACA,KALI;;AAOA,QAAME,WAAW,GAAGH,OAAO,KAAKC,OAAhC;AACAH,EAAAA,CAAC,CAACM,mBAAF,CAAsBD,WAAtB,EAAmCD,IAAnC;AACD,CA3BH","sourcesContent":["export const description = `\nPositive and negative validation tests for variable and const.\n\nTODO: Find a better way to test arrays than using a single arbitrary size. [1]\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\nconst kTestTypes = [\n  'f32',\n  'i32',\n  'u32',\n  'bool',\n  'vec2<f32>',\n  'vec2<i32>',\n  'vec2<u32>',\n  'vec2<bool>',\n  'vec3<f32>',\n  'vec3<i32>',\n  'vec3<u32>',\n  'vec3<bool>',\n  'vec4<f32>',\n  'vec4<i32>',\n  'vec4<u32>',\n  'vec4<bool>',\n  'mat2x2<f32>',\n  'mat2x3<f32>',\n  'mat2x4<f32>',\n  'mat3x2<f32>',\n  'mat3x3<f32>',\n  'mat3x4<f32>',\n  'mat4x2<f32>',\n  'mat4x3<f32>',\n  'mat4x4<f32>',\n  // [1]: 12 is a random number here. find a solution to replace it.\n  'array<f32, 12>',\n  'array<i32, 12>',\n  'array<u32, 12>',\n  'array<bool, 12>',\n] as const;\n\ng.test('initializer_type')\n  .desc(\n    `\n  If present, the initializer's type must match the store type of the variable.\n  Testing scalars, vectors, and matrices of every dimension and type.\n  TODO: add test for: structs - arrays of vectors and matrices - arrays of different length\n`\n  )\n  .params(u =>\n    u\n      .combine('variableOrConstant', ['var', 'let'])\n      .beginSubcases()\n      .combine('lhsType', kTestTypes)\n      .combine('rhsType', kTestTypes)\n  )\n  .fn(t => {\n    const { variableOrConstant, lhsType, rhsType } = t.params;\n\n    const code = `\n      @fragment\n      fn main() {\n        ${variableOrConstant} a : ${lhsType} = ${rhsType}();\n      }\n    `;\n\n    const expectation = lhsType === rhsType;\n    t.expectCompileResult(expectation, code);\n  });\n"],"file":"var_and_let.spec.js"}