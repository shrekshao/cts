{"version":3,"sources":["../../../src/webgpu/shader/types.ts"],"names":["keysOf","assert","align","kArrayLength","HostSharableTypes","kScalarTypeInfo","layout","alignment","size","supportsAtomics","arrayLength","innerLength","undefined","kScalarTypes","kVectorContainerTypeInfo","kVectorContainerTypes","kMatrixContainerTypeInfo","kMatrixContainerTypes","generateTypes","storageClass","baseType","containerType","isAtomic","scalarInfo","scalarType","isHostSharable","toString","type","_kTypeInfo","elementBaseType","vectorType","matrixType","matrixInfo","arrayTypeInfo","arrayStride","elementLayout","sharableType","p","storageMode","supportedScalarTypes","info","isHostShared"],"mappings":"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","sourcesContent":["import { keysOf } from '../../common/util/data_tables.js';\nimport { assert } from '../../common/util/util.js';\nimport { align } from '../util/math.js';\n\nconst kArrayLength = 3;\n\nexport type ContainerType = 'scalar' | 'vector' | 'matrix' | 'atomic' | 'array';\nexport type ScalarType = 'i32' | 'u32' | 'f32' | 'bool';\n\nexport const HostSharableTypes = ['i32', 'u32', 'f32'] as const;\n\n/** Info for each plain scalar type. */\nexport const kScalarTypeInfo = /* prettier-ignore */ {\n  'i32':    { layout: { alignment:  4, size:  4 }, supportsAtomics:  true, arrayLength: 1, innerLength: 0 },\n  'u32':    { layout: { alignment:  4, size:  4 }, supportsAtomics:  true, arrayLength: 1, innerLength: 0 },\n  'f32':    { layout: { alignment:  4, size:  4 }, supportsAtomics: false, arrayLength: 1, innerLength: 0 },\n  'bool':   { layout:                   undefined, supportsAtomics: false, arrayLength: 1, innerLength: 0 },\n} as const;\n/** List of all plain scalar types. */\nexport const kScalarTypes = keysOf(kScalarTypeInfo);\n\n/** Info for each vecN<> container type. */\nexport const kVectorContainerTypeInfo = /* prettier-ignore */ {\n  'vec2':   { layout: { alignment:  8, size:  8 }, arrayLength: 2 , innerLength: 0 },\n  'vec3':   { layout: { alignment: 16, size: 12 }, arrayLength: 3 , innerLength: 0 },\n  'vec4':   { layout: { alignment: 16, size: 16 }, arrayLength: 4 , innerLength: 0 },\n} as const;\n/** List of all vecN<> container types. */\nexport const kVectorContainerTypes = keysOf(kVectorContainerTypeInfo);\n\n/** Info for each matNxN<> container type. */\nexport const kMatrixContainerTypeInfo = /* prettier-ignore */ {\n  'mat2x2': { layout: { alignment:  8, size: 16 }, arrayLength: 2, innerLength: 2 },\n  'mat3x2': { layout: { alignment:  8, size: 24 }, arrayLength: 3, innerLength: 2 },\n  'mat4x2': { layout: { alignment:  8, size: 32 }, arrayLength: 4, innerLength: 2 },\n  'mat2x3': { layout: { alignment: 16, size: 32 }, arrayLength: 2, innerLength: 3 },\n  'mat3x3': { layout: { alignment: 16, size: 48 }, arrayLength: 3, innerLength: 3 },\n  'mat4x3': { layout: { alignment: 16, size: 64 }, arrayLength: 4, innerLength: 3 },\n  'mat2x4': { layout: { alignment: 16, size: 32 }, arrayLength: 2, innerLength: 4 },\n  'mat3x4': { layout: { alignment: 16, size: 48 }, arrayLength: 3, innerLength: 4 },\n  'mat4x4': { layout: { alignment: 16, size: 64 }, arrayLength: 4, innerLength: 4 },\n} as const;\n/** List of all matNxN<> container types. */\nexport const kMatrixContainerTypes = keysOf(kMatrixContainerTypeInfo);\n\nexport type StorageClass = 'storage' | 'uniform' | 'private' | 'function' | 'workgroup';\n\n/**\n * Generate a bunch types (vec, mat, sized/unsized array) for testing.\n */\nexport function* generateTypes({\n  storageClass,\n  baseType,\n  containerType,\n  isAtomic = false,\n}: {\n  storageClass: StorageClass;\n  /** Base scalar type (i32/u32/f32/bool). */\n  baseType: ScalarType;\n  /** Container type (scalar/vector/matrix/array) */\n  containerType: ContainerType;\n  /** Whether to wrap the baseType in `atomic<>`. */\n  isAtomic?: boolean;\n}) {\n  const scalarInfo = kScalarTypeInfo[baseType];\n  if (isAtomic) {\n    assert(scalarInfo.supportsAtomics, 'type does not support atomics');\n  }\n  const scalarType = isAtomic ? `atomic<${baseType}>` : baseType;\n\n  // Storage and uniform require host-sharable types.\n  if (storageClass === 'storage' || storageClass === 'uniform') {\n    assert(isHostSharable(baseType), 'type ' + baseType.toString() + ' is not host sharable');\n  }\n\n  // Scalar types\n  if (containerType === 'scalar') {\n    yield {\n      type: `${scalarType}`,\n      _kTypeInfo: {\n        elementBaseType: `${scalarType}`,\n        ...scalarInfo,\n      },\n    };\n  }\n\n  // Vector types\n  if (containerType === 'vector') {\n    for (const vectorType of kVectorContainerTypes) {\n      yield {\n        type: `${vectorType}<${scalarType}>`,\n        _kTypeInfo: { elementBaseType: baseType, ...kVectorContainerTypeInfo[vectorType] },\n      };\n    }\n  }\n\n  if (containerType === 'matrix') {\n    // Matrices can only be f32.\n    if (baseType === 'f32') {\n      for (const matrixType of kMatrixContainerTypes) {\n        const matrixInfo = kMatrixContainerTypeInfo[matrixType];\n        yield {\n          type: `${matrixType}<${scalarType}>`,\n          _kTypeInfo: {\n            elementBaseType: `vec${matrixInfo.innerLength}<${scalarType}>`,\n            ...matrixInfo,\n          },\n        };\n      }\n    }\n  }\n\n  // Array types\n  if (containerType === 'array') {\n    const arrayTypeInfo = {\n      elementBaseType: `${baseType}`,\n      arrayLength: kArrayLength,\n      layout: scalarInfo.layout\n        ? {\n            alignment: scalarInfo.layout.alignment,\n            size:\n              storageClass === 'uniform'\n                ? // Uniform storage class must have array elements aligned to 16.\n                  kArrayLength *\n                  arrayStride({\n                    ...scalarInfo.layout,\n                    alignment: 16,\n                  })\n                : kArrayLength * arrayStride(scalarInfo.layout),\n          }\n        : undefined,\n    };\n\n    // Sized\n    if (storageClass === 'uniform') {\n      yield {\n        type: `@stride(16) array<${scalarType},${kArrayLength}>`,\n        _kTypeInfo: arrayTypeInfo,\n      };\n    } else {\n      yield { type: `array<${scalarType},${kArrayLength}>`, _kTypeInfo: arrayTypeInfo };\n    }\n    // Unsized\n    if (storageClass === 'storage') {\n      yield { type: `array<${scalarType}>`, _kTypeInfo: arrayTypeInfo };\n    }\n  }\n\n  function arrayStride(elementLayout: { size: number; alignment: number }) {\n    return align(elementLayout.size, elementLayout.alignment);\n  }\n\n  function isHostSharable(baseType: ScalarType) {\n    for (const sharableType of HostSharableTypes) {\n      if (sharableType === baseType) return true;\n    }\n    return false;\n  }\n}\n\n/** Atomic access requires scalar/array container type and storage/workgroup memory. */\nexport function supportsAtomics(p: {\n  storageClass: string;\n  storageMode: string | undefined;\n  access: string;\n  containerType: ContainerType;\n}) {\n  return (\n    ((p.storageClass === 'storage' && p.storageMode === 'read_write') ||\n      p.storageClass === 'workgroup') &&\n    (p.containerType === 'scalar' || p.containerType === 'array')\n  );\n}\n\n/** Generates an iterator of supported base types (i32/u32/f32/bool) */\nexport function* supportedScalarTypes(p: { isAtomic: boolean; storageClass: string }) {\n  for (const scalarType of kScalarTypes) {\n    const info = kScalarTypeInfo[scalarType];\n\n    // Test atomics only on supported scalar types.\n    if (p.isAtomic && !info.supportsAtomics) continue;\n\n    // Storage and uniform require host-sharable types.\n    const isHostShared = p.storageClass === 'storage' || p.storageClass === 'uniform';\n    if (isHostShared && info.layout === undefined) continue;\n\n    yield scalarType;\n  }\n}\n"],"file":"types.js"}