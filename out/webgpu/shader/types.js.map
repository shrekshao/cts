{"version":3,"sources":["../../../src/webgpu/shader/types.ts"],"names":["keysOf","assert","align","kArrayLength","HostSharableTypes","kScalarTypeInfo","layout","alignment","size","supportsAtomics","arrayLength","innerLength","undefined","kScalarTypes","kVectorContainerTypeInfo","kVectorContainerTypes","kMatrixContainerTypeInfo","kMatrixContainerTypes","TexelFormats","format","_shaderType","generateTypes","storageClass","baseType","containerType","isAtomic","scalarInfo","scalarType","isHostSharable","toString","type","_kTypeInfo","elementBaseType","vectorType","matrixType","matrixInfo","arrayTypeInfo","arrayStride","elementLayout","sharableType","p","storageMode","supportedScalarTypes","info","isHostShared"],"mappings":"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","sourcesContent":["import { keysOf } from '../../common/util/data_tables.js';\nimport { assert } from '../../common/util/util.js';\nimport { align } from '../util/math.js';\n\nconst kArrayLength = 3;\n\nexport type ContainerType = 'scalar' | 'vector' | 'matrix' | 'atomic' | 'array';\nexport type ScalarType = 'i32' | 'u32' | 'f32' | 'bool';\n\nexport const HostSharableTypes = ['i32', 'u32', 'f32'] as const;\n\n/** Info for each plain scalar type. */\nexport const kScalarTypeInfo = /* prettier-ignore */ {\n  'i32':    { layout: { alignment:  4, size:  4 }, supportsAtomics:  true, arrayLength: 1, innerLength: 0 },\n  'u32':    { layout: { alignment:  4, size:  4 }, supportsAtomics:  true, arrayLength: 1, innerLength: 0 },\n  'f32':    { layout: { alignment:  4, size:  4 }, supportsAtomics: false, arrayLength: 1, innerLength: 0 },\n  'bool':   { layout:                   undefined, supportsAtomics: false, arrayLength: 1, innerLength: 0 },\n} as const;\n/** List of all plain scalar types. */\nexport const kScalarTypes = keysOf(kScalarTypeInfo);\n\n/** Info for each vecN<> container type. */\nexport const kVectorContainerTypeInfo = /* prettier-ignore */ {\n  'vec2':   { layout: { alignment:  8, size:  8 }, arrayLength: 2 , innerLength: 0 },\n  'vec3':   { layout: { alignment: 16, size: 12 }, arrayLength: 3 , innerLength: 0 },\n  'vec4':   { layout: { alignment: 16, size: 16 }, arrayLength: 4 , innerLength: 0 },\n} as const;\n/** List of all vecN<> container types. */\nexport const kVectorContainerTypes = keysOf(kVectorContainerTypeInfo);\n\n/** Info for each matNxN<> container type. */\nexport const kMatrixContainerTypeInfo = /* prettier-ignore */ {\n  'mat2x2': { layout: { alignment:  8, size: 16 }, arrayLength: 2, innerLength: 2 },\n  'mat3x2': { layout: { alignment:  8, size: 24 }, arrayLength: 3, innerLength: 2 },\n  'mat4x2': { layout: { alignment:  8, size: 32 }, arrayLength: 4, innerLength: 2 },\n  'mat2x3': { layout: { alignment: 16, size: 32 }, arrayLength: 2, innerLength: 3 },\n  'mat3x3': { layout: { alignment: 16, size: 48 }, arrayLength: 3, innerLength: 3 },\n  'mat4x3': { layout: { alignment: 16, size: 64 }, arrayLength: 4, innerLength: 3 },\n  'mat2x4': { layout: { alignment: 16, size: 32 }, arrayLength: 2, innerLength: 4 },\n  'mat3x4': { layout: { alignment: 16, size: 48 }, arrayLength: 3, innerLength: 4 },\n  'mat4x4': { layout: { alignment: 16, size: 64 }, arrayLength: 4, innerLength: 4 },\n} as const;\n/** List of all matNxN<> container types. */\nexport const kMatrixContainerTypes = keysOf(kMatrixContainerTypeInfo);\n\nexport type StorageClass = 'storage' | 'uniform' | 'private' | 'function' | 'workgroup';\n\n/** List of texel formats and their shader representation */\nexport const TexelFormats = [\n  { format: 'rgba8unorm', _shaderType: 'f32' },\n  { format: 'rgba8snorm', _shaderType: 'f32' },\n  { format: 'rgba8uint', _shaderType: 'u32' },\n  { format: 'rgba8sint', _shaderType: 'i32' },\n  { format: 'rgba16uint', _shaderType: 'u32' },\n  { format: 'rgba16sint', _shaderType: 'i32' },\n  { format: 'rgba16float', _shaderType: 'f32' },\n  { format: 'r32uint', _shaderType: 'u32' },\n  { format: 'r32sint', _shaderType: 'i32' },\n  { format: 'r32float', _shaderType: 'f32' },\n  { format: 'rg32uint', _shaderType: 'u32' },\n  { format: 'rg32sint', _shaderType: 'i32' },\n  { format: 'rg32float', _shaderType: 'f32' },\n  { format: 'rgba32uint', _shaderType: 'i32' },\n  { format: 'rgba32sint', _shaderType: 'i32' },\n  { format: 'rgba32float', _shaderType: 'f32' },\n] as const;\n\n/**\n * Generate a bunch types (vec, mat, sized/unsized array) for testing.\n */\nexport function* generateTypes({\n  storageClass,\n  baseType,\n  containerType,\n  isAtomic = false,\n}: {\n  storageClass: StorageClass;\n  /** Base scalar type (i32/u32/f32/bool). */\n  baseType: ScalarType;\n  /** Container type (scalar/vector/matrix/array) */\n  containerType: ContainerType;\n  /** Whether to wrap the baseType in `atomic<>`. */\n  isAtomic?: boolean;\n}) {\n  const scalarInfo = kScalarTypeInfo[baseType];\n  if (isAtomic) {\n    assert(scalarInfo.supportsAtomics, 'type does not support atomics');\n  }\n  const scalarType = isAtomic ? `atomic<${baseType}>` : baseType;\n\n  // Storage and uniform require host-sharable types.\n  if (storageClass === 'storage' || storageClass === 'uniform') {\n    assert(isHostSharable(baseType), 'type ' + baseType.toString() + ' is not host sharable');\n  }\n\n  // Scalar types\n  if (containerType === 'scalar') {\n    yield {\n      type: `${scalarType}`,\n      _kTypeInfo: {\n        elementBaseType: `${scalarType}`,\n        ...scalarInfo,\n      },\n    };\n  }\n\n  // Vector types\n  if (containerType === 'vector') {\n    for (const vectorType of kVectorContainerTypes) {\n      yield {\n        type: `${vectorType}<${scalarType}>`,\n        _kTypeInfo: { elementBaseType: baseType, ...kVectorContainerTypeInfo[vectorType] },\n      };\n    }\n  }\n\n  if (containerType === 'matrix') {\n    // Matrices can only be f32.\n    if (baseType === 'f32') {\n      for (const matrixType of kMatrixContainerTypes) {\n        const matrixInfo = kMatrixContainerTypeInfo[matrixType];\n        yield {\n          type: `${matrixType}<${scalarType}>`,\n          _kTypeInfo: {\n            elementBaseType: `vec${matrixInfo.innerLength}<${scalarType}>`,\n            ...matrixInfo,\n          },\n        };\n      }\n    }\n  }\n\n  // Array types\n  if (containerType === 'array') {\n    const arrayTypeInfo = {\n      elementBaseType: `${baseType}`,\n      arrayLength: kArrayLength,\n      layout: scalarInfo.layout\n        ? {\n            alignment: scalarInfo.layout.alignment,\n            size:\n              storageClass === 'uniform'\n                ? // Uniform storage class must have array elements aligned to 16.\n                  kArrayLength *\n                  arrayStride({\n                    ...scalarInfo.layout,\n                    alignment: 16,\n                  })\n                : kArrayLength * arrayStride(scalarInfo.layout),\n          }\n        : undefined,\n    };\n\n    // Sized\n    if (storageClass === 'uniform') {\n      yield {\n        type: `array<vec4<${scalarType}>,${kArrayLength}>`,\n        _kTypeInfo: arrayTypeInfo,\n      };\n    } else {\n      yield { type: `array<${scalarType},${kArrayLength}>`, _kTypeInfo: arrayTypeInfo };\n    }\n    // Unsized\n    if (storageClass === 'storage') {\n      yield { type: `array<${scalarType}>`, _kTypeInfo: arrayTypeInfo };\n    }\n  }\n\n  function arrayStride(elementLayout: { size: number; alignment: number }) {\n    return align(elementLayout.size, elementLayout.alignment);\n  }\n\n  function isHostSharable(baseType: ScalarType) {\n    for (const sharableType of HostSharableTypes) {\n      if (sharableType === baseType) return true;\n    }\n    return false;\n  }\n}\n\n/** Atomic access requires scalar/array container type and storage/workgroup memory. */\nexport function supportsAtomics(p: {\n  storageClass: string;\n  storageMode: string | undefined;\n  access: string;\n  containerType: ContainerType;\n}) {\n  return (\n    ((p.storageClass === 'storage' && p.storageMode === 'read_write') ||\n      p.storageClass === 'workgroup') &&\n    (p.containerType === 'scalar' || p.containerType === 'array')\n  );\n}\n\n/** Generates an iterator of supported base types (i32/u32/f32/bool) */\nexport function* supportedScalarTypes(p: { isAtomic: boolean; storageClass: string }) {\n  for (const scalarType of kScalarTypes) {\n    const info = kScalarTypeInfo[scalarType];\n\n    // Test atomics only on supported scalar types.\n    if (p.isAtomic && !info.supportsAtomics) continue;\n\n    // Storage and uniform require host-sharable types.\n    const isHostShared = p.storageClass === 'storage' || p.storageClass === 'uniform';\n    if (isHostShared && info.layout === undefined) continue;\n\n    yield scalarType;\n  }\n}\n"],"file":"types.js"}