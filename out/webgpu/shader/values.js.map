{"version":3,"sources":["../../../src/webgpu/shader/values.ts"],"names":["description","assert","uint32ToFloat32","subnormalF32Examples","result_as_bits","max_mantissa","sign_bits","sign_bit","sign_and_exponent","push","lower_bits","length","toString","map","u","normalF32Examples","result","max_mantissa_as_bits","min_exponent_as_bits","max_exponent_as_bits","e","nanF32BitsExamples","exponent_bit","bits","quiet_signalling"],"mappings":"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","sourcesContent":["export const description = `Special and sample values for WGSL scalar types`;\n\nimport { assert } from '../../common/util/util.js';\nimport { uint32ToFloat32 } from '../util/conversion.js';\n\n/** Returns an array of subnormal f32 numbers.\n * Subnormals are non-zero finite numbers with the minimum representable\n * exponent.\n */\nexport function subnormalF32Examples(): Array<number> {\n  // The results, as uint32 values.\n  const result_as_bits: number[] = [];\n\n  const max_mantissa = 0x7f_ffff;\n  const sign_bits = [0, 0x8000_0000];\n  for (const sign_bit of sign_bits) {\n    // exponent bits must be zero.\n    const sign_and_exponent = sign_bit;\n\n    // Set all bits\n    result_as_bits.push(sign_and_exponent | max_mantissa);\n\n    // Set each of the lower bits individually.\n    for (let lower_bits = 1; lower_bits <= max_mantissa; lower_bits <<= 1) {\n      result_as_bits.push(sign_and_exponent | lower_bits);\n    }\n  }\n  assert(\n    result_as_bits.length === 2 * (1 + 23),\n    'subnormal number sample count is ' + result_as_bits.length.toString()\n  );\n  return result_as_bits.map(u => uint32ToFloat32(u));\n}\n\n/** Returns an array of normal f32 numbers.\n * Normal numbers are not: zero, Nan, infinity, subnormal.\n */\nexport function normalF32Examples(): Array<number> {\n  const result: number[] = [1.0, -2.0];\n\n  const max_mantissa_as_bits = 0x7f_ffff;\n  const min_exponent_as_bits = 0x0080_0000;\n  const max_exponent_as_bits = 0x7f00_0000; // Max normal exponent\n  const sign_bits = [0, 0x8000_0000];\n  for (const sign_bit of sign_bits) {\n    for (let e = min_exponent_as_bits; e <= max_exponent_as_bits; e += min_exponent_as_bits) {\n      const sign_and_exponent = sign_bit | e;\n\n      // Set zero mantissa bits\n      result.push(uint32ToFloat32(sign_and_exponent));\n      // Set all mantissa bits\n      result.push(uint32ToFloat32(sign_and_exponent | max_mantissa_as_bits));\n\n      // Set each of the lower bits individually.\n      for (let lower_bits = 1; lower_bits <= max_mantissa_as_bits; lower_bits <<= 1) {\n        result.push(uint32ToFloat32(sign_and_exponent | lower_bits));\n      }\n    }\n  }\n  assert(\n    result.length === 2 + 2 * 254 * 25,\n    'normal number sample count is ' + result.length.toString()\n  );\n  return result;\n}\n\n/** Returns an array of 32-bit NaNs, as Uint32 bit patterns.\n * NaNs have: maximum exponent, but the mantissa is not zero.\n */\nexport function nanF32BitsExamples(): Array<number> {\n  const result: number[] = [];\n  const exponent_bit = 0x7f80_0000;\n  const sign_bits = [0, 0x8000_0000];\n  for (const sign_bit of sign_bits) {\n    const sign_and_exponent = sign_bit | exponent_bit;\n    const bits = sign_and_exponent | 0x40_0000;\n    // Only the most significant bit of the mantissa is set.\n    result.push(bits);\n\n    // Quiet and signalling NaNs differ based on the most significant bit\n    // of the mantissa. Try both.\n    for (const quiet_signalling of [0, 0x40_0000]) {\n      // Set each of the lower bits.\n      for (let lower_bits = 1; lower_bits < 0x40_0000; lower_bits <<= 1) {\n        const bits = sign_and_exponent | quiet_signalling | lower_bits;\n        result.push(bits);\n      }\n    }\n  }\n  return result;\n}\n"],"file":"values.js"}