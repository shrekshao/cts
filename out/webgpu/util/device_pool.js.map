{"version":3,"sources":["../../../src/webgpu/util/device_pool.ts"],"names":["SkipTestCase","attemptGarbageCollection","getGPU","assert","raceWithRejectOnTimeout","assertReject","unreachable","kLimitInfo","kLimits","TestFailedButDeviceReusable","Error","FeaturesNotSupported","TestOOMedShouldAttemptGC","DevicePool","holders","acquire","descriptor","errorMessage","DescriptorToHolderMap","getOrCreate","undefined","ex","name","message","holder","state","beginTestScope","release","DeviceHolder","endTestScope","lostInfo","reason","delete","device","destroy","releaseGPUDevice","expectedDeviceLost","expectedLostReason","unsupported","Set","Map","k","v","uncanonicalizedDescriptor","key","canonicalizeDescriptor","has","JSON","stringify","value","get","set","create","add","insertAndCleanUp","kMaxEntries","size","desc","featuresCanonicalized","requiredFeatures","Array","from","sort","limitsCanonicalized","requiredLimits","limit","requestedValue","defaultValue","default","descriptorCanonicalized","defaultQueue","supportsFeature","adapter","feature","features","gpu","requestAdapter","requestDevice","constructor","_device","lost","then","ev","pushErrorScope","expectDeviceLost","kTimeout","attemptEndTestScope","gpuValidationError","gpuOutOfMemoryError","queue","submit","Promise","all","popErrorScope","onSubmittedWorkDone","GPUValidationError","GPUOutOfMemoryError"],"mappings":"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","sourcesContent":["import { SkipTestCase } from '../../common/framework/fixture.js';\nimport { attemptGarbageCollection } from '../../common/util/collect_garbage.js';\nimport { getGPU } from '../../common/util/navigator_gpu.js';\nimport {\n  assert,\n  raceWithRejectOnTimeout,\n  assertReject,\n  unreachable,\n} from '../../common/util/util.js';\nimport { kLimitInfo, kLimits } from '../capability_info.js';\n\nexport interface DeviceProvider {\n  readonly device: GPUDevice;\n  expectDeviceLost(reason: GPUDeviceLostReason): void;\n}\n\nclass TestFailedButDeviceReusable extends Error {}\nclass FeaturesNotSupported extends Error {}\nexport class TestOOMedShouldAttemptGC extends Error {}\n\nexport class DevicePool {\n  private holders: 'uninitialized' | 'failed' | DescriptorToHolderMap = 'uninitialized';\n\n  /** Acquire a device from the pool and begin the error scopes. */\n  async acquire(descriptor?: UncanonicalizedDeviceDescriptor): Promise<DeviceProvider> {\n    let errorMessage = '';\n    if (this.holders === 'uninitialized') {\n      this.holders = new DescriptorToHolderMap();\n      try {\n        await this.holders.getOrCreate(undefined);\n      } catch (ex) {\n        this.holders = 'failed';\n        if (ex instanceof Error) {\n          errorMessage = ` with ${ex.name} \"${ex.message}\"`;\n        }\n      }\n    }\n\n    assert(\n      this.holders !== 'failed',\n      `WebGPU device failed to initialize${errorMessage}; not retrying`\n    );\n\n    const holder = await this.holders.getOrCreate(descriptor);\n\n    assert(holder.state === 'free', 'Device was in use on DevicePool.acquire');\n    holder.state = 'acquired';\n    holder.beginTestScope();\n    return holder;\n  }\n\n  /**\n   * End the error scopes and check for errors.\n   * Then, if the device seems reusable, release it back into the pool. Otherwise, drop it.\n   */\n  async release(holder: DeviceProvider): Promise<void> {\n    assert(this.holders instanceof DescriptorToHolderMap, 'DevicePool got into a bad state');\n    assert(holder instanceof DeviceHolder, 'DeviceProvider should always be a DeviceHolder');\n\n    assert(holder.state === 'acquired', 'trying to release a device while already released');\n    try {\n      await holder.endTestScope();\n\n      // (Hopefully if the device was lost, it has been reported by the time endErrorScopes()\n      // has finished (or timed out). If not, it could cause a finite number of extra test\n      // failures following this one (but should recover eventually).)\n      assert(\n        holder.lostInfo === undefined,\n        `Device was unexpectedly lost. Reason: ${holder.lostInfo?.reason}, Message: ${holder.lostInfo?.message}`\n      );\n    } catch (ex) {\n      // Any error that isn't explicitly TestFailedButDeviceReusable forces a new device to be\n      // created for the next test.\n      if (!(ex instanceof TestFailedButDeviceReusable)) {\n        this.holders.delete(holder);\n        if ('destroy' in holder.device) {\n          holder.device.destroy();\n        }\n\n        // Release the (hopefully only) ref to the GPUDevice.\n        holder.releaseGPUDevice();\n\n        // Try to clean up, in case there are stray GPU resources in need of collection.\n        if (ex instanceof TestOOMedShouldAttemptGC) {\n          await attemptGarbageCollection();\n        }\n      }\n      // In the try block, we may throw an error if the device is lost in order to force device\n      // reinitialization, however, if the device lost was expected we want to suppress the error\n      // The device lost is expected when `holder.expectedLostReason` is equal to\n      // `holder.lostInfo.reason`.\n      const expectedDeviceLost =\n        holder.expectedLostReason !== undefined &&\n        holder.lostInfo !== undefined &&\n        holder.expectedLostReason === holder.lostInfo.reason;\n      if (!expectedDeviceLost) {\n        throw ex;\n      }\n    } finally {\n      // Mark the holder as free so the device can be reused (if it's still in this.devices).\n      holder.state = 'free';\n    }\n  }\n}\n\n/**\n * Map from GPUDeviceDescriptor to DeviceHolder.\n */\nclass DescriptorToHolderMap {\n  /** Map keys that are known to be unsupported and can be rejected quickly. */\n  private unsupported: Set<string> = new Set();\n  private holders: Map<string, DeviceHolder> = new Map();\n\n  /** Deletes an item from the map by DeviceHolder value. */\n  delete(holder: DeviceHolder): void {\n    for (const [k, v] of this.holders) {\n      if (v === holder) {\n        this.holders.delete(k);\n        return;\n      }\n    }\n    unreachable(\"internal error: couldn't find DeviceHolder to delete\");\n  }\n\n  /**\n   * Gets a DeviceHolder from the map if it exists; otherwise, calls create() to create one,\n   * inserts it, and returns it.\n   *\n   * If an `uncanonicalizedDescriptor` is provided, it is canonicalized and used as the map key.\n   * If one is not provided, the map key is `\"\"` (empty string).\n   *\n   * Throws SkipTestCase if devices with this descriptor are unsupported.\n   */\n  async getOrCreate(\n    uncanonicalizedDescriptor: UncanonicalizedDeviceDescriptor | undefined\n  ): Promise<DeviceHolder> {\n    const [descriptor, key] = canonicalizeDescriptor(uncanonicalizedDescriptor);\n    // Quick-reject descriptors that are known to be unsupported already.\n    if (this.unsupported.has(key)) {\n      throw new SkipTestCase(\n        `GPUDeviceDescriptor previously failed: ${JSON.stringify(descriptor)}`\n      );\n    }\n\n    // Search for an existing device with the same descriptor.\n    {\n      const value = this.holders.get(key);\n      if (value) {\n        // Move it to the end of the Map (most-recently-used).\n        this.holders.delete(key);\n        this.holders.set(key, value);\n        return value;\n      }\n    }\n\n    // No existing item was found; add a new one.\n    let value;\n    try {\n      value = await DeviceHolder.create(descriptor);\n    } catch (ex) {\n      if (ex instanceof FeaturesNotSupported) {\n        this.unsupported.add(key);\n        throw new SkipTestCase(\n          `GPUDeviceDescriptor not supported: ${JSON.stringify(descriptor)}\\n${ex?.message ?? ''}`\n        );\n      }\n\n      throw ex;\n    }\n    this.insertAndCleanUp(key, value);\n    return value;\n  }\n\n  /** Insert an entry, then remove the least-recently-used items if there are too many. */\n  private insertAndCleanUp(key: string, value: DeviceHolder) {\n    this.holders.set(key, value);\n\n    const kMaxEntries = 5;\n    if (this.holders.size > kMaxEntries) {\n      // Delete the first (least recently used) item in the set.\n      for (const [key] of this.holders) {\n        this.holders.delete(key);\n        return;\n      }\n    }\n  }\n}\n\nexport type UncanonicalizedDeviceDescriptor = {\n  requiredFeatures?: Iterable<GPUFeatureName>;\n  requiredLimits?: Record<string, GPUSize32>;\n  /** @deprecated this field cannot be used */\n  nonGuaranteedFeatures?: undefined;\n  /** @deprecated this field cannot be used */\n  nonGuaranteedLimits?: undefined;\n  /** @deprecated this field cannot be used */\n  extensions?: undefined;\n  /** @deprecated this field cannot be used */\n  features?: undefined;\n};\ntype CanonicalDeviceDescriptor = Omit<\n  Required<GPUDeviceDescriptor>,\n  'label' | 'nonGuaranteedFeatures' | 'nonGuaranteedLimits'\n>;\n/**\n * Make a stringified map-key from a GPUDeviceDescriptor.\n * Tries to make sure all defaults are resolved, first - but it's okay if some are missed\n * (it just means some GPUDevice objects won't get deduplicated).\n *\n * This does **not** canonicalize `undefined` (the \"default\" descriptor) into a fully-qualified\n * GPUDeviceDescriptor. This is just because `undefined` is a common case and we want to use it\n * as a sanity check that WebGPU is working.\n */\nfunction canonicalizeDescriptor(\n  desc: UncanonicalizedDeviceDescriptor | undefined\n): [CanonicalDeviceDescriptor | undefined, string] {\n  if (desc === undefined) {\n    return [undefined, ''];\n  }\n\n  const featuresCanonicalized = desc.requiredFeatures\n    ? Array.from(new Set(desc.requiredFeatures)).sort()\n    : [];\n\n  /** Canonicalized version of the requested limits: in canonical order, with only values which are\n   * specified _and_ non-default. */\n  const limitsCanonicalized: Record<string, number> = {};\n  if (desc.requiredLimits) {\n    for (const limit of kLimits) {\n      const requestedValue = desc.requiredLimits[limit];\n      const defaultValue = kLimitInfo[limit].default;\n      // Skip adding a limit to limitsCanonicalized if it is the same as the default.\n      if (requestedValue !== undefined && requestedValue !== defaultValue) {\n        limitsCanonicalized[limit] = requestedValue;\n      }\n    }\n  }\n\n  // Type ensures every field is carried through.\n  const descriptorCanonicalized: CanonicalDeviceDescriptor = {\n    requiredFeatures: featuresCanonicalized,\n    requiredLimits: limitsCanonicalized,\n    defaultQueue: {},\n  };\n  return [descriptorCanonicalized, JSON.stringify(descriptorCanonicalized)];\n}\n\nfunction supportsFeature(\n  adapter: GPUAdapter,\n  descriptor: CanonicalDeviceDescriptor | undefined\n): boolean {\n  if (descriptor === undefined) {\n    return true;\n  }\n\n  for (const feature of descriptor.requiredFeatures) {\n    if (!adapter.features.has(feature)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * DeviceHolder has three states:\n * - 'free': Free to be used for a new test.\n * - 'acquired': In use by a running test.\n */\ntype DeviceHolderState = 'free' | 'acquired';\n\n/**\n * Holds a GPUDevice and tracks its state (free/acquired) and handles device loss.\n */\nclass DeviceHolder implements DeviceProvider {\n  /** The device. Will be cleared during cleanup if there were unexpected errors. */\n  private _device: GPUDevice | undefined;\n  /** Whether the device is in use by a test or not. */\n  state: DeviceHolderState = 'free';\n  /** initially undefined; becomes set when the device is lost */\n  lostInfo?: GPUDeviceLostInfo;\n  /** Set if the device is expected to be lost. */\n  expectedLostReason?: GPUDeviceLostReason;\n\n  // Gets a device and creates a DeviceHolder.\n  // If the device is lost, DeviceHolder.lost gets set.\n  static async create(descriptor: CanonicalDeviceDescriptor | undefined): Promise<DeviceHolder> {\n    const gpu = getGPU();\n    const adapter = await gpu.requestAdapter();\n    assert(adapter !== null, 'requestAdapter returned null');\n    if (!supportsFeature(adapter, descriptor)) {\n      throw new FeaturesNotSupported('One or more features are not supported');\n    }\n    const device = await adapter.requestDevice(descriptor);\n    assert(device !== null, 'requestDevice returned null');\n\n    return new DeviceHolder(device);\n  }\n\n  private constructor(device: GPUDevice) {\n    this._device = device;\n    void this._device.lost.then(ev => {\n      this.lostInfo = ev;\n    });\n  }\n\n  get device() {\n    assert(this._device !== undefined);\n    return this._device;\n  }\n\n  /** Push error scopes that surround test execution. */\n  beginTestScope(): void {\n    assert(this.state === 'acquired');\n    this.device.pushErrorScope('out-of-memory');\n    this.device.pushErrorScope('validation');\n  }\n\n  /** Mark the DeviceHolder as expecting a device loss when the test scope ends. */\n  expectDeviceLost(reason: GPUDeviceLostReason) {\n    assert(this.state === 'acquired');\n    this.expectedLostReason = reason;\n  }\n\n  /**\n   * Attempt to end test scopes: Check that there are no extra error scopes, and that no\n   * otherwise-uncaptured errors occurred during the test. Time out if it takes too long.\n   */\n  endTestScope(): Promise<void> {\n    assert(this.state === 'acquired');\n    const kTimeout = 5000;\n\n    // Time out if attemptEndTestScope (popErrorScope or onSubmittedWorkDone) never completes. If\n    // this rejects, the device won't be reused, so it's OK that popErrorScope calls may not have\n    // finished.\n    //\n    // This could happen due to a browser bug - e.g.,\n    // as of this writing, on Chrome GPU process crash, popErrorScope just hangs.\n    return raceWithRejectOnTimeout(this.attemptEndTestScope(), kTimeout, 'endTestScope timed out');\n  }\n\n  private async attemptEndTestScope(): Promise<void> {\n    let gpuValidationError: GPUError | null;\n    let gpuOutOfMemoryError: GPUError | null;\n\n    // Submit to the queue to attempt to force a GPU flush.\n    this.device.queue.submit([]);\n\n    try {\n      // May reject if the device was lost.\n      [gpuValidationError, gpuOutOfMemoryError] = await Promise.all([\n        this.device.popErrorScope(),\n        this.device.popErrorScope(),\n      ]);\n    } catch (ex) {\n      assert(this.lostInfo !== undefined, 'popErrorScope failed; did beginTestScope get missed?');\n      throw ex;\n    }\n\n    // Attempt to wait for the queue to be idle.\n    if (this.device.queue.onSubmittedWorkDone) {\n      await this.device.queue.onSubmittedWorkDone();\n    }\n\n    await assertReject(\n      this.device.popErrorScope(),\n      'There was an extra error scope on the stack after a test'\n    );\n\n    if (gpuValidationError !== null) {\n      assert(gpuValidationError instanceof GPUValidationError);\n      // Allow the device to be reused.\n      throw new TestFailedButDeviceReusable(\n        `Unexpected validation error occurred: ${gpuValidationError.message}`\n      );\n    }\n    if (gpuOutOfMemoryError !== null) {\n      assert(gpuOutOfMemoryError instanceof GPUOutOfMemoryError);\n      // Don't allow the device to be reused; unexpected OOM could break the device.\n      throw new TestOOMedShouldAttemptGC('Unexpected out-of-memory error occurred');\n    }\n  }\n\n  /**\n   * Release the ref to the GPUDevice. This should be the only ref held by the DevicePool or\n   * GPUTest, so in theory it can get garbage collected.\n   */\n  releaseGPUDevice(): void {\n    this._device = undefined;\n  }\n}\n"],"file":"device_pool.js"}