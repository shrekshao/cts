{"version":3,"sources":["../../../../src/webgpu/util/texture/base.ts"],"names":["assert","unreachable","kTextureFormatInfo","align","reifyExtent3D","maxMipLevelCount","size","dimension","sizeDict","maxMippedDimension","width","Math","max","height","depthOrArrayLayers","floor","log2","physicalMipSize","baseSize","format","level","virtualWidthAtLevel","virtualHeightAtLevel","physicalWidthAtLevel","blockWidth","physicalHeightAtLevel","blockHeight","virtualMipSize","mipLevel","shiftMinOne","n","getTextureDimensionFromView","viewDimension","viewDimensionsForTextureDimension","textureDimension","reifyTextureDescriptor","desc","mipLevelCount","sampleCount","reifyTextureViewDescriptor","textureDescriptor","view","texture","baseMipLevel","baseArrayLayer","aspect","arrayLayerCount","undefined"],"mappings":"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","sourcesContent":["import { assert, unreachable } from '../../../common/util/util.js';\nimport { kTextureFormatInfo } from '../../capability_info.js';\nimport { align } from '../../util/math.js';\nimport { reifyExtent3D } from '../../util/unions.js';\n\n/**\n * Compute the maximum mip level count allowed for a given texture size and texture dimension.\n */\nexport function maxMipLevelCount({\n  size,\n  dimension = '2d',\n}: {\n  readonly size: Readonly<GPUExtent3DDict> | readonly number[];\n  readonly dimension?: GPUTextureDimension;\n}): number {\n  const sizeDict = reifyExtent3D(size);\n\n  let maxMippedDimension = sizeDict.width;\n  if (dimension !== '1d') maxMippedDimension = Math.max(maxMippedDimension, sizeDict.height);\n  if (dimension === '3d')\n    maxMippedDimension = Math.max(maxMippedDimension, sizeDict.depthOrArrayLayers);\n  return Math.floor(Math.log2(maxMippedDimension)) + 1;\n}\n\n/**\n * Compute the \"physical size\" of a mip level: the size of the level, rounded up to a\n * multiple of the texel block size.\n */\nexport function physicalMipSize(\n  baseSize: Required<GPUExtent3DDict>,\n  format: GPUTextureFormat,\n  dimension: GPUTextureDimension,\n  level: number\n): Required<GPUExtent3DDict> {\n  assert(dimension === '2d');\n  assert(Math.max(baseSize.width, baseSize.height) >> level > 0);\n\n  const virtualWidthAtLevel = Math.max(baseSize.width >> level, 1);\n  const virtualHeightAtLevel = Math.max(baseSize.height >> level, 1);\n  const physicalWidthAtLevel = align(virtualWidthAtLevel, kTextureFormatInfo[format].blockWidth);\n  const physicalHeightAtLevel = align(virtualHeightAtLevel, kTextureFormatInfo[format].blockHeight);\n  return {\n    width: physicalWidthAtLevel,\n    height: physicalHeightAtLevel,\n    depthOrArrayLayers: baseSize.depthOrArrayLayers,\n  };\n}\n\n/**\n * Compute the \"virtual size\" of a mip level of a texture (not accounting for texel block rounding).\n */\nexport function virtualMipSize(\n  dimension: GPUTextureDimension,\n  size: readonly [number, number, number],\n  mipLevel: number\n): [number, number, number] {\n  const shiftMinOne = (n: number) => Math.max(1, n >> mipLevel);\n  switch (dimension) {\n    case '1d':\n      assert(size[2] === 1);\n      return [shiftMinOne(size[0]), size[1], size[2]];\n    case '2d':\n      return [shiftMinOne(size[0]), shiftMinOne(size[1]), size[2]];\n    case '3d':\n      return [shiftMinOne(size[0]), shiftMinOne(size[1]), shiftMinOne(size[2])];\n    default:\n      unreachable();\n  }\n}\n\n/**\n * Get texture dimension from view dimension in order to create an compatible texture for a given\n * view dimension.\n */\nexport function getTextureDimensionFromView(viewDimension: GPUTextureViewDimension) {\n  switch (viewDimension) {\n    case '1d':\n      return '1d';\n    case '2d':\n    case '2d-array':\n    case 'cube':\n    case 'cube-array':\n      return '2d';\n    case '3d':\n      return '3d';\n    default:\n      unreachable();\n  }\n}\n\n/** Returns the possible valid view dimensions for a given texture dimension. */\nexport function viewDimensionsForTextureDimension(textureDimension: GPUTextureDimension) {\n  switch (textureDimension) {\n    case '1d':\n      return ['1d'] as const;\n    case '2d':\n      return ['2d', '2d-array', 'cube', 'cube-array'] as const;\n    case '3d':\n      return ['3d'] as const;\n  }\n}\n\n/** Reifies the optional fields of `GPUTextureDescriptor`. */\nexport function reifyTextureDescriptor(\n  desc: Readonly<GPUTextureDescriptor>\n): Required<Omit<GPUTextureDescriptor, 'label'>> {\n  return { dimension: '2d' as const, mipLevelCount: 1, sampleCount: 1, ...desc };\n}\n\n/** Reifies the optional fields of `GPUTextureViewDescriptor` (given a `GPUTextureDescriptor`). */\nexport function reifyTextureViewDescriptor(\n  textureDescriptor: Readonly<GPUTextureDescriptor>,\n  view: Readonly<GPUTextureViewDescriptor>\n): Required<Omit<GPUTextureViewDescriptor, 'label'>> {\n  const texture = reifyTextureDescriptor(textureDescriptor);\n\n  // IDL defaulting\n\n  const baseMipLevel = view.baseMipLevel ?? 0;\n  const baseArrayLayer = view.baseArrayLayer ?? 0;\n  const aspect = view.aspect ?? 'all';\n\n  // Spec defaulting\n\n  const format = view.format ?? texture.format;\n  const mipLevelCount = view.mipLevelCount ?? texture.mipLevelCount - baseMipLevel;\n  const dimension = view.dimension ?? texture.dimension;\n\n  let arrayLayerCount = view.arrayLayerCount;\n  if (arrayLayerCount === undefined) {\n    if (dimension === '2d-array' || dimension === 'cube-array') {\n      arrayLayerCount = reifyExtent3D(texture.size).depthOrArrayLayers - baseArrayLayer;\n    } else if (dimension === 'cube') {\n      arrayLayerCount = 6;\n    } else {\n      arrayLayerCount = 1;\n    }\n  }\n\n  return {\n    format,\n    dimension,\n    aspect,\n    baseMipLevel,\n    mipLevelCount,\n    baseArrayLayer,\n    arrayLayerCount,\n  };\n}\n"],"file":"base.js"}