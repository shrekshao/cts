{"version":3,"sources":["../../../../src/webgpu/util/texture/base.ts"],"names":["assert","unreachable","kTextureFormatInfo","align","standardizeExtent3D","maxMipLevelCount","size","dimension","sizeDict","maxMippedDimension","width","Math","max","height","depthOrArrayLayers","floor","log2","physicalMipSize","baseSize","format","level","virtualWidthAtLevel","virtualHeightAtLevel","physicalWidthAtLevel","blockWidth","physicalHeightAtLevel","blockHeight","virtualMipSize","mipLevel","shiftMinOne","n"],"mappings":";AAAA;AACA,GADA,SAASA,MAAT,EAAiBC,WAAjB,QAAoC,8BAApC,CACA,SAASC,kBAAT,QAAmC,0BAAnC,CACA,SAASC,KAAT,QAAsB,oBAAtB;AACA,SAASC,mBAAT,QAAoC,sBAApC;;AAEA;AACA;AACA;AACA,OAAO,SAASC,gBAAT,CAA0B;AAC/BC,EAAAA,IAD+B;AAE/BC,EAAAA,SAAS,GAAG,IAFmB,EAA1B;;;;AAMI;AACT,QAAMC,QAAQ,GAAGJ,mBAAmB,CAACE,IAAD,CAApC;;AAEA,MAAIG,kBAAkB,GAAGD,QAAQ,CAACE,KAAlC;AACA,MAAIH,SAAS,KAAK,IAAlB,EAAwBE,kBAAkB,GAAGE,IAAI,CAACC,GAAL,CAASH,kBAAT,EAA6BD,QAAQ,CAACK,MAAtC,CAArB;AACxB,MAAIN,SAAS,KAAK,IAAlB;AACEE,EAAAA,kBAAkB,GAAGE,IAAI,CAACC,GAAL,CAASH,kBAAT,EAA6BD,QAAQ,CAACM,kBAAtC,CAArB;AACF,SAAOH,IAAI,CAACI,KAAL,CAAWJ,IAAI,CAACK,IAAL,CAAUP,kBAAV,CAAX,IAA4C,CAAnD;AACD;;AAED;AACA;AACA;AACA;AACA,OAAO,SAASQ,eAAT;AACLC,QADK;AAELC,MAFK;AAGLZ,SAHK;AAILa,KAJK;AAKsB;AAC3BpB,EAAAA,MAAM,CAACO,SAAS,KAAK,IAAf,CAAN;AACAP,EAAAA,MAAM,CAACW,IAAI,CAACC,GAAL,CAASM,QAAQ,CAACR,KAAlB,EAAyBQ,QAAQ,CAACL,MAAlC,KAA6CO,KAA7C,GAAqD,CAAtD,CAAN;;AAEA,QAAMC,mBAAmB,GAAGV,IAAI,CAACC,GAAL,CAASM,QAAQ,CAACR,KAAT,IAAkBU,KAA3B,EAAkC,CAAlC,CAA5B;AACA,QAAME,oBAAoB,GAAGX,IAAI,CAACC,GAAL,CAASM,QAAQ,CAACL,MAAT,IAAmBO,KAA5B,EAAmC,CAAnC,CAA7B;AACA,QAAMG,oBAAoB,GAAGpB,KAAK,CAACkB,mBAAD,EAAsBnB,kBAAkB,CAACiB,MAAD,CAAlB,CAA2BK,UAAjD,CAAlC;AACA,QAAMC,qBAAqB,GAAGtB,KAAK,CAACmB,oBAAD,EAAuBpB,kBAAkB,CAACiB,MAAD,CAAlB,CAA2BO,WAAlD,CAAnC;AACA,SAAO;AACLhB,IAAAA,KAAK,EAAEa,oBADF;AAELV,IAAAA,MAAM,EAAEY,qBAFH;AAGLX,IAAAA,kBAAkB,EAAEI,QAAQ,CAACJ,kBAHxB,EAAP;;AAKD;;AAED;AACA;AACA;AACA,OAAO,SAASa,cAAT;AACLpB,SADK;AAELD,IAFK;AAGLsB,QAHK;AAIqB;AAC1B,QAAMC,WAAW,GAAIC,CAAD,IAAenB,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYkB,CAAC,IAAIF,QAAjB,CAAnC;AACA,UAAQrB,SAAR;AACE,SAAK,IAAL;AACEP,MAAAA,MAAM,CAACM,IAAI,CAAC,CAAD,CAAJ,KAAY,CAAb,CAAN;AACA,aAAO,CAACuB,WAAW,CAACvB,IAAI,CAAC,CAAD,CAAL,CAAZ,EAAuBA,IAAI,CAAC,CAAD,CAA3B,EAAgCA,IAAI,CAAC,CAAD,CAApC,CAAP;AACF,SAAK,IAAL;AACE,aAAO,CAACuB,WAAW,CAACvB,IAAI,CAAC,CAAD,CAAL,CAAZ,EAAuBuB,WAAW,CAACvB,IAAI,CAAC,CAAD,CAAL,CAAlC,EAA6CA,IAAI,CAAC,CAAD,CAAjD,CAAP;AACF,SAAK,IAAL;AACE,aAAO,CAACuB,WAAW,CAACvB,IAAI,CAAC,CAAD,CAAL,CAAZ,EAAuBuB,WAAW,CAACvB,IAAI,CAAC,CAAD,CAAL,CAAlC,EAA6CuB,WAAW,CAACvB,IAAI,CAAC,CAAD,CAAL,CAAxD,CAAP;AACF;AACEL,MAAAA,WAAW,GATf;;AAWD","sourcesContent":["import { assert, unreachable } from '../../../common/util/util.js';\nimport { kTextureFormatInfo } from '../../capability_info.js';\nimport { align } from '../../util/math.js';\nimport { standardizeExtent3D } from '../../util/unions.js';\n\n/**\n * Compute the maximum mip level count allowed for a given texture size and texture dimension.\n */\nexport function maxMipLevelCount({\n  size,\n  dimension = '2d',\n}: {\n  readonly size: Readonly<GPUExtent3DDict> | readonly number[];\n  readonly dimension?: GPUTextureDimension;\n}): number {\n  const sizeDict = standardizeExtent3D(size);\n\n  let maxMippedDimension = sizeDict.width;\n  if (dimension !== '1d') maxMippedDimension = Math.max(maxMippedDimension, sizeDict.height);\n  if (dimension === '3d')\n    maxMippedDimension = Math.max(maxMippedDimension, sizeDict.depthOrArrayLayers);\n  return Math.floor(Math.log2(maxMippedDimension)) + 1;\n}\n\n/**\n * Compute the \"physical size\" of a mip level: the size of the level, rounded up to a\n * multiple of the texel block size.\n */\nexport function physicalMipSize(\n  baseSize: Required<GPUExtent3DDict>,\n  format: GPUTextureFormat,\n  dimension: GPUTextureDimension,\n  level: number\n): Required<GPUExtent3DDict> {\n  assert(dimension === '2d');\n  assert(Math.max(baseSize.width, baseSize.height) >> level > 0);\n\n  const virtualWidthAtLevel = Math.max(baseSize.width >> level, 1);\n  const virtualHeightAtLevel = Math.max(baseSize.height >> level, 1);\n  const physicalWidthAtLevel = align(virtualWidthAtLevel, kTextureFormatInfo[format].blockWidth);\n  const physicalHeightAtLevel = align(virtualHeightAtLevel, kTextureFormatInfo[format].blockHeight);\n  return {\n    width: physicalWidthAtLevel,\n    height: physicalHeightAtLevel,\n    depthOrArrayLayers: baseSize.depthOrArrayLayers,\n  };\n}\n\n/**\n * Compute the \"virtual size\" of a mip level of a texture (not accounting for texel block rounding).\n */\nexport function virtualMipSize(\n  dimension: GPUTextureDimension,\n  size: readonly [number, number, number],\n  mipLevel: number\n): [number, number, number] {\n  const shiftMinOne = (n: number) => Math.max(1, n >> mipLevel);\n  switch (dimension) {\n    case '1d':\n      assert(size[2] === 1);\n      return [shiftMinOne(size[0]), size[1], size[2]];\n    case '2d':\n      return [shiftMinOne(size[0]), shiftMinOne(size[1]), size[2]];\n    case '3d':\n      return [shiftMinOne(size[0]), shiftMinOne(size[1]), shiftMinOne(size[2])];\n    default:\n      unreachable();\n  }\n}\n"],"file":"base.js"}