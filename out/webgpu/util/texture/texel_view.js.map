{"version":3,"sources":["../../../../src/webgpu/util/texture/texel_view.ts"],"names":["assert","memcpy","kTextureFormatInfo","reifyExtent3D","reifyOrigin3D","kTexelRepresentationInfo","makeClampToRange","TexelView","constructor","format","bytes","ulpFromZero","color","fromTextureDataByReference","subrectData","bytesPerRow","rowsPerImage","subrectOrigin","subrectSize","origin","size","info","blockWidth","blockHeight","fromTexelsAsBytes","coords","x","y","z","width","height","depthOrArrayLayers","imageOffsetInRows","rowOffset","offset","bytesPerBlock","subarray","generator","repr","bitsToULPFromZero","unpackBits","bitsToNumber","fromTexelsAsColors","clampToFormatRange","applyClamp","oldGenerator","Uint8Array","pack","encode","numberToBits","writeTextureData","subrectOrigin_","subrectSize_","start","src","dst"],"mappings":"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","sourcesContent":["import { assert, memcpy } from '../../../common/util/util.js';\nimport { EncodableTextureFormat, kTextureFormatInfo } from '../../capability_info.js';\nimport { reifyExtent3D, reifyOrigin3D } from '../unions.js';\n\nimport { kTexelRepresentationInfo, makeClampToRange, PerTexelComponent } from './texel_data.js';\n\n/** Function taking some x,y,z coordinates and returning `Readonly<T>`. */\nexport type PerPixelAtLevel<T> = (coords: Required<GPUOrigin3DDict>) => Readonly<T>;\n\n/**\n * Wrapper to view various representations of texture data in other ways. E.g., can:\n * - Provide a mapped buffer, containing copied texture data, and read color values.\n * - Provide a function that generates color values by coordinate, and convert to ULPs-from-zero.\n *\n * MAINTENANCE_TODO: Would need some refactoring to support block formats, which could be partially\n * supported if useful.\n */\nexport class TexelView {\n  /** The GPUTextureFormat of the TexelView. */\n  readonly format: EncodableTextureFormat;\n  /** Generates the bytes for the texel at the given coordinates. */\n  readonly bytes: PerPixelAtLevel<Uint8Array>;\n  /** Generates the ULPs-from-zero for the texel at the given coordinates. */\n  readonly ulpFromZero: PerPixelAtLevel<PerTexelComponent<number>>;\n  /** Generates the color for the texel at the given coordinates. */\n  readonly color: PerPixelAtLevel<PerTexelComponent<number>>;\n\n  private constructor(\n    format: EncodableTextureFormat,\n    {\n      bytes,\n      ulpFromZero,\n      color,\n    }: {\n      bytes: PerPixelAtLevel<Uint8Array>;\n      ulpFromZero: PerPixelAtLevel<PerTexelComponent<number>>;\n      color: PerPixelAtLevel<PerTexelComponent<number>>;\n    }\n  ) {\n    this.format = format;\n    this.bytes = bytes;\n    this.ulpFromZero = ulpFromZero;\n    this.color = color;\n  }\n\n  /**\n   * Produces a TexelView from \"linear image data\", i.e. the `writeTexture` format. Takes a\n   * reference to the input `subrectData`, so any changes to it will be visible in the TexelView.\n   */\n  static fromTextureDataByReference(\n    format: EncodableTextureFormat,\n    subrectData: Uint8Array | Uint8ClampedArray,\n    {\n      bytesPerRow,\n      rowsPerImage,\n      subrectOrigin,\n      subrectSize,\n    }: {\n      bytesPerRow: number;\n      rowsPerImage: number;\n      subrectOrigin: GPUOrigin3D;\n      subrectSize: GPUExtent3D;\n    }\n  ) {\n    const origin = reifyOrigin3D(subrectOrigin);\n    const size = reifyExtent3D(subrectSize);\n\n    const info = kTextureFormatInfo[format];\n    assert(info.blockWidth === 1 && info.blockHeight === 1, 'unimplemented for block formats');\n\n    return TexelView.fromTexelsAsBytes(format, coords => {\n      assert(\n        coords.x >= origin.x &&\n          coords.y >= origin.y &&\n          coords.z >= origin.z &&\n          coords.x < size.width &&\n          coords.y < size.height &&\n          coords.z < size.depthOrArrayLayers,\n        'coordinate out of bounds'\n      );\n\n      const imageOffsetInRows = (coords.z - origin.z) * rowsPerImage;\n      const rowOffset = (imageOffsetInRows + (coords.y - origin.y)) * bytesPerRow;\n      const offset = rowOffset + (coords.x - origin.x) * info.bytesPerBlock;\n\n      // MAINTENANCE_TODO: To support block formats, decode the block and then index into the result.\n      return subrectData.subarray(offset, offset + info.bytesPerBlock) as Uint8Array;\n    });\n  }\n\n  /** Produces a TexelView from a generator of bytes for individual texel blocks. */\n  static fromTexelsAsBytes(\n    format: EncodableTextureFormat,\n    generator: PerPixelAtLevel<Uint8Array>\n  ): TexelView {\n    const info = kTextureFormatInfo[format];\n    assert(info.blockWidth === 1 && info.blockHeight === 1, 'unimplemented for block formats');\n\n    const repr = kTexelRepresentationInfo[format];\n    return new TexelView(format, {\n      bytes: generator,\n      ulpFromZero: coords => repr.bitsToULPFromZero(repr.unpackBits(generator(coords))),\n      color: coords => repr.bitsToNumber(repr.unpackBits(generator(coords))),\n    });\n  }\n\n  /** Produces a TexelView from a generator of numeric \"color\" values for each texel. */\n  static fromTexelsAsColors(\n    format: EncodableTextureFormat,\n    generator: PerPixelAtLevel<PerTexelComponent<number>>,\n    { clampToFormatRange = false }: { clampToFormatRange?: boolean } = {}\n  ): TexelView {\n    const info = kTextureFormatInfo[format];\n    assert(info.blockWidth === 1 && info.blockHeight === 1, 'unimplemented for block formats');\n\n    if (clampToFormatRange) {\n      const applyClamp = makeClampToRange(format);\n      const oldGenerator = generator;\n      generator = coords => applyClamp(oldGenerator(coords));\n    }\n\n    const repr = kTexelRepresentationInfo[format];\n    return new TexelView(format, {\n      bytes: coords => new Uint8Array(repr.pack(repr.encode(generator(coords)))),\n      ulpFromZero: coords => repr.bitsToULPFromZero(repr.numberToBits(generator(coords))),\n      color: generator,\n    });\n  }\n\n  /** Writes the contents of a TexelView as \"linear image data\", i.e. the `writeTexture` format. */\n  writeTextureData(\n    subrectData: Uint8Array | Uint8ClampedArray,\n    {\n      bytesPerRow,\n      rowsPerImage,\n      subrectOrigin: subrectOrigin_,\n      subrectSize: subrectSize_,\n    }: {\n      bytesPerRow: number;\n      rowsPerImage: number;\n      subrectOrigin: GPUOrigin3D;\n      subrectSize: GPUExtent3D;\n    }\n  ): void {\n    const subrectOrigin = reifyOrigin3D(subrectOrigin_);\n    const subrectSize = reifyExtent3D(subrectSize_);\n\n    const info = kTextureFormatInfo[this.format];\n    assert(info.blockWidth === 1 && info.blockHeight === 1, 'unimplemented for block formats');\n\n    for (let z = subrectOrigin.z; z < subrectOrigin.z + subrectSize.depthOrArrayLayers; ++z) {\n      for (let y = subrectOrigin.y; y < subrectOrigin.y + subrectSize.height; ++y) {\n        for (let x = subrectOrigin.x; x < subrectOrigin.x + subrectSize.width; ++x) {\n          const start = (z * rowsPerImage + y) * bytesPerRow + x * info.bytesPerBlock;\n          memcpy({ src: this.bytes({ x, y, z }) }, { dst: subrectData, start });\n        }\n      }\n    }\n  }\n}\n"],"file":"texel_view.js"}