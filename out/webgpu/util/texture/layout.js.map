{"version":3,"sources":["../../../../src/webgpu/util/texture/layout.ts"],"names":["assert","memcpy","kTextureFormatInfo","align","reifyExtent3D","physicalMipSize","virtualMipSize","kBytesPerRowAlignment","kBufferCopyAlignment","kDefaultLayoutOptions","mipLevel","bytesPerRow","undefined","rowsPerImage","getTextureCopyLayout","format","dimension","baseSize","mipSize","width","height","depthOrArrayLayers","layout","getTextureSubCopyLayout","copySize","blockWidth","blockHeight","bytesPerBlock","copySize_","copySizeBlocks","minBytesPerRow","alignedMinBytesPerRow","bytesPerSlice","sliceSize","byteLength","fillTextureDataWithTexelValue","texelValue","outputBuffer","size","options","outputTexelValueBytes","Uint8Array","slice","row","col","byteOffset","src","dst","start","createTextureUploadBuffer","device","buffer","createBuffer","mappedAtCreation","usage","GPUBufferUsage","COPY_SRC","mapping","getMappedRange","unmap","kImageCopyTypes","bytesInACompleteRow","copyWidth","info","validateBytesPerRow","bytesInLastRow","sizeInBlocks","validateRowsPerImage","dataBytesForCopyOrFail","args","minDataSizeOrOverestimate","copyValid","dataBytesForCopyOrOverestimate","method","copyExtent","valid","offset","requiredBytesInCopy","bytesPerImage","bytesBeforeLastImage"],"mappings":"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","sourcesContent":["import { assert, memcpy } from '../../../common/util/util.js';\nimport {\n  EncodableTextureFormat,\n  kTextureFormatInfo,\n  SizedTextureFormat,\n} from '../../capability_info.js';\nimport { align } from '../math.js';\nimport { reifyExtent3D } from '../unions.js';\n\nimport { physicalMipSize, virtualMipSize } from './base.js';\n\n/** The minimum `bytesPerRow` alignment, per spec. */\nexport const kBytesPerRowAlignment = 256;\n/** The minimum buffer copy alignment, per spec. */\nexport const kBufferCopyAlignment = 4;\n\n/**\n * Overridable layout options for {@link getTextureCopyLayout}.\n */\nexport interface LayoutOptions {\n  mipLevel: number;\n  bytesPerRow?: number;\n  rowsPerImage?: number;\n}\n\nconst kDefaultLayoutOptions = { mipLevel: 0, bytesPerRow: undefined, rowsPerImage: undefined };\n\n/** The info returned by {@link getTextureSubCopyLayout}. */\nexport interface TextureSubCopyLayout {\n  bytesPerBlock: number;\n  byteLength: number;\n  /** Number of bytes in each row, not accounting for {@link kBytesPerRowAlignment}. */\n  minBytesPerRow: number;\n  /**\n   * Actual value of bytesPerRow, defaulting to `align(minBytesPerRow, kBytesPerRowAlignment}`\n   * if not overridden.\n   */\n  bytesPerRow: number;\n  /** Actual value of rowsPerImage, defaulting to `mipSize[1]` if not overridden. */\n  rowsPerImage: number;\n}\n\n/** The info returned by {@link getTextureCopyLayout}. */\nexport interface TextureCopyLayout extends TextureSubCopyLayout {\n  mipSize: [number, number, number];\n}\n\n/**\n * Computes layout information for a copy of the whole subresource at `mipLevel` of a GPUTexture\n * of size `baseSize` with the provided `format` and `dimension`.\n *\n * Computes default values for `bytesPerRow` and `rowsPerImage` if not specified.\n *\n * MAINTENANCE_TODO: Change input/output to Required<GPUExtent3DDict> for consistency.\n */\nexport function getTextureCopyLayout(\n  format: SizedTextureFormat,\n  dimension: GPUTextureDimension,\n  baseSize: readonly [number, number, number],\n  { mipLevel, bytesPerRow, rowsPerImage }: LayoutOptions = kDefaultLayoutOptions\n): TextureCopyLayout {\n  const mipSize = physicalMipSize(\n    { width: baseSize[0], height: baseSize[1], depthOrArrayLayers: baseSize[2] },\n    format,\n    dimension,\n    mipLevel\n  );\n\n  const layout = getTextureSubCopyLayout(format, mipSize, { bytesPerRow, rowsPerImage });\n  return { ...layout, mipSize: [mipSize.width, mipSize.height, mipSize.depthOrArrayLayers] };\n}\n\n/**\n * Computes layout information for a copy of size `copySize` to/from a GPUTexture with the provided\n * `format`.\n *\n * Computes default values for `bytesPerRow` and `rowsPerImage` if not specified.\n */\nexport function getTextureSubCopyLayout(\n  format: SizedTextureFormat,\n  copySize: GPUExtent3D,\n  {\n    bytesPerRow,\n    rowsPerImage,\n  }: { readonly bytesPerRow?: number; readonly rowsPerImage?: number } = {}\n): TextureSubCopyLayout {\n  const { blockWidth, blockHeight, bytesPerBlock } = kTextureFormatInfo[format];\n\n  const copySize_ = reifyExtent3D(copySize);\n  assert(\n    copySize_.width > 0 && copySize_.height > 0 && copySize_.depthOrArrayLayers > 0,\n    'not implemented for empty copySize'\n  );\n  assert(\n    copySize_.width % blockWidth === 0 && copySize_.height % blockHeight === 0,\n    'copySize must be a multiple of the block size'\n  );\n  const copySizeBlocks = {\n    width: copySize_.width / blockWidth,\n    height: copySize_.height / blockHeight,\n    depthOrArrayLayers: copySize_.depthOrArrayLayers,\n  };\n\n  const minBytesPerRow = copySizeBlocks.width * bytesPerBlock;\n  const alignedMinBytesPerRow = align(minBytesPerRow, kBytesPerRowAlignment);\n  if (bytesPerRow !== undefined) {\n    assert(bytesPerRow >= alignedMinBytesPerRow);\n    assert(bytesPerRow % kBytesPerRowAlignment === 0);\n  } else {\n    bytesPerRow = alignedMinBytesPerRow;\n  }\n\n  if (rowsPerImage !== undefined) {\n    assert(rowsPerImage >= copySizeBlocks.height);\n  } else {\n    rowsPerImage = copySizeBlocks.height;\n  }\n\n  const bytesPerSlice = bytesPerRow * rowsPerImage;\n  const sliceSize =\n    bytesPerRow * (copySizeBlocks.height - 1) + bytesPerBlock * copySizeBlocks.width;\n  const byteLength = bytesPerSlice * (copySizeBlocks.depthOrArrayLayers - 1) + sliceSize;\n\n  return {\n    bytesPerBlock,\n    byteLength: align(byteLength, kBufferCopyAlignment),\n    minBytesPerRow,\n    bytesPerRow,\n    rowsPerImage,\n  };\n}\n\n/**\n * Fill an ArrayBuffer with the linear-memory representation of a solid-color\n * texture where every texel has the byte value `texelValue`.\n * Preserves the contents of `outputBuffer` which are in \"padding\" space between image rows.\n *\n * Effectively emulates a copyTextureToBuffer from a solid-color texture to a buffer.\n */\nexport function fillTextureDataWithTexelValue(\n  texelValue: ArrayBuffer,\n  format: EncodableTextureFormat,\n  dimension: GPUTextureDimension,\n  outputBuffer: ArrayBuffer,\n  size: [number, number, number],\n  options: LayoutOptions = kDefaultLayoutOptions\n): void {\n  const { blockWidth, blockHeight, bytesPerBlock } = kTextureFormatInfo[format];\n  // Block formats are not handled correctly below.\n  assert(blockWidth === 1);\n  assert(blockHeight === 1);\n\n  assert(bytesPerBlock === texelValue.byteLength, 'texelValue must be of size bytesPerBlock');\n\n  const { byteLength, rowsPerImage, bytesPerRow } = getTextureCopyLayout(\n    format,\n    dimension,\n    size,\n    options\n  );\n\n  assert(byteLength <= outputBuffer.byteLength);\n\n  const mipSize = virtualMipSize(dimension, size, options.mipLevel);\n\n  const outputTexelValueBytes = new Uint8Array(outputBuffer);\n  for (let slice = 0; slice < mipSize[2]; ++slice) {\n    for (let row = 0; row < mipSize[1]; row += blockHeight) {\n      for (let col = 0; col < mipSize[0]; col += blockWidth) {\n        const byteOffset =\n          slice * rowsPerImage * bytesPerRow + row * bytesPerRow + col * texelValue.byteLength;\n        memcpy({ src: texelValue }, { dst: outputTexelValueBytes, start: byteOffset });\n      }\n    }\n  }\n}\n\n/**\n * Create a `COPY_SRC` GPUBuffer containing the linear-memory representation of a solid-color\n * texture where every texel has the byte value `texelValue`.\n */\nexport function createTextureUploadBuffer(\n  texelValue: ArrayBuffer,\n  device: GPUDevice,\n  format: EncodableTextureFormat,\n  dimension: GPUTextureDimension,\n  size: [number, number, number],\n  options: LayoutOptions = kDefaultLayoutOptions\n): {\n  buffer: GPUBuffer;\n  bytesPerRow: number;\n  rowsPerImage: number;\n} {\n  const { byteLength, bytesPerRow, rowsPerImage, bytesPerBlock } = getTextureCopyLayout(\n    format,\n    dimension,\n    size,\n    options\n  );\n\n  const buffer = device.createBuffer({\n    mappedAtCreation: true,\n    size: byteLength,\n    usage: GPUBufferUsage.COPY_SRC,\n  });\n  const mapping = buffer.getMappedRange();\n\n  assert(texelValue.byteLength === bytesPerBlock);\n  fillTextureDataWithTexelValue(texelValue, format, dimension, mapping, size, options);\n  buffer.unmap();\n\n  return {\n    buffer,\n    bytesPerRow,\n    rowsPerImage,\n  };\n}\n\nexport type ImageCopyType = 'WriteTexture' | 'CopyB2T' | 'CopyT2B';\nexport const kImageCopyTypes: readonly ImageCopyType[] = [\n  'WriteTexture',\n  'CopyB2T',\n  'CopyT2B',\n] as const;\n\n/**\n * Computes `bytesInACompleteRow` (as defined by the WebGPU spec) for image copies (B2T/T2B/writeTexture).\n */\nexport function bytesInACompleteRow(copyWidth: number, format: SizedTextureFormat): number {\n  const info = kTextureFormatInfo[format];\n  assert(copyWidth % info.blockWidth === 0);\n  return (info.bytesPerBlock * copyWidth) / info.blockWidth;\n}\n\nfunction validateBytesPerRow({\n  bytesPerRow,\n  bytesInLastRow,\n  sizeInBlocks,\n}: {\n  bytesPerRow: number | undefined;\n  bytesInLastRow: number;\n  sizeInBlocks: Required<GPUExtent3DDict>;\n}) {\n  // If specified, layout.bytesPerRow must be greater than or equal to bytesInLastRow.\n  if (bytesPerRow !== undefined && bytesPerRow < bytesInLastRow) {\n    return false;\n  }\n  // If heightInBlocks > 1, layout.bytesPerRow must be specified.\n  // If copyExtent.depthOrArrayLayers > 1, layout.bytesPerRow and layout.rowsPerImage must be specified.\n  if (\n    bytesPerRow === undefined &&\n    (sizeInBlocks.height > 1 || sizeInBlocks.depthOrArrayLayers > 1)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction validateRowsPerImage({\n  rowsPerImage,\n  sizeInBlocks,\n}: {\n  rowsPerImage: number | undefined;\n  sizeInBlocks: Required<GPUExtent3DDict>;\n}) {\n  // If specified, layout.rowsPerImage must be greater than or equal to heightInBlocks.\n  if (rowsPerImage !== undefined && rowsPerImage < sizeInBlocks.height) {\n    return false;\n  }\n  // If copyExtent.depthOrArrayLayers > 1, layout.bytesPerRow and layout.rowsPerImage must be specified.\n  if (rowsPerImage === undefined && sizeInBlocks.depthOrArrayLayers > 1) {\n    return false;\n  }\n  return true;\n}\n\ninterface DataBytesForCopyArgs {\n  layout: GPUImageDataLayout;\n  format: SizedTextureFormat;\n  copySize: Readonly<GPUExtent3DDict> | readonly number[];\n  method: ImageCopyType;\n}\n\n/**\n * Validate a copy and compute the number of bytes it needs. Throws if the copy is invalid.\n */\nexport function dataBytesForCopyOrFail(args: DataBytesForCopyArgs): number {\n  const { minDataSizeOrOverestimate, copyValid } = dataBytesForCopyOrOverestimate(args);\n  assert(copyValid, 'copy was invalid');\n  return minDataSizeOrOverestimate;\n}\n\n/**\n * Validate a copy and compute the number of bytes it needs. If the copy is invalid, attempts to\n * \"conservatively guess\" (overestimate) the number of bytes that could be needed for a copy, even\n * if the copy parameters turn out to be invalid. This hopes to avoid \"buffer too small\" validation\n * errors when attempting to test other validation errors.\n */\nexport function dataBytesForCopyOrOverestimate({\n  layout,\n  format,\n  copySize: copySize_,\n  method,\n}: DataBytesForCopyArgs): { minDataSizeOrOverestimate: number; copyValid: boolean } {\n  const copyExtent = reifyExtent3D(copySize_);\n\n  const info = kTextureFormatInfo[format];\n  assert(copyExtent.width % info.blockWidth === 0);\n  assert(copyExtent.height % info.blockHeight === 0);\n  const sizeInBlocks = {\n    width: copyExtent.width / info.blockWidth,\n    height: copyExtent.height / info.blockHeight,\n    depthOrArrayLayers: copyExtent.depthOrArrayLayers,\n  } as const;\n  const bytesInLastRow = sizeInBlocks.width * info.bytesPerBlock;\n\n  let valid = true;\n  const offset = layout.offset ?? 0;\n  if (method !== 'WriteTexture') {\n    if (offset % info.bytesPerBlock !== 0) valid = false;\n    if (layout.bytesPerRow && layout.bytesPerRow % 256 !== 0) valid = false;\n  }\n\n  let requiredBytesInCopy = 0;\n  {\n    let { bytesPerRow, rowsPerImage } = layout;\n\n    // If bytesPerRow or rowsPerImage is invalid, guess a value for the sake of various tests that\n    // don't actually care about the exact value.\n    // (In particular for validation tests that want to test invalid bytesPerRow or rowsPerImage but\n    // need to make sure the total buffer size is still big enough.)\n    if (!validateBytesPerRow({ bytesPerRow, bytesInLastRow, sizeInBlocks })) {\n      bytesPerRow = undefined;\n      valid = false;\n    }\n    if (!validateRowsPerImage({ rowsPerImage, sizeInBlocks })) {\n      rowsPerImage = undefined;\n      valid = false;\n    }\n    // Pick values for cases when (a) bpr/rpi was invalid or (b) they're validly undefined.\n    bytesPerRow ??= align(info.bytesPerBlock * sizeInBlocks.width, 256);\n    rowsPerImage ??= sizeInBlocks.height;\n\n    if (copyExtent.depthOrArrayLayers > 1) {\n      const bytesPerImage = bytesPerRow * rowsPerImage;\n      const bytesBeforeLastImage = bytesPerImage * (copyExtent.depthOrArrayLayers - 1);\n      requiredBytesInCopy += bytesBeforeLastImage;\n    }\n    if (copyExtent.depthOrArrayLayers > 0) {\n      if (sizeInBlocks.height > 1) requiredBytesInCopy += bytesPerRow * (sizeInBlocks.height - 1);\n      if (sizeInBlocks.height > 0) requiredBytesInCopy += bytesInLastRow;\n    }\n  }\n\n  return { minDataSizeOrOverestimate: offset + requiredBytesInCopy, copyValid: valid };\n}\n"],"file":"layout.js"}