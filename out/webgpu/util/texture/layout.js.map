{"version":3,"sources":["../../../../src/webgpu/util/texture/layout.ts"],"names":["assert","kTextureFormatInfo","align","standardizeExtent3D","virtualMipSize","kBytesPerRowAlignment","kBufferCopyAlignment","kDefaultLayoutOptions","mipLevel","bytesPerRow","undefined","rowsPerImage","getTextureCopyLayout","format","dimension","size","options","mipSize","blockWidth","blockHeight","bytesPerBlock","minBytesPerRow","bytesInACompleteRow","alignedMinBytesPerRow","bytesPerSlice","sliceSize","byteLength","fillTextureDataWithTexelValue","texelValue","outputBuffer","texelValueBytes","Uint8Array","outputTexelValueBytes","slice","row","col","byteOffset","set","createTextureUploadBuffer","device","buffer","createBuffer","mappedAtCreation","usage","GPUBufferUsage","COPY_SRC","mapping","getMappedRange","unmap","kImageCopyTypes","copyWidth","info","validateBytesPerRow","bytesInLastRow","sizeInBlocks","height","depthOrArrayLayers","validateRowsPerImage","dataBytesForCopyOrFail","args","minDataSizeOrOverestimate","copyValid","dataBytesForCopyOrOverestimate","layout","copySize","copySize_","method","copyExtent","width","valid","offset","requiredBytesInCopy","bytesPerImage","bytesBeforeLastImage"],"mappings":"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","sourcesContent":["import { assert } from '../../../common/util/util.js';\nimport {\n  EncodableTextureFormat,\n  kTextureFormatInfo,\n  SizedTextureFormat,\n} from '../../capability_info.js';\nimport { align } from '../math.js';\nimport { standardizeExtent3D } from '../unions.js';\n\nimport { virtualMipSize } from './base.js';\n\n/** The minimum `bytesPerRow` alignment, per spec. */\nexport const kBytesPerRowAlignment = 256;\n/** The minimum buffer copy alignment, per spec. */\nexport const kBufferCopyAlignment = 4;\n\n/**\n * Overridable layout options for {@link getTextureCopyLayout}.\n */\nexport interface LayoutOptions {\n  mipLevel: number;\n  bytesPerRow?: number;\n  rowsPerImage?: number;\n}\n\nconst kDefaultLayoutOptions = { mipLevel: 0, bytesPerRow: undefined, rowsPerImage: undefined };\n\n/** The info returned by {@link getTextureCopyLayout}. */\nexport interface TextureCopyLayout {\n  bytesPerBlock: number;\n  byteLength: number;\n  /** Number of bytes in each row, not accounting for {@link kBytesPerRowAlignment}. */\n  minBytesPerRow: number;\n  /**\n   * Actual value of bytesPerRow, defaulting to `align(minBytesPerRow, kBytesPerRowAlignment}`\n   * if not overridden.\n   */\n  bytesPerRow: number;\n  /** Actual value of rowsPerImage, defaulting to `mipSize[1]` if not overridden. */\n  rowsPerImage: number;\n  /** Size of the mip level being copied. */\n  mipSize: [number, number, number];\n}\n\n/**\n * Computes layout information for a copy of size `size` to/from a GPUTexture with the provided\n * `format` and `dimension`.\n *\n * Computes default values for `bytesPerRow` and `rowsPerImage` if not specified.\n */\nexport function getTextureCopyLayout(\n  format: SizedTextureFormat,\n  dimension: GPUTextureDimension,\n  size: readonly [number, number, number],\n  options: LayoutOptions = kDefaultLayoutOptions\n): TextureCopyLayout {\n  const { mipLevel } = options;\n  let { bytesPerRow, rowsPerImage } = options;\n\n  const mipSize = virtualMipSize(dimension, size, mipLevel);\n\n  const { blockWidth, blockHeight, bytesPerBlock } = kTextureFormatInfo[format];\n\n  // We align mipSize to be the physical size of the texture subresource.\n  mipSize[0] = align(mipSize[0], blockWidth);\n  mipSize[1] = align(mipSize[1], blockHeight);\n\n  const minBytesPerRow = bytesInACompleteRow(mipSize[0], format);\n  const alignedMinBytesPerRow = align(minBytesPerRow, kBytesPerRowAlignment);\n  if (bytesPerRow !== undefined) {\n    assert(bytesPerRow >= alignedMinBytesPerRow);\n    assert(bytesPerRow % kBytesPerRowAlignment === 0);\n  } else {\n    bytesPerRow = alignedMinBytesPerRow;\n  }\n\n  if (rowsPerImage !== undefined) {\n    assert(rowsPerImage >= mipSize[1]);\n  } else {\n    rowsPerImage = mipSize[1];\n  }\n\n  const bytesPerSlice = bytesPerRow * rowsPerImage;\n  const sliceSize =\n    bytesPerRow * (mipSize[1] / blockHeight - 1) + bytesPerBlock * (mipSize[0] / blockWidth);\n  const byteLength = bytesPerSlice * (mipSize[2] - 1) + sliceSize;\n\n  return {\n    bytesPerBlock,\n    byteLength: align(byteLength, kBufferCopyAlignment),\n    minBytesPerRow,\n    bytesPerRow,\n    rowsPerImage,\n    mipSize,\n  };\n}\n\n/**\n * Fill an ArrayBuffer with the linear-memory representation of a solid-color\n * texture where every texel has the byte value `texelValue`.\n * Preserves the contents of `outputBuffer` which are in \"padding\" space between image rows.\n *\n * Effectively emulates a copyTextureToBuffer from a solid-color texture to a buffer.\n */\nexport function fillTextureDataWithTexelValue(\n  texelValue: ArrayBuffer,\n  format: EncodableTextureFormat,\n  dimension: GPUTextureDimension,\n  outputBuffer: ArrayBuffer,\n  size: [number, number, number],\n  options: LayoutOptions = kDefaultLayoutOptions\n): void {\n  const { blockWidth, blockHeight, bytesPerBlock } = kTextureFormatInfo[format];\n  // Block formats are not handled correctly below.\n  assert(blockWidth === 1);\n  assert(blockHeight === 1);\n\n  assert(bytesPerBlock === texelValue.byteLength, 'texelValue must be of size bytesPerBlock');\n\n  const { byteLength, rowsPerImage, bytesPerRow } = getTextureCopyLayout(\n    format,\n    dimension,\n    size,\n    options\n  );\n\n  assert(byteLength <= outputBuffer.byteLength);\n\n  const mipSize = virtualMipSize(dimension, size, options.mipLevel);\n\n  const texelValueBytes = new Uint8Array(texelValue);\n  const outputTexelValueBytes = new Uint8Array(outputBuffer);\n  for (let slice = 0; slice < mipSize[2]; ++slice) {\n    for (let row = 0; row < mipSize[1]; row += blockHeight) {\n      for (let col = 0; col < mipSize[0]; col += blockWidth) {\n        const byteOffset =\n          slice * rowsPerImage * bytesPerRow + row * bytesPerRow + col * texelValue.byteLength;\n        outputTexelValueBytes.set(texelValueBytes, byteOffset);\n      }\n    }\n  }\n}\n\n/**\n * Create a `COPY_SRC` GPUBuffer containing the linear-memory representation of a solid-color\n * texture where every texel has the byte value `texelValue`.\n */\nexport function createTextureUploadBuffer(\n  texelValue: ArrayBuffer,\n  device: GPUDevice,\n  format: EncodableTextureFormat,\n  dimension: GPUTextureDimension,\n  size: [number, number, number],\n  options: LayoutOptions = kDefaultLayoutOptions\n): {\n  buffer: GPUBuffer;\n  bytesPerRow: number;\n  rowsPerImage: number;\n} {\n  const { byteLength, bytesPerRow, rowsPerImage, bytesPerBlock } = getTextureCopyLayout(\n    format,\n    dimension,\n    size,\n    options\n  );\n\n  const buffer = device.createBuffer({\n    mappedAtCreation: true,\n    size: byteLength,\n    usage: GPUBufferUsage.COPY_SRC,\n  });\n  const mapping = buffer.getMappedRange();\n\n  assert(texelValue.byteLength === bytesPerBlock);\n  fillTextureDataWithTexelValue(texelValue, format, dimension, mapping, size, options);\n  buffer.unmap();\n\n  return {\n    buffer,\n    bytesPerRow,\n    rowsPerImage,\n  };\n}\n\nexport type ImageCopyType = 'WriteTexture' | 'CopyB2T' | 'CopyT2B';\nexport const kImageCopyTypes: readonly ImageCopyType[] = [\n  'WriteTexture',\n  'CopyB2T',\n  'CopyT2B',\n] as const;\n\n/**\n * Computes `bytesInACompleteRow` (as defined by the WebGPU spec) for image copies (B2T/T2B/writeTexture).\n */\nexport function bytesInACompleteRow(copyWidth: number, format: SizedTextureFormat): number {\n  const info = kTextureFormatInfo[format];\n  assert(copyWidth % info.blockWidth === 0);\n  return (info.bytesPerBlock * copyWidth) / info.blockWidth;\n}\n\nfunction validateBytesPerRow({\n  bytesPerRow,\n  bytesInLastRow,\n  sizeInBlocks,\n}: {\n  bytesPerRow: number | undefined;\n  bytesInLastRow: number;\n  sizeInBlocks: Required<GPUExtent3DDict>;\n}) {\n  // If specified, layout.bytesPerRow must be greater than or equal to bytesInLastRow.\n  if (bytesPerRow !== undefined && bytesPerRow < bytesInLastRow) {\n    return false;\n  }\n  // If heightInBlocks > 1, layout.bytesPerRow must be specified.\n  // If copyExtent.depthOrArrayLayers > 1, layout.bytesPerRow and layout.rowsPerImage must be specified.\n  if (\n    bytesPerRow === undefined &&\n    (sizeInBlocks.height > 1 || sizeInBlocks.depthOrArrayLayers > 1)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction validateRowsPerImage({\n  rowsPerImage,\n  sizeInBlocks,\n}: {\n  rowsPerImage: number | undefined;\n  sizeInBlocks: Required<GPUExtent3DDict>;\n}) {\n  // If specified, layout.rowsPerImage must be greater than or equal to heightInBlocks.\n  if (rowsPerImage !== undefined && rowsPerImage < sizeInBlocks.height) {\n    return false;\n  }\n  // If copyExtent.depthOrArrayLayers > 1, layout.bytesPerRow and layout.rowsPerImage must be specified.\n  if (rowsPerImage === undefined && sizeInBlocks.depthOrArrayLayers > 1) {\n    return false;\n  }\n  return true;\n}\n\ninterface DataBytesForCopyArgs {\n  layout: GPUImageDataLayout;\n  format: SizedTextureFormat;\n  copySize: Readonly<GPUExtent3DDict> | readonly number[];\n  method: ImageCopyType;\n}\n\n/**\n * Validate a copy and compute the number of bytes it needs. Throws if the copy is invalid.\n */\nexport function dataBytesForCopyOrFail(args: DataBytesForCopyArgs): number {\n  const { minDataSizeOrOverestimate, copyValid } = dataBytesForCopyOrOverestimate(args);\n  assert(copyValid, 'copy was invalid');\n  return minDataSizeOrOverestimate;\n}\n\n/**\n * Validate a copy and compute the number of bytes it needs. If the copy is invalid, attempts to\n * \"conservatively guess\" (overestimate) the number of bytes that could be needed for a copy, even\n * if the copy parameters turn out to be invalid. This hopes to avoid \"buffer too small\" validation\n * errors when attempting to test other validation errors.\n */\nexport function dataBytesForCopyOrOverestimate({\n  layout,\n  format,\n  copySize: copySize_,\n  method,\n}: DataBytesForCopyArgs): { minDataSizeOrOverestimate: number; copyValid: boolean } {\n  const copyExtent = standardizeExtent3D(copySize_);\n\n  const info = kTextureFormatInfo[format];\n  assert(copyExtent.width % info.blockWidth === 0);\n  assert(copyExtent.height % info.blockHeight === 0);\n  const sizeInBlocks = {\n    width: copyExtent.width / info.blockWidth,\n    height: copyExtent.height / info.blockHeight,\n    depthOrArrayLayers: copyExtent.depthOrArrayLayers,\n  } as const;\n  const bytesInLastRow = sizeInBlocks.width * info.bytesPerBlock;\n\n  let valid = true;\n  const offset = layout.offset ?? 0;\n  if (method !== 'WriteTexture') {\n    if (offset % info.bytesPerBlock !== 0) valid = false;\n    if (layout.bytesPerRow && layout.bytesPerRow % 256 !== 0) valid = false;\n  }\n\n  let requiredBytesInCopy = 0;\n  {\n    let { bytesPerRow, rowsPerImage } = layout;\n\n    // If bytesPerRow or rowsPerImage is invalid, guess a value for the sake of various tests that\n    // don't actually care about the exact value.\n    // (In particular for validation tests that want to test invalid bytesPerRow or rowsPerImage but\n    // need to make sure the total buffer size is still big enough.)\n    if (!validateBytesPerRow({ bytesPerRow, bytesInLastRow, sizeInBlocks })) {\n      bytesPerRow = undefined;\n      valid = false;\n    }\n    if (!validateRowsPerImage({ rowsPerImage, sizeInBlocks })) {\n      rowsPerImage = undefined;\n      valid = false;\n    }\n    // Pick values for cases when (a) bpr/rpi was invalid or (b) they're validly undefined.\n    bytesPerRow ??= align(info.bytesPerBlock * sizeInBlocks.width, 256);\n    rowsPerImage ??= sizeInBlocks.height;\n\n    if (copyExtent.depthOrArrayLayers > 1) {\n      const bytesPerImage = bytesPerRow * rowsPerImage;\n      const bytesBeforeLastImage = bytesPerImage * (copyExtent.depthOrArrayLayers - 1);\n      requiredBytesInCopy += bytesBeforeLastImage;\n    }\n    if (copyExtent.depthOrArrayLayers > 0) {\n      if (sizeInBlocks.height > 1) requiredBytesInCopy += bytesPerRow * (sizeInBlocks.height - 1);\n      if (sizeInBlocks.height > 0) requiredBytesInCopy += bytesInLastRow;\n    }\n  }\n\n  return { minDataSizeOrOverestimate: offset + requiredBytesInCopy, copyValid: valid };\n}\n"],"file":"layout.js"}