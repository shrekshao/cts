{"version":3,"sources":["../../../../src/webgpu/util/texture/subresource.ts"],"names":["endOfRange","r","begin","count","end","rangeAsIterator","i","SubresourceRange","constructor","subresources","mipRange","layerRange","each","level","layer","mipLevels","layers"],"mappings":";AAAA;AACA;;;;;;;;;;AAWA,SAASA,UAAT,CAAoBC,CAApB,EAAgE;AAC9D,SAAO,WAAWA,CAAX,GAAeA,CAAC,CAACC,KAAF,GAAUD,CAAC,CAACE,KAA3B,GAAmCF,CAAC,CAACG,GAA5C;AACD;;AAED,UAAUC,eAAV,CAA0BJ,CAA1B,EAAiF;AAC/E,OAAK,IAAIK,CAAC,GAAGL,CAAC,CAACC,KAAf,EAAsBI,CAAC,GAAGN,UAAU,CAACC,CAAD,CAApC,EAAyC,EAAEK,CAA3C,EAA8C;AAC5C,UAAMA,CAAN;AACD;AACF;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMC,gBAAN,CAAuB;;;;AAI5BC,EAAAA,WAAW,CAACC,YAAD;;;AAGR;AACD,SAAKC,QAAL,GAAgB;AACdR,MAAAA,KAAK,EAAEO,YAAY,CAACC,QAAb,CAAsBR,KADf;AAEdE,MAAAA,GAAG,EAAEJ,UAAU,CAACS,YAAY,CAACC,QAAd,CAFD,EAAhB;;AAIA,SAAKC,UAAL,GAAkB;AAChBT,MAAAA,KAAK,EAAEO,YAAY,CAACE,UAAb,CAAwBT,KADf;AAEhBE,MAAAA,GAAG,EAAEJ,UAAU,CAACS,YAAY,CAACE,UAAd,CAFC,EAAlB;;AAID;;AAED;AACF;AACA;AACE,GAACC,IAAD,GAAqD;AACnD,SAAK,IAAIC,KAAK,GAAG,KAAKH,QAAL,CAAcR,KAA/B,EAAsCW,KAAK,GAAG,KAAKH,QAAL,CAAcN,GAA5D,EAAiE,EAAES,KAAnE,EAA0E;AACxE,WAAK,IAAIC,KAAK,GAAG,KAAKH,UAAL,CAAgBT,KAAjC,EAAwCY,KAAK,GAAG,KAAKH,UAAL,CAAgBP,GAAhE,EAAqE,EAAEU,KAAvE,EAA8E;AAC5E,cAAM,EAAED,KAAF,EAASC,KAAT,EAAN;AACD;AACF;AACF;;AAED;AACF;AACA;AACA;AACE,GAACC,SAAD,GAAsE;AACpE,SAAK,IAAIF,KAAK,GAAG,KAAKH,QAAL,CAAcR,KAA/B,EAAsCW,KAAK,GAAG,KAAKH,QAAL,CAAcN,GAA5D,EAAiE,EAAES,KAAnE,EAA0E;AACxE,YAAM;AACJA,QAAAA,KADI;AAEJG,QAAAA,MAAM,EAAEX,eAAe,CAAC,KAAKM,UAAN,CAFnB,EAAN;;AAID;AACF,GAxC2B","sourcesContent":["/** A range of indices expressed as { begin, count }. */\nexport interface BeginCountRange {\n  begin: number;\n  count: number;\n}\n\n/* A range of indices, expressed as { begin, end }. */\nexport interface BeginEndRange {\n  begin: number;\n  end: number;\n}\n\nfunction endOfRange(r: BeginEndRange | BeginCountRange): number {\n  return 'count' in r ? r.begin + r.count : r.end;\n}\n\nfunction* rangeAsIterator(r: BeginEndRange | BeginCountRange): Generator<number> {\n  for (let i = r.begin; i < endOfRange(r); ++i) {\n    yield i;\n  }\n}\n\n/**\n * Represents a range of subresources of a single-plane texture:\n * a min/max mip level and min/max array layer.\n */\nexport class SubresourceRange {\n  readonly mipRange: BeginEndRange;\n  readonly layerRange: BeginEndRange;\n\n  constructor(subresources: {\n    mipRange: BeginEndRange | BeginCountRange;\n    layerRange: BeginEndRange | BeginCountRange;\n  }) {\n    this.mipRange = {\n      begin: subresources.mipRange.begin,\n      end: endOfRange(subresources.mipRange),\n    };\n    this.layerRange = {\n      begin: subresources.layerRange.begin,\n      end: endOfRange(subresources.layerRange),\n    };\n  }\n\n  /**\n   * Iterates over the \"rectangle\" of { mip level, array layer } pairs represented by the range.\n   */\n  *each(): Generator<{ level: number; layer: number }> {\n    for (let level = this.mipRange.begin; level < this.mipRange.end; ++level) {\n      for (let layer = this.layerRange.begin; layer < this.layerRange.end; ++layer) {\n        yield { level, layer };\n      }\n    }\n  }\n\n  /**\n   * Iterates over the mip levels represented by the range, each level including an iterator\n   * over the array layers at that level.\n   */\n  *mipLevels(): Generator<{ level: number; layers: Generator<number> }> {\n    for (let level = this.mipRange.begin; level < this.mipRange.end; ++level) {\n      yield {\n        level,\n        layers: rangeAsIterator(this.layerRange),\n      };\n    }\n  }\n}\n"],"file":"subresource.js"}