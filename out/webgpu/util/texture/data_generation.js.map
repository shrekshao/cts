{"version":3,"sources":["../../../../src/webgpu/util/texture/data_generation.ts"],"names":["DataArrayGenerator","dataBuffer","Uint8Array","lastOffset","lastStart","lastByteSize","nextPowerOfTwo","value","Math","clz32","generateData","byteSize","start","offset","prevSize","length","newData","set","fill","i","generateView","buffer","generateAndCopyView","slice"],"mappings":";AAAA;AACA,G,CADA;AACA;AACA;AACA,GACA,OAAO,MAAMA,kBAAN,CAAyB,CACtBC,UAAU,GAAG,IAAIC,UAAJ,CAAe,GAAf,CAAH;;AAEVC,EAAAA,UAAU,GAAG,CAAH;AACVC,EAAAA,SAAS,GAAG,CAAH;AACTC,EAAAA,YAAY,GAAG,CAAH;;AAEpB;AACQC,EAAAA,cAAc,CAACC,KAAD,EAAgB;AACpC,WAAO,KAAM,KAAKC,IAAI,CAACC,KAAL,CAAWF,KAAK,GAAG,CAAnB,CAAlB;AACD;;AAEOG,EAAAA,YAAY,CAACC,QAAD,EAAmBC,KAAa,GAAG,CAAnC,EAAsCC,MAAc,GAAG,CAAvD,EAA0D;AAC5E,UAAMC,QAAQ,GAAG,KAAKb,UAAL,CAAgBc,MAAjC;;AAEA,QAAID,QAAQ,GAAGH,QAAf,EAAyB;AACvB;AACA;AACA,YAAMK,OAAO,GAAG,IAAId,UAAJ,CAAe,KAAKI,cAAL,CAAoBK,QAApB,CAAf,CAAhB;;AAEA,UAAI,KAAKR,UAAL,KAAoBU,MAApB,IAA8B,KAAKT,SAAL,KAAmBQ,KAAjD,IAA0D,KAAKP,YAAnE,EAAiF;AAC/E;AACAW,QAAAA,OAAO,CAACC,GAAR,CAAY,KAAKhB,UAAjB;AACD;;AAED,WAAKA,UAAL,GAAkBe,OAAlB;AACD,KAXD,MAWO,IAAI,KAAKb,UAAL,GAAkBU,MAAtB,EAA8B;AACnC;AACA,WAAKZ,UAAL,CAAgBiB,IAAhB,CAAqB,CAArB,EAAwB,KAAKf,UAA7B,EAAyCU,MAAzC;AACD;;AAED;AACA,QAAI,KAAKV,UAAL,KAAoBU,MAApB,IAA8B,KAAKT,SAAL,KAAmBQ,KAArD,EAA4D;AAC1D,WAAKP,YAAL,GAAoB,CAApB;AACD;;AAED;AACA,QAAI,KAAKA,YAAL,GAAoBM,QAAxB,EAAkC;AAChC,WAAK,IAAIQ,CAAC,GAAG,KAAKd,YAAlB,EAAgCc,CAAC,GAAGR,QAAQ,GAAGE,MAA/C,EAAuD,EAAEM,CAAzD,EAA4D;AAC1D,aAAKlB,UAAL,CAAgBkB,CAAC,GAAGN,MAApB,IAA+B,CAACM,CAAC,IAAI,CAAL,GAASA,CAAT,GAAaP,KAAd,IAAuB,GAAxB,GAA+B,CAA7D,CAD0D,CACM;AACjE;;AAED,WAAKT,UAAL,GAAkBU,MAAlB;AACA,WAAKT,SAAL,GAAiBQ,KAAjB;AACA,WAAKP,YAAL,GAAoBM,QAApB;AACD;AACF;;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACES,EAAAA,YAAY,CAACT,QAAD,EAAmBC,KAAa,GAAG,CAAnC,EAAsCC,MAAc,GAAG,CAAvD,EAAsE;AAChF,SAAKH,YAAL,CAAkBC,QAAlB,EAA4BC,KAA5B,EAAmCC,MAAnC;;AAEA,QAAI,KAAKZ,UAAL,CAAgBc,MAAhB,KAA2BJ,QAA/B,EAAyC;AACvC,aAAO,KAAKV,UAAZ;AACD;AACD,WAAO,IAAIC,UAAJ,CAAe,KAAKD,UAAL,CAAgBoB,MAA/B,EAAuC,CAAvC,EAA0CV,QAA1C,CAAP;AACD;;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEW,EAAAA,mBAAmB,CAACX,QAAD,EAAmBC,KAAa,GAAG,CAAnC,EAAsCC,MAAc,GAAG,CAAvD,EAA0D;AAC3E,SAAKH,YAAL,CAAkBC,QAAlB,EAA4BC,KAA5B,EAAmCC,MAAnC;AACA,WAAO,KAAKZ,UAAL,CAAgBsB,KAAhB,CAAsB,CAAtB,EAAyBZ,QAAzB,CAAP;AACD,GA7E6B","sourcesContent":["/**\n * A helper class that generates ranges of dummy data for buffer or texture operations\n * efficiently. Tries to minimize allocations and data updates.\n */\nexport class DataArrayGenerator {\n  private dataBuffer = new Uint8Array(256);\n\n  private lastOffset = 0;\n  private lastStart = 0;\n  private lastByteSize = 0;\n\n  /** Find the nearest power of two greater than or equal to the input value. */\n  private nextPowerOfTwo(value: number) {\n    return 1 << (32 - Math.clz32(value - 1));\n  }\n\n  private generateData(byteSize: number, start: number = 0, offset: number = 0) {\n    const prevSize = this.dataBuffer.length;\n\n    if (prevSize < byteSize) {\n      // If the requested data is larger than the allocated buffer, reallocate it to a buffer large\n      // enough to handle the new request.\n      const newData = new Uint8Array(this.nextPowerOfTwo(byteSize));\n\n      if (this.lastOffset === offset && this.lastStart === start && this.lastByteSize) {\n        // Do a fast copy of any previous data that was generated.\n        newData.set(this.dataBuffer);\n      }\n\n      this.dataBuffer = newData;\n    } else if (this.lastOffset < offset) {\n      // Ensure all values up to the offset are zeroed out.\n      this.dataBuffer.fill(0, this.lastOffset, offset);\n    }\n\n    // If the offset or start values have changed, the whole data range needs to be regenerated.\n    if (this.lastOffset !== offset || this.lastStart !== start) {\n      this.lastByteSize = 0;\n    }\n\n    // Generate any new values that are required\n    if (this.lastByteSize < byteSize) {\n      for (let i = this.lastByteSize; i < byteSize - offset; ++i) {\n        this.dataBuffer[i + offset] = ((i ** 3 + i + start) % 251) + 1; // Ensure data is always non-zero\n      }\n\n      this.lastOffset = offset;\n      this.lastStart = start;\n      this.lastByteSize = byteSize;\n    }\n  }\n\n  /**\n   * Returns a new view into the generated data that's the correct length. Because this is a view\n   * previously returned views from the same generator will have their values overwritten as well.\n   * @param {number} byteSize - Number of bytes the returned view should contain.\n   * @param {number} [start] - The value of the first element generated in the view.\n   * @param {number} [offset] - Offset of the generated data within the view. Preceeding values will be 0.\n   * @returns {Uint8Array} A new Uint8Array view into the generated data.\n   */\n  generateView(byteSize: number, start: number = 0, offset: number = 0): Uint8Array {\n    this.generateData(byteSize, start, offset);\n\n    if (this.dataBuffer.length === byteSize) {\n      return this.dataBuffer;\n    }\n    return new Uint8Array(this.dataBuffer.buffer, 0, byteSize);\n  }\n\n  /**\n   * Returns a copy of the generated data. Note that this still changes the underlying buffer, so\n   * any previously generated views will still be overwritten, but the returned copy won't reflect\n   * future generate* calls.\n   * @param {number} byteSize - Number of bytes the returned array should contain.\n   * @param {number} [start] - The value of the first element generated in the view.\n   * @param {number} [offset] - Offset of the generated data within the view. Preceeding values will be 0.\n   * @returns {Uint8Array} A new Uint8Array copy of the generated data.\n   */\n  generateAndCopyView(byteSize: number, start: number = 0, offset: number = 0) {\n    this.generateData(byteSize, start, offset);\n    return this.dataBuffer.slice(0, byteSize);\n  }\n}\n"],"file":"data_generation.js"}