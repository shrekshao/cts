{"version":3,"sources":["../../../src/webgpu/util/copy_to_texture.ts"],"names":["assert","memcpy","unreachable","kTextureFormatInfo","GPUTest","checkElementsEqual","checkElementsBetween","displayP3ToSrgb","align","kBytesPerRowAlignment","kTexelRepresentationInfo","isFp16Format","format","isFp32Format","isUnormFormat","CopyToTextureUtils","doFlipY","sourcePixels","width","height","bytesPerPixel","dstPixels","Uint8ClampedArray","i","j","srcPixelPos","dstPixelPos","src","start","length","dst","formatForExpectedPixels","getSourceImageBitmapPixels","isPremultiplied","isFlipY","getExpectedPixels","srcPremultiplied","dstPremultiplied","srcColorSpace","dstColorSpace","bytesPerBlock","orientedPixels","expectedPixels","rep","divide","rgba","requireColorSpaceConversion","requireUnpremultiplyAlpha","requirePremultiplyAlpha","pixelPos","R","G","B","A","Math","max","min","pack","encode","checkCopyExternalImageResult","expected","dstFormat","rowPitch","readbackPromise","readGPUBufferRangeTyped","type","Uint8Array","typedLength","eventualAsyncExpectation","niceStack","readback","check","checkBufferWithRowPitch","data","undefined","message","rec","expectationFailed","cleanup","actual","bytesPerRow","expF16bits","Uint16Array","buffer","byteOffset","BYTES_PER_ELEMENT","byteLength","checkF16bits","y","expRowF16bits","subarray","checkRowF16bits","checkResult","expF32","Float32Array","checkF32","expRowF32","checkRowF32","exp","doTestAndCheckResult","imageCopyExternalImage","dstTextureCopyView","copySize","expectedData","device","queue","copyExternalImageToTexture","externalImage","source","dstTexture","texture","testBuffer","createBuffer","size","usage","GPUBufferUsage","COPY_SRC","COPY_DST","trackForCleanup","encoder","createCommandEncoder","copyTextureToBuffer","mipLevel","origin","x","z","depthOrArrayLayers","submit","finish"],"mappings":"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","sourcesContent":["import { assert, memcpy, TypedArrayBufferView, unreachable } from '../../common/util/util.js';\nimport { RegularTextureFormat, kTextureFormatInfo } from '../capability_info.js';\nimport { GPUTest } from '../gpu_test.js';\n\nimport { checkElementsEqual, checkElementsBetween } from './check_contents.js';\nimport { displayP3ToSrgb } from './color_space_conversion.js';\nimport { align } from './math.js';\nimport { kBytesPerRowAlignment } from './texture/layout.js';\nimport { kTexelRepresentationInfo } from './texture/texel_data.js';\n\nfunction isFp16Format(format: RegularTextureFormat): boolean {\n  switch (format) {\n    case 'r16float':\n    case 'rg16float':\n    case 'rgba16float':\n      return true;\n    default:\n      return false;\n  }\n}\n\nfunction isFp32Format(format: RegularTextureFormat): boolean {\n  switch (format) {\n    case 'r32float':\n    case 'rg32float':\n    case 'rgba32float':\n      return true;\n    default:\n      return false;\n  }\n}\n\nfunction isUnormFormat(format: RegularTextureFormat): boolean {\n  switch (format) {\n    case 'r8unorm':\n    case 'rg8unorm':\n    case 'rgba8unorm':\n    case 'rgba8unorm-srgb':\n    case 'bgra8unorm':\n    case 'bgra8unorm-srgb':\n    case 'rgb10a2unorm':\n      return true;\n    default:\n      return false;\n  }\n}\n\nexport class CopyToTextureUtils extends GPUTest {\n  doFlipY(\n    sourcePixels: Uint8ClampedArray,\n    width: number,\n    height: number,\n    bytesPerPixel: number\n  ): Uint8ClampedArray {\n    const dstPixels = new Uint8ClampedArray(width * height * bytesPerPixel);\n    for (let i = 0; i < height; ++i) {\n      for (let j = 0; j < width; ++j) {\n        const srcPixelPos = i * width + j;\n        // WebGL readPixel returns pixels from bottom-left origin. Using CopyExternalImageToTexture\n        // to copy from WebGL Canvas keeps top-left origin. So the expectation from webgl.readPixel should\n        // be flipped.\n        const dstPixelPos = (height - i - 1) * width + j;\n\n        memcpy(\n          { src: sourcePixels, start: srcPixelPos * bytesPerPixel, length: bytesPerPixel },\n          { dst: dstPixels, start: dstPixelPos * bytesPerPixel }\n        );\n      }\n    }\n\n    return dstPixels;\n  }\n\n  /**\n   * If the destination format specifies a transfer function,\n   * copyExternalImageToTexture (like B2T/T2T copies) should ignore it.\n   */\n  formatForExpectedPixels(format: RegularTextureFormat): RegularTextureFormat {\n    return format === 'rgba8unorm-srgb'\n      ? 'rgba8unorm'\n      : format === 'bgra8unorm-srgb'\n      ? 'bgra8unorm'\n      : format;\n  }\n\n  getSourceImageBitmapPixels(\n    sourcePixels: Uint8ClampedArray,\n    width: number,\n    height: number,\n    isPremultiplied: boolean,\n    isFlipY: boolean\n  ): Uint8ClampedArray {\n    return this.getExpectedPixels(\n      sourcePixels,\n      width,\n      height,\n      'rgba8unorm',\n      false,\n      isPremultiplied,\n      isFlipY\n    );\n  }\n\n  getExpectedPixels(\n    sourcePixels: Uint8ClampedArray,\n    width: number,\n    height: number,\n    format: RegularTextureFormat,\n    srcPremultiplied: boolean,\n    dstPremultiplied: boolean,\n    isFlipY: boolean,\n    srcColorSpace: PredefinedColorSpace = 'srgb',\n    dstColorSpace: GPUPredefinedColorSpace = 'srgb'\n  ): Uint8ClampedArray {\n    const bytesPerPixel = kTextureFormatInfo[format].bytesPerBlock;\n\n    const orientedPixels = isFlipY ? this.doFlipY(sourcePixels, width, height, 4) : sourcePixels;\n    const expectedPixels = new Uint8ClampedArray(bytesPerPixel * width * height);\n\n    // Generate expectedPixels\n    // Use getImageData and readPixels to get canvas contents.\n    const rep = kTexelRepresentationInfo[format];\n    const divide = 255.0;\n    let rgba: { R: number; G: number; B: number; A: number };\n    const requireColorSpaceConversion = srcColorSpace !== dstColorSpace;\n    const requireUnpremultiplyAlpha =\n      requireColorSpaceConversion || (srcPremultiplied && !dstPremultiplied);\n    const requirePremultiplyAlpha =\n      requireColorSpaceConversion || (!srcPremultiplied && dstPremultiplied);\n    for (let i = 0; i < height; ++i) {\n      for (let j = 0; j < width; ++j) {\n        const pixelPos = i * width + j;\n\n        rgba = {\n          R: orientedPixels[pixelPos * 4] / divide,\n          G: orientedPixels[pixelPos * 4 + 1] / divide,\n          B: orientedPixels[pixelPos * 4 + 2] / divide,\n          A: orientedPixels[pixelPos * 4 + 3] / divide,\n        };\n\n        if (requireUnpremultiplyAlpha) {\n          if (rgba.A !== 0.0) {\n            rgba.R /= rgba.A;\n            rgba.G /= rgba.A;\n            rgba.B /= rgba.A;\n          } else {\n            assert(\n              rgba.R === 0.0 && rgba.G === 0.0 && rgba.B === 0.0 && rgba.A === 0.0,\n              'Unpremultiply ops with alpha value 0.0 requires all channels equals to 0.0'\n            );\n          }\n        }\n\n        if (requireColorSpaceConversion) {\n          // WebGPU support 'srgb' as dstColorSpace only.\n          if (srcColorSpace === 'display-p3' && dstColorSpace === 'srgb') {\n            rgba = displayP3ToSrgb(rgba);\n          } else {\n            unreachable();\n          }\n        }\n\n        if (requirePremultiplyAlpha) {\n          rgba.R *= rgba.A;\n          rgba.G *= rgba.A;\n          rgba.B *= rgba.A;\n        }\n\n        // Clamp 0.0 around floats to 0.0\n        if ((rgba.R > 0.0 && rgba.R < 1.0e-8) || (rgba.R < 0.0 && rgba.R > -1.0e-8)) {\n          rgba.R = 0.0;\n        }\n\n        if ((rgba.G > 0.0 && rgba.G < 1.0e-8) || (rgba.G < 0.0 && rgba.G > -1.0e-8)) {\n          rgba.G = 0.0;\n        }\n\n        if ((rgba.B > 0.0 && rgba.B < 1.0e-8) || (rgba.B < 0.0 && rgba.B > -1.0e-8)) {\n          rgba.B = 0.0;\n        }\n\n        if (isUnormFormat(format)) {\n          rgba.R = Math.max(0.0, Math.min(rgba.R, 1.0));\n          rgba.G = Math.max(0.0, Math.min(rgba.G, 1.0));\n          rgba.B = Math.max(0.0, Math.min(rgba.B, 1.0));\n        }\n\n        memcpy(\n          { src: rep.pack(rep.encode(rgba)) },\n          { dst: expectedPixels, start: pixelPos * bytesPerPixel }\n        );\n      }\n    }\n\n    return expectedPixels;\n  }\n\n  // MAINTENANCE_TODO(crbug.com/dawn/868): Should be possible to consolidate this along with texture checking\n  checkCopyExternalImageResult(\n    src: GPUBuffer,\n    expected: TypedArrayBufferView,\n    width: number,\n    height: number,\n    bytesPerPixel: number,\n    dstFormat: RegularTextureFormat\n  ): void {\n    const rowPitch = align(width * bytesPerPixel, kBytesPerRowAlignment);\n\n    const readbackPromise = this.readGPUBufferRangeTyped(src, {\n      type: Uint8Array,\n      typedLength: rowPitch * height,\n    });\n\n    this.eventualAsyncExpectation(async niceStack => {\n      const readback = await readbackPromise;\n      const check = this.checkBufferWithRowPitch(\n        readback.data,\n        expected,\n        width,\n        height,\n        rowPitch,\n        bytesPerPixel,\n        dstFormat\n      );\n      if (check !== undefined) {\n        niceStack.message = check;\n        this.rec.expectationFailed(niceStack);\n      }\n      readback.cleanup();\n    });\n  }\n\n  // MAINTENANCE_TODO(crbug.com/dawn/868): Should be possible to consolidate this along with texture checking\n  checkBufferWithRowPitch(\n    actual: TypedArrayBufferView,\n    expected: TypedArrayBufferView,\n    width: number,\n    height: number,\n    rowPitch: number,\n    bytesPerPixel: number,\n    dstFormat: RegularTextureFormat\n  ): string | undefined {\n    const bytesPerRow = width * bytesPerPixel;\n\n    if (isFp16Format(dstFormat)) {\n      const expF16bits = new Uint16Array(\n        expected.buffer,\n        expected.byteOffset / Uint16Array.BYTES_PER_ELEMENT,\n        expected.byteLength / Uint16Array.BYTES_PER_ELEMENT\n      );\n      const checkF16bits = new Uint16Array(\n        actual.buffer,\n        actual.byteOffset / Uint16Array.BYTES_PER_ELEMENT,\n        actual.byteLength / Uint16Array.BYTES_PER_ELEMENT\n      );\n\n      for (let y = 0; y < height; ++y) {\n        const expRowF16bits = expF16bits.subarray(\n          (y * bytesPerRow) / expF16bits.BYTES_PER_ELEMENT,\n          bytesPerRow / expF16bits.BYTES_PER_ELEMENT\n        );\n\n        const checkRowF16bits = checkF16bits.subarray(\n          (y * bytesPerRow) / checkF16bits.BYTES_PER_ELEMENT,\n          bytesPerRow / checkF16bits.BYTES_PER_ELEMENT\n        );\n\n        // 2701 is 0.0002 in float16. If the result is smaller than this, we\n        // treat the value as 0;\n        const checkResult = checkElementsBetween(checkRowF16bits, [\n          i => (expRowF16bits[i] === 0 ? 0 : expRowF16bits[i] - 1),\n          i => (expRowF16bits[i] === 0 ? 2701 : expRowF16bits[i] + 1),\n        ]);\n        if (checkResult !== undefined) return `on row ${y}: ${checkResult}`;\n      }\n    } else if (isFp32Format(dstFormat)) {\n      const expF32 = new Float32Array(\n        expected.buffer,\n        expected.byteOffset / Float32Array.BYTES_PER_ELEMENT,\n        expected.byteLength / Float32Array.BYTES_PER_ELEMENT\n      );\n      const checkF32 = new Float32Array(\n        actual.buffer,\n        actual.byteOffset / Float32Array.BYTES_PER_ELEMENT,\n        actual.byteLength / Float32Array.BYTES_PER_ELEMENT\n      );\n\n      for (let y = 0; y < height; ++y) {\n        const expRowF32 = expF32.subarray(\n          (y * bytesPerRow) / expF32.BYTES_PER_ELEMENT,\n          bytesPerRow / expF32.BYTES_PER_ELEMENT\n        );\n        const checkRowF32 = checkF32.subarray(\n          (y * bytesPerRow) / checkF32.BYTES_PER_ELEMENT,\n          bytesPerRow / checkF32.BYTES_PER_ELEMENT\n        );\n        const checkResult = checkElementsBetween(checkRowF32, [\n          i => expRowF32[i] - 0.001,\n          i => expRowF32[i] + 0.001,\n        ]);\n        if (checkResult !== undefined) return `on row ${y}: ${checkResult}`;\n      }\n    } else {\n      for (let y = 0; y < height; ++y) {\n        const exp = new Uint8Array(expected.buffer, expected.byteOffset, expected.byteLength);\n        const check = new Uint8Array(actual.buffer, actual.byteOffset, actual.byteLength);\n\n        const checkResult = checkElementsEqual(\n          check.subarray(y * rowPitch, bytesPerRow),\n          exp.subarray(y * bytesPerRow, bytesPerRow)\n        );\n        if (checkResult !== undefined) return `on row ${y}: ${checkResult}`;\n      }\n    }\n    return undefined;\n  }\n\n  doTestAndCheckResult(\n    imageCopyExternalImage: GPUImageCopyExternalImage,\n    dstTextureCopyView: GPUImageCopyTextureTagged,\n    copySize: GPUExtent3DDict,\n    bytesPerPixel: number,\n    expectedData: Uint8ClampedArray,\n    dstFormat: RegularTextureFormat\n  ): void {\n    this.device.queue.copyExternalImageToTexture(\n      imageCopyExternalImage,\n      dstTextureCopyView,\n      copySize\n    );\n\n    const externalImage = imageCopyExternalImage.source;\n    const dstTexture = dstTextureCopyView.texture;\n\n    const bytesPerRow = align(externalImage.width * bytesPerPixel, kBytesPerRowAlignment);\n    const testBuffer = this.device.createBuffer({\n      size: bytesPerRow * externalImage.height,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    this.trackForCleanup(testBuffer);\n\n    const encoder = this.device.createCommandEncoder();\n\n    encoder.copyTextureToBuffer(\n      { texture: dstTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      { buffer: testBuffer, bytesPerRow },\n      { width: externalImage.width, height: externalImage.height, depthOrArrayLayers: 1 }\n    );\n    this.device.queue.submit([encoder.finish()]);\n\n    this.checkCopyExternalImageResult(\n      testBuffer,\n      expectedData,\n      externalImage.width,\n      externalImage.height,\n      bytesPerPixel,\n      dstFormat\n    );\n  }\n}\n"],"file":"copy_to_texture.js"}