{"version":3,"sources":["../../../src/webgpu/util/copy_to_texture.ts"],"names":["assert","memcpy","kTextureFormatInfo","GPUTest","checkElementsEqual","checkElementsBetween","align","kBytesPerRowAlignment","kTexelRepresentationInfo","isFp16Format","format","CopyToTextureUtils","doFlipY","sourcePixels","width","height","bytesPerPixel","dstPixels","Uint8ClampedArray","i","j","srcPixelPos","dstPixelPos","src","start","length","dst","formatForExpectedPixels","getSourceImageBitmapPixels","isPremultiplied","isFlipY","getExpectedPixels","srcPremultiplied","dstPremultiplied","bytesPerBlock","orientedPixels","expectedPixels","rep","divide","rgba","pixelPos","R","G","B","A","pack","encode","checkCopyExternalImageResult","expected","isFp16","exp","Uint8Array","buffer","byteOffset","byteLength","rowPitch","readbackPromise","readGPUBufferRangeTyped","type","typedLength","eventualAsyncExpectation","niceStack","readback","check","checkBufferWithRowPitch","data","undefined","message","rec","expectationFailed","cleanup","actual","bytesPerRow","y","expRow","subarray","checkResult","doTestAndCheckResult","imageCopyExternalImage","dstTextureCopyView","copySize","expectedData","device","queue","copyExternalImageToTexture","externalImage","source","dstTexture","texture","testBuffer","createBuffer","size","usage","GPUBufferUsage","COPY_SRC","COPY_DST","trackForCleanup","encoder","createCommandEncoder","copyTextureToBuffer","mipLevel","origin","x","z","depthOrArrayLayers","submit","finish"],"mappings":";AAAA;AACA,GADA,SAASA,MAAT,EAAiBC,MAAjB,QAA+B,2BAA/B,CACA,SAA+BC,kBAA/B,QAAyD,uBAAzD,CACA,SAASC,OAAT,QAAwB,gBAAxB;;AAEA,SAASC,kBAAT,EAA6BC,oBAA7B,QAAyD,qBAAzD;AACA,SAASC,KAAT,QAAsB,WAAtB;AACA,SAASC,qBAAT,QAAsC,qBAAtC;AACA,SAASC,wBAAT,QAAyC,yBAAzC;;AAEA,OAAO,SAASC,YAAT,CAAsBC,MAAtB,EAAyD;AAC9D,UAAQA,MAAR;AACE,SAAK,UAAL;AACA,SAAK,WAAL;AACA,SAAK,aAAL;AACE,aAAO,IAAP;AACF;AACE,aAAO,KAAP,CANJ;;AAQD;;AAED,OAAO,MAAMC,kBAAN,SAAiCR,OAAjC,CAAyC;AAC9CS,EAAAA,OAAO;AACLC,EAAAA,YADK;AAELC,EAAAA,KAFK;AAGLC,EAAAA,MAHK;AAILC,EAAAA,aAJK;AAKc;AACnB,UAAMC,SAAS,GAAG,IAAIC,iBAAJ,CAAsBJ,KAAK,GAAGC,MAAR,GAAiBC,aAAvC,CAAlB;AACA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAApB,EAA4B,EAAEI,CAA9B,EAAiC;AAC/B,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,KAApB,EAA2B,EAAEM,CAA7B,EAAgC;AAC9B,cAAMC,WAAW,GAAGF,CAAC,GAAGL,KAAJ,GAAYM,CAAhC;AACA;AACA;AACA;AACA,cAAME,WAAW,GAAG,CAACP,MAAM,GAAGI,CAAT,GAAa,CAAd,IAAmBL,KAAnB,GAA2BM,CAA/C;;AAEAnB,QAAAA,MAAM;AACJ,UAAEsB,GAAG,EAAEV,YAAP,EAAqBW,KAAK,EAAEH,WAAW,GAAGL,aAA1C,EAAyDS,MAAM,EAAET,aAAjE,EADI;AAEJ,UAAEU,GAAG,EAAET,SAAP,EAAkBO,KAAK,EAAEF,WAAW,GAAGN,aAAvC,EAFI,CAAN;;AAID;AACF;;AAED,WAAOC,SAAP;AACD;;AAED;AACF;AACA;AACA;AACEU,EAAAA,uBAAuB,CAACjB,MAAD,EAAqD;AAC1E,WAAOA,MAAM,KAAK,iBAAX;AACH,gBADG;AAEHA,IAAAA,MAAM,KAAK,iBAAX;AACA,gBADA;AAEAA,IAAAA,MAJJ;AAKD;;AAEDkB,EAAAA,0BAA0B;AACxBf,EAAAA,YADwB;AAExBC,EAAAA,KAFwB;AAGxBC,EAAAA,MAHwB;AAIxBc,EAAAA,eAJwB;AAKxBC,EAAAA,OALwB;AAML;AACnB,WAAO,KAAKC,iBAAL;AACLlB,IAAAA,YADK;AAELC,IAAAA,KAFK;AAGLC,IAAAA,MAHK;AAIL,gBAJK;AAKL,SALK;AAMLc,IAAAA,eANK;AAOLC,IAAAA,OAPK,CAAP;;AASD;;AAEDC,EAAAA,iBAAiB;AACflB,EAAAA,YADe;AAEfC,EAAAA,KAFe;AAGfC,EAAAA,MAHe;AAIfL,EAAAA,MAJe;AAKfsB,EAAAA,gBALe;AAMfC,EAAAA,gBANe;AAOfH,EAAAA,OAPe;AAQI;AACnB,UAAMd,aAAa,GAAGd,kBAAkB,CAACQ,MAAD,CAAlB,CAA2BwB,aAAjD;;AAEA,UAAMC,cAAc,GAAGL,OAAO,GAAG,KAAKlB,OAAL,CAAaC,YAAb,EAA2BC,KAA3B,EAAkCC,MAAlC,EAA0C,CAA1C,CAAH,GAAkDF,YAAhF;AACA,UAAMuB,cAAc,GAAG,IAAIlB,iBAAJ,CAAsBF,aAAa,GAAGF,KAAhB,GAAwBC,MAA9C,CAAvB;;AAEA;AACA;AACA,UAAMsB,GAAG,GAAG7B,wBAAwB,CAACE,MAAD,CAApC;AACA,UAAM4B,MAAM,GAAG,KAAf;AACA,QAAIC,IAAJ;AACA,SAAK,IAAIpB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAApB,EAA4B,EAAEI,CAA9B,EAAiC;AAC/B,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,KAApB,EAA2B,EAAEM,CAA7B,EAAgC;AAC9B,cAAMoB,QAAQ,GAAGrB,CAAC,GAAGL,KAAJ,GAAYM,CAA7B;;AAEAmB,QAAAA,IAAI,GAAG;AACLE,UAAAA,CAAC,EAAEN,cAAc,CAACK,QAAQ,GAAG,CAAZ,CAAd,GAA+BF,MAD7B;AAELI,UAAAA,CAAC,EAAEP,cAAc,CAACK,QAAQ,GAAG,CAAX,GAAe,CAAhB,CAAd,GAAmCF,MAFjC;AAGLK,UAAAA,CAAC,EAAER,cAAc,CAACK,QAAQ,GAAG,CAAX,GAAe,CAAhB,CAAd,GAAmCF,MAHjC;AAILM,UAAAA,CAAC,EAAET,cAAc,CAACK,QAAQ,GAAG,CAAX,GAAe,CAAhB,CAAd,GAAmCF,MAJjC,EAAP;;;AAOA,YAAI,CAACN,gBAAD,IAAqBC,gBAAzB,EAA2C;AACzCM,UAAAA,IAAI,CAACE,CAAL,IAAUF,IAAI,CAACK,CAAf;AACAL,UAAAA,IAAI,CAACG,CAAL,IAAUH,IAAI,CAACK,CAAf;AACAL,UAAAA,IAAI,CAACI,CAAL,IAAUJ,IAAI,CAACK,CAAf;AACD;;AAED,YAAIZ,gBAAgB,IAAI,CAACC,gBAAzB,EAA2C;AACzCjC,UAAAA,MAAM,CAACuC,IAAI,CAACK,CAAL,KAAW,GAAZ,CAAN;AACAL,UAAAA,IAAI,CAACE,CAAL,IAAUF,IAAI,CAACK,CAAf;AACAL,UAAAA,IAAI,CAACG,CAAL,IAAUH,IAAI,CAACK,CAAf;AACAL,UAAAA,IAAI,CAACI,CAAL,IAAUJ,IAAI,CAACK,CAAf;AACD;;AAED3C,QAAAA,MAAM;AACJ,UAAEsB,GAAG,EAAEc,GAAG,CAACQ,IAAJ,CAASR,GAAG,CAACS,MAAJ,CAAWP,IAAX,CAAT,CAAP,EADI;AAEJ,UAAEb,GAAG,EAAEU,cAAP,EAAuBZ,KAAK,EAAEgB,QAAQ,GAAGxB,aAAzC,EAFI,CAAN;;AAID;AACF;;AAED,WAAOoB,cAAP;AACD;;AAED;AACAW,EAAAA,4BAA4B;AAC1BxB,EAAAA,GAD0B;AAE1ByB,EAAAA,QAF0B;AAG1BlC,EAAAA,KAH0B;AAI1BC,EAAAA,MAJ0B;AAK1BC,EAAAA,aAL0B;AAM1BiC,EAAAA,MAN0B;AAOpB;AACN,UAAMC,GAAG,GAAG,IAAIC,UAAJ,CAAeH,QAAQ,CAACI,MAAxB,EAAgCJ,QAAQ,CAACK,UAAzC,EAAqDL,QAAQ,CAACM,UAA9D,CAAZ;AACA,UAAMC,QAAQ,GAAGjD,KAAK,CAACQ,KAAK,GAAGE,aAAT,EAAwBT,qBAAxB,CAAtB;;AAEA,UAAMiD,eAAe,GAAG,KAAKC,uBAAL,CAA6BlC,GAA7B,EAAkC;AACxDmC,MAAAA,IAAI,EAAEP,UADkD;AAExDQ,MAAAA,WAAW,EAAEJ,QAAQ,GAAGxC,MAFgC,EAAlC,CAAxB;;;AAKA,SAAK6C,wBAAL,CAA8B,MAAMC,SAAN,IAAmB;AAC/C,YAAMC,QAAQ,GAAG,MAAMN,eAAvB;AACA,YAAMO,KAAK,GAAG,KAAKC,uBAAL;AACZF,MAAAA,QAAQ,CAACG,IADG;AAEZf,MAAAA,GAFY;AAGZpC,MAAAA,KAHY;AAIZC,MAAAA,MAJY;AAKZwC,MAAAA,QALY;AAMZvC,MAAAA,aANY;AAOZiC,MAAAA,MAPY,CAAd;;AASA,UAAIc,KAAK,KAAKG,SAAd,EAAyB;AACvBL,QAAAA,SAAS,CAACM,OAAV,GAAoBJ,KAApB;AACA,aAAKK,GAAL,CAASC,iBAAT,CAA2BR,SAA3B;AACD;AACDC,MAAAA,QAAQ,CAACQ,OAAT;AACD,KAhBD;AAiBD;;AAED;AACAN,EAAAA,uBAAuB;AACrBO,EAAAA,MADqB;AAErBrB,EAAAA,GAFqB;AAGrBpC,EAAAA,KAHqB;AAIrBC,EAAAA,MAJqB;AAKrBwC,EAAAA,QALqB;AAMrBvC,EAAAA,aANqB;AAOrBiC,EAAAA,MAPqB;AAQD;AACpB,UAAMuB,WAAW,GAAG1D,KAAK,GAAGE,aAA5B;AACA;AACA;AACA;AACA,QAAIiC,MAAJ,EAAY;AACV,WAAK,IAAIwB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1D,MAApB,EAA4B,EAAE0D,CAA9B,EAAiC;AAC/B,cAAMC,MAAM,GAAGxB,GAAG,CAACyB,QAAJ,CAAaF,CAAC,GAAGD,WAAjB,EAA8BA,WAA9B,CAAf;AACA,cAAMI,WAAW,GAAGvE,oBAAoB,CAACkE,MAAM,CAACI,QAAP,CAAgBF,CAAC,GAAGlB,QAApB,EAA8BiB,WAA9B,CAAD,EAA6C;AACnFrD,QAAAA,CAAC,IAAKuD,MAAM,CAACvD,CAAD,CAAN,GAAY,CAAZ,GAAgBuD,MAAM,CAACvD,CAAD,CAAN,GAAY,CAA5B,GAAgCuD,MAAM,CAACvD,CAAD,CADuC;AAEnFA,QAAAA,CAAC,IAAIuD,MAAM,CAACvD,CAAD,CAAN,GAAY,CAFkE,CAA7C,CAAxC;;AAIA,YAAIyD,WAAW,KAAKV,SAApB,EAA+B,OAAQ,UAASO,CAAE,KAAIG,WAAY,EAAnC;AAChC;AACF,KATD,MASO;AACL,WAAK,IAAIH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1D,MAApB,EAA4B,EAAE0D,CAA9B,EAAiC;AAC/B,cAAMG,WAAW,GAAGxE,kBAAkB;AACpCmE,QAAAA,MAAM,CAACI,QAAP,CAAgBF,CAAC,GAAGlB,QAApB,EAA8BiB,WAA9B,CADoC;AAEpCtB,QAAAA,GAAG,CAACyB,QAAJ,CAAaF,CAAC,GAAGD,WAAjB,EAA8BA,WAA9B,CAFoC,CAAtC;;AAIA,YAAII,WAAW,KAAKV,SAApB,EAA+B,OAAQ,UAASO,CAAE,KAAIG,WAAY,EAAnC;AAChC;AACF;AACD,WAAOV,SAAP;AACD;;AAEDW,EAAAA,oBAAoB;AAClBC,EAAAA,sBADkB;AAElBC,EAAAA,kBAFkB;AAGlBC,EAAAA,QAHkB;AAIlBhE,EAAAA,aAJkB;AAKlBiE,EAAAA,YALkB;AAMlBhC,EAAAA,MANkB;AAOZ;AACN,SAAKiC,MAAL,CAAYC,KAAZ,CAAkBC,0BAAlB;AACEN,IAAAA,sBADF;AAEEC,IAAAA,kBAFF;AAGEC,IAAAA,QAHF;;;AAMA,UAAMK,aAAa,GAAGP,sBAAsB,CAACQ,MAA7C;AACA,UAAMC,UAAU,GAAGR,kBAAkB,CAACS,OAAtC;;AAEA,UAAMhB,WAAW,GAAGlE,KAAK,CAAC+E,aAAa,CAACvE,KAAd,GAAsBE,aAAvB,EAAsCT,qBAAtC,CAAzB;AACA,UAAMkF,UAAU,GAAG,KAAKP,MAAL,CAAYQ,YAAZ,CAAyB;AAC1CC,MAAAA,IAAI,EAAEnB,WAAW,GAAGa,aAAa,CAACtE,MADQ;AAE1C6E,MAAAA,KAAK,EAAEC,cAAc,CAACC,QAAf,GAA0BD,cAAc,CAACE,QAFN,EAAzB,CAAnB;;AAIA,SAAKC,eAAL,CAAqBP,UAArB;;AAEA,UAAMQ,OAAO,GAAG,KAAKf,MAAL,CAAYgB,oBAAZ,EAAhB;;AAEAD,IAAAA,OAAO,CAACE,mBAAR;AACE,MAAEX,OAAO,EAAED,UAAX,EAAuBa,QAAQ,EAAE,CAAjC,EAAoCC,MAAM,EAAE,EAAEC,CAAC,EAAE,CAAL,EAAQ7B,CAAC,EAAE,CAAX,EAAc8B,CAAC,EAAE,CAAjB,EAA5C,EADF;AAEE,MAAEnD,MAAM,EAAEqC,UAAV,EAAsBjB,WAAtB,EAFF;AAGE,MAAE1D,KAAK,EAAEuE,aAAa,CAACvE,KAAvB,EAA8BC,MAAM,EAAEsE,aAAa,CAACtE,MAApD,EAA4DyF,kBAAkB,EAAE,CAAhF,EAHF;;AAKA,SAAKtB,MAAL,CAAYC,KAAZ,CAAkBsB,MAAlB,CAAyB,CAACR,OAAO,CAACS,MAAR,EAAD,CAAzB;;AAEA,SAAK3D,4BAAL;AACE0C,IAAAA,UADF;AAEER,IAAAA,YAFF;AAGEI,IAAAA,aAAa,CAACvE,KAHhB;AAIEuE,IAAAA,aAAa,CAACtE,MAJhB;AAKEC,IAAAA,aALF;AAMEiC,IAAAA,MANF;;AAQD,GA7N6C","sourcesContent":["import { assert, memcpy } from '../../common/util/util.js';\nimport { RegularTextureFormat, kTextureFormatInfo } from '../capability_info.js';\nimport { GPUTest } from '../gpu_test.js';\n\nimport { checkElementsEqual, checkElementsBetween } from './check_contents.js';\nimport { align } from './math.js';\nimport { kBytesPerRowAlignment } from './texture/layout.js';\nimport { kTexelRepresentationInfo } from './texture/texel_data.js';\n\nexport function isFp16Format(format: GPUTextureFormat): boolean {\n  switch (format) {\n    case 'r16float':\n    case 'rg16float':\n    case 'rgba16float':\n      return true;\n    default:\n      return false;\n  }\n}\n\nexport class CopyToTextureUtils extends GPUTest {\n  doFlipY(\n    sourcePixels: Uint8ClampedArray,\n    width: number,\n    height: number,\n    bytesPerPixel: number\n  ): Uint8ClampedArray {\n    const dstPixels = new Uint8ClampedArray(width * height * bytesPerPixel);\n    for (let i = 0; i < height; ++i) {\n      for (let j = 0; j < width; ++j) {\n        const srcPixelPos = i * width + j;\n        // WebGL readPixel returns pixels from bottom-left origin. Using CopyExternalImageToTexture\n        // to copy from WebGL Canvas keeps top-left origin. So the expectation from webgl.readPixel should\n        // be flipped.\n        const dstPixelPos = (height - i - 1) * width + j;\n\n        memcpy(\n          { src: sourcePixels, start: srcPixelPos * bytesPerPixel, length: bytesPerPixel },\n          { dst: dstPixels, start: dstPixelPos * bytesPerPixel }\n        );\n      }\n    }\n\n    return dstPixels;\n  }\n\n  /**\n   * If the destination format specifies a transfer function,\n   * copyExternalImageToTexture (like B2T/T2T copies) should ignore it.\n   */\n  formatForExpectedPixels(format: RegularTextureFormat): RegularTextureFormat {\n    return format === 'rgba8unorm-srgb'\n      ? 'rgba8unorm'\n      : format === 'bgra8unorm-srgb'\n      ? 'bgra8unorm'\n      : format;\n  }\n\n  getSourceImageBitmapPixels(\n    sourcePixels: Uint8ClampedArray,\n    width: number,\n    height: number,\n    isPremultiplied: boolean,\n    isFlipY: boolean\n  ): Uint8ClampedArray {\n    return this.getExpectedPixels(\n      sourcePixels,\n      width,\n      height,\n      'rgba8unorm',\n      false,\n      isPremultiplied,\n      isFlipY\n    );\n  }\n\n  getExpectedPixels(\n    sourcePixels: Uint8ClampedArray,\n    width: number,\n    height: number,\n    format: RegularTextureFormat,\n    srcPremultiplied: boolean,\n    dstPremultiplied: boolean,\n    isFlipY: boolean\n  ): Uint8ClampedArray {\n    const bytesPerPixel = kTextureFormatInfo[format].bytesPerBlock;\n\n    const orientedPixels = isFlipY ? this.doFlipY(sourcePixels, width, height, 4) : sourcePixels;\n    const expectedPixels = new Uint8ClampedArray(bytesPerPixel * width * height);\n\n    // Generate expectedPixels\n    // Use getImageData and readPixels to get canvas contents.\n    const rep = kTexelRepresentationInfo[format];\n    const divide = 255.0;\n    let rgba: { R: number; G: number; B: number; A: number };\n    for (let i = 0; i < height; ++i) {\n      for (let j = 0; j < width; ++j) {\n        const pixelPos = i * width + j;\n\n        rgba = {\n          R: orientedPixels[pixelPos * 4] / divide,\n          G: orientedPixels[pixelPos * 4 + 1] / divide,\n          B: orientedPixels[pixelPos * 4 + 2] / divide,\n          A: orientedPixels[pixelPos * 4 + 3] / divide,\n        };\n\n        if (!srcPremultiplied && dstPremultiplied) {\n          rgba.R *= rgba.A;\n          rgba.G *= rgba.A;\n          rgba.B *= rgba.A;\n        }\n\n        if (srcPremultiplied && !dstPremultiplied) {\n          assert(rgba.A !== 0.0);\n          rgba.R /= rgba.A;\n          rgba.G /= rgba.A;\n          rgba.B /= rgba.A;\n        }\n\n        memcpy(\n          { src: rep.pack(rep.encode(rgba)) },\n          { dst: expectedPixels, start: pixelPos * bytesPerPixel }\n        );\n      }\n    }\n\n    return expectedPixels;\n  }\n\n  // MAINTENANCE_TODO(crbug.com/dawn/868): Should be possible to consolidate this along with texture checking\n  checkCopyExternalImageResult(\n    src: GPUBuffer,\n    expected: ArrayBufferView,\n    width: number,\n    height: number,\n    bytesPerPixel: number,\n    isFp16: boolean\n  ): void {\n    const exp = new Uint8Array(expected.buffer, expected.byteOffset, expected.byteLength);\n    const rowPitch = align(width * bytesPerPixel, kBytesPerRowAlignment);\n\n    const readbackPromise = this.readGPUBufferRangeTyped(src, {\n      type: Uint8Array,\n      typedLength: rowPitch * height,\n    });\n\n    this.eventualAsyncExpectation(async niceStack => {\n      const readback = await readbackPromise;\n      const check = this.checkBufferWithRowPitch(\n        readback.data,\n        exp,\n        width,\n        height,\n        rowPitch,\n        bytesPerPixel,\n        isFp16\n      );\n      if (check !== undefined) {\n        niceStack.message = check;\n        this.rec.expectationFailed(niceStack);\n      }\n      readback.cleanup();\n    });\n  }\n\n  // MAINTENANCE_TODO(crbug.com/dawn/868): Should be possible to consolidate this along with texture checking\n  checkBufferWithRowPitch(\n    actual: Uint8Array,\n    exp: Uint8Array,\n    width: number,\n    height: number,\n    rowPitch: number,\n    bytesPerPixel: number,\n    isFp16: boolean\n  ): string | undefined {\n    const bytesPerRow = width * bytesPerPixel;\n    // When dst format is fp16 formats, the expectation and real result always has 1 bit difference in the ending\n    // (e.g. CC vs CD) if there needs some alpha ops (if alpha channel is not 0.0 or 1.0). Suspect it is errors when\n    // doing encoding. We check fp16 dst texture format with 1-bit ULP tolerance.\n    if (isFp16) {\n      for (let y = 0; y < height; ++y) {\n        const expRow = exp.subarray(y * bytesPerRow, bytesPerRow);\n        const checkResult = checkElementsBetween(actual.subarray(y * rowPitch, bytesPerRow), [\n          i => (expRow[i] > 0 ? expRow[i] - 1 : expRow[i]),\n          i => expRow[i] + 1,\n        ]);\n        if (checkResult !== undefined) return `on row ${y}: ${checkResult}`;\n      }\n    } else {\n      for (let y = 0; y < height; ++y) {\n        const checkResult = checkElementsEqual(\n          actual.subarray(y * rowPitch, bytesPerRow),\n          exp.subarray(y * bytesPerRow, bytesPerRow)\n        );\n        if (checkResult !== undefined) return `on row ${y}: ${checkResult}`;\n      }\n    }\n    return undefined;\n  }\n\n  doTestAndCheckResult(\n    imageCopyExternalImage: GPUImageCopyExternalImage,\n    dstTextureCopyView: GPUImageCopyTextureTagged,\n    copySize: GPUExtent3DDict,\n    bytesPerPixel: number,\n    expectedData: Uint8ClampedArray,\n    isFp16: boolean\n  ): void {\n    this.device.queue.copyExternalImageToTexture(\n      imageCopyExternalImage,\n      dstTextureCopyView,\n      copySize\n    );\n\n    const externalImage = imageCopyExternalImage.source;\n    const dstTexture = dstTextureCopyView.texture;\n\n    const bytesPerRow = align(externalImage.width * bytesPerPixel, kBytesPerRowAlignment);\n    const testBuffer = this.device.createBuffer({\n      size: bytesPerRow * externalImage.height,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    this.trackForCleanup(testBuffer);\n\n    const encoder = this.device.createCommandEncoder();\n\n    encoder.copyTextureToBuffer(\n      { texture: dstTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      { buffer: testBuffer, bytesPerRow },\n      { width: externalImage.width, height: externalImage.height, depthOrArrayLayers: 1 }\n    );\n    this.device.queue.submit([encoder.finish()]);\n\n    this.checkCopyExternalImageResult(\n      testBuffer,\n      expectedData,\n      externalImage.width,\n      externalImage.height,\n      bytesPerPixel,\n      isFp16\n    );\n  }\n}\n"],"file":"copy_to_texture.js"}