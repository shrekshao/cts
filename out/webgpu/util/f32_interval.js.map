{"version":3,"sources":["../../../src/webgpu/util/f32_interval.ts"],"names":["assert","unreachable","kValue","cartesianProduct","correctlyRoundedF32","flushSubnormalNumber","isF32Finite","isSubnormalNumber","oneULP","F32Interval","constructor","bounds","begin","end","length","Number","isNaN","isPoint","contains","n","NEGATIVE_INFINITY","POSITIVE_INFINITY","i","toF32Interval","isFinite","span","intervals","forEach","Math","min","max","toString","any","_any","undefined","kNegPiToPiInterval","f32","negative","pi","whole","positive","kGreaterThanZeroInterval","subnormal","isF32Vector","v","toF32Vector","f","map","addFlushedIfNeeded","values","some","concat","limitPointToIntervalDomain","domain","impl","limitBinaryToIntervalDomain","x","y","d","roundAndFlushPointToInterval","op","inputs","results","Set","roundAndFlushBinaryToInterval","x_values","y_values","x_inputs","y_inputs","inner_x","inner_y","add","roundAndFlushTernaryToInterval","z","z_values","z_inputs","inner_z","roundAndFlushVectorPairToInterval","every","e","x_rounded","y_rounded","x_flushed","y_flushed","runPointOp","extrema","result","b","runBinaryOp","outputs","runTernaryOp","runVectorPairBinaryOp","CorrectlyRoundedIntervalOp","correctlyRoundedInterval","AbsoluteErrorIntervalOp","error_range","_","absoluteErrorInterval","abs","ULPIntervalOp","numULP","ulp","ulpInterval","AbsIntervalOp","absInterval","acoshIntervals","acoshAlternativeInterval","acoshPrimaryInterval","AcoshAlternativeIntervalOp","inner_value","multiplicationInterval","additionInterval","subtractionInterval","sqrt_value","sqrtInterval","logInterval","AcoshPrimaryIntervalOp","AdditionIntervalOp","AsinhIntervalOp","asinhInterval","AtanIntervalOp","atan","atanInterval","Atan2IntervalOp","atan2","atan2Interval","AtanhIntervalOp","numerator","denominator","log_interval","divisionInterval","atanhInterval","CeilIntervalOp","ceil","ceilInterval","ClampMedianIntervalOp","sort","a","clampIntervals","clampMinMaxInterval","clampMedianInterval","ClampMinMaxIntervalOp","low","high","CosIntervalOp","cos","cosInterval","CoshIntervalOp","minus_n","negationInterval","expInterval","coshInterval","DegreesIntervalOp","degreesInterval","DivisionIntervalOp","DotIntervalOp","multiplications","reduce","previous","current","dotInterval","ExpIntervalOp","exp","Exp2IntervalOp","pow","exp2Interval","FloorIntervalOp","floor","floorInterval","FractIntervalOp","less_than_one","fractInterval","InverseSqrtIntervalOp","sqrt","inverseSqrtInterval","LdexpIntervalOp","e1","e2","ldexpInterval","LogIntervalOp","log","Log2IntervalOp","log2","log2Interval","MaxIntervalOp","maxInterval","MinIntervalOp","minInterval","MixImpreciseIntervalOp","t","mixIntervals","mixImpreciseInterval","mixPreciseInterval","MixPreciseIntervalOp","s","MultiplicationInnerOp","MultiplicationIntervalOp","NegationIntervalOp","PowIntervalOp","powInterval","RadiansIntervalOp","radiansInterval","RemainderIntervalOp","truncInterval","remainderInterval","RoundIntervalOp","k","diff_before","diff_after","roundInterval","saturateInterval","SignIntervalOp","signInterval","SinIntervalOp","sin","sinInterval","SinhIntervalOp","sinhInterval","SmoothStepOp","smoothStepInterval","SqrtIntervalOp","StepIntervalOp","edge","stepInterval","SubtractionInnerOp","SubtractionIntervalOp","TanIntervalOp","tanInterval","TanhIntervalOp","tanhInterval","TruncIntervalOp","trunc"],"mappings":"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","sourcesContent":["import { assert, unreachable } from '../../common/util/util.js';\n\nimport { kValue } from './constants.js';\nimport {\n  cartesianProduct,\n  correctlyRoundedF32,\n  flushSubnormalNumber,\n  isF32Finite,\n  isSubnormalNumber,\n  oneULP,\n} from './math.js';\n\n/**\n * Representation of bounds for an interval as an array with either one or two\n * elements. Single element indicates that the interval is a single point. For\n * two elements, the first is the lower bound of the interval and the second is\n * the upper bound.\n */\nexport type IntervalBounds = [number] | [number, number];\n\n/** Represents a closed interval in the f32 range */\nexport class F32Interval {\n  public readonly begin: number;\n  public readonly end: number;\n  private static _any: F32Interval;\n\n  /** Constructor\n   *\n   * @param bounds either a pair of numbers indicating the beginning then the\n   *               end of the interval, or a single element array indicating the\n   *               interval is a point\n   */\n  public constructor(...bounds: IntervalBounds) {\n    const [begin, end] = bounds.length === 2 ? bounds : [bounds[0], bounds[0]];\n    assert(!Number.isNaN(begin) && !Number.isNaN(end), `bounds need to be non-NaN`);\n    assert(begin <= end, `bounds[0] (${begin}) must be less than or equal to bounds[1]  (${end})`);\n\n    this.begin = begin;\n    this.end = end;\n  }\n\n  /** @returns begin and end if non-point interval, otherwise just begin */\n  public bounds(): IntervalBounds {\n    return this.isPoint() ? [this.begin] : [this.begin, this.end];\n  }\n\n  /** @returns if a point or interval is completely contained by this interval */\n  public contains(n: number | F32Interval): boolean {\n    if (Number.isNaN(n)) {\n      // Being the any interval indicates that accuracy is not defined for this\n      // test, so the test is just checking that this input doesn't cause the\n      // implementation to misbehave, so NaN is accepted.\n      return this.begin === Number.NEGATIVE_INFINITY && this.end === Number.POSITIVE_INFINITY;\n    }\n    const i = toF32Interval(n);\n    return this.begin <= i.begin && this.end >= i.end;\n  }\n\n  /** @returns if this interval contains a single point */\n  public isPoint(): boolean {\n    return this.begin === this.end;\n  }\n\n  /** @returns if this interval only contains f32 finite values */\n  public isFinite(): boolean {\n    return isF32Finite(this.begin) && isF32Finite(this.end);\n  }\n\n  /** @returns an interval with the tightest bounds that includes all provided intervals */\n  static span(...intervals: F32Interval[]): F32Interval {\n    assert(intervals.length > 0, `span of an empty list of F32Intervals is not allowed`);\n    let begin = Number.POSITIVE_INFINITY;\n    let end = Number.NEGATIVE_INFINITY;\n    intervals.forEach(i => {\n      begin = Math.min(i.begin, begin);\n      end = Math.max(i.end, end);\n    });\n    return new F32Interval(begin, end);\n  }\n\n  /** @returns a string representation for logging purposes */\n  public toString(): string {\n    return `[${this.bounds()}]`;\n  }\n\n  /** @returns a singleton for interval of all possible values\n   * This interval is used in situations where accuracy is not defined, so any\n   * result is valid.\n   */\n  public static any(): F32Interval {\n    if (this._any === undefined) {\n      this._any = new F32Interval(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);\n    }\n    return this._any;\n  }\n}\n\n/** @returns an interval containing the point or the original interval */\nfunction toF32Interval(n: number | F32Interval): F32Interval {\n  if (n instanceof F32Interval) {\n    return n;\n  }\n  return new F32Interval(n, n);\n}\n\n/** F32Interval of [-π, π] */\nconst kNegPiToPiInterval = new F32Interval(\n  kValue.f32.negative.pi.whole,\n  kValue.f32.positive.pi.whole\n);\n\n/** F32Interval of values greater than 0 and less than or equal to f32 max */\nconst kGreaterThanZeroInterval = new F32Interval(\n  kValue.f32.subnormal.positive.min,\n  kValue.f32.positive.max\n);\n\n/** Representation of a vec2/3/4 of floating point intervals as an array of F32Intervals */\ntype F32Vector =\n  | [F32Interval, F32Interval]\n  | [F32Interval, F32Interval, F32Interval]\n  | [F32Interval, F32Interval, F32Interval, F32Interval];\n\n/** Coerce F32Interval[] to F32Vector if possible */\nfunction isF32Vector(v: number[] | F32Interval[]): v is F32Vector {\n  if (v[0] instanceof F32Interval) {\n    return v.length === 2 || v.length === 3 || v.length === 4;\n  }\n  return false;\n}\n\n/** @returns an F32Vector representation of an array fo F32Intervals if possible */\nfunction toF32Vector(v: number[] | F32Vector): F32Vector {\n  if (isF32Vector(v)) {\n    return v;\n  }\n\n  const f = v.map(toF32Interval);\n  if (isF32Vector(f)) {\n    return f;\n  }\n  unreachable(`Cannot convert [${v}] to F32Vector`);\n}\n\n/**\n * @returns the input plus zero if any of the entries are subnormal, otherwise\n * returns the input\n */\nfunction addFlushedIfNeeded(values: number[]): number[] {\n  return values.some(isSubnormalNumber) ? values.concat(0) : values;\n}\n\n/**\n * A function that converts a point to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface PointToInterval {\n  (x: number): F32Interval;\n}\n\n/** Operation used to implement a PointToInterval */\nexport interface PointToIntervalOp {\n  /** @returns acceptance interval for a function at point x */\n  impl: PointToInterval;\n\n  /**\n   * Calculates where in the domain defined by x the min/max extrema of impl\n   * occur and returns a span of those points to be used as the domain instead.\n   *\n   * Used by runPointOp before invoking impl.\n   * If not defined, the bounds of the existing domain are assumed to be the\n   * extrema.\n   *\n   * This is only implemented for operations that meet all of the following\n   * criteria:\n   *   a) non-monotonic\n   *   b) used in inherited accuracy calculations\n   *   c) need to take in an interval for b)\n   *      i.e. fooInterval takes in x: number | F32Interval, not x: number\n   */\n  extrema?: (x: F32Interval) => F32Interval;\n}\n\n/**\n * Restrict the inputs to an PointToInterval operation\n *\n * Only used for operations that have tighter domain requirements than 'must be\n * f32 finite'.\n *\n * @param domain interval to restrict inputs to\n * @param impl operation implementation to run if input is within the required domain\n * @returns a PointToInterval that calls impl if domain contains the input,\n *          otherwise it returns the any() interval */\nfunction limitPointToIntervalDomain(domain: F32Interval, impl: PointToInterval): PointToInterval {\n  return (n: number): F32Interval => {\n    return domain.contains(n) ? impl(n) : F32Interval.any();\n  };\n}\n\n/**\n * A function that converts a pair of points to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface BinaryToInterval {\n  (x: number, y: number): F32Interval;\n}\n\n/** Operation used to implement a BinaryToInterval */\ninterface BinaryToIntervalOp {\n  /** @returns acceptance interval for a function at point (x, y) */\n  impl: BinaryToInterval;\n  /**\n   * Calculates where in domain defined by x & y the min/max extrema of impl\n   * occur and returns spans of those points to be used as the domain instead.\n   *\n   * Used by runBinaryOp before invoking impl.\n   * If not defined, the bounds of the existing domain are assumed to be the\n   * extrema.\n   *\n   * This is only implemented for functions that meet all of the following\n   * criteria:\n   *   a) non-monotonic\n   *   b) used in inherited accuracy calculations\n   *   c) need to take in an interval for b)\n   */\n  extrema?: (x: F32Interval, y: F32Interval) => [F32Interval, F32Interval];\n}\n\n/** Domain for a BinaryToInterval implementation */\ninterface BinaryToIntervalDomain {\n  x: F32Interval;\n  // y is an array to support handling domains composed of discrete intervals\n  y: F32Interval[];\n}\n\n/**\n * Restrict the inputs to a BinaryToInterval\n *\n * Only used for operations that have tighter domain requirements than 'must be\n * f32 finite'.\n *\n * @param domain set of intervals to restrict inputs to\n * @param impl operation implementation to run if input is within the required domain\n * @returns a BinaryToInterval that calls impl if domain contains the input,\n *          otherwise it returns the any() interval */\nfunction limitBinaryToIntervalDomain(\n  domain: BinaryToIntervalDomain,\n  impl: BinaryToInterval\n): BinaryToInterval {\n  return (x: number, y: number): F32Interval => {\n    if (!domain.x.contains(x)) {\n      return F32Interval.any();\n    }\n\n    if (!domain.y.some(d => d.contains(y))) {\n      return F32Interval.any();\n    }\n\n    return impl(x, y);\n  };\n}\n\n/**\n * A function that converts a triplet of points to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface TernaryToInterval {\n  (x: number, y: number, z: number): F32Interval;\n}\n\n/** Operation used to implement a TernaryToInterval */\ninterface TernaryToIntervalOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns acceptance interval for a function at point (x, y, z) */\n  impl: TernaryToInterval;\n}\n\n/**\n * A function that converts a pair of vectors to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorPairToInterval {\n  (x: number[], y: number[]): F32Interval;\n}\n\n/** Operation used to implement a VectorPairToInterval */\ninterface VectorPairToIntervalOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns acceptance interval for a function on vectors (x, y) */\n  impl: VectorPairToInterval;\n}\n\n/** Converts a point to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * op.extrema is invoked before this point in the call stack.\n * op.domain is tested before this point in the call stack.\n *\n * @param n value to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushPointToInterval(n: number, op: PointToIntervalOp) {\n  assert(!Number.isNaN(n), `flush not defined for NaN`);\n  const values = correctlyRoundedF32(n);\n  const inputs = addFlushedIfNeeded(values);\n  const results = new Set<F32Interval>(inputs.map(op.impl));\n  return F32Interval.span(...results);\n}\n\n/** Converts a pair to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * All unique combinations of x & y are run.\n * op.extrema is invoked before this point in the call stack.\n * op.domain is tested before this point in the call stack.\n *\n * @param x first param to flush & round then invoke op.impl on\n * @param y second param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushBinaryToInterval(x: number, y: number, op: BinaryToIntervalOp): F32Interval {\n  assert(!Number.isNaN(x), `flush not defined for NaN`);\n  assert(!Number.isNaN(y), `flush not defined for NaN`);\n  const x_values = correctlyRoundedF32(x);\n  const y_values = correctlyRoundedF32(y);\n  const x_inputs = addFlushedIfNeeded(x_values);\n  const y_inputs = addFlushedIfNeeded(y_values);\n  const intervals = new Set<F32Interval>();\n  x_inputs.forEach(inner_x => {\n    y_inputs.forEach(inner_y => {\n      intervals.add(op.impl(inner_x, inner_y));\n    });\n  });\n  return F32Interval.span(...intervals);\n}\n\n/** Converts a triplet to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * All unique combinations of x, y & z are run.\n *\n * @param x first param to flush & round then invoke op.impl on\n * @param y second param to flush & round then invoke op.impl on\n * @param z third param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushTernaryToInterval(\n  x: number,\n  y: number,\n  z: number,\n  op: TernaryToIntervalOp\n): F32Interval {\n  assert(!Number.isNaN(x), `flush not defined for NaN`);\n  assert(!Number.isNaN(y), `flush not defined for NaN`);\n  assert(!Number.isNaN(z), `flush not defined for NaN`);\n  const x_values = correctlyRoundedF32(x);\n  const y_values = correctlyRoundedF32(y);\n  const z_values = correctlyRoundedF32(z);\n  const x_inputs = addFlushedIfNeeded(x_values);\n  const y_inputs = addFlushedIfNeeded(y_values);\n  const z_inputs = addFlushedIfNeeded(z_values);\n  const intervals = new Set<F32Interval>();\n  // prettier-ignore\n  x_inputs.forEach(inner_x => {\n    y_inputs.forEach(inner_y => {\n      z_inputs.forEach(inner_z => {\n        intervals.add(op.impl(inner_x, inner_y, inner_z));\n      });\n    });\n  });\n\n  return F32Interval.span(...intervals);\n}\n\n/** Converts a pair of vectors to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * All unique combinations of x & y are run.\n *\n * @param x first param to flush & round then invoke op.impl on\n * @param y second param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushVectorPairToInterval(\n  x: number[],\n  y: number[],\n  op: VectorPairToIntervalOp\n): F32Interval {\n  assert(\n    x.every(e => !Number.isNaN(e)),\n    `flush not defined for NaN`\n  );\n  assert(\n    y.every(e => !Number.isNaN(e)),\n    `flush not defined for NaN`\n  );\n\n  const x_rounded: number[][] = x.map(correctlyRoundedF32);\n  const y_rounded: number[][] = y.map(correctlyRoundedF32);\n  const x_flushed: number[][] = x_rounded.map(addFlushedIfNeeded);\n  const y_flushed: number[][] = y_rounded.map(addFlushedIfNeeded);\n  const x_inputs = cartesianProduct<number>(...x_flushed);\n  const y_inputs = cartesianProduct<number>(...y_flushed);\n\n  const intervals = new Set<F32Interval>();\n  x_inputs.forEach(inner_x => {\n    y_inputs.forEach(inner_y => {\n      intervals.add(op.impl(inner_x, inner_y));\n    });\n  });\n  return F32Interval.span(...intervals);\n}\n\n/** Calculate the acceptance interval for a unary function over an interval\n *\n * If the interval is actually a point, this just decays to\n * roundAndFlushPointToInterval.\n *\n * The provided domain interval may be adjusted if the operation defines an\n * extrema function.\n *\n * @param x input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runPointOp(x: F32Interval, op: PointToIntervalOp): F32Interval {\n  if (!x.isFinite()) {\n    return F32Interval.any();\n  }\n\n  if (op.extrema !== undefined) {\n    x = op.extrema(x);\n  }\n\n  const result = F32Interval.span(...x.bounds().map(b => roundAndFlushPointToInterval(b, op)));\n  return result.isFinite() ? result : F32Interval.any();\n}\n\n/** Calculate the acceptance interval for a binary function over an interval\n *\n * The provided domain intervals may be adjusted if the operation defines an\n * extrema function.\n *\n * @param x first input domain interval\n * @param y second input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runBinaryOp(x: F32Interval, y: F32Interval, op: BinaryToIntervalOp): F32Interval {\n  if (!x.isFinite() || !y.isFinite()) {\n    return F32Interval.any();\n  }\n\n  if (op.extrema !== undefined) {\n    [x, y] = op.extrema(x, y);\n  }\n\n  const outputs = new Set<F32Interval>();\n  x.bounds().forEach(inner_x => {\n    y.bounds().forEach(inner_y => {\n      outputs.add(roundAndFlushBinaryToInterval(inner_x, inner_y, op));\n    });\n  });\n\n  const result = F32Interval.span(...outputs);\n  return result.isFinite() ? result : F32Interval.any();\n}\n\n/** Calculate the acceptance interval for a ternary function over an interval\n *\n * @param x first input domain interval\n * @param y second input domain interval\n * @param z third input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runTernaryOp(\n  x: F32Interval,\n  y: F32Interval,\n  z: F32Interval,\n  op: TernaryToIntervalOp\n): F32Interval {\n  if (!x.isFinite() || !y.isFinite() || !z.isFinite()) {\n    return F32Interval.any();\n  }\n\n  const outputs = new Set<F32Interval>();\n  x.bounds().forEach(inner_x => {\n    y.bounds().forEach(inner_y => {\n      z.bounds().forEach(inner_z => {\n        outputs.add(roundAndFlushTernaryToInterval(inner_x, inner_y, inner_z, op));\n      });\n    });\n  });\n\n  const result = F32Interval.span(...outputs);\n  return result.isFinite() ? result : F32Interval.any();\n}\n\n/** Calculate the acceptance interval for a vector pair function over given intervals\n *\n * @param x first input domain intervals vector\n * @param y second input domain intervals vector\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runVectorPairBinaryOp(\n  x: F32Vector,\n  y: F32Vector,\n  op: VectorPairToIntervalOp\n): F32Interval {\n  if (x.some(e => !e.isFinite()) || y.some(e => !e.isFinite())) {\n    return F32Interval.any();\n  }\n\n  const x_values = cartesianProduct<number>(...x.map(e => e.bounds()));\n  const y_values = cartesianProduct<number>(...y.map(e => e.bounds()));\n\n  const outputs = new Set<F32Interval>();\n  x_values.forEach(inner_x => {\n    y_values.forEach(inner_y => {\n      outputs.add(roundAndFlushVectorPairToInterval(inner_x, inner_y, op));\n    });\n  });\n\n  const result = F32Interval.span(...outputs);\n  return result.isFinite() ? result : F32Interval.any();\n}\n\n/** Defines a PointToIntervalOp for an interval of the correctly rounded values around the point */\nconst CorrectlyRoundedIntervalOp: PointToIntervalOp = {\n  impl: (n: number) => {\n    assert(!Number.isNaN(n), `absolute not defined for NaN`);\n    return toF32Interval(n);\n  },\n};\n\n/** @returns an interval of the correctly rounded values around the point */\nexport function correctlyRoundedInterval(n: number): F32Interval {\n  return runPointOp(toF32Interval(n), CorrectlyRoundedIntervalOp);\n}\n\n/** @returns a PointToIntervalOp for [n - error_range, n + error_range] */\nfunction AbsoluteErrorIntervalOp(error_range: number): PointToIntervalOp {\n  const op: PointToIntervalOp = {\n    impl: (_: number) => {\n      return F32Interval.any();\n    },\n  };\n\n  if (isF32Finite(error_range)) {\n    op.impl = (n: number) => {\n      assert(!Number.isNaN(n), `absolute error not defined for NaN`);\n      return new F32Interval(n - error_range, n + error_range);\n    };\n  }\n\n  return op;\n}\n\n/** @returns an interval of the absolute error around the point */\nexport function absoluteErrorInterval(n: number, error_range: number): F32Interval {\n  error_range = Math.abs(error_range);\n  return runPointOp(toF32Interval(n), AbsoluteErrorIntervalOp(error_range));\n}\n\n/** @returns a PointToIntervalOp for [n - numULP * ULP(n), n + numULP * ULP(n)] */\nfunction ULPIntervalOp(numULP: number): PointToIntervalOp {\n  const op: PointToIntervalOp = {\n    impl: (_: number) => {\n      return F32Interval.any();\n    },\n  };\n\n  if (isF32Finite(numULP)) {\n    op.impl = (n: number) => {\n      assert(!Number.isNaN(n), `ULP error not defined for NaN`);\n\n      const ulp = oneULP(n);\n      const begin = n - numULP * ulp;\n      const end = n + numULP * ulp;\n\n      return new F32Interval(\n        Math.min(begin, flushSubnormalNumber(begin)),\n        Math.max(end, flushSubnormalNumber(end))\n      );\n    };\n  }\n\n  return op;\n}\n\n/** @returns an interval of N * ULP around the point */\nexport function ulpInterval(n: number, numULP: number): F32Interval {\n  numULP = Math.abs(numULP);\n  return runPointOp(toF32Interval(n), ULPIntervalOp(numULP));\n}\n\nconst AbsIntervalOp: PointToIntervalOp = {\n  impl: (n: number) => {\n    return correctlyRoundedInterval(Math.abs(n));\n  },\n};\n\n/** Calculate an acceptance interval for abs(n) */\nexport function absInterval(n: number): F32Interval {\n  return runPointOp(toF32Interval(n), AbsIntervalOp);\n}\n\n/** All acceptance interval functions for acosh(x) */\nexport const acoshIntervals: PointToInterval[] = [acoshAlternativeInterval, acoshPrimaryInterval];\n\nconst AcoshAlternativeIntervalOp: PointToIntervalOp = {\n  impl: (x: number): F32Interval => {\n    // acosh(x) = log(x + sqrt((x + 1.0f) * (x - 1.0)))\n    const inner_value = multiplicationInterval(\n      additionInterval(x, 1.0),\n      subtractionInterval(x, 1.0)\n    );\n    const sqrt_value = sqrtInterval(inner_value);\n    return logInterval(additionInterval(x, sqrt_value));\n  },\n};\n\n/** Calculate an acceptance interval of acosh(x) using log(x + sqrt((x + 1.0f) * (x - 1.0))) */\nexport function acoshAlternativeInterval(x: number | F32Interval): F32Interval {\n  return runPointOp(toF32Interval(x), AcoshAlternativeIntervalOp);\n}\n\nconst AcoshPrimaryIntervalOp: PointToIntervalOp = {\n  impl: (x: number): F32Interval => {\n    // acosh(x) = log(x + sqrt(x * x - 1.0))\n    const inner_value = subtractionInterval(multiplicationInterval(x, x), 1.0);\n    const sqrt_value = sqrtInterval(inner_value);\n    return logInterval(additionInterval(x, sqrt_value));\n  },\n};\n\n/** Calculate an acceptance interval of acosh(x) using log(x + sqrt(x * x - 1.0)) */\nexport function acoshPrimaryInterval(x: number | F32Interval): F32Interval {\n  return runPointOp(toF32Interval(x), AcoshPrimaryIntervalOp);\n}\n\nconst AdditionIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(x + y);\n  },\n};\n\n/** Calculate an acceptance interval of x + y */\nexport function additionInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryOp(toF32Interval(x), toF32Interval(y), AdditionIntervalOp);\n}\n\nconst AsinhIntervalOp: PointToIntervalOp = {\n  impl: (x: number): F32Interval => {\n    // asinh(x) = log(x + sqrt(x * x + 1.0))\n    const inner_value = additionInterval(multiplicationInterval(x, x), 1.0);\n    const sqrt_value = sqrtInterval(inner_value);\n    return logInterval(additionInterval(x, sqrt_value));\n  },\n};\n\n/** Calculate an acceptance interval of asinh(x) */\nexport function asinhInterval(n: number): F32Interval {\n  return runPointOp(toF32Interval(n), AsinhIntervalOp);\n}\n\nconst AtanIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return ulpInterval(Math.atan(n), 4096);\n  },\n};\n\n/** Calculate an acceptance interval of atan(x) */\nexport function atanInterval(n: number): F32Interval {\n  return runPointOp(toF32Interval(n), AtanIntervalOp);\n}\n\nconst Atan2IntervalOp: BinaryToIntervalOp = {\n  impl: (y: number, x: number): F32Interval => {\n    const numULP = 4096;\n    if (y === 0) {\n      if (x === 0) {\n        return F32Interval.any();\n      } else {\n        return F32Interval.span(\n          ulpInterval(kValue.f32.negative.pi.whole, numULP),\n          ulpInterval(kValue.f32.positive.pi.whole, numULP)\n        );\n      }\n    }\n    return ulpInterval(Math.atan2(y, x), numULP);\n  },\n  extrema: (y: F32Interval, x: F32Interval): [F32Interval, F32Interval] => {\n    if (y.contains(0)) {\n      if (x.contains(0)) {\n        return [toF32Interval(0), toF32Interval(0)];\n      }\n      return [toF32Interval(0), x];\n    }\n    return [y, x];\n  },\n};\n\n/** Calculate an acceptance interval of atan2(y, x) */\nexport function atan2Interval(y: number | F32Interval, x: number | F32Interval): F32Interval {\n  return runBinaryOp(toF32Interval(y), toF32Interval(x), Atan2IntervalOp);\n}\n\nconst AtanhIntervalOp: PointToIntervalOp = {\n  impl: (n: number) => {\n    // atanh(x) = log((1.0 + x) / (1.0 - x)) * 0.5\n    const numerator = additionInterval(1.0, n);\n    const denominator = subtractionInterval(1.0, n);\n    const log_interval = logInterval(divisionInterval(numerator, denominator));\n    return multiplicationInterval(log_interval, 0.5);\n  },\n};\n\n/** Calculate an acceptance interval of atanh(x) */\nexport function atanhInterval(n: number): F32Interval {\n  return runPointOp(toF32Interval(n), AtanhIntervalOp);\n}\n\nconst CeilIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return correctlyRoundedInterval(Math.ceil(n));\n  },\n};\n\n/** Calculate an acceptance interval of ceil(x) */\nexport function ceilInterval(n: number): F32Interval {\n  return runPointOp(toF32Interval(n), CeilIntervalOp);\n}\n\nconst ClampMedianIntervalOp: TernaryToIntervalOp = {\n  impl: (x: number, y: number, z: number): F32Interval => {\n    return correctlyRoundedInterval(\n      // Default sort is string sort, so have to implement numeric comparison.\n      // Cannot use the b-a one liner, because that assumes no infinities.\n      [x, y, z].sort((a, b) => {\n        if (a < b) {\n          return -1;\n        }\n        if (a > b) {\n          return 1;\n        }\n        return 0;\n      })[1]\n    );\n  },\n};\n\n/** All acceptance interval functions for clamp(x, y, z) */\nexport const clampIntervals: TernaryToInterval[] = [clampMinMaxInterval, clampMedianInterval];\n\n/** Calculate an acceptance interval of clamp(x, y, z) via median(x, y, z) */\nexport function clampMedianInterval(\n  x: number | F32Interval,\n  y: number | F32Interval,\n  z: number | F32Interval\n): F32Interval {\n  return runTernaryOp(toF32Interval(x), toF32Interval(y), toF32Interval(z), ClampMedianIntervalOp);\n}\n\nconst ClampMinMaxIntervalOp: TernaryToIntervalOp = {\n  impl: (x: number, low: number, high: number): F32Interval => {\n    return correctlyRoundedInterval(Math.min(Math.max(x, low), high));\n  },\n};\n\n/** Calculate an acceptance interval of clamp(x, high, low) via min(max(x, low), high) */\nexport function clampMinMaxInterval(\n  x: number | F32Interval,\n  low: number | F32Interval,\n  high: number | F32Interval\n): F32Interval {\n  return runTernaryOp(\n    toF32Interval(x),\n    toF32Interval(low),\n    toF32Interval(high),\n    ClampMinMaxIntervalOp\n  );\n}\n\nconst CosIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kNegPiToPiInterval,\n    (n: number): F32Interval => {\n      return absoluteErrorInterval(Math.cos(n), 2 ** -11);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of cos(x) */\nexport function cosInterval(n: number): F32Interval {\n  return runPointOp(toF32Interval(n), CosIntervalOp);\n}\n\nconst CoshIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    // cosh(x) = (exp(x) + exp(-x)) * 0.5\n    const minus_n = negationInterval(n);\n    return multiplicationInterval(additionInterval(expInterval(n), expInterval(minus_n)), 0.5);\n  },\n};\n\n/** Calculate an acceptance interval of cosh(x) */\nexport function coshInterval(n: number): F32Interval {\n  return runPointOp(toF32Interval(n), CoshIntervalOp);\n}\n\nconst DegreesIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return multiplicationInterval(n, 57.295779513082322865);\n  },\n};\n\n/** Calculate an acceptance interval of degrees(x) */\nexport function degreesInterval(n: number): F32Interval {\n  return runPointOp(toF32Interval(n), DegreesIntervalOp);\n}\n\nconst DivisionIntervalOp: BinaryToIntervalOp = {\n  impl: limitBinaryToIntervalDomain(\n    {\n      x: new F32Interval(kValue.f32.negative.min, kValue.f32.positive.max),\n      y: [new F32Interval(-(2 ** 126), -(2 ** -126)), new F32Interval(2 ** -126, 2 ** 126)],\n    },\n    (x: number, y: number): F32Interval => {\n      if (y === 0) {\n        return F32Interval.any();\n      }\n      return ulpInterval(x / y, 2.5);\n    }\n  ),\n  extrema: (x: F32Interval, y: F32Interval): [F32Interval, F32Interval] => {\n    // division has a discontinuity at y = 0.\n    if (y.contains(0)) {\n      y = toF32Interval(0);\n    }\n    return [x, y];\n  },\n};\n\n/** Calculate an acceptance interval of x / y */\nexport function divisionInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryOp(toF32Interval(x), toF32Interval(y), DivisionIntervalOp);\n}\n\nconst DotIntervalOp: VectorPairToIntervalOp = {\n  impl: (x: number[], y: number[]): F32Interval => {\n    // dot(x, y) = sum of x[i] * y[i]\n    const multiplications: F32Interval[] = x.map((_, i) => multiplicationInterval(x[i], y[i]));\n    return multiplications.reduce((previous, current) => additionInterval(previous, current));\n  },\n};\n\nexport function dotInterval(x: number[], y: number[]): F32Interval {\n  assert(x.length === y.length, `dot not defined for vectors with different lengths`);\n  return runVectorPairBinaryOp(toF32Vector(x), toF32Vector(y), DotIntervalOp);\n}\n\nconst ExpIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return ulpInterval(Math.exp(n), 3 + 2 * Math.abs(n));\n  },\n};\n\n/** Calculate an acceptance interval for exp(x) */\nexport function expInterval(x: number | F32Interval): F32Interval {\n  return runPointOp(toF32Interval(x), ExpIntervalOp);\n}\n\nconst Exp2IntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return ulpInterval(Math.pow(2, n), 3 + 2 * Math.abs(n));\n  },\n};\n\n/** Calculate an acceptance interval for exp2(x) */\nexport function exp2Interval(x: number | F32Interval): F32Interval {\n  return runPointOp(toF32Interval(x), Exp2IntervalOp);\n}\n\nconst FloorIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return correctlyRoundedInterval(Math.floor(n));\n  },\n};\n\n/** Calculate an acceptance interval of floor(x) */\nexport function floorInterval(n: number): F32Interval {\n  return runPointOp(toF32Interval(n), FloorIntervalOp);\n}\n\nconst FractIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    // fract(x) = x - floor(x) is defined in the spec.\n    // For people coming from a non-graphics background this will cause some unintuitive results. For example,\n    // fract(-1.1) is not 0.1 or -0.1, but instead 0.9.\n    // This is how other shading languages operate and allows for a desirable wrap around in graphics programming.\n    const result = subtractionInterval(n, floorInterval(n));\n    if (result.contains(1)) {\n      // Very small negative numbers can lead to catastrophic cancellation, thus calculating a fract of 1.0, which is\n      // technically not a fractional part, so some implementations clamp the result to next nearest number.\n      return F32Interval.span(result, toF32Interval(kValue.f32.positive.less_than_one));\n    }\n    return result;\n  },\n};\n\n/** Calculate an acceptance interval of fract(x) */\nexport function fractInterval(n: number): F32Interval {\n  return runPointOp(toF32Interval(n), FractIntervalOp);\n}\n\nconst InverseSqrtIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kGreaterThanZeroInterval,\n    (n: number): F32Interval => {\n      return ulpInterval(1 / Math.sqrt(n), 2);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of inverseSqrt(x) */\nexport function inverseSqrtInterval(n: number | F32Interval): F32Interval {\n  return runPointOp(toF32Interval(n), InverseSqrtIntervalOp);\n}\n\nconst LdexpIntervalOp: BinaryToIntervalOp = {\n  impl: limitBinaryToIntervalDomain(\n    // Implementing SPIR-V's more restrictive domain until\n    // https://github.com/gpuweb/gpuweb/issues/3134 is resolved\n    {\n      x: new F32Interval(kValue.f32.negative.min, kValue.f32.positive.max),\n      y: [new F32Interval(-126, 128)],\n    },\n    (e1: number, e2: number): F32Interval => {\n      // Though the spec says the result of ldexp(e1, e2) = e1 * 2 ^ e2, the\n      // accuracy is listed as correctly rounded to the true value, so the\n      // inheritance framework does not need to be invoked to determine bounds.\n      // Instead the value at a higher precision is calculated and passed to\n      // correctlyRoundedInterval.\n      const result = e1 * 2 ** e2;\n      if (Number.isNaN(result)) {\n        // Overflowed TS's number type, so definitely out of bounds for f32\n        return F32Interval.any();\n      }\n      return correctlyRoundedInterval(result);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of ldexp(e1, e2) */\nexport function ldexpInterval(e1: number, e2: number): F32Interval {\n  return roundAndFlushBinaryToInterval(e1, e2, LdexpIntervalOp);\n}\n\nconst LogIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kGreaterThanZeroInterval,\n    (n: number): F32Interval => {\n      if (n >= 0.5 && n <= 2.0) {\n        return absoluteErrorInterval(Math.log(n), 2 ** -21);\n      }\n      return ulpInterval(Math.log(n), 3);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of log(x) */\nexport function logInterval(x: number | F32Interval): F32Interval {\n  return runPointOp(toF32Interval(x), LogIntervalOp);\n}\n\nconst Log2IntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kGreaterThanZeroInterval,\n    (n: number): F32Interval => {\n      if (n >= 0.5 && n <= 2.0) {\n        return absoluteErrorInterval(Math.log2(n), 2 ** -21);\n      }\n      return ulpInterval(Math.log2(n), 3);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of log2(x) */\nexport function log2Interval(x: number | F32Interval): F32Interval {\n  return runPointOp(toF32Interval(x), Log2IntervalOp);\n}\n\nconst MaxIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(Math.max(x, y));\n  },\n};\n\n/** Calculate an acceptance interval of max(x, y) */\nexport function maxInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryOp(toF32Interval(x), toF32Interval(y), MaxIntervalOp);\n}\n\nconst MinIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(Math.min(x, y));\n  },\n};\n\n/** Calculate an acceptance interval of min(x, y) */\nexport function minInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryOp(toF32Interval(x), toF32Interval(y), MinIntervalOp);\n}\n\nconst MixImpreciseIntervalOp: TernaryToIntervalOp = {\n  impl: (x: number, y: number, z: number): F32Interval => {\n    // x + (y - x) * z =\n    //  x + t, where t = (y - x) * z\n    const t = multiplicationInterval(subtractionInterval(y, x), z);\n    return additionInterval(x, t);\n  },\n};\n\n/** All acceptance interval functions for mix(x, y, z) */\nexport const mixIntervals: TernaryToInterval[] = [mixImpreciseInterval, mixPreciseInterval];\n\n/** Calculate an acceptance interval of mix(x, y, z) using x + (y - x) * z */\nexport function mixImpreciseInterval(x: number, y: number, z: number): F32Interval {\n  return runTernaryOp(toF32Interval(x), toF32Interval(y), toF32Interval(z), MixImpreciseIntervalOp);\n}\n\nconst MixPreciseIntervalOp: TernaryToIntervalOp = {\n  impl: (x: number, y: number, z: number): F32Interval => {\n    // x * (1.0 - z) + y * z =\n    //   t + s, where t = x * (1.0 - z), s = y * z\n    const t = multiplicationInterval(x, subtractionInterval(1.0, z));\n    const s = multiplicationInterval(y, z);\n    return additionInterval(t, s);\n  },\n};\n\n/** Calculate an acceptance interval of mix(x, y, z) using x * (1.0 - z) + y * z */\nexport function mixPreciseInterval(x: number, y: number, z: number): F32Interval {\n  return runTernaryOp(toF32Interval(x), toF32Interval(y), toF32Interval(z), MixPreciseIntervalOp);\n}\n\nconst MultiplicationInnerOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(x * y);\n  },\n};\n\nconst MultiplicationIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return roundAndFlushBinaryToInterval(x, y, MultiplicationInnerOp);\n  },\n};\n\n/** Calculate an acceptance interval of x * y */\nexport function multiplicationInterval(\n  x: number | F32Interval,\n  y: number | F32Interval\n): F32Interval {\n  return runBinaryOp(toF32Interval(x), toF32Interval(y), MultiplicationIntervalOp);\n}\n\nconst NegationIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return correctlyRoundedInterval(-n);\n  },\n};\n\n/** Calculate an acceptance interval of -x */\nexport function negationInterval(n: number): F32Interval {\n  return runPointOp(toF32Interval(n), NegationIntervalOp);\n}\n\nconst PowIntervalOp: BinaryToIntervalOp = {\n  // pow(x, y) has no explicit domain restrictions, but inherits the x <= 0\n  // domain restriction from log2(x). Invoking log2Interval(x) in impl will\n  // enforce this, so there is no need to wrap the impl call here.\n  impl: (x: number, y: number): F32Interval => {\n    return exp2Interval(multiplicationInterval(y, log2Interval(x)));\n  },\n};\n\n/** Calculate an acceptance interval of pow(x, y) */\nexport function powInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryOp(toF32Interval(x), toF32Interval(y), PowIntervalOp);\n}\n\nconst RadiansIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return multiplicationInterval(n, 0.017453292519943295474);\n  },\n};\n\n/** Calculate an acceptance interval of radians(x) */\nexport function radiansInterval(n: number): F32Interval {\n  return runPointOp(toF32Interval(n), RadiansIntervalOp);\n}\n\nconst RemainderIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    // x % y = x - y * trunc(x/y)\n    return subtractionInterval(x, multiplicationInterval(y, truncInterval(divisionInterval(x, y))));\n  },\n};\n\n/** Calculate an acceptance interval for x % y */\nexport function remainderInterval(x: number, y: number): F32Interval {\n  return runBinaryOp(toF32Interval(x), toF32Interval(y), RemainderIntervalOp);\n}\n\nconst RoundIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    const k = Math.floor(n);\n    const diff_before = n - k;\n    const diff_after = k + 1 - n;\n    if (diff_before < diff_after) {\n      return correctlyRoundedInterval(k);\n    } else if (diff_before > diff_after) {\n      return correctlyRoundedInterval(k + 1);\n    }\n\n    // n is in the middle of two integers.\n    // The tie breaking rule is 'k if k is even, k + 1 if k is odd'\n    if (k % 2 === 0) {\n      return correctlyRoundedInterval(k);\n    }\n    return correctlyRoundedInterval(k + 1);\n  },\n};\n\n/** Calculate an acceptance interval of round(x) */\nexport function roundInterval(n: number): F32Interval {\n  return runPointOp(toF32Interval(n), RoundIntervalOp);\n}\n\n/**\n * Calculate an acceptance interval of saturate(n) as clamp(n, 0.0, 1.0)\n *\n * The definition of saturate is such that both possible implementations of\n * clamp will return the same value, so arbitrarily picking the minmax version\n * to use.\n */\nexport function saturateInterval(n: number): F32Interval {\n  return runTernaryOp(\n    toF32Interval(n),\n    toF32Interval(0.0),\n    toF32Interval(1.0),\n    ClampMinMaxIntervalOp\n  );\n}\n\nconst SignIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    if (n > 0.0) {\n      return correctlyRoundedInterval(1.0);\n    }\n    if (n < 0.0) {\n      return correctlyRoundedInterval(-1.0);\n    }\n\n    return correctlyRoundedInterval(0.0);\n  },\n};\n\n/** Calculate an acceptance interval of sin(x) */\nexport function signInterval(n: number): F32Interval {\n  return runPointOp(toF32Interval(n), SignIntervalOp);\n}\n\nconst SinIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kNegPiToPiInterval,\n    (n: number): F32Interval => {\n      return absoluteErrorInterval(Math.sin(n), 2 ** -11);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of sin(x) */\nexport function sinInterval(n: number): F32Interval {\n  return runPointOp(toF32Interval(n), SinIntervalOp);\n}\n\nconst SinhIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    // sinh(x) = (exp(x) - exp(-x)) * 0.5\n    const minus_n = negationInterval(n);\n    return multiplicationInterval(subtractionInterval(expInterval(n), expInterval(minus_n)), 0.5);\n  },\n};\n\n/** Calculate an acceptance interval of sinh(x) */\nexport function sinhInterval(n: number): F32Interval {\n  return runPointOp(toF32Interval(n), SinhIntervalOp);\n}\n\nconst SmoothStepOp: TernaryToIntervalOp = {\n  impl: (low: number, high: number, x: number): F32Interval => {\n    // For clamp(foo, 0.0, 1.0) the different implementations of clamp provide\n    // the same value, so arbitrarily picking the minmax version to use.\n    // t = clamp((x - low) / (high - low), 0.0, 1.0)\n    // prettier-ignore\n    const t = clampMedianInterval(\n      divisionInterval(\n        subtractionInterval(x, low),\n        subtractionInterval(high, low)),\n      0.0,\n      1.0);\n    // Inherited from t * t * (3.0 - 2.0 * t)\n    // prettier-ignore\n    return multiplicationInterval(\n      t,\n      multiplicationInterval(t,\n        subtractionInterval(3.0,\n          multiplicationInterval(2.0, t))));\n  },\n};\n\n/** Calculate an acceptance interval of smoothStep(low, high, x) */\nexport function smoothStepInterval(low: number, high: number, x: number): F32Interval {\n  return runTernaryOp(toF32Interval(low), toF32Interval(high), toF32Interval(x), SmoothStepOp);\n}\n\nconst SqrtIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return divisionInterval(1.0, inverseSqrtInterval(n));\n  },\n};\n\n/** Calculate an acceptance interval of sqrt(x) */\nexport function sqrtInterval(n: number | F32Interval): F32Interval {\n  return runPointOp(toF32Interval(n), SqrtIntervalOp);\n}\n\nconst StepIntervalOp: BinaryToIntervalOp = {\n  impl: (edge: number, x: number): F32Interval => {\n    if (edge <= x) {\n      return correctlyRoundedInterval(1.0);\n    }\n    return correctlyRoundedInterval(0.0);\n  },\n};\n\n/** Calculate an acceptance 'interval' for step(edge, x)\n *\n * step only returns two possible values, so its interval requires special\n * interpretation in CTS tests.\n * This interval will be one of four values: [0, 0], [0, 1], [1, 1] & [-∞, +∞].\n * [0, 0] and [1, 1] indicate that the correct answer in point they encapsulate.\n * [0, 1] should not be treated as a span, i.e. 0.1 is acceptable, but instead\n * indicate either 0.0 or 1.0 are acceptable answers.\n * [-∞, +∞] is treated as the any interval, since an undefined or infinite value was passed in.\n */\nexport function stepInterval(edge: number, x: number): F32Interval {\n  return runBinaryOp(toF32Interval(edge), toF32Interval(x), StepIntervalOp);\n}\n\nconst SubtractionInnerOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(x - y);\n  },\n};\n\nconst SubtractionIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return roundAndFlushBinaryToInterval(x, y, SubtractionInnerOp);\n  },\n};\n\n/** Calculate an acceptance interval of x - y */\nexport function subtractionInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryOp(toF32Interval(x), toF32Interval(y), SubtractionIntervalOp);\n}\n\nconst TanIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return divisionInterval(sinInterval(n), cosInterval(n));\n  },\n};\n\n/** Calculate an acceptance interval of tan(x) */\nexport function tanInterval(n: number): F32Interval {\n  return runPointOp(toF32Interval(n), TanIntervalOp);\n}\n\nconst TanhIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return divisionInterval(sinhInterval(n), coshInterval(n));\n  },\n};\n\n/** Calculate an acceptance interval of tanh(x) */\nexport function tanhInterval(n: number): F32Interval {\n  return runPointOp(toF32Interval(n), TanhIntervalOp);\n}\n\nconst TruncIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return correctlyRoundedInterval(Math.trunc(n));\n  },\n};\n\n/** Calculate an acceptance interval of trunc(x) */\nexport function truncInterval(n: number | F32Interval): F32Interval {\n  return runPointOp(toF32Interval(n), TruncIntervalOp);\n}\n"],"file":"f32_interval.js"}