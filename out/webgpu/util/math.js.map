{"version":3,"sources":["../../../src/webgpu/util/math.ts"],"names":["assert","kBit","kValue","f32","f32Bits","i32","kMaxSafeMultipleOf8","Number","MAX_SAFE_INTEGER","align","n","alignment","isInteger","Math","ceil","roundDown","floor","clamp","min","max","flushSubnormalNumber","val","u32_val","Uint32Array","Float32Array","buffer","flushSubnormalBits","flushSubnormalScalar","isSubnormalScalar","type","kind","value","valueOf","isSubnormalNumber","nextAfter","dir","flush","isNaN","nan","positive","s","POSITIVE_INFINITY","infinity","NEGATIVE_INFINITY","negative","subnormal","converted","u32_result","is_positive","next","oneULP","target","NaN","nearest_max","nearest_min","a","b","withinULP","ulp_flush","ulp_noflush","ulp","diff","correctlyRounded","test_value","accept_to_zero","accept_no_flush","result","correctlyRoundedImpl","target32","after_target","before_target","lerp","t","isFinite","x","linearRange","num_steps","Array","from","keys","map","i","biasedRange","c","pow","fullF32Range","counts","pos_sub","pos_norm","neg_norm","undefined","neg_sub","multiplyMatrices","A","B","length","product","fill","m","p","signExtend","bits","shift","quantizeToF32","num","quantizeToI32","isPowerOfTwo","gcd","bTemp","lcm"],"mappings":"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","sourcesContent":["import { assert } from '../../common/util/util.js';\n\nimport { kBit, kValue } from './constants.js';\nimport { f32, f32Bits, i32, Scalar } from './conversion.js';\n\n/**\n * A multiple of 8 guaranteed to be way too large to allocate (just under 8 pebibytes).\n * This is a \"safe\" integer (ULP <= 1.0) very close to MAX_SAFE_INTEGER.\n *\n * Note: allocations of this size are likely to exceed limitations other than just the system's\n * physical memory, so test cases are also needed to try to trigger \"true\" OOM.\n */\nexport const kMaxSafeMultipleOf8 = Number.MAX_SAFE_INTEGER - 7;\n\n/** Round `n` up to the next multiple of `alignment` (inclusive). */\n// MAINTENANCE_TODO: Rename to `roundUp`\nexport function align(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.ceil(n / alignment) * alignment;\n}\n\n/** Round `n` down to the next multiple of `alignment` (inclusive). */\nexport function roundDown(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.floor(n / alignment) * alignment;\n}\n\n/** Clamp a number to the provided range. */\nexport function clamp(n: number, { min, max }: { min: number; max: number }): number {\n  assert(max >= min);\n  return Math.min(Math.max(n, min), max);\n}\n\n/** @returns 0 if |val| is a subnormal f32 number, otherwise returns |val| */\nexport function flushSubnormalNumber(val: number): number {\n  const u32_val = new Uint32Array(new Float32Array([val]).buffer)[0];\n  return (u32_val & 0x7f800000) === 0 ? 0 : val;\n}\n\n/**\n * @returns 0 if |val| is a bit field for a subnormal f32 number, otherwise\n * returns |val|\n * |val| is assumed to be a u32 value representing a f32\n */\nfunction flushSubnormalBits(val: number): number {\n  return (val & 0x7f800000) === 0 ? 0 : val;\n}\n\n/** @returns 0 if |val| is a subnormal f32 number, otherwise returns |val| */\nexport function flushSubnormalScalar(val: Scalar): Scalar {\n  return isSubnormalScalar(val) ? f32(0) : val;\n}\n\n/**\n * @returns true if |val| is a subnormal f32 number, otherwise returns false\n * 0 is considered a non-subnormal number by this function.\n */\nexport function isSubnormalScalar(val: Scalar): boolean {\n  if (val.type.kind !== 'f32') {\n    return false;\n  }\n\n  if (val === f32(0)) {\n    return false;\n  }\n\n  const u32_val = new Uint32Array(new Float32Array([val.value.valueOf() as number]).buffer)[0];\n  return (u32_val & 0x7f800000) === 0;\n}\n\n/** Utility to pass TS numbers into |isSubnormalNumber| */\nexport function isSubnormalNumber(val: number): boolean {\n  return isSubnormalScalar(f32(val));\n}\n\n/**\n * @returns the next single precision floating point value after |val|,\n * towards +inf if |dir| is true, otherwise towards -inf.\n * If |flush| is true, all subnormal values will be flushed to 0,\n * before processing.\n * If |flush| is false, the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfter will be the closest subnormal in the correct\n * direction.\n * val needs to be in [min f32, max f32]\n */\nexport function nextAfter(val: number, dir: boolean = true, flush: boolean): Scalar {\n  if (Number.isNaN(val)) {\n    return f32Bits(kBit.f32.nan.positive.s);\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return f32Bits(kBit.f32.infinity.positive);\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return f32Bits(kBit.f32.infinity.negative);\n  }\n\n  assert(\n    val <= kValue.f32.positive.max && val >= kValue.f32.negative.min,\n    `${val} is not in the range of float32`\n  );\n\n  val = flush ? flushSubnormalNumber(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir) {\n      return flush ? f32Bits(kBit.f32.positive.min) : f32Bits(kBit.f32.subnormal.positive.min);\n    } else {\n      return flush ? f32Bits(kBit.f32.negative.max) : f32Bits(kBit.f32.subnormal.negative.max);\n    }\n  }\n\n  const converted: number = new Float32Array([val])[0];\n  let u32_result: number;\n  if (val === converted) {\n    // val is expressible precisely as a float32\n    let u32_val: number = new Uint32Array(new Float32Array([val]).buffer)[0];\n    const is_positive = (u32_val & 0x80000000) === 0;\n    if (dir === is_positive) {\n      u32_val += 1;\n    } else {\n      u32_val -= 1;\n    }\n    u32_result = flush ? flushSubnormalBits(u32_val) : u32_val;\n  } else {\n    // val had to be rounded to be expressed as a float32\n    if (dir === converted > val) {\n      // Rounding was in the direction requested\n      u32_result = new Uint32Array(new Float32Array([converted]).buffer)[0];\n    } else {\n      // Round was opposite of the direction requested, so need nextAfter in the requested direction.\n      // This will not recurse since converted is guaranteed to be a float32 due to the conversion above.\n      const next = nextAfter(converted, dir, flush).value.valueOf() as number;\n      u32_result = new Uint32Array(new Float32Array([next]).buffer)[0];\n    }\n  }\n\n  // Checking for overflow\n  if ((u32_result & 0x7f800000) === 0x7f800000) {\n    if (dir) {\n      return f32Bits(kBit.f32.infinity.positive);\n    } else {\n      return f32Bits(kBit.f32.infinity.negative);\n    }\n  }\n\n  return f32Bits(u32_result);\n}\n\n/**\n * @returns ulp(x), the unit of least precision for a specific number as a 32-bit float\n *\n * ulp(x) is the distance between the two floating point numbers nearest x.\n * This value is also called unit of last place, ULP, and 1 ULP.\n * See the WGSL spec and http://www.ens-lyon.fr/LIP/Pub/Rapports/RR/RR2005/RR2005-09.pdf\n * for a more detailed/nuanced discussion of the definition of ulp(x).\n *\n * @param target number to calculate ULP for\n * @param flush should subnormals be flushed to zero\n */\nexport function oneULP(target: number, flush: boolean): number {\n  if (Number.isNaN(target)) {\n    return Number.NaN;\n  }\n\n  if (flush) {\n    target = flushSubnormalNumber(target);\n  }\n\n  // For values at the edge of the range or beyond ulp(x) is defined as  the distance between the two nearest\n  // representable numbers to the appropriate edge.\n  if (target === Number.POSITIVE_INFINITY || target >= kValue.f32.positive.max) {\n    return kValue.f32.positive.max - kValue.f32.positive.nearest_max;\n  } else if (target === Number.NEGATIVE_INFINITY || target <= kValue.f32.negative.min) {\n    return kValue.f32.negative.nearest_min - kValue.f32.negative.min;\n  } else {\n    const converted: number = new Float32Array([target])[0];\n    if (converted === target) {\n      // |target| is precisely representable as a f32 so taking distance between it and the nearest neighbour in the\n      // direction of 0.\n      if (target > 0) {\n        const a = nextAfter(target, false, flush).value.valueOf() as number;\n        return target - a;\n      } else if (target < 0) {\n        const b = nextAfter(target, true, flush).value.valueOf() as number;\n        return b - target;\n      } else {\n        // For 0 both neighbours should be the same distance, so just using the positive value and simplifying.\n        return nextAfter(target, true, flush).value.valueOf() as number;\n      }\n    } else {\n      // |target| is not precisely representable as a f32 so taking distance of neighbouring f32s.\n      const b = nextAfter(target, true, flush).value.valueOf() as number;\n      const a = nextAfter(target, false, flush).value.valueOf() as number;\n      return b - a;\n    }\n  }\n}\n\n/**\n * @returns if a number is within N * ulp(x) of a target value\n * @param val number to test\n * @param target expected number\n * @param n acceptance range\n * @param flush should subnormals be flushed to zero\n */\nexport function withinULP(val: number, target: number, n: number = 1) {\n  if (Number.isNaN(val) || Number.isNaN(target)) {\n    return false;\n  }\n\n  const ulp_flush = oneULP(target, true);\n  const ulp_noflush = oneULP(target, false);\n  if (Number.isNaN(ulp_flush) || Number.isNaN(ulp_noflush)) {\n    return false;\n  }\n\n  if (val === target) {\n    return true;\n  }\n\n  const ulp = Math.max(ulp_flush, ulp_noflush);\n  const diff = val > target ? val - target : target - val;\n  return diff <= n * ulp;\n}\n\n/**\n * @returns if a test value is correctly rounded to an target value. Only\n * defined for |test_values| being a float32. target values may be any number.\n *\n * Correctly rounded means that if the target value is precisely expressible\n * as a float32, then |test_value| === |target|.\n * Otherwise |test_value| needs to be either the closest expressible number\n * greater or less than |target|.\n *\n * By default internally tests with both subnormals being flushed to 0 and not\n * being flushed, but |accept_to_zero| and |accept_no_flush| can be used to\n * control that behaviour. At least one accept flag must be true.\n */\nexport function correctlyRounded(\n  test_value: Scalar,\n  target: number,\n  accept_to_zero: boolean = true,\n  accept_no_flush: boolean = true\n): boolean {\n  assert(\n    accept_to_zero || accept_no_flush,\n    `At least one of |accept_to_zero| & |accept_no_flush| must be true`\n  );\n\n  let result: boolean = false;\n  if (accept_to_zero) {\n    result = result || correctlyRoundedImpl(test_value, target, true);\n  }\n  if (accept_no_flush) {\n    result = result || correctlyRoundedImpl(test_value, target, false);\n  }\n  return result;\n}\n\nfunction correctlyRoundedImpl(test_value: Scalar, target: number, flush: boolean): boolean {\n  assert(test_value.type.kind === 'f32', `${test_value} is expected to be a 'f32'`);\n\n  if (Number.isNaN(target)) {\n    return Number.isNaN(test_value.value.valueOf() as number);\n  }\n\n  if (target === Number.POSITIVE_INFINITY) {\n    return test_value.value === f32Bits(kBit.f32.infinity.positive).value;\n  }\n\n  if (target === Number.NEGATIVE_INFINITY) {\n    return test_value.value === f32Bits(kBit.f32.infinity.negative).value;\n  }\n\n  test_value = flush ? flushSubnormalScalar(test_value) : test_value;\n  target = flush ? flushSubnormalNumber(target) : target;\n\n  const target32 = new Float32Array([target])[0];\n  const converted: number = target32;\n  if (target === converted) {\n    // expected is precisely expressible in float32\n    return test_value.value === f32(target32).value;\n  }\n\n  let after_target: Scalar;\n  let before_target: Scalar;\n\n  if (converted > target) {\n    // target32 is rounded towards +inf, so is after_target\n    after_target = f32(target32);\n    before_target = nextAfter(target32, false, flush);\n  } else {\n    // target32 is rounded towards -inf, so is before_target\n    after_target = nextAfter(target32, true, flush);\n    before_target = f32(target32);\n  }\n\n  return test_value.value === before_target.value || test_value.value === after_target.value;\n}\n\n/**\n * Calculates the linear interpolation between two values of a given fractional.\n *\n * If |t| is 0, |a| is returned, if |t| is 1, |b| is returned, otherwise\n * interpolation/extrapolation equivalent to a + t(b - a) is performed.\n *\n * Numerical stable version is adapted from http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0811r2.html\n */\nexport function lerp(a: number, b: number, t: number): number {\n  if (!Number.isFinite(a) || !Number.isFinite(b)) {\n    return Number.NaN;\n  }\n\n  if ((a <= 0.0 && b >= 0.0) || (a >= 0.0 && b <= 0.0)) {\n    return t * b + (1 - t) * a;\n  }\n\n  if (t === 1.0) {\n    return b;\n  }\n\n  const x = a + t * (b - a);\n  return t > 1.0 === b > a ? Math.max(b, x) : Math.min(b, x);\n}\n\n/** @returns a linear increasing range of numbers. */\nexport function linearRange(a: number, b: number, num_steps: number): Array<number> {\n  if (num_steps <= 0) {\n    return Array<number>();\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i => lerp(a, b, i / (num_steps - 1)));\n}\n\n/**\n * @returns a non-linear increasing range of numbers, with a bias towards the beginning.\n *\n * Generates a linear range on [0,1] with |num_steps|, then squares all the values to make the curve be quadratic,\n * thus biasing towards 0, but remaining on the [0, 1] range.\n * This biased range is then scaled to the desired range using lerp.\n * Different curves could be generated by changing c, where greater values of c will bias more towards 0.\n */\nexport function biasedRange(a: number, b: number, num_steps: number): Array<number> {\n  const c = 2;\n  if (num_steps <= 0) {\n    return Array<number>();\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i =>\n    lerp(a, b, Math.pow(lerp(0, 1, i / (num_steps - 1)), c))\n  );\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included. The normal number regions are biased towards zero, and the subnormal regions are linearly spread.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, values must be 0 or greater.\n */\nexport function fullF32Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n  return [\n    ...biasedRange(kValue.f32.negative.max, kValue.f32.negative.min, counts.neg_norm),\n    ...linearRange(\n      kValue.f32.subnormal.negative.min,\n      kValue.f32.subnormal.negative.max,\n      counts.neg_sub\n    ),\n    0.0,\n    ...linearRange(\n      kValue.f32.subnormal.positive.min,\n      kValue.f32.subnormal.positive.max,\n      counts.pos_sub\n    ),\n    ...biasedRange(kValue.f32.positive.min, kValue.f32.positive.max, counts.pos_norm),\n  ];\n}\n\n/**\n * @returns the result matrix in Array<Array<number>> type.\n *\n * Matrix multiplication. A is m x n and B is n x p. Returns\n * m x p result.\n */\n// A is m x n. B is n x p. product is m x p.\nexport function multiplyMatrices(\n  A: Array<Array<number>>,\n  B: Array<Array<number>>\n): Array<Array<number>> {\n  assert(A.length > 0 && B.length > 0 && B[0].length > 0 && A[0].length === B.length);\n  const product = new Array<Array<number>>(A.length);\n  for (let i = 0; i < product.length; ++i) {\n    product[i] = new Array<number>(B[0].length).fill(0);\n  }\n\n  for (let m = 0; m < A.length; ++m) {\n    for (let p = 0; p < B[0].length; ++p) {\n      for (let n = 0; n < B.length; ++n) {\n        product[m][p] += A[m][n] * B[n][p];\n      }\n    }\n  }\n\n  return product;\n}\n\n/** Sign-extend the `bits`-bit number `n` to a 32-bit signed integer. */\nexport function signExtend(n: number, bits: number): number {\n  const shift = 32 - bits;\n  return (n << shift) >> shift;\n}\n\n/** @returns the closest 32-bit floating point value to the input */\nexport function quantizeToF32(num: number): number {\n  return f32(num).value as number;\n}\n\n/** @returns the closest 32-bit signed integer value to the input */\nexport function quantizeToI32(num: number): number {\n  return i32(num).value as number;\n}\n\n/** @returns whether the number is an integer and a power of two */\nexport function isPowerOfTwo(n: number): boolean {\n  if (!Number.isInteger(n)) {\n    return false;\n  }\n  return n !== 0 && (n & (n - 1)) === 0;\n}\n\n/** @returns the Greatest Common Divisor (GCD) of the inputs */\nexport function gcd(a: number, b: number): number {\n  assert(Number.isInteger(a) && a > 0);\n  assert(Number.isInteger(b) && b > 0);\n\n  while (b !== 0) {\n    const bTemp = b;\n    b = a % b;\n    a = bTemp;\n  }\n\n  return a;\n}\n\n/** @returns the Least Common Multiplier (LCM) of the inputs */\nexport function lcm(a: number, b: number): number {\n  return (a * b) / gcd(a, b);\n}\n"],"file":"math.js"}