{"version":3,"sources":["../../../src/webgpu/util/math.ts"],"names":["assert","kBit","kValue","f32","f32Bits","i32","kMaxSafeMultipleOf8","Number","MAX_SAFE_INTEGER","align","n","alignment","isInteger","Math","ceil","roundDown","floor","clamp","min","max","flushSubnormalNumber","val","isSubnormalNumber","flushSubnormalScalar","isSubnormalScalar","type","kind","u32_val","Uint32Array","Float32Array","value","valueOf","buffer","negative","positive","isF32Finite","nextAfter","dir","flush","isNaN","nan","s","POSITIVE_INFINITY","infinity","NEGATIVE_INFINITY","subnormal","converted","u32_result","is_positive","next","f32_result","oneULPImpl","target","NaN","nearest_max","nearest_min","before","after","oneULP","undefined","withinULP","ulp","diff","correctlyRoundedF32","n_32","other","lerp","a","b","t","isFinite","x","linearRange","num_steps","Array","from","keys","map","i","biasedRange","c","pow","fullF32Range","counts","pos_sub","pos_norm","neg_norm","neg_sub","bit_fields","trunc","hexToF32","fullI32Range","kInterestingF32Values","sparseF32Range","multiplyMatrices","A","B","length","product","fill","m","p","signExtend","bits","shift","quantizeToF32","num","quantizeToI32","isPowerOfTwo","gcd","bTemp","lcm","hex","hexToF64","h32","l32","u32Arr","f64Arr","Float64Array","cartesianProductImpl","elements","intermediate","result","forEach","e","push","concat","cartesianProduct","inputs"],"mappings":"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","sourcesContent":["import { assert } from '../../common/util/util.js';\n\nimport { kBit, kValue } from './constants.js';\nimport { f32, f32Bits, i32, Scalar } from './conversion.js';\n\n/**\n * A multiple of 8 guaranteed to be way too large to allocate (just under 8 pebibytes).\n * This is a \"safe\" integer (ULP <= 1.0) very close to MAX_SAFE_INTEGER.\n *\n * Note: allocations of this size are likely to exceed limitations other than just the system's\n * physical memory, so test cases are also needed to try to trigger \"true\" OOM.\n */\nexport const kMaxSafeMultipleOf8 = Number.MAX_SAFE_INTEGER - 7;\n\n/** Round `n` up to the next multiple of `alignment` (inclusive). */\n// MAINTENANCE_TODO: Rename to `roundUp`\nexport function align(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.ceil(n / alignment) * alignment;\n}\n\n/** Round `n` down to the next multiple of `alignment` (inclusive). */\nexport function roundDown(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.floor(n / alignment) * alignment;\n}\n\n/** Clamp a number to the provided range. */\nexport function clamp(n: number, { min, max }: { min: number; max: number }): number {\n  assert(max >= min);\n  return Math.min(Math.max(n, min), max);\n}\n\n/** @returns 0 if |val| is a subnormal f32 number, otherwise returns |val| */\nexport function flushSubnormalNumber(val: number): number {\n  return isSubnormalNumber(val) ? 0 : val;\n}\n\n/** @returns 0 if |val| is a subnormal f32 number, otherwise returns |val| */\nexport function flushSubnormalScalar(val: Scalar): Scalar {\n  return isSubnormalScalar(val) ? f32(0) : val;\n}\n\n/**\n * @returns true if |val| is a subnormal f32 number, otherwise returns false\n * 0 is considered a non-subnormal number by this function.\n */\nexport function isSubnormalScalar(val: Scalar): boolean {\n  if (val.type.kind !== 'f32') {\n    return false;\n  }\n\n  if (val === f32(0)) {\n    return false;\n  }\n\n  const u32_val = new Uint32Array(new Float32Array([val.value.valueOf() as number]).buffer)[0];\n  return (u32_val & 0x7f800000) === 0;\n}\n\n/** Utility to pass TS numbers into |isSubnormalNumber| */\nexport function isSubnormalNumber(val: number): boolean {\n  return val > kValue.f32.negative.max && val < kValue.f32.positive.min;\n}\n\n/** @returns if number is in the finite range of f32 */\nexport function isF32Finite(n: number) {\n  return n >= kValue.f32.negative.min && n <= kValue.f32.positive.max;\n}\n\n/**\n * @returns the next single precision floating point value after |val|,\n * towards +inf if |dir| is true, otherwise towards -inf.\n * If |flush| is true, all subnormal values will be flushed to 0,\n * before processing.\n * If |flush| is false, the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfter will be the closest subnormal in the correct\n * direction.\n * val needs to be in [min f32, max f32]\n */\nexport function nextAfter(val: number, dir: boolean = true, flush: boolean): Scalar {\n  if (Number.isNaN(val)) {\n    return f32Bits(kBit.f32.nan.positive.s);\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return f32Bits(kBit.f32.infinity.positive);\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return f32Bits(kBit.f32.infinity.negative);\n  }\n\n  assert(\n    val <= kValue.f32.positive.max && val >= kValue.f32.negative.min,\n    `${val} is not in the range of float32`\n  );\n\n  val = flush ? flushSubnormalNumber(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir) {\n      return flush ? f32Bits(kBit.f32.positive.min) : f32Bits(kBit.f32.subnormal.positive.min);\n    } else {\n      return flush ? f32Bits(kBit.f32.negative.max) : f32Bits(kBit.f32.subnormal.negative.max);\n    }\n  }\n\n  const converted: number = new Float32Array([val])[0];\n  let u32_result: number;\n  if (val === converted) {\n    // val is expressible precisely as a float32\n    u32_result = new Uint32Array(new Float32Array([val]).buffer)[0];\n    const is_positive = (u32_result & 0x80000000) === 0;\n    if (dir === is_positive) {\n      u32_result += 1;\n    } else {\n      u32_result -= 1;\n    }\n  } else {\n    // val had to be rounded to be expressed as a float32\n    if (dir === converted > val) {\n      // Rounding was in the direction requested\n      u32_result = new Uint32Array(new Float32Array([converted]).buffer)[0];\n    } else {\n      // Round was opposite of the direction requested, so need nextAfter in the requested direction.\n      // This will not recurse since converted is guaranteed to be a float32 due to the conversion above.\n      const next = nextAfter(converted, dir, flush).value.valueOf() as number;\n      u32_result = new Uint32Array(new Float32Array([next]).buffer)[0];\n    }\n  }\n\n  // Checking for overflow\n  if ((u32_result & 0x7f800000) === 0x7f800000) {\n    if (dir) {\n      return f32Bits(kBit.f32.infinity.positive);\n    } else {\n      return f32Bits(kBit.f32.infinity.negative);\n    }\n  }\n\n  const f32_result = f32Bits(u32_result);\n  return flush ? flushSubnormalScalar(f32_result) : f32_result;\n}\n\n/**\n * @returns ulp(x) for a specific flushing mode\n *\n * This is the main implementation of oneULP, which is normally what should be\n * used. This should only be called directly if a specific flushing mode is\n * required.\n *\n * @param target number to calculate ULP for\n * @param flush should subnormals be flushed to zero\n */\nfunction oneULPImpl(target: number, flush: boolean): number {\n  if (Number.isNaN(target)) {\n    return Number.NaN;\n  }\n\n  target = flush ? flushSubnormalNumber(target) : target;\n\n  // For values at the edge of the range or beyond ulp(x) is defined as the distance between the two nearest\n  // f32 representable numbers to the appropriate edge.\n  if (target === Number.POSITIVE_INFINITY || target >= kValue.f32.positive.max) {\n    return kValue.f32.positive.max - kValue.f32.positive.nearest_max;\n  } else if (target === Number.NEGATIVE_INFINITY || target <= kValue.f32.negative.min) {\n    return kValue.f32.negative.nearest_min - kValue.f32.negative.min;\n  }\n\n  // ulp(x) is min(after - before), where\n  //     before <= x <= after\n  //     before =/= after\n  //     before and after are f32 representable\n  const before = nextAfter(target, false, flush).value.valueOf() as number;\n  const after = nextAfter(target, true, flush).value.valueOf() as number;\n  const converted: number = new Float32Array([target])[0];\n  if (converted === target) {\n    // |target| is f32 representable, so either before or after will be x\n    return Math.min(target - before, after - target);\n  } else {\n    // |target| is not f32 representable so taking distance of neighbouring f32s.\n    return after - before;\n  }\n}\n\n/**\n * @returns ulp(x), the unit of least precision for a specific number as a 32-bit float\n *\n * ulp(x) is the distance between the two floating point numbers nearest x.\n * This value is also called unit of last place, ULP, and 1 ULP.\n * See the WGSL spec and http://www.ens-lyon.fr/LIP/Pub/Rapports/RR/RR2005/RR2005-09.pdf\n * for a more detailed/nuanced discussion of the definition of ulp(x).\n *\n * @param target number to calculate ULP for\n * @param flush should subnormals be flushed to zero, if not set both flushed\n *              and non-flush values are considered.\n */\nexport function oneULP(target: number, flush?: boolean): number {\n  if (flush === undefined) {\n    return Math.max(oneULPImpl(target, false), oneULPImpl(target, true));\n  }\n\n  return oneULPImpl(target, flush);\n}\n\n/**\n * @returns if a number is within N * ulp(x) of a target value\n * @param val number to test\n * @param target expected number\n * @param n acceptance range\n * @param flush should subnormals be flushed to zero\n */\nexport function withinULP(val: number, target: number, n: number = 1) {\n  if (Number.isNaN(val) || Number.isNaN(target)) {\n    return false;\n  }\n\n  const ulp = oneULP(target);\n  if (Number.isNaN(ulp)) {\n    return false;\n  }\n\n  if (val === target) {\n    return true;\n  }\n\n  const diff = val > target ? val - target : target - val;\n  return diff <= n * ulp;\n}\n\n/**\n * Calculate the valid roundings when quantizing to 32-bit floats\n *\n * TS/JS's number type is internally a f64, so quantization needs to occur when\n * converting to f32 for WGSL. WGSL does not specify a specific rounding mode,\n * so if there if a number is not precisely representable in 32-bits, but in the\n * range, there are two possible valid quantizations. If it is precisely\n * representable, there is only one valid quantization. This function calculates\n * the valid roundings and returns them in an array.\n *\n * This function does not consider flushing mode, so subnormals are maintained.\n * The caller is responsible to flushing before and after as appropriate.\n *\n * Out of range values return the appropriate infinity and edge value.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 32-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF32(n: number): number[] {\n  assert(!Number.isNaN(n), `correctlyRoundedF32 not defined for NaN`);\n  // Above f32 range\n  if (n === Number.POSITIVE_INFINITY || n > kValue.f32.positive.max) {\n    return [kValue.f32.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // Below f32 range\n  if (n === Number.NEGATIVE_INFINITY || n < kValue.f32.negative.min) {\n    return [Number.NEGATIVE_INFINITY, kValue.f32.negative.min];\n  }\n\n  const n_32 = new Float32Array([n])[0];\n  const converted: number = n_32;\n  if (n === converted) {\n    // n is precisely expressible as a f32, so should not be rounded\n    return [n];\n  }\n\n  if (converted > n) {\n    // x_32 rounded towards +inf, so is after x\n    const other = nextAfter(n_32, false, false).value as number;\n    return [other, converted];\n  } else {\n    // x_32 rounded towards -inf, so is before x\n    const other = nextAfter(n_32, true, false).value as number;\n    return [converted, other];\n  }\n}\n\n/**\n * Calculates the linear interpolation between two values of a given fractional.\n *\n * If |t| is 0, |a| is returned, if |t| is 1, |b| is returned, otherwise\n * interpolation/extrapolation equivalent to a + t(b - a) is performed.\n *\n * Numerical stable version is adapted from http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0811r2.html\n */\nexport function lerp(a: number, b: number, t: number): number {\n  if (!Number.isFinite(a) || !Number.isFinite(b)) {\n    return Number.NaN;\n  }\n\n  if ((a <= 0.0 && b >= 0.0) || (a >= 0.0 && b <= 0.0)) {\n    return t * b + (1 - t) * a;\n  }\n\n  if (t === 1.0) {\n    return b;\n  }\n\n  const x = a + t * (b - a);\n  return t > 1.0 === b > a ? Math.max(b, x) : Math.min(b, x);\n}\n\n/** @returns a linear increasing range of numbers. */\nexport function linearRange(a: number, b: number, num_steps: number): Array<number> {\n  if (num_steps <= 0) {\n    return Array<number>();\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i => lerp(a, b, i / (num_steps - 1)));\n}\n\n/**\n * @returns a non-linear increasing range of numbers, with a bias towards the beginning.\n *\n * Generates a linear range on [0,1] with |num_steps|, then squares all the values to make the curve be quadratic,\n * thus biasing towards 0, but remaining on the [0, 1] range.\n * This biased range is then scaled to the desired range using lerp.\n * Different curves could be generated by changing c, where greater values of c will bias more towards 0.\n */\nexport function biasedRange(a: number, b: number, num_steps: number): Array<number> {\n  const c = 2;\n  if (num_steps <= 0) {\n    return Array<number>();\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i =>\n    lerp(a, b, Math.pow(lerp(0, 1, i / (num_steps - 1)), c))\n  );\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f32 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the f32 range.\n *\n * This function is intended to provide dense coverage of the f32 range, for a minimal list of values to use to cover\n * f32 behaviour, use sparseF32Range instead.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, entries\n *               must be 0 or greater.\n */\nexport function fullF32Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  // Generating bit fields first and then converting to f32, so that the spread across the possible f32 values is more\n  // even. Generating against the bounds of f32 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRange(kBit.f32.negative.min, kBit.f32.negative.max, counts.neg_norm),\n    ...linearRange(\n      kBit.f32.subnormal.negative.min,\n      kBit.f32.subnormal.negative.max,\n      counts.neg_sub\n    ),\n    0,\n    ...linearRange(\n      kBit.f32.subnormal.positive.min,\n      kBit.f32.subnormal.positive.max,\n      counts.pos_sub\n    ),\n    ...linearRange(kBit.f32.positive.min, kBit.f32.positive.max, counts.pos_norm),\n  ].map(Math.trunc);\n  return bit_fields.map(hexToF32);\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit signed ints\n *\n * Numbers are divided into 2 regions: negatives, and positives, with their spreads biased towards 0\n * Zero is included in range.\n *\n * @param counts structure param with 2 entries indicating the number of entries to be generated each region, values must be 0 or greater.\n */\nexport function fullI32Range(\n  counts: {\n    negative?: number;\n    positive: number;\n  } = { positive: 50 }\n): Array<number> {\n  counts.negative = counts.negative === undefined ? counts.positive : counts.negative;\n  return [\n    ...biasedRange(kValue.i32.negative.min, -1, counts.negative),\n    0,\n    ...biasedRange(1, kValue.i32.positive.max, counts.positive),\n  ].map(Math.trunc);\n}\n\n/** Short list of f32 values of interest to test against */\nconst kInterestingF32Values: Array<number> = [\n  Number.NEGATIVE_INFINITY,\n  kValue.f32.negative.min,\n  -10.0,\n  -1.0,\n  kValue.f32.negative.max,\n  kValue.f32.subnormal.negative.min,\n  kValue.f32.subnormal.negative.max,\n  0.0,\n  kValue.f32.subnormal.positive.min,\n  kValue.f32.subnormal.positive.max,\n  kValue.f32.positive.min,\n  1.0,\n  10.0,\n  kValue.f32.positive.max,\n  Number.POSITIVE_INFINITY,\n];\n\n/** @returns minimal f32 values that cover the entire range of f32 behaviours\n *\n * Has specially selected values that cover edge cases, normals, and subnormals.\n * This is used instead of fullF32Range when the number of test cases being\n * generated is a super linear function of the length of f32 values which is\n * leading to time outs.\n *\n * These values have been chosen to attempt to test the widest range of f32\n * behaviours in the lowest number of entries, so may potentially miss function\n * specific values of interest. If there are known values of interest they\n * should be appended to this list in the test generation code.\n */\nexport function sparseF32Range(): Array<number> {\n  return kInterestingF32Values;\n}\n\n/**\n * @returns the result matrix in Array<Array<number>> type.\n *\n * Matrix multiplication. A is m x n and B is n x p. Returns\n * m x p result.\n */\n// A is m x n. B is n x p. product is m x p.\nexport function multiplyMatrices(\n  A: Array<Array<number>>,\n  B: Array<Array<number>>\n): Array<Array<number>> {\n  assert(A.length > 0 && B.length > 0 && B[0].length > 0 && A[0].length === B.length);\n  const product = new Array<Array<number>>(A.length);\n  for (let i = 0; i < product.length; ++i) {\n    product[i] = new Array<number>(B[0].length).fill(0);\n  }\n\n  for (let m = 0; m < A.length; ++m) {\n    for (let p = 0; p < B[0].length; ++p) {\n      for (let n = 0; n < B.length; ++n) {\n        product[m][p] += A[m][n] * B[n][p];\n      }\n    }\n  }\n\n  return product;\n}\n\n/** Sign-extend the `bits`-bit number `n` to a 32-bit signed integer. */\nexport function signExtend(n: number, bits: number): number {\n  const shift = 32 - bits;\n  return (n << shift) >> shift;\n}\n\n/** @returns the closest 32-bit floating point value to the input */\nexport function quantizeToF32(num: number): number {\n  return f32(num).value as number;\n}\n\n/** @returns the closest 32-bit signed integer value to the input */\nexport function quantizeToI32(num: number): number {\n  return i32(num).value as number;\n}\n\n/** @returns whether the number is an integer and a power of two */\nexport function isPowerOfTwo(n: number): boolean {\n  if (!Number.isInteger(n)) {\n    return false;\n  }\n  return n !== 0 && (n & (n - 1)) === 0;\n}\n\n/** @returns the Greatest Common Divisor (GCD) of the inputs */\nexport function gcd(a: number, b: number): number {\n  assert(Number.isInteger(a) && a > 0);\n  assert(Number.isInteger(b) && b > 0);\n\n  while (b !== 0) {\n    const bTemp = b;\n    b = a % b;\n    a = bTemp;\n  }\n\n  return a;\n}\n\n/** @returns the Least Common Multiplier (LCM) of the inputs */\nexport function lcm(a: number, b: number): number {\n  return (a * b) / gcd(a, b);\n}\n\n/** Converts a 32-bit hex values to a 32-bit float value */\nexport function hexToF32(hex: number): number {\n  return new Float32Array(new Uint32Array([hex]).buffer)[0];\n}\n\n/** Converts two 32-bit hex values to a 64-bit float value */\nexport function hexToF64(h32: number, l32: number): number {\n  const u32Arr = new Uint32Array(2);\n  u32Arr[0] = l32;\n  u32Arr[1] = h32;\n  const f64Arr = new Float64Array(u32Arr.buffer);\n  return f64Arr[0];\n}\n\n/** @returns the cross of an array with the intermediate result of cartesianProduct\n *\n * @param elements array of values to cross with the intermediate result of\n *                 cartesianProduct\n * @param intermediate arrays of values representing the partial result of\n *                     cartesianProduct\n */\nfunction cartesianProductImpl<T>(elements: T[], intermediate: T[][]): T[][] {\n  const result: T[][] = [];\n  elements.forEach(e => {\n    if (intermediate.length > 0) {\n      intermediate.forEach(a => {\n        result.push(a.concat(e));\n      });\n    } else {\n      result.push([e]);\n    }\n  });\n  return result;\n}\n\n/** @returns the cartesian product (NxMx...) of a set of arrays\n *\n * This is implemented by calculating the cross of a single input against an\n * intermediate result for each input to build up the final array of arrays.\n *\n * There are examples of doing this more succinctly using map & reduce online,\n * but they are a bit more opaque to read.\n *\n * @param inputs arrays of numbers to calculate cartesian product over\n */\nexport function cartesianProduct<T>(...inputs: T[][]): T[][] {\n  let result: T[][] = [];\n  inputs.forEach(i => {\n    result = cartesianProductImpl<T>(i, result);\n  });\n\n  return result;\n}\n"],"file":"math.js"}