{"version":3,"file":"math.js","names":["assert","Float16Array","kBit","kValue","f16","f16Bits","f32","f32Bits","floatBitsToNumber","i32","kFloat16Format","kFloat32Format","kMaxSafeMultipleOf8","Number","MAX_SAFE_INTEGER","align","n","alignment","isInteger","Math","ceil","roundDown","floor","clamp","min","max","flushSubnormalNumberF32","val","isSubnormalNumberF32","flushSubnormalScalarF32","isSubnormalScalarF32","type","kind","u32_val","Uint32Array","Float32Array","value","valueOf","buffer","negative","positive","isFiniteF32","flushSubnormalNumberF16","isSubnormalNumberF16","flushSubnormalScalarF16","isSubnormalScalarF16","u16_val","Uint16Array","isFiniteF16","nextAfterF32","dir","mode","isNaN","nan","s","POSITIVE_INFINITY","infinity","NEGATIVE_INFINITY","subnormal","converted","u32_result","is_positive","next","f32_result","nextAfterF16","u16_result","f16_result","oneULP","target","NaN","nearest_max","nearest_min","before","after","correctlyRoundedF32","n_32","other","correctlyRoundedF16","n_16","lerp","a","b","t","isFinite","x","linearRange","num_steps","Array","from","keys","map","i","biasedRange","c","pow","fullF32Range","counts","pos_sub","pos_norm","neg_norm","undefined","neg_sub","bit_fields","trunc","hexToF32","sourceFilteredF32Range","source","low","high","filter","fullF16Range","hexToF16","fullI32Range","fullU32Range","count","u32","kInterestingF32Values","sparseF32Range","kVectorF32Values","flatMap","f","vectorF32Range","dim","kSparseVectorF32Values","idx","sparseVectorF32Range","multiplyMatrices","A","B","length","product","fill","m","p","signExtend","bits","shift","quantizeToF32","num","quantizeToI32","isPowerOfTwo","gcd","bTemp","lcm","hex","hexToF64","h32","l32","u32Arr","f64Arr","Float64Array","cartesianProductImpl","elements","intermediate","result","forEach","e","push","cartesianProduct","inputs"],"sources":["../../../src/webgpu/util/math.ts"],"sourcesContent":["import { assert } from '../../common/util/util.js';\nimport { Float16Array } from '../../external/petamoriken/float16/float16.js';\n\nimport { kBit, kValue } from './constants.js';\nimport {\n  f16,\n  f16Bits,\n  f32,\n  f32Bits,\n  floatBitsToNumber,\n  i32,\n  kFloat16Format,\n  kFloat32Format,\n  Scalar,\n} from './conversion.js';\n\n/**\n * A multiple of 8 guaranteed to be way too large to allocate (just under 8 pebibytes).\n * This is a \"safe\" integer (ULP <= 1.0) very close to MAX_SAFE_INTEGER.\n *\n * Note: allocations of this size are likely to exceed limitations other than just the system's\n * physical memory, so test cases are also needed to try to trigger \"true\" OOM.\n */\nexport const kMaxSafeMultipleOf8 = Number.MAX_SAFE_INTEGER - 7;\n\n/** Round `n` up to the next multiple of `alignment` (inclusive). */\n// MAINTENANCE_TODO: Rename to `roundUp`\nexport function align(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.ceil(n / alignment) * alignment;\n}\n\n/** Round `n` down to the next multiple of `alignment` (inclusive). */\nexport function roundDown(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.floor(n / alignment) * alignment;\n}\n\n/** Clamp a number to the provided range. */\nexport function clamp(n: number, { min, max }: { min: number; max: number }): number {\n  assert(max >= min);\n  return Math.min(Math.max(n, min), max);\n}\n\n/** @returns 0 if |val| is a subnormal f32 number, otherwise returns |val| */\nexport function flushSubnormalNumberF32(val: number): number {\n  return isSubnormalNumberF32(val) ? 0 : val;\n}\n\n/** @returns 0 if |val| is a subnormal f32 number, otherwise returns |val| */\nexport function flushSubnormalScalarF32(val: Scalar): Scalar {\n  return isSubnormalScalarF32(val) ? f32(0) : val;\n}\n\n/**\n * @returns true if |val| is a subnormal f32 number, otherwise returns false\n * 0 is considered a non-subnormal number by this function.\n */\nexport function isSubnormalScalarF32(val: Scalar): boolean {\n  if (val.type.kind !== 'f32') {\n    return false;\n  }\n\n  if (val === f32(0)) {\n    return false;\n  }\n\n  const u32_val = new Uint32Array(new Float32Array([val.value.valueOf() as number]).buffer)[0];\n  return (u32_val & 0x7f800000) === 0;\n}\n\n/** U/** @returns if number is within subnormal range of f32 */\nexport function isSubnormalNumberF32(n: number): boolean {\n  return n > kValue.f32.negative.max && n < kValue.f32.positive.min;\n}\n\n/** @returns if number is in the finite range of f32 */\nexport function isFiniteF32(n: number) {\n  return n >= kValue.f32.negative.min && n <= kValue.f32.positive.max;\n}\n\n/** @returns 0 if |val| is a subnormal f16 number, otherwise returns |val| */\nexport function flushSubnormalNumberF16(val: number): number {\n  return isSubnormalNumberF16(val) ? 0 : val;\n}\n\n/** @returns 0 if |val| is a subnormal f16 number, otherwise returns |val| */\nexport function flushSubnormalScalarF16(val: Scalar): Scalar {\n  return isSubnormalScalarF16(val) ? f16(0) : val;\n}\n\n/**\n * @returns true if |val| is a subnormal f16 number, otherwise returns false\n * 0 is considered a non-subnormal number by this function.\n */\nexport function isSubnormalScalarF16(val: Scalar): boolean {\n  if (val.type.kind !== 'f16') {\n    return false;\n  }\n\n  if (val === f16(0)) {\n    return false;\n  }\n\n  const u16_val = new Uint16Array(new Float16Array([val.value.valueOf() as number]).buffer)[0];\n  return (u16_val & 0x7f800000) === 0;\n}\n\n/** @returns if number is within subnormal range of f16 */\nexport function isSubnormalNumberF16(n: number): boolean {\n  return n > kValue.f16.negative.max && n < kValue.f16.positive.min;\n}\n\n/** @returns if number is in the finite range of f16 */\nexport function isFiniteF16(n: number) {\n  return n >= kValue.f16.negative.min && n <= kValue.f16.positive.max;\n}\n\n/** Should FTZ occur during calculations or not */\nexport type FlushMode = 'flush' | 'no-flush';\n\n/**\n * @returns the next f32 value after |val|,\n * towards +inf if |dir| is true, otherwise towards -inf.\n\n * If |mpode| is 'flush', all subnormal values will be flushed to 0,\n * before processing and for -/+0 the nextAfterF32 will be the closest normal in\n * the correct direction.\n\n * If |mode| is 'no-flush', the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfterF32 will be the closest subnormal in the correct\n * direction.\n *\n * val needs to be in [min f32, max f32]\n */\nexport function nextAfterF32(val: number, dir: boolean = true, mode: FlushMode): Scalar {\n  if (Number.isNaN(val)) {\n    return f32Bits(kBit.f32.nan.positive.s);\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return f32Bits(kBit.f32.infinity.positive);\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return f32Bits(kBit.f32.infinity.negative);\n  }\n\n  assert(\n    val <= kValue.f32.positive.max && val >= kValue.f32.negative.min,\n    `${val} is not in the range of float32`\n  );\n\n  val = mode === 'flush' ? flushSubnormalNumberF32(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir) {\n      return mode === 'flush'\n        ? f32Bits(kBit.f32.positive.min)\n        : f32Bits(kBit.f32.subnormal.positive.min);\n    } else {\n      return mode === 'flush'\n        ? f32Bits(kBit.f32.negative.max)\n        : f32Bits(kBit.f32.subnormal.negative.max);\n    }\n  }\n\n  const converted: number = new Float32Array([val])[0];\n  let u32_result: number;\n  if (val === converted) {\n    // val is expressible precisely as a float32\n    u32_result = new Uint32Array(new Float32Array([val]).buffer)[0];\n    const is_positive = (u32_result & 0x80000000) === 0;\n    if (dir === is_positive) {\n      u32_result += 1;\n    } else {\n      u32_result -= 1;\n    }\n  } else {\n    // val had to be rounded to be expressed as a float32\n    if (dir === converted > val) {\n      // Rounding was in the direction requested\n      u32_result = new Uint32Array(new Float32Array([converted]).buffer)[0];\n    } else {\n      // Round was opposite of the direction requested, so need nextAfterF32 in the requested direction.\n      // This will not recurse since converted is guaranteed to be a float32 due to the conversion above.\n      const next = nextAfterF32(converted, dir, mode).value.valueOf() as number;\n      u32_result = new Uint32Array(new Float32Array([next]).buffer)[0];\n    }\n  }\n\n  // Checking for overflow\n  if ((u32_result & 0x7f800000) === 0x7f800000) {\n    if (dir) {\n      return f32Bits(kBit.f32.infinity.positive);\n    } else {\n      return f32Bits(kBit.f32.infinity.negative);\n    }\n  }\n\n  const f32_result = f32Bits(u32_result);\n  return mode === 'flush' ? flushSubnormalScalarF32(f32_result) : f32_result;\n}\n\n/**\n * @returns the next f16 value after |val|,\n * towards +inf if |dir| is true, otherwise towards -inf.\n *\n * If |mode| is true, all subnormal values will be flushed to 0,\n * before processing, and for -/+0 the nextAfterF16 will be the closest normal\n * in the correct direction\n *\n * If |mode| is false, the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfterF16 will be the closest subnormal in the correct\n * direction.\n *\n * val needs to be in [min f16, max f16]\n */\nexport function nextAfterF16(val: number, dir: boolean = true, mode: FlushMode): Scalar {\n  if (Number.isNaN(val)) {\n    return f16Bits(kBit.f16.nan.positive.s);\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return f16Bits(kBit.f16.infinity.positive);\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return f16Bits(kBit.f16.infinity.negative);\n  }\n\n  assert(\n    val <= kValue.f16.positive.max && val >= kValue.f16.negative.min,\n    `${val} is not in the range of float16`\n  );\n\n  val = mode === 'flush' ? flushSubnormalNumberF16(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir) {\n      return mode === 'flush'\n        ? f16Bits(kBit.f16.positive.min)\n        : f16Bits(kBit.f16.subnormal.positive.min);\n    } else {\n      return mode === 'flush'\n        ? f16Bits(kBit.f16.negative.max)\n        : f16Bits(kBit.f16.subnormal.negative.max);\n    }\n  }\n\n  const converted: number = new Float16Array([val])[0];\n  let u16_result: number;\n  if (val === converted) {\n    // val is expressible precisely as a float16\n    u16_result = new Uint16Array(new Float16Array([val]).buffer)[0];\n    const is_positive = (u16_result & 0x8000) === 0;\n    if (dir === is_positive) {\n      u16_result += 1;\n    } else {\n      u16_result -= 1;\n    }\n  } else {\n    // val had to be rounded to be expressed as a float16\n    if (dir === converted > val) {\n      // Rounding was in the direction requested\n      u16_result = new Uint16Array(new Float16Array([converted]).buffer)[0];\n    } else {\n      // Round was opposite of the direction requested, so need nextAfterF16 in the requested direction.\n      // This will not recurse since converted is guaranteed to be a float16 due to the conversion above.\n      const next = nextAfterF16(converted, dir, mode).value.valueOf() as number;\n      u16_result = new Uint16Array(new Float16Array([next]).buffer)[0];\n    }\n  }\n\n  // Checking for overflow\n  if ((u16_result & 0x7f800000) === 0x7f800000) {\n    if (dir) {\n      return f16Bits(kBit.f16.infinity.positive);\n    } else {\n      return f16Bits(kBit.f16.infinity.negative);\n    }\n  }\n\n  const f16_result = f16Bits(u16_result);\n  return mode === 'flush' ? flushSubnormalScalarF16(f16_result) : f16_result;\n}\n\n/**\n * @returns ulp(x), the unit of least precision for a specific number as a 32-bit float\n *\n * ulp(x) is the distance between the two floating point numbers nearest x.\n * This value is also called unit of last place, ULP, and 1 ULP.\n * See the WGSL spec and http://www.ens-lyon.fr/LIP/Pub/Rapports/RR/RR2005/RR2005-09.pdf\n * for a more detailed/nuanced discussion of the definition of ulp(x).\n *\n * @param target number to calculate ULP for\n * @param mode should FTZ occuring during calculation or not\n */\nexport function oneULP(target: number, mode: FlushMode = 'flush'): number {\n  if (Number.isNaN(target)) {\n    return Number.NaN;\n  }\n\n  target = mode === 'flush' ? flushSubnormalNumberF32(target) : target;\n\n  // For values at the edge of the range or beyond ulp(x) is defined as the distance between the two nearest\n  // f32 representable numbers to the appropriate edge.\n  if (target === Number.POSITIVE_INFINITY || target >= kValue.f32.positive.max) {\n    return kValue.f32.positive.max - kValue.f32.positive.nearest_max;\n  } else if (target === Number.NEGATIVE_INFINITY || target <= kValue.f32.negative.min) {\n    return kValue.f32.negative.nearest_min - kValue.f32.negative.min;\n  }\n\n  // ulp(x) is min(after - before), where\n  //     before <= x <= after\n  //     before =/= after\n  //     before and after are f32 representable\n  const before = nextAfterF32(target, false, mode).value.valueOf() as number;\n  const after = nextAfterF32(target, true, mode).value.valueOf() as number;\n  const converted: number = new Float32Array([target])[0];\n  if (converted === target) {\n    // |target| is f32 representable, so either before or after will be x\n    return Math.min(target - before, after - target);\n  } else {\n    // |target| is not f32 representable so taking distance of neighbouring f32s.\n    return after - before;\n  }\n}\n\n/**\n * Calculate the valid roundings when quantizing to 32-bit floats\n *\n * TS/JS's number type is internally a f64, so quantization needs to occur when\n * converting to f32 for WGSL. WGSL does not specify a specific rounding mode,\n * so if a number is not precisely representable in 32-bits, but in the\n * range, there are two possible valid quantizations. If it is precisely\n * representable, there is only one valid quantization. This function calculates\n * the valid roundings and returns them in an array.\n *\n * This function does not consider flushing mode, so subnormals are maintained.\n * The caller is responsible to flushing before and after as appropriate.\n *\n * Out of range values return the appropriate infinity and edge value.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 32-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF32(n: number): number[] {\n  assert(!Number.isNaN(n), `correctlyRoundedF32 not defined for NaN`);\n  // Above f32 range\n  if (n === Number.POSITIVE_INFINITY || n > kValue.f32.positive.max) {\n    return [kValue.f32.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // Below f32 range\n  if (n === Number.NEGATIVE_INFINITY || n < kValue.f32.negative.min) {\n    return [Number.NEGATIVE_INFINITY, kValue.f32.negative.min];\n  }\n\n  const n_32 = new Float32Array([n])[0];\n  const converted: number = n_32;\n  if (n === converted) {\n    // n is precisely expressible as a f32, so should not be rounded\n    return [n];\n  }\n\n  if (converted > n) {\n    // n_32 rounded towards +inf, so is after n\n    const other = nextAfterF32(n_32, false, 'no-flush').value as number;\n    return [other, converted];\n  } else {\n    // n_32 rounded towards -inf, so is before n\n    const other = nextAfterF32(n_32, true, 'no-flush').value as number;\n    return [converted, other];\n  }\n}\n\n/**\n * Calculate the valid roundings when quantizing to 16-bit floats\n *\n * TS/JS's number type is internally a f64, so quantization needs to occur when\n * converting to f16 for WGSL. WGSL does not specify a specific rounding mode,\n * so if a number is not precisely representable in 16-bits, but in the\n * range, there are two possible valid quantizations. If it is precisely\n * representable, there is only one valid quantization. This function calculates\n * the valid roundings and returns them in an array.\n *\n * This function does not consider flushing mode, so subnormals are maintained.\n * The caller is responsible to flushing before and after as appropriate.\n *\n * Out of range values return the appropriate infinity and edge value.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 16-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF16(n: number): number[] {\n  assert(!Number.isNaN(n), `correctlyRoundedF16 not defined for NaN`);\n  // Above f16 range\n  if (n === Number.POSITIVE_INFINITY || n > kValue.f16.positive.max) {\n    return [kValue.f16.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // Below f16 range\n  if (n === Number.NEGATIVE_INFINITY || n < kValue.f16.negative.min) {\n    return [Number.NEGATIVE_INFINITY, kValue.f16.negative.min];\n  }\n\n  const n_16 = new Float16Array([n])[0];\n  const converted: number = n_16;\n  if (n === converted) {\n    // n is precisely expressible as a f16, so should not be rounded\n    return [n];\n  }\n\n  if (converted > n) {\n    // n_16 rounded towards +inf, so is after n\n    const other = nextAfterF16(n_16, false, 'no-flush').value as number;\n    return [other, converted];\n  } else {\n    // n_16 rounded towards -inf, so is before n\n    const other = nextAfterF16(n_16, true, 'no-flush').value as number;\n    return [converted, other];\n  }\n}\n\n/**\n * Calculates the linear interpolation between two values of a given fractional.\n *\n * If |t| is 0, |a| is returned, if |t| is 1, |b| is returned, otherwise\n * interpolation/extrapolation equivalent to a + t(b - a) is performed.\n *\n * Numerical stable version is adapted from http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0811r2.html\n */\nexport function lerp(a: number, b: number, t: number): number {\n  if (!Number.isFinite(a) || !Number.isFinite(b)) {\n    return Number.NaN;\n  }\n\n  if ((a <= 0.0 && b >= 0.0) || (a >= 0.0 && b <= 0.0)) {\n    return t * b + (1 - t) * a;\n  }\n\n  if (t === 1.0) {\n    return b;\n  }\n\n  const x = a + t * (b - a);\n  return t > 1.0 === b > a ? Math.max(b, x) : Math.min(b, x);\n}\n\n/** @returns a linear increasing range of numbers. */\nexport function linearRange(a: number, b: number, num_steps: number): Array<number> {\n  if (num_steps <= 0) {\n    return Array<number>();\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i => lerp(a, b, i / (num_steps - 1)));\n}\n\n/**\n * @returns a non-linear increasing range of numbers, with a bias towards the beginning.\n *\n * Generates a linear range on [0,1] with |num_steps|, then squares all the values to make the curve be quadratic,\n * thus biasing towards 0, but remaining on the [0, 1] range.\n * This biased range is then scaled to the desired range using lerp.\n * Different curves could be generated by changing c, where greater values of c will bias more towards 0.\n */\nexport function biasedRange(a: number, b: number, num_steps: number): Array<number> {\n  const c = 2;\n  if (num_steps <= 0) {\n    return Array<number>();\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i =>\n    lerp(a, b, Math.pow(lerp(0, 1, i / (num_steps - 1)), c))\n  );\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f32 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the f32 range.\n *\n * This function is intended to provide dense coverage of the f32 range, for a minimal list of values to use to cover\n * f32 behaviour, use sparseF32Range instead.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, entries\n *               must be 0 or greater.\n */\nexport function fullF32Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  // Generating bit fields first and then converting to f32, so that the spread across the possible f32 values is more\n  // even. Generating against the bounds of f32 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRange(kBit.f32.negative.min, kBit.f32.negative.max, counts.neg_norm),\n    ...linearRange(\n      kBit.f32.subnormal.negative.min,\n      kBit.f32.subnormal.negative.max,\n      counts.neg_sub\n    ),\n    0,\n    ...linearRange(\n      kBit.f32.subnormal.positive.min,\n      kBit.f32.subnormal.positive.max,\n      counts.pos_sub\n    ),\n    ...linearRange(kBit.f32.positive.min, kBit.f32.positive.max, counts.pos_norm),\n  ].map(Math.trunc);\n  return bit_fields.map(hexToF32);\n}\n\n/**\n * @returns an ascending sorted array of numbers.\n *\n * The numbers returned are based on the `full32Range` as described above. The difference comes depending\n * on the `source` parameter. If the `source` is `const` then the numbers will be restricted to be\n * in the range `[low, high]`. This allows filtering out a set of `f32` values which are invalid for\n * const-evaluation but are needed to test the non-const implementation.\n *\n * @param source the input source for the test. If the `source` is `const` then the return will be filtered\n * @param low the lowest f32 value to permit when filtered\n * @param high the highest f32 value to permit when filtered\n */\nexport function sourceFilteredF32Range(source: String, low: number, high: number): Array<number> {\n  return fullF32Range().filter(x => source !== 'const' || (x >= low && x <= high));\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 16-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f16 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the f16 range.\n *\n * This function is intended to provide dense coverage of the f16 range, for a minimal list of values to use to cover\n * f16 behaviour, use sparseF16Range instead.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, entries\n *               must be 0 or greater.\n */\nexport function fullF16Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  // Generating bit fields first and then converting to f16, so that the spread across the possible f16 values is more\n  // even. Generating against the bounds of f16 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRange(kBit.f16.negative.min, kBit.f16.negative.max, counts.neg_norm),\n    ...linearRange(\n      kBit.f16.subnormal.negative.min,\n      kBit.f16.subnormal.negative.max,\n      counts.neg_sub\n    ),\n    0,\n    ...linearRange(\n      kBit.f16.subnormal.positive.min,\n      kBit.f16.subnormal.positive.max,\n      counts.pos_sub\n    ),\n    ...linearRange(kBit.f16.positive.min, kBit.f16.positive.max, counts.pos_norm),\n  ].map(Math.trunc);\n  return bit_fields.map(hexToF16);\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit signed ints\n *\n * Numbers are divided into 2 regions: negatives, and positives, with their spreads biased towards 0\n * Zero is included in range.\n *\n * @param counts structure param with 2 entries indicating the number of entries to be generated each region, values must be 0 or greater.\n */\nexport function fullI32Range(\n  counts: {\n    negative?: number;\n    positive: number;\n  } = { positive: 50 }\n): Array<number> {\n  counts.negative = counts.negative === undefined ? counts.positive : counts.negative;\n  return [\n    ...biasedRange(kValue.i32.negative.min, -1, counts.negative),\n    0,\n    ...biasedRange(1, kValue.i32.positive.max, counts.positive),\n  ].map(Math.trunc);\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit unsigned ints\n *\n * Numbers are biased towards 0, and 0 is included in the range.\n *\n * @param count number of entries to include in the range, in addition to 0, must be greater than 0, defaults to 50\n */\nexport function fullU32Range(count: number = 50): Array<number> {\n  return [0, ...biasedRange(1, kValue.u32.max, count)].map(Math.trunc);\n}\n\n/** Short list of f32 values of interest to test against */\nconst kInterestingF32Values: number[] = [\n  kValue.f32.negative.min,\n  -10.0,\n  -1.0,\n  kValue.f32.negative.max,\n  kValue.f32.subnormal.negative.min,\n  kValue.f32.subnormal.negative.max,\n  0.0,\n  kValue.f32.subnormal.positive.min,\n  kValue.f32.subnormal.positive.max,\n  kValue.f32.positive.min,\n  1.0,\n  10.0,\n  kValue.f32.positive.max,\n];\n\n/** @returns minimal f32 values that cover the entire range of f32 behaviours\n *\n * Has specially selected values that cover edge cases, normals, and subnormals.\n * This is used instead of fullF32Range when the number of test cases being\n * generated is a super linear function of the length of f32 values which is\n * leading to time outs.\n *\n * These values have been chosen to attempt to test the widest range of f32\n * behaviours in the lowest number of entries, so may potentially miss function\n * specific values of interest. If there are known values of interest they\n * should be appended to this list in the test generation code.\n */\nexport function sparseF32Range(): number[] {\n  return kInterestingF32Values;\n}\n\nconst kVectorF32Values = {\n  2: kInterestingF32Values.flatMap(f => [\n    [f, 1.0],\n    [1.0, f],\n    [f, -1.0],\n    [-1.0, f],\n  ]),\n  3: kInterestingF32Values.flatMap(f => [\n    [f, 1.0, 2.0],\n    [1.0, f, 2.0],\n    [1.0, 2.0, f],\n    [f, -1.0, -2.0],\n    [-1.0, f, -2.0],\n    [-1.0, -2.0, f],\n  ]),\n  4: kInterestingF32Values.flatMap(f => [\n    [f, 1.0, 2.0, 3.0],\n    [1.0, f, 2.0, 3.0],\n    [1.0, 2.0, f, 3.0],\n    [1.0, 2.0, 3.0, f],\n    [f, -1.0, -2.0, -3.0],\n    [-1.0, f, -2.0, -3.0],\n    [-1.0, -2.0, f, -3.0],\n    [-1.0, -2.0, -3.0, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting float\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting float values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n *  Instead they insert the interesting f32 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorF32Range(dim: number): number[][] {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorF32Range only accepts dimensions 2, 3, and 4');\n  return kVectorF32Values[dim];\n}\n\nconst kSparseVectorF32Values = {\n  2: sparseF32Range().map((f, idx) => [idx % 2 === 0 ? f : idx, idx % 2 === 1 ? f : -idx]),\n  3: sparseF32Range().map((f, idx) => [\n    idx % 3 === 0 ? f : idx,\n    idx % 3 === 1 ? f : -idx,\n    idx % 3 === 2 ? f : idx,\n  ]),\n  4: sparseF32Range().map((f, idx) => [\n    idx % 4 === 0 ? f : idx,\n    idx % 4 === 1 ? f : -idx,\n    idx % 4 === 2 ? f : idx,\n    idx % 4 === 3 ? f : -idx,\n  ]),\n};\n\n/**\n * Minimal set of vectors, indexed by dimension, that contain interesting float\n * values.\n *\n * This is an even more stripped down version of `vectorF32Range` for when\n * pairs of vectors are being tested.\n * All of the interesting floats from sparseF32 are guaranteed to be tested, but\n * not in every position.\n */\nexport function sparseVectorF32Range(dim: number): number[][] {\n  assert(\n    dim === 2 || dim === 3 || dim === 4,\n    'sparseVectorF32Range only accepts dimensions 2, 3, and 4'\n  );\n  return kSparseVectorF32Values[dim];\n}\n/**\n * @returns the result matrix in Array<Array<number>> type.\n *\n * Matrix multiplication. A is m x n and B is n x p. Returns\n * m x p result.\n */\n// A is m x n. B is n x p. product is m x p.\nexport function multiplyMatrices(\n  A: Array<Array<number>>,\n  B: Array<Array<number>>\n): Array<Array<number>> {\n  assert(A.length > 0 && B.length > 0 && B[0].length > 0 && A[0].length === B.length);\n  const product = new Array<Array<number>>(A.length);\n  for (let i = 0; i < product.length; ++i) {\n    product[i] = new Array<number>(B[0].length).fill(0);\n  }\n\n  for (let m = 0; m < A.length; ++m) {\n    for (let p = 0; p < B[0].length; ++p) {\n      for (let n = 0; n < B.length; ++n) {\n        product[m][p] += A[m][n] * B[n][p];\n      }\n    }\n  }\n\n  return product;\n}\n\n/** Sign-extend the `bits`-bit number `n` to a 32-bit signed integer. */\nexport function signExtend(n: number, bits: number): number {\n  const shift = 32 - bits;\n  return (n << shift) >> shift;\n}\n\n/** @returns the closest 32-bit floating point value to the input */\nexport function quantizeToF32(num: number): number {\n  return f32(num).value as number;\n}\n\n/** @returns the closest 32-bit signed integer value to the input */\nexport function quantizeToI32(num: number): number {\n  return i32(num).value as number;\n}\n\n/** @returns whether the number is an integer and a power of two */\nexport function isPowerOfTwo(n: number): boolean {\n  if (!Number.isInteger(n)) {\n    return false;\n  }\n  return n !== 0 && (n & (n - 1)) === 0;\n}\n\n/** @returns the Greatest Common Divisor (GCD) of the inputs */\nexport function gcd(a: number, b: number): number {\n  assert(Number.isInteger(a) && a > 0);\n  assert(Number.isInteger(b) && b > 0);\n\n  while (b !== 0) {\n    const bTemp = b;\n    b = a % b;\n    a = bTemp;\n  }\n\n  return a;\n}\n\n/** @returns the Least Common Multiplier (LCM) of the inputs */\nexport function lcm(a: number, b: number): number {\n  return (a * b) / gcd(a, b);\n}\n\n/** Converts a 32-bit hex value to a 32-bit float value */\nexport function hexToF32(hex: number): number {\n  return floatBitsToNumber(hex, kFloat32Format);\n}\n\n/** Converts a 16-bit hex value to a 16-bit float value */\nexport function hexToF16(hex: number): number {\n  return floatBitsToNumber(hex, kFloat16Format);\n}\n\n/** Converts two 32-bit hex values to a 64-bit float value */\nexport function hexToF64(h32: number, l32: number): number {\n  const u32Arr = new Uint32Array(2);\n  u32Arr[0] = l32;\n  u32Arr[1] = h32;\n  const f64Arr = new Float64Array(u32Arr.buffer);\n  return f64Arr[0];\n}\n\n/** @returns the cross of an array with the intermediate result of cartesianProduct\n *\n * @param elements array of values to cross with the intermediate result of\n *                 cartesianProduct\n * @param intermediate arrays of values representing the partial result of\n *                     cartesianProduct\n */\nfunction cartesianProductImpl<T>(elements: T[], intermediate: T[][]): T[][] {\n  const result: T[][] = [];\n  elements.forEach((e: T) => {\n    if (intermediate.length > 0) {\n      intermediate.forEach((i: T[]) => {\n        result.push([...i, e]);\n      });\n    } else {\n      result.push([e]);\n    }\n  });\n  return result;\n}\n\n/** @returns the cartesian product (NxMx...) of a set of arrays\n *\n * This is implemented by calculating the cross of a single input against an\n * intermediate result for each input to build up the final array of arrays.\n *\n * There are examples of doing this more succinctly using map & reduce online,\n * but they are a bit more opaque to read.\n *\n * @param inputs arrays of numbers to calculate cartesian product over\n */\nexport function cartesianProduct<T>(...inputs: T[][]): T[][] {\n  let result: T[][] = [];\n  inputs.forEach((i: T[]) => {\n    result = cartesianProductImpl<T>(i, result);\n  });\n\n  return result;\n}\n"],"mappings":"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"}