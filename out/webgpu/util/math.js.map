{"version":3,"sources":["../../../src/webgpu/util/math.ts"],"names":["assert","Float16Array","kBit","kValue","f16","f16Bits","f32","f32Bits","floatBitsToNumber","i32","kFloat16Format","kFloat32Format","kMaxSafeMultipleOf8","Number","MAX_SAFE_INTEGER","align","n","alignment","isInteger","Math","ceil","roundDown","floor","clamp","min","max","flushSubnormalNumberF32","val","isSubnormalNumberF32","flushSubnormalScalarF32","isSubnormalScalarF32","type","kind","u32_val","Uint32Array","Float32Array","value","valueOf","buffer","negative","positive","isFiniteF32","flushSubnormalNumberF16","isSubnormalNumberF16","flushSubnormalScalarF16","isSubnormalScalarF16","u16_val","Uint16Array","isFiniteF16","nextAfterF32","dir","flush","isNaN","nan","s","POSITIVE_INFINITY","infinity","NEGATIVE_INFINITY","subnormal","converted","u32_result","is_positive","next","f32_result","nextAfterF16","u16_result","f16_result","oneULPImpl","target","NaN","nearest_max","nearest_min","before","after","oneULP","undefined","withinULP","ulp","diff","correctlyRoundedF32","n_32","other","correctlyRoundedF16","n_16","lerp","a","b","t","isFinite","x","linearRange","num_steps","Array","from","keys","map","i","biasedRange","c","pow","fullF32Range","counts","pos_sub","pos_norm","neg_norm","neg_sub","bit_fields","trunc","hexToF32","fullI32Range","kInterestingF32Values","sparseF32Range","kVectorTestValues","flatMap","f","multiplyMatrices","A","B","length","product","fill","m","p","signExtend","bits","shift","quantizeToF32","num","quantizeToI32","isPowerOfTwo","gcd","bTemp","lcm","hex","hexToF16","hexToF64","h32","l32","u32Arr","f64Arr","Float64Array","cartesianProductImpl","elements","intermediate","result","forEach","e","push","concat","cartesianProduct","inputs"],"mappings":"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","sourcesContent":["import { assert } from '../../common/util/util.js';\nimport { Float16Array } from '../../external/petamoriken/float16/float16.js';\n\nimport { kBit, kValue } from './constants.js';\nimport {\n  f16,\n  f16Bits,\n  f32,\n  f32Bits,\n  floatBitsToNumber,\n  i32,\n  kFloat16Format,\n  kFloat32Format,\n  Scalar,\n} from './conversion.js';\n\n/**\n * A multiple of 8 guaranteed to be way too large to allocate (just under 8 pebibytes).\n * This is a \"safe\" integer (ULP <= 1.0) very close to MAX_SAFE_INTEGER.\n *\n * Note: allocations of this size are likely to exceed limitations other than just the system's\n * physical memory, so test cases are also needed to try to trigger \"true\" OOM.\n */\nexport const kMaxSafeMultipleOf8 = Number.MAX_SAFE_INTEGER - 7;\n\n/** Round `n` up to the next multiple of `alignment` (inclusive). */\n// MAINTENANCE_TODO: Rename to `roundUp`\nexport function align(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.ceil(n / alignment) * alignment;\n}\n\n/** Round `n` down to the next multiple of `alignment` (inclusive). */\nexport function roundDown(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.floor(n / alignment) * alignment;\n}\n\n/** Clamp a number to the provided range. */\nexport function clamp(n: number, { min, max }: { min: number; max: number }): number {\n  assert(max >= min);\n  return Math.min(Math.max(n, min), max);\n}\n\n/** @returns 0 if |val| is a subnormal f32 number, otherwise returns |val| */\nexport function flushSubnormalNumberF32(val: number): number {\n  return isSubnormalNumberF32(val) ? 0 : val;\n}\n\n/** @returns 0 if |val| is a subnormal f32 number, otherwise returns |val| */\nexport function flushSubnormalScalarF32(val: Scalar): Scalar {\n  return isSubnormalScalarF32(val) ? f32(0) : val;\n}\n\n/**\n * @returns true if |val| is a subnormal f32 number, otherwise returns false\n * 0 is considered a non-subnormal number by this function.\n */\nexport function isSubnormalScalarF32(val: Scalar): boolean {\n  if (val.type.kind !== 'f32') {\n    return false;\n  }\n\n  if (val === f32(0)) {\n    return false;\n  }\n\n  const u32_val = new Uint32Array(new Float32Array([val.value.valueOf() as number]).buffer)[0];\n  return (u32_val & 0x7f800000) === 0;\n}\n\n/** U/** @returns if number is within subnormal range of f32 */\nexport function isSubnormalNumberF32(n: number): boolean {\n  return n > kValue.f32.negative.max && n < kValue.f32.positive.min;\n}\n\n/** @returns if number is in the finite range of f32 */\nexport function isFiniteF32(n: number) {\n  return n >= kValue.f32.negative.min && n <= kValue.f32.positive.max;\n}\n\n/** @returns 0 if |val| is a subnormal f16 number, otherwise returns |val| */\nexport function flushSubnormalNumberF16(val: number): number {\n  return isSubnormalNumberF16(val) ? 0 : val;\n}\n\n/** @returns 0 if |val| is a subnormal f16 number, otherwise returns |val| */\nexport function flushSubnormalScalarF16(val: Scalar): Scalar {\n  return isSubnormalScalarF16(val) ? f16(0) : val;\n}\n\n/**\n * @returns true if |val| is a subnormal f16 number, otherwise returns false\n * 0 is considered a non-subnormal number by this function.\n */\nexport function isSubnormalScalarF16(val: Scalar): boolean {\n  if (val.type.kind !== 'f16') {\n    return false;\n  }\n\n  if (val === f16(0)) {\n    return false;\n  }\n\n  const u16_val = new Uint16Array(new Float16Array([val.value.valueOf() as number]).buffer)[0];\n  return (u16_val & 0x7f800000) === 0;\n}\n\n/** @returns if number is within subnormal range of f16 */\nexport function isSubnormalNumberF16(n: number): boolean {\n  return n > kValue.f16.negative.max && n < kValue.f16.positive.min;\n}\n\n/** @returns if number is in the finite range of f16 */\nexport function isFiniteF16(n: number) {\n  return n >= kValue.f16.negative.min && n <= kValue.f16.positive.max;\n}\n\n/**\n * @returns the next f32 value after |val|,\n * towards +inf if |dir| is true, otherwise towards -inf.\n * If |flush| is true, all subnormal values will be flushed to 0,\n * before processing.\n * If |flush| is false, the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfterF32 will be the closest subnormal in the correct\n * direction.\n * val needs to be in [min f32, max f32]\n */\nexport function nextAfterF32(val: number, dir: boolean = true, flush: boolean): Scalar {\n  if (Number.isNaN(val)) {\n    return f32Bits(kBit.f32.nan.positive.s);\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return f32Bits(kBit.f32.infinity.positive);\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return f32Bits(kBit.f32.infinity.negative);\n  }\n\n  assert(\n    val <= kValue.f32.positive.max && val >= kValue.f32.negative.min,\n    `${val} is not in the range of float32`\n  );\n\n  val = flush ? flushSubnormalNumberF32(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir) {\n      return flush ? f32Bits(kBit.f32.positive.min) : f32Bits(kBit.f32.subnormal.positive.min);\n    } else {\n      return flush ? f32Bits(kBit.f32.negative.max) : f32Bits(kBit.f32.subnormal.negative.max);\n    }\n  }\n\n  const converted: number = new Float32Array([val])[0];\n  let u32_result: number;\n  if (val === converted) {\n    // val is expressible precisely as a float32\n    u32_result = new Uint32Array(new Float32Array([val]).buffer)[0];\n    const is_positive = (u32_result & 0x80000000) === 0;\n    if (dir === is_positive) {\n      u32_result += 1;\n    } else {\n      u32_result -= 1;\n    }\n  } else {\n    // val had to be rounded to be expressed as a float32\n    if (dir === converted > val) {\n      // Rounding was in the direction requested\n      u32_result = new Uint32Array(new Float32Array([converted]).buffer)[0];\n    } else {\n      // Round was opposite of the direction requested, so need nextAfterF32 in the requested direction.\n      // This will not recurse since converted is guaranteed to be a float32 due to the conversion above.\n      const next = nextAfterF32(converted, dir, flush).value.valueOf() as number;\n      u32_result = new Uint32Array(new Float32Array([next]).buffer)[0];\n    }\n  }\n\n  // Checking for overflow\n  if ((u32_result & 0x7f800000) === 0x7f800000) {\n    if (dir) {\n      return f32Bits(kBit.f32.infinity.positive);\n    } else {\n      return f32Bits(kBit.f32.infinity.negative);\n    }\n  }\n\n  const f32_result = f32Bits(u32_result);\n  return flush ? flushSubnormalScalarF32(f32_result) : f32_result;\n}\n\n/**\n * @returns the next f16 value after |val|,\n * towards +inf if |dir| is true, otherwise towards -inf.\n * If |flush| is true, all subnormal values will be flushed to 0,\n * before processing.\n * If |flush| is false, the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfterF16 will be the closest subnormal in the correct\n * direction.\n * val needs to be in [min f16, max f16]\n */\nexport function nextAfterF16(val: number, dir: boolean = true, flush: boolean): Scalar {\n  if (Number.isNaN(val)) {\n    return f16Bits(kBit.f16.nan.positive.s);\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return f16Bits(kBit.f16.infinity.positive);\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return f16Bits(kBit.f16.infinity.negative);\n  }\n\n  assert(\n    val <= kValue.f16.positive.max && val >= kValue.f16.negative.min,\n    `${val} is not in the range of float16`\n  );\n\n  val = flush ? flushSubnormalNumberF16(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir) {\n      return flush ? f16Bits(kBit.f16.positive.min) : f16Bits(kBit.f16.subnormal.positive.min);\n    } else {\n      return flush ? f16Bits(kBit.f16.negative.max) : f16Bits(kBit.f16.subnormal.negative.max);\n    }\n  }\n\n  const converted: number = new Float16Array([val])[0];\n  let u16_result: number;\n  if (val === converted) {\n    // val is expressible precisely as a float16\n    u16_result = new Uint16Array(new Float16Array([val]).buffer)[0];\n    const is_positive = (u16_result & 0x8000) === 0;\n    if (dir === is_positive) {\n      u16_result += 1;\n    } else {\n      u16_result -= 1;\n    }\n  } else {\n    // val had to be rounded to be expressed as a float16\n    if (dir === converted > val) {\n      // Rounding was in the direction requested\n      u16_result = new Uint16Array(new Float16Array([converted]).buffer)[0];\n    } else {\n      // Round was opposite of the direction requested, so need nextAfterF16 in the requested direction.\n      // This will not recurse since converted is guaranteed to be a float16 due to the conversion above.\n      const next = nextAfterF16(converted, dir, flush).value.valueOf() as number;\n      u16_result = new Uint16Array(new Float16Array([next]).buffer)[0];\n    }\n  }\n\n  // Checking for overflow\n  if ((u16_result & 0x7f800000) === 0x7f800000) {\n    if (dir) {\n      return f16Bits(kBit.f16.infinity.positive);\n    } else {\n      return f16Bits(kBit.f16.infinity.negative);\n    }\n  }\n\n  const f16_result = f16Bits(u16_result);\n  return flush ? flushSubnormalScalarF16(f16_result) : f16_result;\n}\n\n/**\n * @returns ulp(x) for a specific flushing mode\n *\n * This is the main implementation of oneULP, which is normally what should be\n * used. This should only be called directly if a specific flushing mode is\n * required.\n *\n * @param target number to calculate ULP for\n * @param flush should subnormals be flushed to zero\n */\nfunction oneULPImpl(target: number, flush: boolean): number {\n  if (Number.isNaN(target)) {\n    return Number.NaN;\n  }\n\n  target = flush ? flushSubnormalNumberF32(target) : target;\n\n  // For values at the edge of the range or beyond ulp(x) is defined as the distance between the two nearest\n  // f32 representable numbers to the appropriate edge.\n  if (target === Number.POSITIVE_INFINITY || target >= kValue.f32.positive.max) {\n    return kValue.f32.positive.max - kValue.f32.positive.nearest_max;\n  } else if (target === Number.NEGATIVE_INFINITY || target <= kValue.f32.negative.min) {\n    return kValue.f32.negative.nearest_min - kValue.f32.negative.min;\n  }\n\n  // ulp(x) is min(after - before), where\n  //     before <= x <= after\n  //     before =/= after\n  //     before and after are f32 representable\n  const before = nextAfterF32(target, false, flush).value.valueOf() as number;\n  const after = nextAfterF32(target, true, flush).value.valueOf() as number;\n  const converted: number = new Float32Array([target])[0];\n  if (converted === target) {\n    // |target| is f32 representable, so either before or after will be x\n    return Math.min(target - before, after - target);\n  } else {\n    // |target| is not f32 representable so taking distance of neighbouring f32s.\n    return after - before;\n  }\n}\n\n/**\n * @returns ulp(x), the unit of least precision for a specific number as a 32-bit float\n *\n * ulp(x) is the distance between the two floating point numbers nearest x.\n * This value is also called unit of last place, ULP, and 1 ULP.\n * See the WGSL spec and http://www.ens-lyon.fr/LIP/Pub/Rapports/RR/RR2005/RR2005-09.pdf\n * for a more detailed/nuanced discussion of the definition of ulp(x).\n *\n * @param target number to calculate ULP for\n * @param flush should subnormals be flushed to zero, if not set both flushed\n *              and non-flush values are considered.\n */\nexport function oneULP(target: number, flush?: boolean): number {\n  if (flush === undefined) {\n    return Math.max(oneULPImpl(target, false), oneULPImpl(target, true));\n  }\n\n  return oneULPImpl(target, flush);\n}\n\n/**\n * @returns if a number is within N * ulp(x) of a target value\n * @param val number to test\n * @param target expected number\n * @param n acceptance range\n * @param flush should subnormals be flushed to zero\n */\nexport function withinULP(val: number, target: number, n: number = 1) {\n  if (Number.isNaN(val) || Number.isNaN(target)) {\n    return false;\n  }\n\n  const ulp = oneULP(target);\n  if (Number.isNaN(ulp)) {\n    return false;\n  }\n\n  if (val === target) {\n    return true;\n  }\n\n  const diff = val > target ? val - target : target - val;\n  return diff <= n * ulp;\n}\n\n/**\n * Calculate the valid roundings when quantizing to 32-bit floats\n *\n * TS/JS's number type is internally a f64, so quantization needs to occur when\n * converting to f32 for WGSL. WGSL does not specify a specific rounding mode,\n * so if a number is not precisely representable in 32-bits, but in the\n * range, there are two possible valid quantizations. If it is precisely\n * representable, there is only one valid quantization. This function calculates\n * the valid roundings and returns them in an array.\n *\n * This function does not consider flushing mode, so subnormals are maintained.\n * The caller is responsible to flushing before and after as appropriate.\n *\n * Out of range values return the appropriate infinity and edge value.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 32-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF32(n: number): number[] {\n  assert(!Number.isNaN(n), `correctlyRoundedF32 not defined for NaN`);\n  // Above f32 range\n  if (n === Number.POSITIVE_INFINITY || n > kValue.f32.positive.max) {\n    return [kValue.f32.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // Below f32 range\n  if (n === Number.NEGATIVE_INFINITY || n < kValue.f32.negative.min) {\n    return [Number.NEGATIVE_INFINITY, kValue.f32.negative.min];\n  }\n\n  const n_32 = new Float32Array([n])[0];\n  const converted: number = n_32;\n  if (n === converted) {\n    // n is precisely expressible as a f32, so should not be rounded\n    return [n];\n  }\n\n  if (converted > n) {\n    // n_32 rounded towards +inf, so is after n\n    const other = nextAfterF32(n_32, false, false).value as number;\n    return [other, converted];\n  } else {\n    // n_32 rounded towards -inf, so is before n\n    const other = nextAfterF32(n_32, true, false).value as number;\n    return [converted, other];\n  }\n}\n\n/**\n * Calculate the valid roundings when quantizing to 16-bit floats\n *\n * TS/JS's number type is internally a f64, so quantization needs to occur when\n * converting to f16 for WGSL. WGSL does not specify a specific rounding mode,\n * so if a number is not precisely representable in 16-bits, but in the\n * range, there are two possible valid quantizations. If it is precisely\n * representable, there is only one valid quantization. This function calculates\n * the valid roundings and returns them in an array.\n *\n * This function does not consider flushing mode, so subnormals are maintained.\n * The caller is responsible to flushing before and after as appropriate.\n *\n * Out of range values return the appropriate infinity and edge value.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 16-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF16(n: number): number[] {\n  assert(!Number.isNaN(n), `correctlyRoundedF16 not defined for NaN`);\n  // Above f16 range\n  if (n === Number.POSITIVE_INFINITY || n > kValue.f16.positive.max) {\n    return [kValue.f16.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // Below f16 range\n  if (n === Number.NEGATIVE_INFINITY || n < kValue.f16.negative.min) {\n    return [Number.NEGATIVE_INFINITY, kValue.f16.negative.min];\n  }\n\n  const n_16 = new Float16Array([n])[0];\n  const converted: number = n_16;\n  if (n === converted) {\n    // n is precisely expressible as a f16, so should not be rounded\n    return [n];\n  }\n\n  if (converted > n) {\n    // n_16 rounded towards +inf, so is after n\n    const other = nextAfterF16(n_16, false, false).value as number;\n    return [other, converted];\n  } else {\n    // n_16 rounded towards -inf, so is before n\n    const other = nextAfterF16(n_16, true, false).value as number;\n    return [converted, other];\n  }\n}\n\n/**\n * Calculates the linear interpolation between two values of a given fractional.\n *\n * If |t| is 0, |a| is returned, if |t| is 1, |b| is returned, otherwise\n * interpolation/extrapolation equivalent to a + t(b - a) is performed.\n *\n * Numerical stable version is adapted from http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0811r2.html\n */\nexport function lerp(a: number, b: number, t: number): number {\n  if (!Number.isFinite(a) || !Number.isFinite(b)) {\n    return Number.NaN;\n  }\n\n  if ((a <= 0.0 && b >= 0.0) || (a >= 0.0 && b <= 0.0)) {\n    return t * b + (1 - t) * a;\n  }\n\n  if (t === 1.0) {\n    return b;\n  }\n\n  const x = a + t * (b - a);\n  return t > 1.0 === b > a ? Math.max(b, x) : Math.min(b, x);\n}\n\n/** @returns a linear increasing range of numbers. */\nexport function linearRange(a: number, b: number, num_steps: number): Array<number> {\n  if (num_steps <= 0) {\n    return Array<number>();\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i => lerp(a, b, i / (num_steps - 1)));\n}\n\n/**\n * @returns a non-linear increasing range of numbers, with a bias towards the beginning.\n *\n * Generates a linear range on [0,1] with |num_steps|, then squares all the values to make the curve be quadratic,\n * thus biasing towards 0, but remaining on the [0, 1] range.\n * This biased range is then scaled to the desired range using lerp.\n * Different curves could be generated by changing c, where greater values of c will bias more towards 0.\n */\nexport function biasedRange(a: number, b: number, num_steps: number): Array<number> {\n  const c = 2;\n  if (num_steps <= 0) {\n    return Array<number>();\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i =>\n    lerp(a, b, Math.pow(lerp(0, 1, i / (num_steps - 1)), c))\n  );\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f32 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the f32 range.\n *\n * This function is intended to provide dense coverage of the f32 range, for a minimal list of values to use to cover\n * f32 behaviour, use sparseF32Range instead.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, entries\n *               must be 0 or greater.\n */\nexport function fullF32Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  // Generating bit fields first and then converting to f32, so that the spread across the possible f32 values is more\n  // even. Generating against the bounds of f32 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRange(kBit.f32.negative.min, kBit.f32.negative.max, counts.neg_norm),\n    ...linearRange(\n      kBit.f32.subnormal.negative.min,\n      kBit.f32.subnormal.negative.max,\n      counts.neg_sub\n    ),\n    0,\n    ...linearRange(\n      kBit.f32.subnormal.positive.min,\n      kBit.f32.subnormal.positive.max,\n      counts.pos_sub\n    ),\n    ...linearRange(kBit.f32.positive.min, kBit.f32.positive.max, counts.pos_norm),\n  ].map(Math.trunc);\n  return bit_fields.map(hexToF32);\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit signed ints\n *\n * Numbers are divided into 2 regions: negatives, and positives, with their spreads biased towards 0\n * Zero is included in range.\n *\n * @param counts structure param with 2 entries indicating the number of entries to be generated each region, values must be 0 or greater.\n */\nexport function fullI32Range(\n  counts: {\n    negative?: number;\n    positive: number;\n  } = { positive: 50 }\n): Array<number> {\n  counts.negative = counts.negative === undefined ? counts.positive : counts.negative;\n  return [\n    ...biasedRange(kValue.i32.negative.min, -1, counts.negative),\n    0,\n    ...biasedRange(1, kValue.i32.positive.max, counts.positive),\n  ].map(Math.trunc);\n}\n\n/** Short list of f32 values of interest to test against */\nconst kInterestingF32Values: number[] = [\n  Number.NEGATIVE_INFINITY,\n  kValue.f32.negative.min,\n  -10.0,\n  -1.0,\n  kValue.f32.negative.max,\n  kValue.f32.subnormal.negative.min,\n  kValue.f32.subnormal.negative.max,\n  0.0,\n  kValue.f32.subnormal.positive.min,\n  kValue.f32.subnormal.positive.max,\n  kValue.f32.positive.min,\n  1.0,\n  10.0,\n  kValue.f32.positive.max,\n  Number.POSITIVE_INFINITY,\n];\n\n/** @returns minimal f32 values that cover the entire range of f32 behaviours\n *\n * Has specially selected values that cover edge cases, normals, and subnormals.\n * This is used instead of fullF32Range when the number of test cases being\n * generated is a super linear function of the length of f32 values which is\n * leading to time outs.\n *\n * These values have been chosen to attempt to test the widest range of f32\n * behaviours in the lowest number of entries, so may potentially miss function\n * specific values of interest. If there are known values of interest they\n * should be appended to this list in the test generation code.\n */\nexport function sparseF32Range(): Array<number> {\n  return kInterestingF32Values;\n}\n\n/**\n * Set of vectors, indexed by dimension, that contain interesting float values\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting float values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n * Instead they insert the interesting f32 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport const kVectorTestValues = {\n  2: sparseF32Range().flatMap(f => [\n    [f, 1.0],\n    [1.0, f],\n    [f, -1.0],\n    [-1.0, f],\n  ]),\n  3: sparseF32Range().flatMap(f => [\n    [f, 1.0, 2.0],\n    [1.0, f, 2.0],\n    [1.0, 2.0, f],\n    [f, -1.0, -2.0],\n    [-1.0, f, -2.0],\n    [-1.0, -2.0, f],\n  ]),\n  4: sparseF32Range().flatMap(f => [\n    [f, 1.0, 2.0, 3.0],\n    [1.0, f, 2.0, 3.0],\n    [1.0, 2.0, f, 3.0],\n    [1.0, 2.0, 3.0, f],\n    [f, -1.0, -2.0, -3.0],\n    [-1.0, f, -2.0, -3.0],\n    [-1.0, -2.0, f, -3.0],\n    [-1.0, -2.0, -3.0, f],\n  ]),\n};\n\n/**\n * @returns the result matrix in Array<Array<number>> type.\n *\n * Matrix multiplication. A is m x n and B is n x p. Returns\n * m x p result.\n */\n// A is m x n. B is n x p. product is m x p.\nexport function multiplyMatrices(\n  A: Array<Array<number>>,\n  B: Array<Array<number>>\n): Array<Array<number>> {\n  assert(A.length > 0 && B.length > 0 && B[0].length > 0 && A[0].length === B.length);\n  const product = new Array<Array<number>>(A.length);\n  for (let i = 0; i < product.length; ++i) {\n    product[i] = new Array<number>(B[0].length).fill(0);\n  }\n\n  for (let m = 0; m < A.length; ++m) {\n    for (let p = 0; p < B[0].length; ++p) {\n      for (let n = 0; n < B.length; ++n) {\n        product[m][p] += A[m][n] * B[n][p];\n      }\n    }\n  }\n\n  return product;\n}\n\n/** Sign-extend the `bits`-bit number `n` to a 32-bit signed integer. */\nexport function signExtend(n: number, bits: number): number {\n  const shift = 32 - bits;\n  return (n << shift) >> shift;\n}\n\n/** @returns the closest 32-bit floating point value to the input */\nexport function quantizeToF32(num: number): number {\n  return f32(num).value as number;\n}\n\n/** @returns the closest 32-bit signed integer value to the input */\nexport function quantizeToI32(num: number): number {\n  return i32(num).value as number;\n}\n\n/** @returns whether the number is an integer and a power of two */\nexport function isPowerOfTwo(n: number): boolean {\n  if (!Number.isInteger(n)) {\n    return false;\n  }\n  return n !== 0 && (n & (n - 1)) === 0;\n}\n\n/** @returns the Greatest Common Divisor (GCD) of the inputs */\nexport function gcd(a: number, b: number): number {\n  assert(Number.isInteger(a) && a > 0);\n  assert(Number.isInteger(b) && b > 0);\n\n  while (b !== 0) {\n    const bTemp = b;\n    b = a % b;\n    a = bTemp;\n  }\n\n  return a;\n}\n\n/** @returns the Least Common Multiplier (LCM) of the inputs */\nexport function lcm(a: number, b: number): number {\n  return (a * b) / gcd(a, b);\n}\n\n/** Converts a 32-bit hex value to a 32-bit float value */\nexport function hexToF32(hex: number): number {\n  return floatBitsToNumber(hex, kFloat32Format);\n}\n\n/** Converts a 16-bit hex value to a 16-bit float value */\nexport function hexToF16(hex: number): number {\n  return floatBitsToNumber(hex, kFloat16Format);\n}\n\n/** Converts two 32-bit hex values to a 64-bit float value */\nexport function hexToF64(h32: number, l32: number): number {\n  const u32Arr = new Uint32Array(2);\n  u32Arr[0] = l32;\n  u32Arr[1] = h32;\n  const f64Arr = new Float64Array(u32Arr.buffer);\n  return f64Arr[0];\n}\n\n/** @returns the cross of an array with the intermediate result of cartesianProduct\n *\n * @param elements array of values to cross with the intermediate result of\n *                 cartesianProduct\n * @param intermediate arrays of values representing the partial result of\n *                     cartesianProduct\n */\nfunction cartesianProductImpl<T>(elements: T[], intermediate: T[][]): T[][] {\n  const result: T[][] = [];\n  elements.forEach(e => {\n    if (intermediate.length > 0) {\n      intermediate.forEach(a => {\n        result.push(a.concat(e));\n      });\n    } else {\n      result.push([e]);\n    }\n  });\n  return result;\n}\n\n/** @returns the cartesian product (NxMx...) of a set of arrays\n *\n * This is implemented by calculating the cross of a single input against an\n * intermediate result for each input to build up the final array of arrays.\n *\n * There are examples of doing this more succinctly using map & reduce online,\n * but they are a bit more opaque to read.\n *\n * @param inputs arrays of numbers to calculate cartesian product over\n */\nexport function cartesianProduct<T>(...inputs: T[][]): T[][] {\n  let result: T[][] = [];\n  inputs.forEach(i => {\n    result = cartesianProductImpl<T>(i, result);\n  });\n\n  return result;\n}\n"],"file":"math.js"}