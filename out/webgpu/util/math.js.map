{"version":3,"sources":["../../../src/webgpu/util/math.ts"],"names":["assert","kBit","f32","f32Bits","kMaxSafeMultipleOf8","Number","MAX_SAFE_INTEGER","align","n","alignment","isInteger","Math","ceil","roundDown","floor","clamp","min","max","diffULP","a","b","isFinite","Infinity","arr","Uint32Array","Float32Array","buffer","u32_a","u32_b","sign_a","sign_b","masked_a","masked_b","subnormal_or_zero_a","subnormal_or_zero_b","bits_a","bits_b","nextAfter","val","dir","isNaN","nan","positive","s","POSITIVE_INFINITY","infinity","NEGATIVE_INFINITY","negative","subnormal","converted","u32_val","is_positive","result","correctlyRounded","test_value","target","type","kind","value","valueOf","target32","after_target","before_target"],"mappings":";AAAA;AACA,GADA,SAASA,MAAT,QAAuB,2BAAvB,CACA,SAASC,IAAT,QAAqB,wCAArB;AAEA,SAASC,GAAT,EAAcC,OAAd,QAAqC,iBAArC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,mBAAmB,GAAGC,MAAM,CAACC,gBAAP,GAA0B,CAAtD;;AAEP;AACA;AACA,OAAO,SAASC,KAAT,CAAeC,CAAf,EAA0BC,SAA1B,EAAqD;AAC1DT,EAAAA,MAAM,CAACK,MAAM,CAACK,SAAP,CAAiBF,CAAjB,KAAuBA,CAAC,IAAI,CAA7B,EAAgC,kCAAhC,CAAN;AACAR,EAAAA,MAAM,CAACK,MAAM,CAACK,SAAP,CAAiBD,SAAjB,KAA+BA,SAAS,GAAG,CAA5C,EAA+C,sCAA/C,CAAN;AACA,SAAOE,IAAI,CAACC,IAAL,CAAUJ,CAAC,GAAGC,SAAd,IAA2BA,SAAlC;AACD;;AAED;AACA,OAAO,SAASI,SAAT,CAAmBL,CAAnB,EAA8BC,SAA9B,EAAyD;AAC9DT,EAAAA,MAAM,CAACK,MAAM,CAACK,SAAP,CAAiBF,CAAjB,KAAuBA,CAAC,IAAI,CAA7B,EAAgC,kCAAhC,CAAN;AACAR,EAAAA,MAAM,CAACK,MAAM,CAACK,SAAP,CAAiBD,SAAjB,KAA+BA,SAAS,GAAG,CAA5C,EAA+C,sCAA/C,CAAN;AACA,SAAOE,IAAI,CAACG,KAAL,CAAWN,CAAC,GAAGC,SAAf,IAA4BA,SAAnC;AACD;;AAED;AACA,OAAO,SAASM,KAAT,CAAeP,CAAf,EAA0B,EAAEQ,GAAF,EAAOC,GAAP,EAA1B,EAA8E;AACnFjB,EAAAA,MAAM,CAACiB,GAAG,IAAID,GAAR,CAAN;AACA,SAAOL,IAAI,CAACK,GAAL,CAASL,IAAI,CAACM,GAAL,CAAST,CAAT,EAAYQ,GAAZ,CAAT,EAA2BC,GAA3B,CAAP;AACD;;AAED;AACA;AACA;AACA;AACA,OAAO,SAASC,OAAT,CAAiBC,CAAjB,EAA4BC,CAA5B,EAA+C;AACpD,MAAI,CAACf,MAAM,CAACgB,QAAP,CAAgBF,CAAhB,CAAD,IAAuB,CAACd,MAAM,CAACgB,QAAP,CAAgBD,CAAhB,CAA5B,EAAgD;AAC9C,WAAOE,QAAP;AACD;;AAED,QAAMC,GAAG,GAAG,IAAIC,WAAJ,CAAgB,IAAIC,YAAJ,CAAiB,CAACN,CAAD,EAAIC,CAAJ,CAAjB,EAAyBM,MAAzC,CAAZ;AACA,QAAMC,KAAK,GAAGJ,GAAG,CAAC,CAAD,CAAjB;AACA,QAAMK,KAAK,GAAGL,GAAG,CAAC,CAAD,CAAjB;;AAEA,QAAMM,MAAM,GAAG,CAACF,KAAK,GAAG,UAAT,MAAyB,CAAxC;AACA,QAAMG,MAAM,GAAG,CAACF,KAAK,GAAG,UAAT,MAAyB,CAAxC;AACA,QAAMG,QAAQ,GAAGJ,KAAK,GAAG,UAAzB;AACA,QAAMK,QAAQ,GAAGJ,KAAK,GAAG,UAAzB;AACA,QAAMK,mBAAmB,GAAG,CAACN,KAAK,GAAG,UAAT,MAAyB,CAArD;AACA,QAAMO,mBAAmB,GAAG,CAACN,KAAK,GAAG,UAAT,MAAyB,CAArD;;AAEA;AACA;AACA;AACA;AACA,QAAMO,MAAM,GAAGF,mBAAmB,GAAG,CAAH,GAAOF,QAAQ,GAAG,QAApD;AACA,QAAMK,MAAM,GAAGF,mBAAmB,GAAG,CAAH,GAAOF,QAAQ,GAAG,QAApD;;AAEA,MAAIH,MAAM,KAAKC,MAAf,EAAuB;AACrB,WAAOnB,IAAI,CAACM,GAAL,CAASkB,MAAT,EAAiBC,MAAjB,IAA2BzB,IAAI,CAACK,GAAL,CAASmB,MAAT,EAAiBC,MAAjB,CAAlC;AACD;AACD,SAAOD,MAAM,GAAGC,MAAhB;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,SAAT,CAAmBC,GAAnB,EAAgCC,GAAY,GAAG,IAA/C,EAA6D;AAClE,MAAIlC,MAAM,CAACmC,KAAP,CAAaF,GAAb,CAAJ,EAAuB;AACrB,WAAOnC,OAAO,CAACF,IAAI,CAACC,GAAL,CAASuC,GAAT,CAAaC,QAAb,CAAsBC,CAAvB,CAAd;AACD;;AAED,MAAIL,GAAG,KAAKjC,MAAM,CAACuC,iBAAnB,EAAsC;AACpC,WAAOzC,OAAO,CAACF,IAAI,CAACC,GAAL,CAAS2C,QAAT,CAAkBH,QAAnB,CAAd;AACD;;AAED,MAAIJ,GAAG,KAAKjC,MAAM,CAACyC,iBAAnB,EAAsC;AACpC,WAAO3C,OAAO,CAACF,IAAI,CAACC,GAAL,CAAS2C,QAAT,CAAkBE,QAAnB,CAAd;AACD;;AAED;AACA,MAAIT,GAAG,KAAK,CAAZ,EAAe;AACb,QAAIC,GAAJ,EAAS;AACP,aAAOpC,OAAO,CAACF,IAAI,CAACC,GAAL,CAAS8C,SAAT,CAAmBN,QAAnB,CAA4B1B,GAA7B,CAAd;AACD,KAFD,MAEO;AACL,aAAOb,OAAO,CAACF,IAAI,CAACC,GAAL,CAAS8C,SAAT,CAAmBD,QAAnB,CAA4B9B,GAA7B,CAAd;AACD;AACF;;AAED;AACA,QAAMgC,SAAiB,GAAG,IAAIxB,YAAJ,CAAiB,CAACa,GAAD,CAAjB,EAAwB,CAAxB,CAA1B;AACAtC,EAAAA,MAAM,CAACsC,GAAG,KAAKW,SAAT,EAAqB,GAAEX,GAAI,+BAA3B,CAAN;;AAEA,QAAMY,OAAO,GAAG,IAAI1B,WAAJ,CAAgB,IAAIC,YAAJ,CAAiB,CAACa,GAAD,CAAjB,EAAwBZ,MAAxC,EAAgD,CAAhD,CAAhB;AACA,QAAMyB,WAAW,GAAG,CAACD,OAAO,GAAG,UAAX,MAA2B,CAA/C;AACA,MAAIE,MAAM,GAAGF,OAAb;AACA,MAAIX,GAAG,KAAKY,WAAZ,EAAyB;AACvBC,IAAAA,MAAM,IAAI,CAAV;AACD,GAFD,MAEO;AACLA,IAAAA,MAAM,IAAI,CAAV;AACD;;AAED;AACA,MAAI,CAACA,MAAM,GAAG,UAAV,MAA0B,UAA9B,EAA0C;AACxC,QAAIb,GAAJ,EAAS;AACP,aAAOpC,OAAO,CAACF,IAAI,CAACC,GAAL,CAAS2C,QAAT,CAAkBH,QAAnB,CAAd;AACD,KAFD,MAEO;AACL,aAAOvC,OAAO,CAACF,IAAI,CAACC,GAAL,CAAS2C,QAAT,CAAkBE,QAAnB,CAAd;AACD;AACF;AACD,SAAO5C,OAAO,CAACiD,MAAD,CAAd;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,gBAAT,CAA0BC,UAA1B,EAA8CC,MAA9C,EAAuE;AAC5EvD,EAAAA,MAAM,CAACsD,UAAU,CAACE,IAAX,CAAgBC,IAAhB,KAAyB,KAA1B,EAAkC,GAAEH,UAAW,4BAA/C,CAAN;;AAEA,MAAIjD,MAAM,CAACmC,KAAP,CAAae,MAAb,CAAJ,EAA0B;AACxB,WAAOlD,MAAM,CAACmC,KAAP,CAAac,UAAU,CAACI,KAAX,CAAiBC,OAAjB,EAAb,CAAP;AACD;;AAED,MAAIJ,MAAM,KAAKlD,MAAM,CAACuC,iBAAtB,EAAyC;AACvC,WAAOU,UAAU,CAACI,KAAX,KAAqBvD,OAAO,CAACF,IAAI,CAACC,GAAL,CAAS2C,QAAT,CAAkBH,QAAnB,CAAP,CAAoCgB,KAAhE;AACD;;AAED,MAAIH,MAAM,KAAKlD,MAAM,CAACyC,iBAAtB,EAAyC;AACvC,WAAOQ,UAAU,CAACI,KAAX,KAAqBvD,OAAO,CAACF,IAAI,CAACC,GAAL,CAAS2C,QAAT,CAAkBE,QAAnB,CAAP,CAAoCW,KAAhE;AACD;;AAED,QAAME,QAAQ,GAAG,IAAInC,YAAJ,CAAiB,CAAC8B,MAAD,CAAjB,EAA2B,CAA3B,CAAjB;AACA,QAAMN,SAAiB,GAAGW,QAA1B;AACA,MAAIL,MAAM,KAAKN,SAAf,EAA0B;AACxB;AACA,WAAOK,UAAU,CAACI,KAAX,KAAqBxD,GAAG,CAAC0D,QAAD,CAAH,CAAcF,KAA1C;AACD;;AAED,MAAIG,YAAJ;AACA,MAAIC,aAAJ;;AAEA,MAAIb,SAAS,GAAGM,MAAhB,EAAwB;AACtB;AACAM,IAAAA,YAAY,GAAG3D,GAAG,CAAC0D,QAAD,CAAlB;AACAE,IAAAA,aAAa,GAAGzB,SAAS,CAACuB,QAAD,EAAW,KAAX,CAAzB;AACD,GAJD,MAIO;AACL;AACAC,IAAAA,YAAY,GAAGxB,SAAS,CAACuB,QAAD,EAAW,IAAX,CAAxB;AACAE,IAAAA,aAAa,GAAG5D,GAAG,CAAC0D,QAAD,CAAnB;AACD;;AAED,SAAON,UAAU,CAACI,KAAX,KAAqBI,aAAa,CAACJ,KAAnC,IAA4CJ,UAAU,CAACI,KAAX,KAAqBG,YAAY,CAACH,KAArF;AACD","sourcesContent":["import { assert } from '../../common/util/util.js';\nimport { kBit } from '../shader/execution/builtin/builtin.js';\n\nimport { f32, f32Bits, Scalar } from './conversion.js';\n\n/**\n * A multiple of 8 guaranteed to be way too large to allocate (just under 8 pebibytes).\n * This is a \"safe\" integer (ULP <= 1.0) very close to MAX_SAFE_INTEGER.\n *\n * Note: allocations of this size are likely to exceed limitations other than just the system's\n * physical memory, so test cases are also needed to try to trigger \"true\" OOM.\n */\nexport const kMaxSafeMultipleOf8 = Number.MAX_SAFE_INTEGER - 7;\n\n/** Round `n` up to the next multiple of `alignment` (inclusive). */\n// MAINTENANCE_TODO: Rename to `roundUp`\nexport function align(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.ceil(n / alignment) * alignment;\n}\n\n/** Round `n` down to the next multiple of `alignment` (inclusive). */\nexport function roundDown(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.floor(n / alignment) * alignment;\n}\n\n/** Clamp a number to the provided range. */\nexport function clamp(n: number, { min, max }: { min: number; max: number }): number {\n  assert(max >= min);\n  return Math.min(Math.max(n, min), max);\n}\n\n/**\n * @returns the Units of Last Place difference between the numbers a and b.\n * If either `a` or `b` are not finite numbers, then diffULP() returns Infinity.\n */\nexport function diffULP(a: number, b: number): number {\n  if (!Number.isFinite(a) || !Number.isFinite(b)) {\n    return Infinity;\n  }\n\n  const arr = new Uint32Array(new Float32Array([a, b]).buffer);\n  const u32_a = arr[0];\n  const u32_b = arr[1];\n\n  const sign_a = (u32_a & 0x80000000) !== 0;\n  const sign_b = (u32_b & 0x80000000) !== 0;\n  const masked_a = u32_a & 0x7fffffff;\n  const masked_b = u32_b & 0x7fffffff;\n  const subnormal_or_zero_a = (u32_a & 0x7f800000) === 0;\n  const subnormal_or_zero_b = (u32_b & 0x7f800000) === 0;\n\n  // If the number is subnormal, then reduce it to 0 for ULP comparison.\n  // If the number is normal then reduce its bits-representation so to that we\n  // can pretend that the subnormal numbers don't exist, for the purposes of\n  // counting ULP steps from zero (or any subnormal) to any of the normal numbers.\n  const bits_a = subnormal_or_zero_a ? 0 : masked_a - 0x7fffff;\n  const bits_b = subnormal_or_zero_b ? 0 : masked_b - 0x7fffff;\n\n  if (sign_a === sign_b) {\n    return Math.max(bits_a, bits_b) - Math.min(bits_a, bits_b);\n  }\n  return bits_a + bits_b;\n}\n\n/**\n * @returns the next single precision floating point value after |val|,\n * towards +inf if |dir| is true, otherwise towards -inf.\n * For -/+0 the nextAfter will be the closest subnormal in the correct\n * direction, since -0 === +0.\n * |val| must be expressible as a f32.\n */\nexport function nextAfter(val: number, dir: boolean = true): Scalar {\n  if (Number.isNaN(val)) {\n    return f32Bits(kBit.f32.nan.positive.s);\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return f32Bits(kBit.f32.infinity.positive);\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return f32Bits(kBit.f32.infinity.negative);\n  }\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir) {\n      return f32Bits(kBit.f32.subnormal.positive.min);\n    } else {\n      return f32Bits(kBit.f32.subnormal.negative.max);\n    }\n  }\n\n  // number is float64 internally, so need to test if value is expressible as a float32.\n  const converted: number = new Float32Array([val])[0];\n  assert(val === converted, `${val} is not expressible as a f32.`);\n\n  const u32_val = new Uint32Array(new Float32Array([val]).buffer)[0];\n  const is_positive = (u32_val & 0x80000000) === 0;\n  let result = u32_val;\n  if (dir === is_positive) {\n    result += 1;\n  } else {\n    result -= 1;\n  }\n\n  // Checking for overflow\n  if ((result & 0x7f800000) === 0x7f800000) {\n    if (dir) {\n      return f32Bits(kBit.f32.infinity.positive);\n    } else {\n      return f32Bits(kBit.f32.infinity.negative);\n    }\n  }\n  return f32Bits(result);\n}\n\n/**\n * @returns if a test value is correctly rounded to an target value. Only\n * defined for |test_values| being a float32. target values may be any number.\n *\n * Correctly rounded means that if the target value is precisely expressible\n * as a float32, then |test_value| === |target|.\n * Otherwise |test_value| needs to be either the closest expressible number greater\n * or less than |target|.\n */\nexport function correctlyRounded(test_value: Scalar, target: number): boolean {\n  assert(test_value.type.kind === 'f32', `${test_value} is expected to be a 'f32'`);\n\n  if (Number.isNaN(target)) {\n    return Number.isNaN(test_value.value.valueOf() as number);\n  }\n\n  if (target === Number.POSITIVE_INFINITY) {\n    return test_value.value === f32Bits(kBit.f32.infinity.positive).value;\n  }\n\n  if (target === Number.NEGATIVE_INFINITY) {\n    return test_value.value === f32Bits(kBit.f32.infinity.negative).value;\n  }\n\n  const target32 = new Float32Array([target])[0];\n  const converted: number = target32;\n  if (target === converted) {\n    // expected is precisely expressible in float32\n    return test_value.value === f32(target32).value;\n  }\n\n  let after_target: Scalar;\n  let before_target: Scalar;\n\n  if (converted > target) {\n    // target32 is rounded towards +inf, so is after_target\n    after_target = f32(target32);\n    before_target = nextAfter(target32, false);\n  } else {\n    // target32 is rounded towards -inf, so is before_target\n    after_target = nextAfter(target32, true);\n    before_target = f32(target32);\n  }\n\n  return test_value.value === before_target.value || test_value.value === after_target.value;\n}\n"],"file":"math.js"}