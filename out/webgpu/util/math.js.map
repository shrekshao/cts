{"version":3,"sources":["../../../src/webgpu/util/math.ts"],"names":["assert","kBit","kValue","f32","f32Bits","i32","kMaxSafeMultipleOf8","Number","MAX_SAFE_INTEGER","align","n","alignment","isInteger","Math","ceil","roundDown","floor","clamp","min","max","diffULP","a","b","isFinite","Infinity","arr","Uint32Array","Float32Array","buffer","u32_a","u32_b","sign_a","sign_b","masked_a","masked_b","subnormal_or_zero_a","subnormal_or_zero_b","bits_a","bits_b","flushSubnormalNumber","val","u32_val","flushSubnormalBits","flushSubnormalScalar","isSubnormalScalar","type","kind","value","valueOf","isSubnormalNumber","nextAfter","dir","flush","isNaN","nan","positive","s","POSITIVE_INFINITY","infinity","NEGATIVE_INFINITY","negative","subnormal","converted","is_positive","result","correctlyRounded","test_value","target","accept_to_zero","accept_no_flush","correctlyRoundedImpl","target32","after_target","before_target","lerp","t","NaN","x","linearRange","num_steps","Array","from","keys","map","i","biasedRange","c","pow","fullF32Range","counts","pos_sub","pos_norm","neg_norm","undefined","neg_sub","multiplyMatrices","A","B","length","product","fill","m","p","signExtend","bits","shift","quantizeToF32","num","quantizeToI32","isPowerOfTwo","gcd","bTemp","lcm"],"mappings":"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","sourcesContent":["import { assert } from '../../common/util/util.js';\n\nimport { kBit, kValue } from './constants.js';\nimport { f32, f32Bits, i32, Scalar } from './conversion.js';\n\n/**\n * A multiple of 8 guaranteed to be way too large to allocate (just under 8 pebibytes).\n * This is a \"safe\" integer (ULP <= 1.0) very close to MAX_SAFE_INTEGER.\n *\n * Note: allocations of this size are likely to exceed limitations other than just the system's\n * physical memory, so test cases are also needed to try to trigger \"true\" OOM.\n */\nexport const kMaxSafeMultipleOf8 = Number.MAX_SAFE_INTEGER - 7;\n\n/** Round `n` up to the next multiple of `alignment` (inclusive). */\n// MAINTENANCE_TODO: Rename to `roundUp`\nexport function align(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.ceil(n / alignment) * alignment;\n}\n\n/** Round `n` down to the next multiple of `alignment` (inclusive). */\nexport function roundDown(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.floor(n / alignment) * alignment;\n}\n\n/** Clamp a number to the provided range. */\nexport function clamp(n: number, { min, max }: { min: number; max: number }): number {\n  assert(max >= min);\n  return Math.min(Math.max(n, min), max);\n}\n\n/**\n * @returns the (absolute) Units of Last Place difference between the float32 numbers a and b, taken\n * as JS doubles. If either `a` or `b` are not finite numbers, then diffULP() returns Infinity.\n *\n * Subnormal numbers are skipped, so 0 is one ULP from the minimum normal number.\n * Subnormal values are rounded to 0.\n */\nexport function diffULP(a: number, b: number): number {\n  if (!Number.isFinite(a) || !Number.isFinite(b)) {\n    return Infinity;\n  }\n\n  const arr = new Uint32Array(new Float32Array([a, b]).buffer);\n  const u32_a = arr[0];\n  const u32_b = arr[1];\n\n  const sign_a = (u32_a & 0x80000000) !== 0;\n  const sign_b = (u32_b & 0x80000000) !== 0;\n  const masked_a = u32_a & 0x7fffffff;\n  const masked_b = u32_b & 0x7fffffff;\n  const subnormal_or_zero_a = (u32_a & 0x7f800000) === 0;\n  const subnormal_or_zero_b = (u32_b & 0x7f800000) === 0;\n\n  // If the number is subnormal, then reduce it to 0 for ULP comparison.\n  // If the number is normal then reduce its bits-representation so to that we\n  // can pretend that the subnormal numbers don't exist, for the purposes of\n  // counting ULP steps from zero (or any subnormal) to any of the normal numbers.\n  const bits_a = subnormal_or_zero_a ? 0 : masked_a - 0x7fffff;\n  const bits_b = subnormal_or_zero_b ? 0 : masked_b - 0x7fffff;\n\n  if (sign_a === sign_b) {\n    return Math.max(bits_a, bits_b) - Math.min(bits_a, bits_b);\n  }\n  return bits_a + bits_b;\n}\n\n/**\n * @returns 0 if |val| is a subnormal f32 number, otherwise returns |val|\n */\nfunction flushSubnormalNumber(val: number): number {\n  const u32_val = new Uint32Array(new Float32Array([val]).buffer)[0];\n  return (u32_val & 0x7f800000) === 0 ? 0 : val;\n}\n\n/**\n * @returns 0 if |val| is a bit field for a subnormal f32 number, otherwise\n * returns |val|\n * |val| is assumed to be a u32 value representing a f32\n */\nfunction flushSubnormalBits(val: number): number {\n  return (val & 0x7f800000) === 0 ? 0 : val;\n}\n\n/**\n * @returns 0 if |val| is a subnormal f32 number, otherwise returns |val|\n */\nexport function flushSubnormalScalar(val: Scalar): Scalar {\n  return isSubnormalScalar(val) ? f32(0) : val;\n}\n\n/**\n * @returns true if |val| is a subnormal f32 number, otherwise returns false\n * 0 is considered a non-subnormal number by this function.\n */\nexport function isSubnormalScalar(val: Scalar): boolean {\n  if (val.type.kind !== 'f32') {\n    return false;\n  }\n\n  if (val === f32(0)) {\n    return false;\n  }\n\n  const u32_val = new Uint32Array(new Float32Array([val.value.valueOf() as number]).buffer)[0];\n  return (u32_val & 0x7f800000) === 0;\n}\n\n/** Utility to pass TS numbers into |isSubnormalNumber| */\nexport function isSubnormalNumber(val: number): boolean {\n  return isSubnormalScalar(f32(val));\n}\n\n/**\n * @returns the next single precision floating point value after |val|,\n * towards +inf if |dir| is true, otherwise towards -inf.\n * If |flush| is true, all subnormal values will be flushed to 0,\n * before processing.\n * If |flush| is false, the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfter will be the closest subnormal in the correct\n * direction.\n * |val| must be expressible as a f32.\n */\nexport function nextAfter(val: number, dir: boolean = true, flush: boolean): Scalar {\n  if (Number.isNaN(val)) {\n    return f32Bits(kBit.f32.nan.positive.s);\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return f32Bits(kBit.f32.infinity.positive);\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return f32Bits(kBit.f32.infinity.negative);\n  }\n\n  val = flush ? flushSubnormalNumber(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir) {\n      return flush ? f32Bits(kBit.f32.positive.min) : f32Bits(kBit.f32.subnormal.positive.min);\n    } else {\n      return flush ? f32Bits(kBit.f32.negative.max) : f32Bits(kBit.f32.subnormal.negative.max);\n    }\n  }\n\n  // number is float64 internally, so need to test if value is expressible as a float32.\n  const converted: number = new Float32Array([val])[0];\n  assert(val === converted, `${val} is not expressible as a f32.`);\n\n  const u32_val = new Uint32Array(new Float32Array([val]).buffer)[0];\n  const is_positive = (u32_val & 0x80000000) === 0;\n  let result = u32_val;\n  if (dir === is_positive) {\n    result += 1;\n  } else {\n    result -= 1;\n  }\n  result = flush ? flushSubnormalBits(result) : result;\n\n  // Checking for overflow\n  if ((result & 0x7f800000) === 0x7f800000) {\n    if (dir) {\n      return f32Bits(kBit.f32.infinity.positive);\n    } else {\n      return f32Bits(kBit.f32.infinity.negative);\n    }\n  }\n  return f32Bits(result);\n}\n\n/**\n * @returns if a test value is correctly rounded to an target value. Only\n * defined for |test_values| being a float32. target values may be any number.\n *\n * Correctly rounded means that if the target value is precisely expressible\n * as a float32, then |test_value| === |target|.\n * Otherwise |test_value| needs to be either the closest expressible number\n * greater or less than |target|.\n *\n * By default internally tests with both subnormals being flushed to 0 and not\n * being flushed, but |accept_to_zero| and |accept_no_flush| can be used to\n * control that behaviour. At least one accept flag must be true.\n */\nexport function correctlyRounded(\n  test_value: Scalar,\n  target: number,\n  accept_to_zero: boolean = true,\n  accept_no_flush: boolean = true\n): boolean {\n  assert(\n    accept_to_zero || accept_no_flush,\n    `At least one of |accept_to_zero| & |accept_no_flush| must be true`\n  );\n\n  let result: boolean = false;\n  if (accept_to_zero) {\n    result = result || correctlyRoundedImpl(test_value, target, true);\n  }\n  if (accept_no_flush) {\n    result = result || correctlyRoundedImpl(test_value, target, false);\n  }\n  return result;\n}\n\nfunction correctlyRoundedImpl(test_value: Scalar, target: number, flush: boolean): boolean {\n  assert(test_value.type.kind === 'f32', `${test_value} is expected to be a 'f32'`);\n\n  if (Number.isNaN(target)) {\n    return Number.isNaN(test_value.value.valueOf() as number);\n  }\n\n  if (target === Number.POSITIVE_INFINITY) {\n    return test_value.value === f32Bits(kBit.f32.infinity.positive).value;\n  }\n\n  if (target === Number.NEGATIVE_INFINITY) {\n    return test_value.value === f32Bits(kBit.f32.infinity.negative).value;\n  }\n\n  test_value = flush ? flushSubnormalScalar(test_value) : test_value;\n  target = flush ? flushSubnormalNumber(target) : target;\n\n  const target32 = new Float32Array([target])[0];\n  const converted: number = target32;\n  if (target === converted) {\n    // expected is precisely expressible in float32\n    return test_value.value === f32(target32).value;\n  }\n\n  let after_target: Scalar;\n  let before_target: Scalar;\n\n  if (converted > target) {\n    // target32 is rounded towards +inf, so is after_target\n    after_target = f32(target32);\n    before_target = nextAfter(target32, false, flush);\n  } else {\n    // target32 is rounded towards -inf, so is before_target\n    after_target = nextAfter(target32, true, flush);\n    before_target = f32(target32);\n  }\n\n  return test_value.value === before_target.value || test_value.value === after_target.value;\n}\n\n/**\n * Calculates the linear interpolation between two values of a given fractional.\n *\n * If |t| is 0, |a| is returned, if |t| is 1, |b| is returned, otherwise\n * interpolation/extrapolation equivalent to a + t(b - a) is performed.\n *\n * Numerical stable version is adapted from http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0811r2.html\n */\nexport function lerp(a: number, b: number, t: number): number {\n  if (!Number.isFinite(a) || !Number.isFinite(b)) {\n    return Number.NaN;\n  }\n\n  if ((a <= 0.0 && b >= 0.0) || (a >= 0.0 && b <= 0.0)) {\n    return t * b + (1 - t) * a;\n  }\n\n  if (t === 1.0) {\n    return b;\n  }\n\n  const x = a + t * (b - a);\n  return t > 1.0 === b > a ? Math.max(b, x) : Math.min(b, x);\n}\n\n/** @returns a linear increasing range of numbers. */\nexport function linearRange(a: number, b: number, num_steps: number): Array<number> {\n  if (num_steps <= 0) {\n    return Array<number>();\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i => lerp(a, b, i / (num_steps - 1)));\n}\n\n/**\n * @returns a non-linear increasing range of numbers, with a bias towards the beginning.\n *\n * Generates a linear range on [0,1] with |num_steps|, then squares all the values to make the curve be quadratic,\n * thus biasing towards 0, but remaining on the [0, 1] range.\n * This biased range is then scaled to the desired range using lerp.\n * Different curves could be generated by changing c, where greater values of c will bias more towards 0.\n */\nexport function biasedRange(a: number, b: number, num_steps: number): Array<number> {\n  const c = 2;\n  if (num_steps <= 0) {\n    return Array<number>();\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i =>\n    lerp(a, b, Math.pow(lerp(0, 1, i / (num_steps - 1)), c))\n  );\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included. The normal number regions are biased towards zero, and the subnormal regions are linearly spread.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, values must be 0 or greater.\n */\nexport function fullF32Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : (counts.neg_norm as number);\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : (counts.neg_sub as number);\n  return [\n    ...biasedRange(kValue.f32.negative.max, kValue.f32.negative.min, counts.neg_norm),\n    ...linearRange(\n      kValue.f32.subnormal.negative.min,\n      kValue.f32.subnormal.negative.max,\n      counts.neg_sub\n    ),\n    0.0,\n    ...linearRange(\n      kValue.f32.subnormal.positive.min,\n      kValue.f32.subnormal.positive.max,\n      counts.pos_sub\n    ),\n    ...biasedRange(kValue.f32.positive.min, kValue.f32.positive.max, counts.pos_norm),\n  ];\n}\n\n/**\n * @returns the result matrix in Array<Array<number>> type.\n *\n * Matrix multiplication. A is m x n and B is n x p. Returns\n * m x p result.\n */\n// A is m x n. B is n x p. product is m x p.\nexport function multiplyMatrices(\n  A: Array<Array<number>>,\n  B: Array<Array<number>>\n): Array<Array<number>> {\n  assert(A.length > 0 && B.length > 0 && B[0].length > 0 && A[0].length === B.length);\n  const product = new Array<Array<number>>(A.length);\n  for (let i = 0; i < product.length; ++i) {\n    product[i] = new Array<number>(B[0].length).fill(0);\n  }\n\n  for (let m = 0; m < A.length; ++m) {\n    for (let p = 0; p < B[0].length; ++p) {\n      for (let n = 0; n < B.length; ++n) {\n        product[m][p] += A[m][n] * B[n][p];\n      }\n    }\n  }\n\n  return product;\n}\n\n/** Sign-extend the `bits`-bit number `n` to a 32-bit signed integer. */\nexport function signExtend(n: number, bits: number): number {\n  const shift = 32 - bits;\n  return (n << shift) >> shift;\n}\n\n/** @returns the closest 32-bit floating point value to the input */\nexport function quantizeToF32(num: number): number {\n  return f32(num).value as number;\n}\n\n/** @returns the closest 32-bit signed integer value to the input */\nexport function quantizeToI32(num: number): number {\n  return i32(num).value as number;\n}\n\n/** @returns whether the number is an integer and a power of two */\nexport function isPowerOfTwo(n: number): boolean {\n  if (!Number.isInteger(n)) {\n    return false;\n  }\n  return n !== 0 && (n & (n - 1)) === 0;\n}\n\n/** @returns the Greatest Common Divisor (GCD) of the inputs */\nexport function gcd(a: number, b: number): number {\n  assert(Number.isInteger(a) && a > 0);\n  assert(Number.isInteger(b) && b > 0);\n\n  while (b !== 0) {\n    const bTemp = b;\n    b = a % b;\n    a = bTemp;\n  }\n\n  return a;\n}\n\n/** @returns the Least Common Multiplier (LCM) of the inputs */\nexport function lcm(a: number, b: number): number {\n  return (a * b) / gcd(a, b);\n}\n"],"file":"math.js"}