{"version":3,"file":"math.js","names":["assert","Float16Array","kBit","kValue","f32","floatBitsToNumber","i32","kFloat16Format","kFloat32Format","u32","kMaxSafeMultipleOf8","Number","MAX_SAFE_INTEGER","align","n","alignment","isInteger","Math","ceil","roundDown","floor","clamp","min","max","flushSubnormalNumberF32","val","isSubnormalNumberF32","negative","positive","isFiniteF32","flushSubnormalNumberF16","isSubnormalNumberF16","f16","isFiniteF16","nextAfterF32Data","ArrayBuffer","nextAfterF32Hex","Uint32Array","nextAfterF32Float","Float32Array","nextAfterF32","dir","mode","isNaN","POSITIVE_INFINITY","infinity","NEGATIVE_INFINITY","subnormal","is_positive","nextAfterF16Data","nextAfterF16Hex","Uint16Array","nextAfterF16Float","nextAfterF16","oneULPF32","target","NaN","nearest_max","nearest_min","before","after","converted","correctlyRoundedF32","n_32","other","correctlyRoundedF16","n_16","frexpData","frexpDataU32","frexpDataF32","frexp","fract","exp","lerp","a","b","t","isFinite","x","linearRange","num_steps","Array","from","keys","map","i","biasedRange","c","pow","fullF32Range","counts","pos_sub","pos_norm","neg_norm","undefined","neg_sub","bit_fields","trunc","hexToF32","sourceFilteredF32Range","source","low","high","filter","fullF16Range","hexToF16","kInterestingI32Values","sparseI32Range","kVectorI32Values","flatMap","f","vectorI32Range","dim","fullI32Range","kInterestingU32Values","sparseU32Range","kVectorU32Values","vectorU32Range","fullU32Range","count","kInterestingF32Values","sparseF32Range","kVectorF32Values","vectorF32Range","kSparseVectorF32Values","idx","sparseVectorF32Range","kSparseMatrixF32Values","sparseMatrixF32Range","r","multiplyMatrices","A","B","length","product","fill","m","p","signExtend","bits","shift","quantizeToF32","num","value","quantizeToI32","quantizeToU32","isPowerOfTwo","gcd","bTemp","lcm","hex","hexToF64","Float64Array","BigInt64Array","buffer","cartesianProductImpl","elements","intermediate","result","forEach","e","push","cartesianProduct","inputs","calculatePermutations","input","head","tail","slice","concat","permutations","flatten2DArray","every","j","unflatten2DArray","_","map2DArray","op"],"sources":["../../../src/webgpu/util/math.ts"],"sourcesContent":["import { assert } from '../../common/util/util.js';\nimport { Float16Array } from '../../external/petamoriken/float16/float16.js';\n\nimport { kBit, kValue } from './constants.js';\nimport { f32, floatBitsToNumber, i32, kFloat16Format, kFloat32Format, u32 } from './conversion.js';\n\n/**\n * A multiple of 8 guaranteed to be way too large to allocate (just under 8 pebibytes).\n * This is a \"safe\" integer (ULP <= 1.0) very close to MAX_SAFE_INTEGER.\n *\n * Note: allocations of this size are likely to exceed limitations other than just the system's\n * physical memory, so test cases are also needed to try to trigger \"true\" OOM.\n */\nexport const kMaxSafeMultipleOf8 = Number.MAX_SAFE_INTEGER - 7;\n\n/** Round `n` up to the next multiple of `alignment` (inclusive). */\n// MAINTENANCE_TODO: Rename to `roundUp`\nexport function align(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.ceil(n / alignment) * alignment;\n}\n\n/** Round `n` down to the next multiple of `alignment` (inclusive). */\nexport function roundDown(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.floor(n / alignment) * alignment;\n}\n\n/** Clamp a number to the provided range. */\nexport function clamp(n: number, { min, max }: { min: number; max: number }): number {\n  assert(max >= min);\n  return Math.min(Math.max(n, min), max);\n}\n\n/** @returns 0 if |val| is a subnormal f32 number, otherwise returns |val| */\nexport function flushSubnormalNumberF32(val: number): number {\n  return isSubnormalNumberF32(val) ? 0 : val;\n}\n\n/** @returns if number is within subnormal range of f32 */\nexport function isSubnormalNumberF32(n: number): boolean {\n  return n > kValue.f32.negative.max && n < kValue.f32.positive.min;\n}\n\n/** @returns if number is in the finite range of f32 */\nexport function isFiniteF32(n: number) {\n  return n >= kValue.f32.negative.min && n <= kValue.f32.positive.max;\n}\n\n/** @returns 0 if |val| is a subnormal f16 number, otherwise returns |val| */\nexport function flushSubnormalNumberF16(val: number): number {\n  return isSubnormalNumberF16(val) ? 0 : val;\n}\n\n/** @returns if number is within subnormal range of f16 */\nexport function isSubnormalNumberF16(n: number): boolean {\n  return n > kValue.f16.negative.max && n < kValue.f16.positive.min;\n}\n\n/** @returns if number is in the finite range of f16 */\nexport function isFiniteF16(n: number) {\n  return n >= kValue.f16.negative.min && n <= kValue.f16.positive.max;\n}\n\n/** Should FTZ occur during calculations or not */\nexport type FlushMode = 'flush' | 'no-flush';\n\n/** Should nextAfter calculate towards positive infinity or negative infinity */\nexport type NextDirection = 'positive' | 'negative';\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation when\n * converting between numeric formats\n *\n * Usage of a once-allocated pattern like this makes nextAfterF32 non-reentrant,\n * so cannot call itself directly or indirectly.\n */\nconst nextAfterF32Data = new ArrayBuffer(4);\nconst nextAfterF32Hex = new Uint32Array(nextAfterF32Data);\nconst nextAfterF32Float = new Float32Array(nextAfterF32Data);\n\n/**\n * @returns the next f32 value after |val|, towards +inf or -inf as specified by |dir|.\n\n * If |mode| is 'flush', all subnormal values will be flushed to 0,\n * before processing and for -/+0 the nextAfterF32 will be the closest normal in\n * the correct direction.\n\n * If |mode| is 'no-flush', the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfterF32 will be the closest subnormal in the correct\n * direction.\n *\n * val needs to be in [min f32, max f32]\n */\nexport function nextAfterF32(val: number, dir: NextDirection, mode: FlushMode): number {\n  if (Number.isNaN(val)) {\n    return val;\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return kValue.f32.infinity.positive;\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return kValue.f32.infinity.negative;\n  }\n\n  assert(\n    val <= kValue.f32.positive.max && val >= kValue.f32.negative.min,\n    `${val} is not in the range of f32`\n  );\n\n  val = mode === 'flush' ? flushSubnormalNumberF32(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir === 'positive') {\n      return mode === 'flush' ? kValue.f32.positive.min : kValue.f32.subnormal.positive.min;\n    } else {\n      return mode === 'flush' ? kValue.f32.negative.max : kValue.f32.subnormal.negative.max;\n    }\n  }\n\n  nextAfterF32Float[0] = val; // This quantizes from number (f64) to f32\n  if (\n    (dir === 'positive' && nextAfterF32Float[0] <= val) ||\n    (dir === 'negative' && nextAfterF32Float[0] >= val)\n  ) {\n    // val is either f32 precise or quantizing rounded in the opposite direction\n    // from what is needed, so need to calculate the value in the correct\n    // direction.\n    const is_positive = (nextAfterF32Hex[0] & 0x80000000) === 0;\n    if (is_positive === (dir === 'positive')) {\n      nextAfterF32Hex[0] += 1;\n    } else {\n      nextAfterF32Hex[0] -= 1;\n    }\n  }\n\n  // Checking for overflow\n  if ((nextAfterF32Hex[0] & 0x7f800000) === 0x7f800000) {\n    if (dir === 'positive') {\n      return kValue.f32.infinity.positive;\n    } else {\n      return kValue.f32.infinity.negative;\n    }\n  }\n\n  return mode === 'flush' ? flushSubnormalNumberF32(nextAfterF32Float[0]) : nextAfterF32Float[0];\n}\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation when\n * converting between numeric formats\n *\n * Usage of a once-allocated pattern like this makes nextAfterF16 non-reentrant,\n * so cannot call itself directly or indirectly.\n */\nconst nextAfterF16Data = new ArrayBuffer(2);\nconst nextAfterF16Hex = new Uint16Array(nextAfterF16Data);\nconst nextAfterF16Float = new Float16Array(nextAfterF16Data);\n\n/**\n * @returns the next f16 value after |val|, towards +inf or -inf as specified by |dir|.\n\n * If |mode| is 'flush', all subnormal values will be flushed to 0,\n * before processing and for -/+0 the nextAfterF16 will be the closest normal in\n * the correct direction.\n\n * If |mode| is 'no-flush', the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfterF16 will be the closest subnormal in the correct\n * direction.\n *\n * val needs to be in [min f16, max f16]\n */\nexport function nextAfterF16(val: number, dir: NextDirection, mode: FlushMode): number {\n  if (Number.isNaN(val)) {\n    return val;\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return kValue.f16.infinity.positive;\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return kValue.f16.infinity.negative;\n  }\n\n  assert(\n    val <= kValue.f16.positive.max && val >= kValue.f16.negative.min,\n    `${val} is not in the range of f16`\n  );\n\n  val = mode === 'flush' ? flushSubnormalNumberF16(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir === 'positive') {\n      return mode === 'flush' ? kValue.f16.positive.min : kValue.f16.subnormal.positive.min;\n    } else {\n      return mode === 'flush' ? kValue.f16.negative.max : kValue.f16.subnormal.negative.max;\n    }\n  }\n\n  nextAfterF16Float[0] = val; // This quantizes from number (f64) to f16\n  if (\n    (dir === 'positive' && nextAfterF16Float[0] <= val) ||\n    (dir === 'negative' && nextAfterF16Float[0] >= val)\n  ) {\n    // val is either f16 precise or quantizing rounded in the opposite direction\n    // from what is needed, so need to calculate the value in the correct\n    // direction.\n    const is_positive = (nextAfterF16Hex[0] & 0x8000) === 0;\n    if (is_positive === (dir === 'positive')) {\n      nextAfterF16Hex[0] += 1;\n    } else {\n      nextAfterF16Hex[0] -= 1;\n    }\n  }\n\n  // Checking for overflow\n  if ((nextAfterF16Hex[0] & 0x7c00) === 0x7c00) {\n    if (dir === 'positive') {\n      return kValue.f16.infinity.positive;\n    } else {\n      return kValue.f16.infinity.negative;\n    }\n  }\n\n  return mode === 'flush' ? flushSubnormalNumberF16(nextAfterF16Float[0]) : nextAfterF16Float[0];\n}\n\n/**\n * @returns ulp(x), the unit of least precision for a specific number as a 32-bit float\n *\n * ulp(x) is the distance between the two floating point numbers nearest x.\n * This value is also called unit of last place, ULP, and 1 ULP.\n * See the WGSL spec and http://www.ens-lyon.fr/LIP/Pub/Rapports/RR/RR2005/RR2005-09.pdf\n * for a more detailed/nuanced discussion of the definition of ulp(x).\n *\n * @param target number to calculate ULP for\n * @param mode should FTZ occuring during calculation or not\n */\nexport function oneULPF32(target: number, mode: FlushMode = 'flush'): number {\n  if (Number.isNaN(target)) {\n    return Number.NaN;\n  }\n\n  target = mode === 'flush' ? flushSubnormalNumberF32(target) : target;\n\n  // For values at the edge of the range or beyond ulp(x) is defined as the distance between the two nearest\n  // f32 representable numbers to the appropriate edge.\n  if (target === Number.POSITIVE_INFINITY || target >= kValue.f32.positive.max) {\n    return kValue.f32.positive.max - kValue.f32.positive.nearest_max;\n  } else if (target === Number.NEGATIVE_INFINITY || target <= kValue.f32.negative.min) {\n    return kValue.f32.negative.nearest_min - kValue.f32.negative.min;\n  }\n\n  // ulp(x) is min(after - before), where\n  //     before <= x <= after\n  //     before =/= after\n  //     before and after are f32 representable\n  const before = nextAfterF32(target, 'negative', mode);\n  const after = nextAfterF32(target, 'positive', mode);\n  const converted: number = new Float32Array([target])[0];\n  if (converted === target) {\n    // |target| is f32 representable, so either before or after will be x\n    return Math.min(target - before, after - target);\n  } else {\n    // |target| is not f32 representable so taking distance of neighbouring f32s.\n    return after - before;\n  }\n}\n\n/**\n * Calculate the valid roundings when quantizing to 32-bit floats\n *\n * TS/JS's number type is internally a f64, so quantization needs to occur when\n * converting to f32 for WGSL. WGSL does not specify a specific rounding mode,\n * so if a number is not precisely representable in 32-bits, but in the\n * range, there are two possible valid quantizations. If it is precisely\n * representable, there is only one valid quantization. This function calculates\n * the valid roundings and returns them in an array.\n *\n * This function does not consider flushing mode, so subnormals are maintained.\n * The caller is responsible to flushing before and after as appropriate.\n *\n * Out of range values return the appropriate infinity and edge value.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 32-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF32(n: number): number[] {\n  assert(!Number.isNaN(n), `correctlyRoundedF32 not defined for NaN`);\n  // Above f32 range\n  if (n === Number.POSITIVE_INFINITY || n > kValue.f32.positive.max) {\n    return [kValue.f32.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // Below f32 range\n  if (n === Number.NEGATIVE_INFINITY || n < kValue.f32.negative.min) {\n    return [Number.NEGATIVE_INFINITY, kValue.f32.negative.min];\n  }\n\n  const n_32 = new Float32Array([n])[0];\n  const converted: number = n_32;\n  if (n === converted) {\n    // n is precisely expressible as a f32, so should not be rounded\n    return [n];\n  }\n\n  if (converted > n) {\n    // n_32 rounded towards +inf, so is after n\n    const other = nextAfterF32(n_32, 'negative', 'no-flush');\n    return [other, converted];\n  } else {\n    // n_32 rounded towards -inf, so is before n\n    const other = nextAfterF32(n_32, 'positive', 'no-flush');\n    return [converted, other];\n  }\n}\n\n/**\n * Calculate the valid roundings when quantizing to 16-bit floats\n *\n * TS/JS's number type is internally a f64, so quantization needs to occur when\n * converting to f16 for WGSL. WGSL does not specify a specific rounding mode,\n * so if a number is not precisely representable in 16-bits, but in the\n * range, there are two possible valid quantizations. If it is precisely\n * representable, there is only one valid quantization. This function calculates\n * the valid roundings and returns them in an array.\n *\n * This function does not consider flushing mode, so subnormals are maintained.\n * The caller is responsible to flushing before and after as appropriate.\n *\n * Out of range values return the appropriate infinity and edge value.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 16-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF16(n: number): number[] {\n  assert(!Number.isNaN(n), `correctlyRoundedF16 not defined for NaN`);\n  // Above f16 range\n  if (n === Number.POSITIVE_INFINITY || n > kValue.f16.positive.max) {\n    return [kValue.f16.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // Below f16 range\n  if (n === Number.NEGATIVE_INFINITY || n < kValue.f16.negative.min) {\n    return [Number.NEGATIVE_INFINITY, kValue.f16.negative.min];\n  }\n\n  const n_16 = new Float16Array([n])[0];\n  const converted: number = n_16;\n  if (n === converted) {\n    // n is precisely expressible as a f16, so should not be rounded\n    return [n];\n  }\n\n  if (converted > n) {\n    // n_16 rounded towards +inf, so is after n\n    const other = nextAfterF16(n_16, 'negative', 'no-flush');\n    return [other, converted];\n  } else {\n    // n_16 rounded towards -inf, so is before n\n    const other = nextAfterF16(n_16, 'positive', 'no-flush');\n    return [converted, other];\n  }\n}\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation in frexp\n *\n * This makes frexp non-reentrant due to shared state between calls.\n */\nconst frexpData = new ArrayBuffer(4);\nconst frexpDataU32 = new Uint32Array(frexpData);\nconst frexpDataF32 = new Float32Array(frexpData);\n\n/**\n * Calculates WGSL frexp\n *\n * Splits val into a fraction and an exponent so that\n * val = fraction * 2 ^ exponent.\n * The fraction is 0.0 or its magnitude is in the range [0.5, 1.0).\n *\n * Inspired by golang's implementation of frexp.\n *\n * This code is non-reentrant due to the use of a non-local data buffer and\n * views.\n *\n * @param val the f32 to split\n * @returns the results of splitting val\n */\nexport function frexp(val: number): { fract: number; exp: number } {\n  frexpDataF32[0] = val;\n  // Do not directly use val after this point, so that changes are reflected in\n  // both the f32 and u32 views.\n\n  // Handles 0 and -0\n  if (frexpDataF32[0] === 0) {\n    return { fract: frexpDataF32[0], exp: 0 };\n  }\n\n  // Covers NaNs, OOB and Infinities\n  if (!isFiniteF32(frexpDataF32[0])) {\n    return { fract: frexpDataF32[0], exp: 0 };\n  }\n\n  // Normalize if subnormal\n  let exp = 0;\n  if (isSubnormalNumberF32(frexpDataF32[0])) {\n    frexpDataF32[0] = frexpDataF32[0] * (1 << 23);\n    exp = -23;\n  }\n  exp += ((frexpDataU32[0] >> 23) & 0xff) - 126; // shift & mask, minus the bias + 1\n\n  frexpDataU32[0] &= 0x807fffff; // mask the exponent bits\n  frexpDataU32[0] |= 0x3f000000; // extract the mantissa bits\n  const fract = frexpDataF32[0]; // Convert from bits to number\n  return { fract, exp };\n}\n\n/**\n * Calculates the linear interpolation between two values of a given fractional.\n *\n * If |t| is 0, |a| is returned, if |t| is 1, |b| is returned, otherwise\n * interpolation/extrapolation equivalent to a + t(b - a) is performed.\n *\n * Numerical stable version is adapted from http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0811r2.html\n */\nexport function lerp(a: number, b: number, t: number): number {\n  if (!Number.isFinite(a) || !Number.isFinite(b)) {\n    return Number.NaN;\n  }\n\n  if ((a <= 0.0 && b >= 0.0) || (a >= 0.0 && b <= 0.0)) {\n    return t * b + (1 - t) * a;\n  }\n\n  if (t === 1.0) {\n    return b;\n  }\n\n  const x = a + t * (b - a);\n  return t > 1.0 === b > a ? Math.max(b, x) : Math.min(b, x);\n}\n\n/** @returns a linear increasing range of numbers. */\nexport function linearRange(a: number, b: number, num_steps: number): Array<number> {\n  if (num_steps <= 0) {\n    return Array<number>();\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i => lerp(a, b, i / (num_steps - 1)));\n}\n\n/**\n * @returns a non-linear increasing range of numbers, with a bias towards the beginning.\n *\n * Generates a linear range on [0,1] with |num_steps|, then squares all the values to make the curve be quadratic,\n * thus biasing towards 0, but remaining on the [0, 1] range.\n * This biased range is then scaled to the desired range using lerp.\n * Different curves could be generated by changing c, where greater values of c will bias more towards 0.\n */\nexport function biasedRange(a: number, b: number, num_steps: number): Array<number> {\n  const c = 2;\n  if (num_steps <= 0) {\n    return Array<number>();\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i => lerp(a, b, Math.pow(i / (num_steps - 1), c)));\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f32 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the f32 range.\n *\n * This function is intended to provide dense coverage of the f32 range, for a minimal list of values to use to cover\n * f32 behaviour, use sparseF32Range instead.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, entries\n *               must be 0 or greater.\n */\nexport function fullF32Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  // Generating bit fields first and then converting to f32, so that the spread across the possible f32 values is more\n  // even. Generating against the bounds of f32 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRange(kBit.f32.negative.min, kBit.f32.negative.max, counts.neg_norm),\n    ...linearRange(\n      kBit.f32.subnormal.negative.min,\n      kBit.f32.subnormal.negative.max,\n      counts.neg_sub\n    ),\n    0,\n    ...linearRange(\n      kBit.f32.subnormal.positive.min,\n      kBit.f32.subnormal.positive.max,\n      counts.pos_sub\n    ),\n    ...linearRange(kBit.f32.positive.min, kBit.f32.positive.max, counts.pos_norm),\n  ].map(Math.trunc);\n  return bit_fields.map(hexToF32);\n}\n\n/**\n * @returns an ascending sorted array of numbers.\n *\n * The numbers returned are based on the `full32Range` as described above. The difference comes depending\n * on the `source` parameter. If the `source` is `const` then the numbers will be restricted to be\n * in the range `[low, high]`. This allows filtering out a set of `f32` values which are invalid for\n * const-evaluation but are needed to test the non-const implementation.\n *\n * @param source the input source for the test. If the `source` is `const` then the return will be filtered\n * @param low the lowest f32 value to permit when filtered\n * @param high the highest f32 value to permit when filtered\n */\nexport function sourceFilteredF32Range(source: String, low: number, high: number): Array<number> {\n  return fullF32Range().filter(x => source !== 'const' || (x >= low && x <= high));\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 16-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f16 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the f16 range.\n *\n * This function is intended to provide dense coverage of the f16 range, for a minimal list of values to use to cover\n * f16 behaviour, use sparseF16Range instead.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, entries\n *               must be 0 or greater.\n */\nexport function fullF16Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  // Generating bit fields first and then converting to f16, so that the spread across the possible f16 values is more\n  // even. Generating against the bounds of f16 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRange(kBit.f16.negative.min, kBit.f16.negative.max, counts.neg_norm),\n    ...linearRange(\n      kBit.f16.subnormal.negative.min,\n      kBit.f16.subnormal.negative.max,\n      counts.neg_sub\n    ),\n    0,\n    ...linearRange(\n      kBit.f16.subnormal.positive.min,\n      kBit.f16.subnormal.positive.max,\n      counts.pos_sub\n    ),\n    ...linearRange(kBit.f16.positive.min, kBit.f16.positive.max, counts.pos_norm),\n  ].map(Math.trunc);\n  return bit_fields.map(hexToF16);\n}\n\n/** Short list of i32 values of interest to test against */\nconst kInterestingI32Values: number[] = [\n  kValue.i32.negative.max,\n  kValue.i32.negative.max / 2,\n  -1,\n  0,\n  1,\n  kValue.i32.positive.max / 2,\n  kValue.i32.positive.max,\n];\n\n/** @returns minimal i32 values that cover the entire range of i32 behaviours\n *\n * This is used instead of fullI32Range when the number of test cases being\n * generated is a super linear function of the length of i32 values which is\n * leading to time outs.\n */\nexport function sparseI32Range(): number[] {\n  return kInterestingI32Values;\n}\n\nconst kVectorI32Values = {\n  2: kInterestingI32Values.flatMap(f => [\n    [f, 1],\n    [1, f],\n    [f, -1],\n    [-1, f],\n  ]),\n  3: kInterestingI32Values.flatMap(f => [\n    [f, 1, 2],\n    [1, f, 2],\n    [1, 2, f],\n    [f, -1, -2],\n    [-1, f, -2],\n    [-1, -2, f],\n  ]),\n  4: kInterestingI32Values.flatMap(f => [\n    [f, 1, 2, 3],\n    [1, f, 2, 3],\n    [1, 2, f, 3],\n    [1, 2, 3, f],\n    [f, -1, -2, -3],\n    [-1, f, -2, -3],\n    [-1, -2, f, -3],\n    [-1, -2, -3, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting i32\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting i32 values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting i32 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorI32Range(dim: number): number[][] {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorI32Range only accepts dimensions 2, 3, and 4');\n  return kVectorI32Values[dim];\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit signed ints\n *\n * Numbers are divided into 2 regions: negatives, and positives, with their spreads biased towards 0\n * Zero is included in range.\n *\n * @param counts structure param with 2 entries indicating the number of entries to be generated each region, values must be 0 or greater.\n */\nexport function fullI32Range(\n  counts: {\n    negative?: number;\n    positive: number;\n  } = { positive: 50 }\n): Array<number> {\n  counts.negative = counts.negative === undefined ? counts.positive : counts.negative;\n  return [\n    ...biasedRange(kValue.i32.negative.min, -1, counts.negative),\n    0,\n    ...biasedRange(1, kValue.i32.positive.max, counts.positive),\n  ].map(Math.trunc);\n}\n\n/** Short list of u32 values of interest to test against */\nconst kInterestingU32Values: number[] = [0, 1, kValue.u32.max / 2, kValue.u32.max];\n\n/** @returns minimal u32 values that cover the entire range of u32 behaviours\n *\n * This is used instead of fullU32Range when the number of test cases being\n * generated is a super linear function of the length of u32 values which is\n * leading to time outs.\n */\nexport function sparseU32Range(): number[] {\n  return kInterestingU32Values;\n}\n\nconst kVectorU32Values = {\n  2: kInterestingU32Values.flatMap(f => [\n    [f, 1],\n    [1, f],\n  ]),\n  3: kInterestingU32Values.flatMap(f => [\n    [f, 1, 2],\n    [1, f, 2],\n    [1, 2, f],\n  ]),\n  4: kInterestingU32Values.flatMap(f => [\n    [f, 1, 2, 3],\n    [1, f, 2, 3],\n    [1, 2, f, 3],\n    [1, 2, 3, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting u32\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting u32 values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting u32 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorU32Range(dim: number): number[][] {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorU32Range only accepts dimensions 2, 3, and 4');\n  return kVectorU32Values[dim];\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit unsigned ints\n *\n * Numbers are biased towards 0, and 0 is included in the range.\n *\n * @param count number of entries to include in the range, in addition to 0, must be greater than 0, defaults to 50\n */\nexport function fullU32Range(count: number = 50): Array<number> {\n  return [0, ...biasedRange(1, kValue.u32.max, count)].map(Math.trunc);\n}\n\n/** Short list of f32 values of interest to test against */\nconst kInterestingF32Values: number[] = [\n  kValue.f32.negative.min,\n  -10.0,\n  -1.0,\n  kValue.f32.negative.max,\n  kValue.f32.subnormal.negative.min,\n  kValue.f32.subnormal.negative.max,\n  0.0,\n  kValue.f32.subnormal.positive.min,\n  kValue.f32.subnormal.positive.max,\n  kValue.f32.positive.min,\n  1.0,\n  10.0,\n  kValue.f32.positive.max,\n];\n\n/** @returns minimal f32 values that cover the entire range of f32 behaviours\n *\n * Has specially selected values that cover edge cases, normals, and subnormals.\n * This is used instead of fullF32Range when the number of test cases being\n * generated is a super linear function of the length of f32 values which is\n * leading to time outs.\n *\n * These values have been chosen to attempt to test the widest range of f32\n * behaviours in the lowest number of entries, so may potentially miss function\n * specific values of interest. If there are known values of interest they\n * should be appended to this list in the test generation code.\n */\nexport function sparseF32Range(): number[] {\n  return kInterestingF32Values;\n}\n\nconst kVectorF32Values = {\n  2: sparseF32Range().flatMap(f => [\n    [f, 1.0],\n    [1.0, f],\n    [f, -1.0],\n    [-1.0, f],\n  ]),\n  3: sparseF32Range().flatMap(f => [\n    [f, 1.0, 2.0],\n    [1.0, f, 2.0],\n    [1.0, 2.0, f],\n    [f, -1.0, -2.0],\n    [-1.0, f, -2.0],\n    [-1.0, -2.0, f],\n  ]),\n  4: sparseF32Range().flatMap(f => [\n    [f, 1.0, 2.0, 3.0],\n    [1.0, f, 2.0, 3.0],\n    [1.0, 2.0, f, 3.0],\n    [1.0, 2.0, 3.0, f],\n    [f, -1.0, -2.0, -3.0],\n    [-1.0, f, -2.0, -3.0],\n    [-1.0, -2.0, f, -3.0],\n    [-1.0, -2.0, -3.0, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting float\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting float values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting f32 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorF32Range(dim: number): number[][] {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorF32Range only accepts dimensions 2, 3, and 4');\n  return kVectorF32Values[dim];\n}\n\nconst kSparseVectorF32Values = {\n  2: sparseF32Range().map((f, idx) => [idx % 2 === 0 ? f : idx, idx % 2 === 1 ? f : -idx]),\n  3: sparseF32Range().map((f, idx) => [\n    idx % 3 === 0 ? f : idx,\n    idx % 3 === 1 ? f : -idx,\n    idx % 3 === 2 ? f : idx,\n  ]),\n  4: sparseF32Range().map((f, idx) => [\n    idx % 4 === 0 ? f : idx,\n    idx % 4 === 1 ? f : -idx,\n    idx % 4 === 2 ? f : idx,\n    idx % 4 === 3 ? f : -idx,\n  ]),\n};\n\n/**\n * Minimal set of vectors, indexed by dimension, that contain interesting float\n * values.\n *\n * This is an even more stripped down version of `vectorF32Range` for when\n * pairs of vectors are being tested.\n * All of the interesting floats from sparseF32 are guaranteed to be tested, but\n * not in every position.\n */\nexport function sparseVectorF32Range(dim: number): number[][] {\n  assert(\n    dim === 2 || dim === 3 || dim === 4,\n    'sparseVectorF32Range only accepts dimensions 2, 3, and 4'\n  );\n  return kSparseVectorF32Values[dim];\n}\n\nconst kSparseMatrixF32Values = {\n  2: {\n    2: kInterestingF32Values.map((f, idx) => [\n      [idx % 4 === 0 ? f : idx, idx % 4 === 1 ? f : -idx],\n      [idx % 4 === 2 ? f : -idx, idx % 4 === 3 ? f : idx],\n    ]),\n    3: kInterestingF32Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx, idx % 6 === 2 ? f : idx],\n      [idx % 6 === 3 ? f : -idx, idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    4: kInterestingF32Values.map((f, idx) => [\n      [\n        idx % 8 === 0 ? f : idx,\n        idx % 8 === 1 ? f : -idx,\n        idx % 8 === 2 ? f : idx,\n        idx % 8 === 3 ? f : -idx,\n      ],\n      [\n        idx % 8 === 4 ? f : -idx,\n        idx % 8 === 5 ? f : idx,\n        idx % 8 === 6 ? f : -idx,\n        idx % 8 === 7 ? f : idx,\n      ],\n    ]),\n  },\n  3: {\n    2: kInterestingF32Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx],\n      [idx % 6 === 2 ? f : -idx, idx % 6 === 3 ? f : idx],\n      [idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    3: kInterestingF32Values.map((f, idx) => [\n      [idx % 9 === 0 ? f : idx, idx % 9 === 1 ? f : -idx, idx % 9 === 2 ? f : idx],\n      [idx % 9 === 3 ? f : -idx, idx % 9 === 4 ? f : idx, idx % 9 === 5 ? f : -idx],\n      [idx % 9 === 6 ? f : idx, idx % 9 === 7 ? f : -idx, idx % 9 === 8 ? f : idx],\n    ]),\n    4: kInterestingF32Values.map((f, idx) => [\n      [\n        idx % 12 === 0 ? f : idx,\n        idx % 12 === 1 ? f : -idx,\n        idx % 12 === 2 ? f : idx,\n        idx % 12 === 3 ? f : -idx,\n      ],\n      [\n        idx % 12 === 4 ? f : -idx,\n        idx % 12 === 5 ? f : idx,\n        idx % 12 === 6 ? f : -idx,\n        idx % 12 === 7 ? f : idx,\n      ],\n      [\n        idx % 12 === 8 ? f : idx,\n        idx % 12 === 9 ? f : -idx,\n        idx % 12 === 10 ? f : idx,\n        idx % 12 === 11 ? f : -idx,\n      ],\n    ]),\n  },\n  4: {\n    2: kInterestingF32Values.map((f, idx) => [\n      [idx % 8 === 0 ? f : idx, idx % 8 === 1 ? f : -idx],\n      [idx % 8 === 2 ? f : -idx, idx % 8 === 3 ? f : idx],\n      [idx % 8 === 4 ? f : idx, idx % 8 === 5 ? f : -idx],\n      [idx % 8 === 6 ? f : -idx, idx % 8 === 7 ? f : idx],\n    ]),\n    3: kInterestingF32Values.map((f, idx) => [\n      [idx % 12 === 0 ? f : idx, idx % 12 === 1 ? f : -idx, idx % 12 === 2 ? f : idx],\n      [idx % 12 === 3 ? f : -idx, idx % 12 === 4 ? f : idx, idx % 12 === 5 ? f : -idx],\n      [idx % 12 === 6 ? f : idx, idx % 12 === 7 ? f : -idx, idx % 12 === 8 ? f : idx],\n      [idx % 12 === 9 ? f : -idx, idx % 12 === 10 ? f : idx, idx % 12 === 11 ? f : -idx],\n    ]),\n    4: kInterestingF32Values.map((f, idx) => [\n      [\n        idx % 16 === 0 ? f : idx,\n        idx % 16 === 1 ? f : -idx,\n        idx % 16 === 2 ? f : idx,\n        idx % 16 === 3 ? f : -idx,\n      ],\n      [\n        idx % 16 === 4 ? f : -idx,\n        idx % 16 === 5 ? f : idx,\n        idx % 16 === 6 ? f : -idx,\n        idx % 16 === 7 ? f : idx,\n      ],\n      [\n        idx % 16 === 8 ? f : idx,\n        idx % 16 === 9 ? f : -idx,\n        idx % 16 === 10 ? f : idx,\n        idx % 16 === 11 ? f : -idx,\n      ],\n      [\n        idx % 16 === 12 ? f : -idx,\n        idx % 16 === 13 ? f : idx,\n        idx % 16 === 14 ? f : -idx,\n        idx % 16 === 15 ? f : idx,\n      ],\n    ]),\n  },\n};\n\n/**\n * Returns a minimal set of matrices, indexed by dimension containing interesting\n * float values.\n *\n * This is the matrix analogue of `sparseVectorF32Range`, so it is producing a\n * minimal coverage set of matrices that test all of the interesting f32 values.\n * There is not a more expansive set of matrices, since matrices are even more\n * expensive than vectors for increasing runtime with coverage.\n *\n * All of the interesting floats from sparseF32 are guaranteed to be tested, but\n * not in every position.\n */\nexport function sparseMatrixF32Range(c: number, r: number): number[][][] {\n  assert(\n    c === 2 || c === 3 || c === 4,\n    'sparseMatrixF32Range only accepts column counts of 2, 3, and 4'\n  );\n  assert(\n    r === 2 || r === 3 || r === 4,\n    'sparseMatrixF32Range only accepts row counts of 2, 3, and 4'\n  );\n  return kSparseMatrixF32Values[c][r];\n}\n\n/**\n * @returns the result matrix in Array<Array<number>> type.\n *\n * Matrix multiplication. A is m x n and B is n x p. Returns\n * m x p result.\n */\n// A is m x n. B is n x p. product is m x p.\nexport function multiplyMatrices(\n  A: Array<Array<number>>,\n  B: Array<Array<number>>\n): Array<Array<number>> {\n  assert(A.length > 0 && B.length > 0 && B[0].length > 0 && A[0].length === B.length);\n  const product = new Array<Array<number>>(A.length);\n  for (let i = 0; i < product.length; ++i) {\n    product[i] = new Array<number>(B[0].length).fill(0);\n  }\n\n  for (let m = 0; m < A.length; ++m) {\n    for (let p = 0; p < B[0].length; ++p) {\n      for (let n = 0; n < B.length; ++n) {\n        product[m][p] += A[m][n] * B[n][p];\n      }\n    }\n  }\n\n  return product;\n}\n\n/** Sign-extend the `bits`-bit number `n` to a 32-bit signed integer. */\nexport function signExtend(n: number, bits: number): number {\n  const shift = 32 - bits;\n  return (n << shift) >> shift;\n}\n\nexport interface QuantizeFunc {\n  (num: number): number;\n}\n\n/** @returns the closest 32-bit floating point value to the input */\nexport function quantizeToF32(num: number): number {\n  return f32(num).value as number;\n}\n\n/** @returns the closest 32-bit signed integer value to the input */\nexport function quantizeToI32(num: number): number {\n  return i32(num).value as number;\n}\n\n/** @returns the closest 32-bit signed integer value to the input */\nexport function quantizeToU32(num: number): number {\n  return u32(num).value as number;\n}\n\n/** @returns whether the number is an integer and a power of two */\nexport function isPowerOfTwo(n: number): boolean {\n  if (!Number.isInteger(n)) {\n    return false;\n  }\n  return n !== 0 && (n & (n - 1)) === 0;\n}\n\n/** @returns the Greatest Common Divisor (GCD) of the inputs */\nexport function gcd(a: number, b: number): number {\n  assert(Number.isInteger(a) && a > 0);\n  assert(Number.isInteger(b) && b > 0);\n\n  while (b !== 0) {\n    const bTemp = b;\n    b = a % b;\n    a = bTemp;\n  }\n\n  return a;\n}\n\n/** @returns the Least Common Multiplier (LCM) of the inputs */\nexport function lcm(a: number, b: number): number {\n  return (a * b) / gcd(a, b);\n}\n\n/** Converts a 32-bit hex value to a 32-bit float value */\nexport function hexToF32(hex: number): number {\n  return floatBitsToNumber(hex, kFloat32Format);\n}\n\n/** Converts a 16-bit hex value to a 16-bit float value */\nexport function hexToF16(hex: number): number {\n  return floatBitsToNumber(hex, kFloat16Format);\n}\n\n/** Converts 64-bit hex value to a 64-bit float value */\nexport function hexToF64(hex: bigint): number {\n  return new Float64Array(new BigInt64Array([hex]).buffer)[0];\n}\n\n/** @returns the cross of an array with the intermediate result of cartesianProduct\n *\n * @param elements array of values to cross with the intermediate result of\n *                 cartesianProduct\n * @param intermediate arrays of values representing the partial result of\n *                     cartesianProduct\n */\nfunction cartesianProductImpl<T>(elements: T[], intermediate: T[][]): T[][] {\n  const result: T[][] = [];\n  elements.forEach((e: T) => {\n    if (intermediate.length > 0) {\n      intermediate.forEach((i: T[]) => {\n        result.push([...i, e]);\n      });\n    } else {\n      result.push([e]);\n    }\n  });\n  return result;\n}\n\n/** @returns the cartesian product (NxMx...) of a set of arrays\n *\n * This is implemented by calculating the cross of a single input against an\n * intermediate result for each input to build up the final array of arrays.\n *\n * There are examples of doing this more succinctly using map & reduce online,\n * but they are a bit more opaque to read.\n *\n * @param inputs arrays of numbers to calculate cartesian product over\n */\nexport function cartesianProduct<T>(...inputs: T[][]): T[][] {\n  let result: T[][] = [];\n  inputs.forEach((i: T[]) => {\n    result = cartesianProductImpl<T>(i, result);\n  });\n\n  return result;\n}\n\n/** @returns all of the permutations of an array\n *\n * Recursively calculates all of the permutations, does not cull duplicate\n * entries.\n *\n * Only feasible for inputs of lengths 5 or so, since the number of permutations\n * is (input.length)!, so will cause the stack to explode for longer inputs.\n *\n * This code could be made iterative using something like\n * Steinhaus–Johnson–Trotter and additionally turned into a generator to reduce\n * the stack size, but there is still a fundamental combinatorial explosion\n * here that will affect runtime.\n *\n * @param input the array to get permutations of\n */\nexport function calculatePermutations<T>(input: T[]): T[][] {\n  if (input.length === 0) {\n    return [];\n  }\n\n  if (input.length === 1) {\n    return [input];\n  }\n\n  if (input.length === 2) {\n    return [input, [input[1], input[0]]];\n  }\n\n  const result: T[][] = [];\n  input.forEach((head, idx) => {\n    const tail = input.slice(0, idx).concat(input.slice(idx + 1));\n    const permutations = calculatePermutations(tail);\n    permutations.forEach(p => {\n      result.push([head, ...p]);\n    });\n  });\n\n  return result;\n}\n\n/**\n * Convert an Array of Arrays to linear array\n *\n * Caller is responsible to retaining the dimensions of the array for later\n * unflattening\n *\n * @param m Matrix to convert\n */\nexport function flatten2DArray<T>(m: T[][]): T[] {\n  const c = m.length;\n  const r = m[0].length;\n  assert(\n    m.every(c => c.length === r),\n    `Unexpectedly received jagged array to flatten`\n  );\n  const result: T[] = Array<T>(c * r);\n  for (let i = 0; i < c; i++) {\n    for (let j = 0; j < r; j++) {\n      result[j + i * r] = m[i][j];\n    }\n  }\n  return result;\n}\n\n/**\n * Convert linear array to an Array of Arrays\n * @param n an array to convert\n * @param c number of elements in the array containing arrays\n * @param r number of elements in the arrays that are contained\n */\nexport function unflatten2DArray<T>(n: T[], c: number, r: number): T[][] {\n  assert(\n    c > 0 && Number.isInteger(c) && r > 0 && Number.isInteger(r),\n    `columns (${c}) and rows (${r}) need to be positive integers`\n  );\n  assert(n.length === c * r, `m.length(${n.length}) should equal c * r (${c * r})`);\n  const result: T[][] = [...Array(c)].map(_ => [...Array(r)]);\n  for (let i = 0; i < c; i++) {\n    for (let j = 0; j < r; j++) {\n      result[i][j] = n[j + i * r];\n    }\n  }\n  return result;\n}\n\n/**\n * Performs a .map over a matrix and return the result\n * The shape of the input and output matrices will be the same\n *\n * @param m input matrix of type T\n * @param op operation that converts an element of type T to one of type S\n * @returns a matrix with elements of type S that are calculated by applying op element by element\n */\nexport function map2DArray<T, S>(m: T[][], op: (input: T) => S): S[][] {\n  const c = m.length;\n  const r = m[0].length;\n  assert(\n    m.every(c => c.length === r),\n    `Unexpectedly received jagged array to map`\n  );\n  const result: S[][] = [...Array(c)].map(_ => [...Array(r)]);\n  for (let i = 0; i < c; i++) {\n    for (let j = 0; j < r; j++) {\n      result[i][j] = op(m[i][j]);\n    }\n  }\n  return result;\n}\n"],"mappings":"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"}