{"version":3,"file":"texture.js","names":["assert","kTextureFormatInfo","align","reifyExtent3D","makeTextureWithContents","device","texelView","desc","width","height","depthOrArrayLayers","size","bytesPerBlock","blockWidth","format","bytesPerRow","stagingBuffer","createBuffer","mappedAtCreation","usage","GPUBufferUsage","COPY_SRC","writeTextureData","Uint8Array","getMappedRange","rowsPerImage","subrectOrigin","subrectSize","unmap","texture","createTexture","GPUTextureUsage","COPY_DST","commandEncoder","createCommandEncoder","copyBufferToTexture","buffer","queue","submit","finish","destroy"],"sources":["../../../src/webgpu/util/texture.ts"],"sourcesContent":["import { assert } from '../../common/util/util.js';\nimport { kTextureFormatInfo } from '../capability_info.js';\n\nimport { align } from './math.js';\nimport { TexelView } from './texture/texel_view.js';\nimport { reifyExtent3D } from './unions.js';\n\n/**\n * Creates a texture with the contents of a TexelView.\n */\nexport function makeTextureWithContents(\n  device: GPUDevice,\n  texelView: TexelView,\n  desc: Omit<GPUTextureDescriptor, 'format'>\n): GPUTexture {\n  const { width, height, depthOrArrayLayers } = reifyExtent3D(desc.size);\n\n  const { bytesPerBlock, blockWidth } = kTextureFormatInfo[texelView.format];\n  // Currently unimplemented for compressed textures.\n  assert(blockWidth === 1);\n\n  // Compute bytes per row.\n  const bytesPerRow = align(bytesPerBlock * width, 256);\n\n  // Create a staging buffer to upload the texture contents.\n  const stagingBuffer = device.createBuffer({\n    mappedAtCreation: true,\n    size: bytesPerRow * height * depthOrArrayLayers,\n    usage: GPUBufferUsage.COPY_SRC,\n  });\n\n  // Write the texels into the staging buffer.\n  texelView.writeTextureData(new Uint8Array(stagingBuffer.getMappedRange()), {\n    bytesPerRow,\n    rowsPerImage: height,\n    subrectOrigin: [0, 0, 0],\n    subrectSize: [width, height, depthOrArrayLayers],\n  });\n  stagingBuffer.unmap();\n\n  // Create the texture.\n  const texture = device.createTexture({\n    ...desc,\n    format: texelView.format,\n    usage: desc.usage | GPUTextureUsage.COPY_DST,\n  });\n\n  // Copy from the staging buffer into the texture.\n  const commandEncoder = device.createCommandEncoder();\n  commandEncoder.copyBufferToTexture(\n    { buffer: stagingBuffer, bytesPerRow },\n    { texture },\n    desc.size\n  );\n  device.queue.submit([commandEncoder.finish()]);\n\n  // Clean up the staging buffer.\n  stagingBuffer.destroy();\n\n  return texture;\n}\n"],"mappings":";AAAA;AAAA,GAAA,SAASA,MAAM,QAAQ,2BAA2B,CAClD,SAASC,kBAAkB,QAAQ,uBAAuB;AAE1D,SAASC,KAAK,QAAQ,WAAW;;AAEjC,SAASC,aAAa,QAAQ,aAAa;;AAE3C;AACA;AACA;AACA,OAAO,SAASC,uBAAuB;AACrCC,MAAiB;AACjBC,SAAoB;AACpBC,IAA0C;AAC9B;EACZ,MAAM,EAAEC,KAAK,EAAEC,MAAM,EAAEC,kBAAkB,CAAC,CAAC,GAAGP,aAAa,CAACI,IAAI,CAACI,IAAI,CAAC;;EAEtE,MAAM,EAAEC,aAAa,EAAEC,UAAU,CAAC,CAAC,GAAGZ,kBAAkB,CAACK,SAAS,CAACQ,MAAM,CAAC;EAC1E;EACAd,MAAM,CAACa,UAAU,KAAK,CAAC,CAAC;;EAExB;EACA,MAAME,WAAW,GAAGb,KAAK,CAACU,aAAa,GAAGJ,KAAK,EAAE,GAAG,CAAC;;EAErD;EACA,MAAMQ,aAAa,GAAGX,MAAM,CAACY,YAAY,CAAC;IACxCC,gBAAgB,EAAE,IAAI;IACtBP,IAAI,EAAEI,WAAW,GAAGN,MAAM,GAAGC,kBAAkB;IAC/CS,KAAK,EAAEC,cAAc,CAACC;EACxB,CAAC,CAAC;;EAEF;EACAf,SAAS,CAACgB,gBAAgB,CAAC,IAAIC,UAAU,CAACP,aAAa,CAACQ,cAAc,EAAE,CAAC,EAAE;IACzET,WAAW;IACXU,YAAY,EAAEhB,MAAM;IACpBiB,aAAa,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACxBC,WAAW,EAAE,CAACnB,KAAK,EAAEC,MAAM,EAAEC,kBAAkB;EACjD,CAAC,CAAC;EACFM,aAAa,CAACY,KAAK,EAAE;;EAErB;EACA,MAAMC,OAAO,GAAGxB,MAAM,CAACyB,aAAa,CAAC;IACnC,GAAGvB,IAAI;IACPO,MAAM,EAAER,SAAS,CAACQ,MAAM;IACxBK,KAAK,EAAEZ,IAAI,CAACY,KAAK,GAAGY,eAAe,CAACC;EACtC,CAAC,CAAC;;EAEF;EACA,MAAMC,cAAc,GAAG5B,MAAM,CAAC6B,oBAAoB,EAAE;EACpDD,cAAc,CAACE,mBAAmB;EAChC,EAAEC,MAAM,EAAEpB,aAAa,EAAED,WAAW,CAAC,CAAC;EACtC,EAAEc,OAAO,CAAC,CAAC;EACXtB,IAAI,CAACI,IAAI,CACV;;EACDN,MAAM,CAACgC,KAAK,CAACC,MAAM,CAAC,CAACL,cAAc,CAACM,MAAM,EAAE,CAAC,CAAC;;EAE9C;EACAvB,aAAa,CAACwB,OAAO,EAAE;;EAEvB,OAAOX,OAAO;AAChB"}