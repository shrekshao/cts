{"version":3,"sources":["../../../src/webgpu/util/compare.ts"],"names":["Colors","f32","isFloatValue","Scalar","Vector","correctlyRounded","oneULP","withinULP","absMatch","diff","got","expected","Number","isFinite","Math","abs","ulpMatch","ulp","correctlyRoundedMatch","compare","cmpFloats","gTy","type","eTy","bothFloatTypes","matched","red","toString","g","e","isFloat","kind","value","green","gLen","elements","length","eLen","gElements","Array","eElements","i","max","cmp","join","Error","anyOf","expectations","failed","Set","undefined","v","c","add","ulpComparator","x","target","n","match","_"],"mappings":"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","sourcesContent":["import { Colors } from '../../common/util/colors.js';\n\nimport { f32, isFloatValue, Scalar, Value, Vector } from './conversion.js';\nimport { correctlyRounded, oneULP, withinULP } from './math.js';\n\n/** Comparison describes the result of a Comparator function. */\nexport interface Comparison {\n  matched: boolean; // True if the two values were considered a match\n  got: string; // The string representation of the 'got' value (possibly with markup)\n  expected: string; // The string representation of the 'expected' value (possibly with markup)\n}\n\n/** FloatMatch is a function that compares whether the two floating point numbers match. */\nexport interface FloatMatch {\n  (got: number, expected: number): boolean;\n}\n\n/** Comparator is a function that compares whether the provided value matches an expectation. */\nexport interface Comparator {\n  (got: Value, cmpFloats: FloatMatch): Comparison;\n}\n\n/**\n * @returns a FloatMatch that returns true iff the two numbers are equal to, or\n * less than the specified absolute error threshold.\n */\nexport function absMatch(diff: number): FloatMatch {\n  return (got, expected) => {\n    if (got === expected) {\n      return true;\n    }\n    if (!Number.isFinite(got) || !Number.isFinite(expected)) {\n      return false;\n    }\n    return Math.abs(got - expected) <= diff;\n  };\n}\n\n/**\n * @returns a FloatMatch that returns true iff the two numbers are within or\n * equal to the specified ULP threshold value.\n */\nexport function ulpMatch(ulp: number): FloatMatch {\n  return (got, expected) => {\n    if (got === expected) {\n      return true;\n    }\n    return withinULP(got, expected, ulp);\n  };\n}\n\n/**\n * @returns a FloatMatch that returns true iff |expected| is a correctly round\n * to |got|.\n * |got| must be expressible as a float32.\n */\nexport function correctlyRoundedMatch(): FloatMatch {\n  return (got, expected) => {\n    return correctlyRounded(f32(got), expected);\n  };\n}\n\n/**\n * compare() compares 'got' to 'expected', returning the Comparison information.\n * @param got the value obtained from the test\n * @param expected the expected value\n * @param cmpFloats the FloatMatch used to compare floating point values\n * @returns the comparison results\n */\nexport function compare(got: Value, expected: Value, cmpFloats: FloatMatch): Comparison {\n  {\n    // Check types\n    const gTy = got.type;\n    const eTy = expected.type;\n    const bothFloatTypes = isFloatValue(got) && isFloatValue(expected);\n    if (gTy !== eTy && !bothFloatTypes) {\n      return {\n        matched: false,\n        got: `${Colors.red(gTy.toString())}(${got})`,\n        expected: `${Colors.red(eTy.toString())}(${expected})`,\n      };\n    }\n  }\n\n  if (got instanceof Scalar) {\n    const g = got;\n    const e = expected as Scalar;\n    const isFloat = g.type.kind === 'f64' || g.type.kind === 'f32' || g.type.kind === 'f16';\n    const matched =\n      (isFloat && cmpFloats(g.value as number, e.value as number)) ||\n      (!isFloat && g.value === e.value);\n    return {\n      matched,\n      got: g.toString(),\n      expected: matched ? Colors.green(e.toString()) : Colors.red(e.toString()),\n    };\n  }\n  if (got instanceof Vector) {\n    const gLen = got.elements.length;\n    const eLen = (expected as Vector).elements.length;\n    let matched = gLen === eLen;\n    const gElements = new Array<string>(gLen);\n    const eElements = new Array<string>(eLen);\n    for (let i = 0; i < Math.max(gLen, eLen); i++) {\n      if (i < gLen && i < eLen) {\n        const g = got.elements[i];\n        const e = (expected as Vector).elements[i];\n        const cmp = compare(g, e, cmpFloats);\n        matched = matched && cmp.matched;\n        gElements[i] = cmp.got;\n        eElements[i] = cmp.expected;\n        continue;\n      }\n      matched = false;\n      if (i < gLen) {\n        gElements[i] = got.elements[i].toString();\n      }\n      if (i < eLen) {\n        eElements[i] = (expected as Vector).elements[i].toString();\n      }\n    }\n    return {\n      matched,\n      got: `${got.type}(${gElements.join(', ')})`,\n      expected: `${expected.type}(${eElements.join(', ')})`,\n    };\n  }\n  throw new Error(`unhandled type '${typeof got}`);\n}\n\n/** @returns a Comparator that checks whether a test value matches any of the provided options */\nexport function anyOf(...expectations: (Value | Comparator)[]): Comparator {\n  return (got, cmpFloats) => {\n    const failed = new Set<string>();\n    for (const e of expectations) {\n      let cmp: Comparison;\n      if ((e as Value).type !== undefined) {\n        const v = e as Value;\n        cmp = compare(got, v, cmpFloats);\n      } else {\n        const c = e as Comparator;\n        cmp = c(got, cmpFloats);\n      }\n      if (cmp.matched) {\n        return cmp;\n      }\n      failed.add(cmp.expected);\n    }\n    return { matched: false, got: got.toString(), expected: [...failed].join(' or ') };\n  };\n}\n\n/** @returns a Comparator that checks whether a result is within N * ULP of a target value, where N is defined by a function\n *\n * N is n(x), where x is the input into the function under test, not the result of the function.\n * For a function f(x) = X that is being tested, the acceptance interval is defined as within X +/- n(x) * ulp(X).\n */\nexport function ulpComparator(x: number, target: Scalar, n: (x: number) => number): Comparator {\n  const c = n(x);\n  const match = ulpMatch(c);\n  return (got, _) => {\n    const cmp = compare(got, target, match);\n    if (cmp.matched) {\n      return cmp;\n    }\n    const ulp = Math.max(\n      oneULP(target.value as number, true),\n      oneULP(target.value as number, false)\n    );\n    return {\n      matched: false,\n      got: got.toString(),\n      expected: `within ${c} * ULP (${ulp}) of ${target}`,\n    };\n  };\n}\n"],"file":"compare.js"}