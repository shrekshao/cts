{"version":3,"sources":["../../../src/webgpu/util/command_buffer_maker.ts"],"names":["kRenderEncodeTypes","kProgrammableEncoderTypes","kEncoderTypes","CommandBufferMaker","constructor","t","encoder","finish","validateFinish","shouldSucceed","expectGPUError","validateFinishAndSubmit","shouldBeValid","submitShouldSucceedIfValid","commandBuffer","expectValidationError","queue","submit","validateFinishAndSubmitGivenState","resourceState"],"mappings":";AAAA;AACA,GACA,OAAO,MAAMA,kBAAkB,GAAG,CAAC,aAAD,EAAgB,eAAhB,CAA3B;;AAEP,OAAO,MAAMC,yBAAyB,GAAG,CAAC,cAAD,EAAiB,GAAGD,kBAApB,CAAlC;;AAEP,OAAO,MAAME,aAAa,GAAG,CAAC,UAAD,EAAa,GAAGD,yBAAhB,CAAtB;;;;;;;;;;;AAWP;AACA;AACA,OAAO,MAAME,kBAAN,CAAgD;AACrD;AACA;;;AAGA;AACF;AACA;AACA;;;AAGE;AACF;AACA;AACA;;;AAGE;AACF;AACA;AACA;;;;;;AAME;AACF;AACA;AACA;AACA;;;AAGEC,EAAAA,WAAW;AACTC,EAAAA,CADS;AAETC,EAAAA,OAFS;AAGTC,EAAAA,MAHS;AAIT;AACA;AACA,SAAKD,OAAL,GAAeA,OAAf;AACA,SAAKC,MAAL,GAAcA,MAAd;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAKC,cAAL,GAAsB,CAACC,aAAD,KAA4B;AAChD,aAAOJ,CAAC,CAACK,cAAF,CAAiB,YAAjB,EAA+B,KAAKH,MAApC,EAA4C,CAACE,aAA7C,CAAP;AACD,KAFD;;AAIA,SAAKE,uBAAL,GAA+B;AAC7BC,IAAAA,aAD6B;AAE7BC,IAAAA,0BAF6B;AAG1B;AACH,YAAMC,aAAa,GAAG,KAAKN,cAAL,CAAoBI,aAApB,CAAtB;AACA,UAAIA,aAAJ,EAAmB;AACjBP,QAAAA,CAAC,CAACU,qBAAF,CAAwB,MAAMV,CAAC,CAACW,KAAF,CAAQC,MAAR,CAAe,CAACH,aAAD,CAAf,CAA9B,EAA+D,CAACD,0BAAhE;AACD;AACF,KARD;;AAUA,SAAKK,iCAAL,GAAyC,CAACC,aAAD,KAAkC;AACzE,WAAKR,uBAAL,CAA6BQ,aAAa,KAAK,SAA/C,EAA0DA,aAAa,KAAK,WAA5E;AACD,KAFD;AAGD,GAhEoD","sourcesContent":["import { ResourceState, GPUTest } from '../gpu_test.js';\n\nexport const kRenderEncodeTypes = ['render pass', 'render bundle'] as const;\nexport type RenderEncodeType = typeof kRenderEncodeTypes[number];\nexport const kProgrammableEncoderTypes = ['compute pass', ...kRenderEncodeTypes] as const;\nexport type ProgrammableEncoderType = typeof kProgrammableEncoderTypes[number];\nexport const kEncoderTypes = ['non-pass', ...kProgrammableEncoderTypes] as const;\nexport type EncoderType = typeof kEncoderTypes[number];\n\n// Look up the type of the encoder based on `T`. If `T` is a union, this will be too!\ntype EncoderByEncoderType<T extends EncoderType> = {\n  'non-pass': GPUCommandEncoder;\n  'compute pass': GPUComputePassEncoder;\n  'render pass': GPURenderPassEncoder;\n  'render bundle': GPURenderBundleEncoder;\n}[T];\n\n/** See {@link webgpu/api/validation/validation_test.ValidationTest.createEncoder |\n * GPUTest.createEncoder()}. */\nexport class CommandBufferMaker<T extends EncoderType> {\n  /** `GPU___Encoder` for recording commands into. */\n  // Look up the type of the encoder based on `T`. If `T` is a union, this will be too!\n  readonly encoder: EncoderByEncoderType<T>;\n\n  /**\n   * Finish any passes, finish and record any bundles, and finish/return the command buffer. Any\n   * errors are ignored and the GPUCommandBuffer (which may be an error buffer) is returned.\n   */\n  readonly finish: () => GPUCommandBuffer;\n\n  /**\n   * Finish any passes, finish and record any bundles, and finish/return the command buffer.\n   * Checks for validation errors in (only) the appropriate finish call.\n   */\n  readonly validateFinish: (shouldSucceed: boolean) => GPUCommandBuffer;\n\n  /**\n   * Finish the command buffer and submit it. Checks for validation errors in either the submit or\n   * the appropriate finish call, depending on the state of a resource used in the encoding.\n   */\n  readonly validateFinishAndSubmit: (\n    shouldBeValid: boolean,\n    submitShouldSucceedIfValid: boolean\n  ) => void;\n\n  /**\n   * `validateFinishAndSubmit()` based on the state of a resource in the command encoder.\n   * - `finish()` should fail if the resource is 'invalid'.\n   * - Only `submit()` should fail if the resource is 'destroyed'.\n   */\n  readonly validateFinishAndSubmitGivenState: (resourceState: ResourceState) => void;\n\n  constructor(\n    t: GPUTest,\n    encoder: EncoderByEncoderType<EncoderType>,\n    finish: () => GPUCommandBuffer\n  ) {\n    // TypeScript introduces an intersection type here where we don't want one.\n    this.encoder = encoder as EncoderByEncoderType<T>;\n    this.finish = finish;\n\n    // Define extra methods like this, otherwise they get unbound when destructured, e.g.:\n    //   const { encoder, validateFinishAndSubmit } = t.createEncoder(type);\n    // Alternatively, do not destructure, and call member functions, e.g.:\n    //   const encoder = t.createEncoder(type);\n    //   encoder.validateFinish(true);\n    this.validateFinish = (shouldSucceed: boolean) => {\n      return t.expectGPUError('validation', this.finish, !shouldSucceed);\n    };\n\n    this.validateFinishAndSubmit = (\n      shouldBeValid: boolean,\n      submitShouldSucceedIfValid: boolean\n    ) => {\n      const commandBuffer = this.validateFinish(shouldBeValid);\n      if (shouldBeValid) {\n        t.expectValidationError(() => t.queue.submit([commandBuffer]), !submitShouldSucceedIfValid);\n      }\n    };\n\n    this.validateFinishAndSubmitGivenState = (resourceState: ResourceState) => {\n      this.validateFinishAndSubmit(resourceState !== 'invalid', resourceState !== 'destroyed');\n    };\n  }\n}\n"],"file":"command_buffer_maker.js"}