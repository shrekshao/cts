{"version":3,"sources":["../../../src/webgpu/util/shader.ts"],"names":["unreachable","kPlainTypeInfo","i32","suffix","fractionDigits","u32","f32","getPlainTypeInfo","sampleType","getFragmentShaderCodeWithOutput","outputs","length","resultStrings","outputStructString","i","o","plainType","outputType","v","values","map","n","toFixed","componentCount","push","join"],"mappings":"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","sourcesContent":["import { unreachable } from '../../common/util/util.js';\n\nconst kPlainTypeInfo = {\n  i32: {\n    suffix: '',\n    fractionDigits: 0,\n  },\n  u32: {\n    suffix: 'u',\n    fractionDigits: 0,\n  },\n  f32: {\n    suffix: '',\n    fractionDigits: 4,\n  },\n};\n\n/**\n *\n * @param sampleType sampleType of texture format\n * @returns plain type compatible of the sampleType\n */\nexport function getPlainTypeInfo(sampleType: GPUTextureSampleType): keyof typeof kPlainTypeInfo {\n  switch (sampleType) {\n    case 'sint':\n      return 'i32';\n    case 'uint':\n      return 'u32';\n    case 'float':\n    case 'unfilterable-float':\n    case 'depth':\n      return 'f32';\n    default:\n      unreachable();\n  }\n}\n\n/**\n * Build a fragment shader based on output value and types\n * e.g. write to color target 0 a vec4<f32>(1.0, 0.0, 1.0, 1.0) and color target 2 a vec2<u32>(1, 2)\n * outputs: [\n *   {\n *     values: [1, 0, 1, 1],,\n *     plainType: 'f32',\n *     componentCount: 4,\n *   },\n *   null,\n *   {\n *     values: [1, 2],\n *     plainType: 'u32',\n *     componentCount: 2,\n *   },\n * ]\n *\n * return:\n * struct Outputs {\n *     @location(0) o1 : vec4<f32>;\n *     @location(2) o3 : vec2<u32>;\n * }\n * @stage(fragment) fn main() -> Outputs {\n *     return Outputs(vec4<f32>(1.0, 0.0, 1.0, 1.0), vec4<u32>(1, 2));\n * }\n * @param outputs the shader outputs for each location attribute\n * @returns the fragment shader string\n */\nexport function getFragmentShaderCodeWithOutput(\n  outputs: ({\n    values: readonly number[];\n    plainType: 'i32' | 'u32' | 'f32';\n    componentCount: number;\n  } | null)[]\n): string {\n  if (outputs.length === 0) {\n    return `\n        @stage(fragment) fn main() {\n        }`;\n  }\n\n  const resultStrings = [] as string[];\n  let outputStructString = '';\n\n  for (let i = 0; i < outputs.length; i++) {\n    const o = outputs[i];\n    if (o === null) {\n      continue;\n    }\n\n    const plainType = o.plainType;\n    const { suffix, fractionDigits } = kPlainTypeInfo[plainType];\n\n    let outputType;\n    const v = o.values.map(n => n.toFixed(fractionDigits));\n    switch (o.componentCount) {\n      case 1:\n        outputType = plainType;\n        resultStrings.push(`${v[0]}${suffix}`);\n        break;\n      case 2:\n        outputType = `vec2<${plainType}>`;\n        resultStrings.push(`${outputType}(${v[0]}${suffix}, ${v[1]}${suffix})`);\n        break;\n      case 3:\n        outputType = `vec3<${plainType}>`;\n        resultStrings.push(`${outputType}(${v[0]}${suffix}, ${v[1]}${suffix}, ${v[2]}${suffix})`);\n        break;\n      case 4:\n        outputType = `vec4<${plainType}>`;\n        resultStrings.push(\n          `${outputType}(${v[0]}${suffix}, ${v[1]}${suffix}, ${v[2]}${suffix}, ${v[3]}${suffix})`\n        );\n        break;\n      default:\n        unreachable();\n    }\n\n    outputStructString += `@location(${i}) o${i} : ${outputType},\\n`;\n  }\n\n  return `\n    struct Outputs {\n      ${outputStructString}\n    }\n\n    @stage(fragment) fn main() -> Outputs {\n        return Outputs(${resultStrings.join(',')});\n    }`;\n}\n"],"file":"shader.js"}