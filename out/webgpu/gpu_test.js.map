{"version":3,"sources":["../../src/webgpu/gpu_test.ts"],"names":["Fixture","attemptGarbageCollection","assert","range","unreachable","kTextureFormatInfo","kQueryTypeInfo","resolvePerAspectFormat","makeBufferWithContents","checkElementsEqual","checkElementsBetween","checkElementsFloat16Between","CommandBufferMaker","DevicePool","TestOOMedShouldAttemptGC","align","roundDown","makeTextureWithContents","getTextureCopyLayout","getTextureSubCopyLayout","kTexelRepresentationInfo","devicePool","mismatchedDevicePool","kResourceStateValues","kResourceStates","initUncanonicalizedDeviceDescriptor","descriptor","requiredFeatures","Array","filter","f","undefined","GPUTest","device","provider","acquiredDevice","acquire","mismatchedDevice","mismatchedProvider","mismatchedAcquiredDevice","selectMismatchedDeviceOrSkipTestCase","reserve","queue","init","finalize","threw","thrownValue","release","ex","selectDeviceOrSkipTestCase","oldProvider","selectDeviceForTextureFormatOrSkipTestCase","formats","isArray","features","Set","format","add","feature","from","selectDeviceForQueryTypeOrSkipTestCase","types","map","t","createCopyForMapRead","src","srcOffset","size","dst","createBuffer","usage","GPUBufferUsage","MAP_READ","COPY_DST","trackForCleanup","c","createCommandEncoder","copyBufferToBuffer","submit","finish","createAlignedCopyForMapRead","offset","alignedOffset","subarrayByteStart","alignedSize","mappable","readGPUBufferRangeTyped","srcByteOffset","method","type","typedLength","BYTES_PER_ELEMENT","byteLength","mapOffset","mapSize","subarrayStart","mapAsync","GPUMapMode","READ","mapped","getMappedRange","data","subarray","cleanup","unmap","destroy","expectGPUBufferValuesPassCheck","check","mode","readbackPromise","eventualAsyncExpectation","niceStack","readback","expectOK","expectGPUBufferValuesEqual","expected","a","constructor","length","expectGPUBufferRepeatsSingleValue","buffer","expectedValue","numRows","minBytesPerRow","bytesPerRow","valueSize","kMaxBufferSizeToCheckOnCpu","bufferSize","valueBytes","Uint8Array","rowValues","fill","rowBytes","concat","expectedContents","row","set","storageBuffer","STORAGE","expectedDataSize","Math","max","expectedDataBuffer","mappedAtCreation","expectedData","Uint32Array","value","values","min","padding","expectedBytes","Uint16Array","expectedWords","resultBuffer","COPY_SRC","readsPerRow","ceil","reducer","pipeline","createComputePipeline","compute","module","createShaderModule","code","entryPoint","bindGroup","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","commandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatch","end","expectedResults","expectSingleColor","exp","dimension","slice","aspect","rowsPerImage","mipSize","rep","expectedTexelData","pack","encode","copyTextureToBuffer","texture","mipLevel","origin","x","y","z","readSinglePixelFrom2DTexture","expectSinglePixelIn2DTexture","generateWarningOnly","expectSinglePixelBetweenTwoValuesIn2DTexture","checkElementsBetweenFn","act","b","i","expectSinglePixelBetweenTwoValuesFloat16In2DTexture","expectGPUError","fn","shouldError","pushErrorScope","returnValue","promise","popErrorScope","error","failed","GPUOutOfMemoryError","GPUValidationError","message","rec","expectationFailed","debug","expectValidationError","gpuValidationError","validationFailed","expectDeviceLost","reason","dataArray","texelView","desc","createTexture2DWithMipmaps","mipmapDataArray","mipLevelCount","textureSizeMipmap0","createTexture","width","height","depthOrArrayLayers","GPUTextureUsage","TEXTURE_BINDING","textureEncoder","mipLevelData","r","o","copyBufferToTexture","createEncoder","encoderType","attachmentInfo","occlusionQuerySet","fullAttachmentInfo","colorFormats","sampleCount","encoder","rbEncoder","createRenderBundleEncoder","executeBundles","makeAttachmentView","RENDER_ATTACHMENT","createView","depthStencilAttachment","depthStencilFormat","view","depthReadOnly","stencilReadOnly","depth","depthClearValue","depthLoadOp","depthStoreOp","stencil","stencilClearValue","stencilLoadOp","stencilStoreOp","passDesc","colorAttachments","clearValue","loadOp","storeOp","beginRenderPass"],"mappings":"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","sourcesContent":["import { Fixture } from '../common/framework/fixture.js';\nimport { attemptGarbageCollection } from '../common/util/collect_garbage.js';\nimport {\n  assert,\n  range,\n  TypedArrayBufferView,\n  TypedArrayBufferViewConstructor,\n  unreachable,\n} from '../common/util/util.js';\n\nimport {\n  EncodableTextureFormat,\n  SizedTextureFormat,\n  kTextureFormatInfo,\n  kQueryTypeInfo,\n  resolvePerAspectFormat,\n} from './capability_info.js';\nimport { makeBufferWithContents } from './util/buffer.js';\nimport {\n  checkElementsEqual,\n  checkElementsBetween,\n  checkElementsFloat16Between,\n} from './util/check_contents.js';\nimport { CommandBufferMaker, EncoderType } from './util/command_buffer_maker.js';\nimport {\n  DevicePool,\n  DeviceProvider,\n  TestOOMedShouldAttemptGC,\n  UncanonicalizedDeviceDescriptor,\n} from './util/device_pool.js';\nimport { align, roundDown } from './util/math.js';\nimport { makeTextureWithContents } from './util/texture.js';\nimport {\n  getTextureCopyLayout,\n  getTextureSubCopyLayout,\n  LayoutOptions as TextureLayoutOptions,\n} from './util/texture/layout.js';\nimport { PerTexelComponent, kTexelRepresentationInfo } from './util/texture/texel_data.js';\nimport { TexelView } from './util/texture/texel_view.js';\n\nconst devicePool = new DevicePool();\n\n// MAINTENANCE_TODO: When DevicePool becomes able to provide multiple devices at once, use the\n// usual one instead of a new one.\nconst mismatchedDevicePool = new DevicePool();\n\nconst kResourceStateValues = ['valid', 'invalid', 'destroyed'] as const;\nexport type ResourceState = typeof kResourceStateValues[number];\nexport const kResourceStates: readonly ResourceState[] = kResourceStateValues;\n\nexport function initUncanonicalizedDeviceDescriptor(\n  descriptor: UncanonicalizedDeviceDescriptor | GPUFeatureName | Array<GPUFeatureName | undefined>\n): UncanonicalizedDeviceDescriptor {\n  if (typeof descriptor === 'string') {\n    return { requiredFeatures: [descriptor] };\n  } else if (descriptor instanceof Array) {\n    return {\n      requiredFeatures: descriptor.filter(f => f !== undefined) as GPUFeatureName[],\n    };\n  } else {\n    return descriptor;\n  }\n}\n\n/**\n * Base fixture for WebGPU tests.\n */\nexport class GPUTest extends Fixture {\n  private provider: DeviceProvider | undefined;\n  /** Must not be replaced once acquired. */\n  private acquiredDevice: GPUDevice | undefined;\n\n  // Some tests(e.g. Device mismatched validation) require another GPUDevice\n  // different from the default GPUDevice of GPUTest. It is only used to\n  //create device mismatched objects.\n  private mismatchedProvider: DeviceProvider | undefined;\n  private mismatchedAcquiredDevice: GPUDevice | undefined;\n\n  /** GPUDevice for the test to use. */\n  get device(): GPUDevice {\n    assert(\n      this.provider !== undefined,\n      'No provider available right now; did you \"await\" selectDeviceOrSkipTestCase?'\n    );\n    if (!this.acquiredDevice) {\n      this.acquiredDevice = this.provider.acquire();\n    }\n    return this.acquiredDevice;\n  }\n\n  /** GPUDevice for tests requires another device from default one.\n   *  e.g. creating objects required creating mismatched objects required\n   * by device mismatched validation tests.\n   */\n  get mismatchedDevice(): GPUDevice {\n    assert(\n      this.mismatchedProvider !== undefined,\n      'No provider available right now; did you \"await\" selectMismatchedDeviceOrSkipTestCase?'\n    );\n    if (!this.mismatchedAcquiredDevice) {\n      this.mismatchedAcquiredDevice = this.mismatchedProvider.acquire();\n    }\n    return this.mismatchedAcquiredDevice;\n  }\n\n  /**\n   * Create other device different with current test device, which could be got by `.mismatchedDevice`.\n   * A `descriptor` may be undefined, which returns a `default` mismatched device.\n   * If the request descriptor or feature name can't be supported, throws an exception to skip the entire test case.\n   */\n  async selectMismatchedDeviceOrSkipTestCase(\n    descriptor:\n      | UncanonicalizedDeviceDescriptor\n      | GPUFeatureName\n      | undefined\n      | Array<GPUFeatureName | undefined>\n  ): Promise<void> {\n    assert(\n      this.mismatchedProvider === undefined,\n      \"Can't selectMismatchedDeviceOrSkipTestCase() multiple times\"\n    );\n\n    this.mismatchedProvider =\n      descriptor === undefined\n        ? await mismatchedDevicePool.reserve()\n        : await mismatchedDevicePool.reserve(initUncanonicalizedDeviceDescriptor(descriptor));\n\n    this.mismatchedAcquiredDevice = this.mismatchedProvider.acquire();\n  }\n\n  /** GPUQueue for the test to use. (Same as `t.device.queue`.) */\n  get queue(): GPUQueue {\n    return this.device.queue;\n  }\n\n  protected async init(): Promise<void> {\n    await super.init();\n\n    this.provider = await devicePool.reserve();\n  }\n\n  protected async finalize(): Promise<void> {\n    await super.finalize();\n\n    if (this.provider) {\n      let threw = false;\n      let thrownValue: unknown;\n      {\n        const provider = this.provider;\n        this.provider = undefined;\n        try {\n          await devicePool.release(provider);\n        } catch (ex) {\n          threw = true;\n          thrownValue = ex;\n        }\n      }\n      // The GPUDevice and GPUQueue should now have no outstanding references.\n\n      if (threw) {\n        if (thrownValue instanceof TestOOMedShouldAttemptGC) {\n          // Try to clean up, in case there are stray GPU resources in need of collection.\n          await attemptGarbageCollection();\n        }\n        throw thrownValue;\n      }\n    }\n\n    if (this.mismatchedProvider) {\n      // MAINTENANCE_TODO(kainino0x): Deduplicate this with code in GPUTest.finalize\n      let threw = false;\n      let thrownValue: unknown;\n      {\n        const provider = this.mismatchedProvider;\n        this.mismatchedProvider = undefined;\n        try {\n          await mismatchedDevicePool.release(provider);\n        } catch (ex) {\n          threw = true;\n          thrownValue = ex;\n        }\n      }\n\n      if (threw) {\n        if (thrownValue instanceof TestOOMedShouldAttemptGC) {\n          // Try to clean up, in case there are stray GPU resources in need of collection.\n          await attemptGarbageCollection();\n        }\n        throw thrownValue;\n      }\n    }\n  }\n\n  /**\n   * When a GPUTest test accesses `.device` for the first time, a \"default\" GPUDevice\n   * (descriptor = `undefined`) is provided by default.\n   * However, some tests or cases need particular nonGuaranteedFeatures to be enabled.\n   * Call this function with a descriptor or feature name (or `undefined`) to select a\n   * GPUDevice with matching capabilities.\n   *\n   * If the request descriptor can't be supported, throws an exception to skip the entire test case.\n   */\n  async selectDeviceOrSkipTestCase(\n    descriptor:\n      | UncanonicalizedDeviceDescriptor\n      | GPUFeatureName\n      | undefined\n      | Array<GPUFeatureName | undefined>\n  ): Promise<void> {\n    if (descriptor === undefined) return;\n\n    assert(this.provider !== undefined);\n    // Make sure the device isn't replaced after it's been retrieved once.\n    assert(\n      !this.acquiredDevice,\n      \"Can't selectDeviceOrSkipTestCase() after the device has been used\"\n    );\n\n    const oldProvider = this.provider;\n    this.provider = undefined;\n    await devicePool.release(oldProvider);\n\n    this.provider = await devicePool.reserve(initUncanonicalizedDeviceDescriptor(descriptor));\n    this.acquiredDevice = this.provider.acquire();\n  }\n\n  /**\n   * Create device with texture format(s) required feature(s).\n   * If the device creation fails, then skip the test for that format(s).\n   */\n  async selectDeviceForTextureFormatOrSkipTestCase(\n    formats: GPUTextureFormat | undefined | (GPUTextureFormat | undefined)[]\n  ): Promise<void> {\n    if (!Array.isArray(formats)) {\n      formats = [formats];\n    }\n    const features = new Set<GPUFeatureName | undefined>();\n    for (const format of formats) {\n      if (format !== undefined) {\n        features.add(kTextureFormatInfo[format].feature);\n      }\n    }\n\n    await this.selectDeviceOrSkipTestCase(Array.from(features));\n  }\n\n  /**\n   * Create device with query type(s) required feature(s).\n   * If the device creation fails, then skip the test for that type(s).\n   */\n  async selectDeviceForQueryTypeOrSkipTestCase(\n    types: GPUQueryType | GPUQueryType[]\n  ): Promise<void> {\n    if (!Array.isArray(types)) {\n      types = [types];\n    }\n    const features = types.map(t => kQueryTypeInfo[t].feature);\n    await this.selectDeviceOrSkipTestCase(features);\n  }\n\n  /** Snapshot a GPUBuffer's contents, returning a new GPUBuffer with the `MAP_READ` usage. */\n  private createCopyForMapRead(src: GPUBuffer, srcOffset: number, size: number): GPUBuffer {\n    assert(srcOffset % 4 === 0);\n    assert(size % 4 === 0);\n\n    const dst = this.device.createBuffer({\n      size,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    this.trackForCleanup(dst);\n\n    const c = this.device.createCommandEncoder();\n    c.copyBufferToBuffer(src, srcOffset, dst, 0, size);\n    this.queue.submit([c.finish()]);\n\n    return dst;\n  }\n\n  /**\n   * Offset and size passed to createCopyForMapRead must be divisible by 4. For that\n   * we might need to copy more bytes from the buffer than we want to map.\n   * begin and end values represent the part of the copied buffer that stores the contents\n   * we initially wanted to map.\n   * The copy will not cause an OOB error because the buffer size must be 4-aligned.\n   */\n  private createAlignedCopyForMapRead(\n    src: GPUBuffer,\n    size: number,\n    offset: number\n  ): { mappable: GPUBuffer; subarrayByteStart: number } {\n    const alignedOffset = roundDown(offset, 4);\n    const subarrayByteStart = offset - alignedOffset;\n    const alignedSize = align(size + subarrayByteStart, 4);\n    const mappable = this.createCopyForMapRead(src, alignedOffset, alignedSize);\n    return { mappable, subarrayByteStart };\n  }\n\n  /**\n   * Snapshot the current contents of a range of a GPUBuffer, and return them as a TypedArray.\n   * Also provides a cleanup() function to unmap and destroy the staging buffer.\n   */\n  async readGPUBufferRangeTyped<T extends TypedArrayBufferView>(\n    src: GPUBuffer,\n    {\n      srcByteOffset = 0,\n      method = 'copy',\n      type,\n      typedLength,\n    }: {\n      srcByteOffset?: number;\n      method?: 'copy' | 'map';\n      type: TypedArrayBufferViewConstructor<T>;\n      typedLength: number;\n    }\n  ): Promise<{ data: T; cleanup(): void }> {\n    assert(\n      srcByteOffset % type.BYTES_PER_ELEMENT === 0,\n      'srcByteOffset must be a multiple of BYTES_PER_ELEMENT'\n    );\n\n    const byteLength = typedLength * type.BYTES_PER_ELEMENT;\n    let mappable: GPUBuffer;\n    let mapOffset: number | undefined, mapSize: number | undefined, subarrayByteStart: number;\n    if (method === 'copy') {\n      ({ mappable, subarrayByteStart } = this.createAlignedCopyForMapRead(\n        src,\n        byteLength,\n        srcByteOffset\n      ));\n    } else if (method === 'map') {\n      mappable = src;\n      mapOffset = roundDown(srcByteOffset, 8);\n      mapSize = align(byteLength, 4);\n      subarrayByteStart = srcByteOffset - mapOffset;\n    } else {\n      unreachable();\n    }\n\n    assert(subarrayByteStart % type.BYTES_PER_ELEMENT === 0);\n    const subarrayStart = subarrayByteStart / type.BYTES_PER_ELEMENT;\n\n    // 2. Map the staging buffer, and create the TypedArray from it.\n    await mappable.mapAsync(GPUMapMode.READ, mapOffset, mapSize);\n    const mapped = new type(mappable.getMappedRange(mapOffset, mapSize));\n    const data = mapped.subarray(subarrayStart, typedLength) as T;\n\n    return {\n      data,\n      cleanup() {\n        mappable.unmap();\n        mappable.destroy();\n      },\n    };\n  }\n\n  /**\n   * Expect a GPUBuffer's contents to pass the provided check.\n   *\n   * A library of checks can be found in {@link webgpu/util/check_contents}.\n   */\n  expectGPUBufferValuesPassCheck<T extends TypedArrayBufferView>(\n    src: GPUBuffer,\n    check: (actual: T) => Error | undefined,\n    {\n      srcByteOffset = 0,\n      type,\n      typedLength,\n      method = 'copy',\n      mode = 'fail',\n    }: {\n      srcByteOffset?: number;\n      type: TypedArrayBufferViewConstructor<T>;\n      typedLength: number;\n      method?: 'copy' | 'map';\n      mode?: 'fail' | 'warn';\n    }\n  ) {\n    const readbackPromise = this.readGPUBufferRangeTyped(src, {\n      srcByteOffset,\n      type,\n      typedLength,\n      method,\n    });\n    this.eventualAsyncExpectation(async niceStack => {\n      const readback = await readbackPromise;\n      this.expectOK(check(readback.data), { mode, niceStack });\n      readback.cleanup();\n    });\n  }\n\n  /**\n   * Expect a GPUBuffer's contents to equal the values in the provided TypedArray.\n   */\n  expectGPUBufferValuesEqual(\n    src: GPUBuffer,\n    expected: TypedArrayBufferView,\n    srcByteOffset: number = 0,\n    { method = 'copy', mode = 'fail' }: { method?: 'copy' | 'map'; mode?: 'fail' | 'warn' } = {}\n  ): void {\n    this.expectGPUBufferValuesPassCheck(src, a => checkElementsEqual(a, expected), {\n      srcByteOffset,\n      type: expected.constructor as TypedArrayBufferViewConstructor,\n      typedLength: expected.length,\n      method,\n      mode,\n    });\n  }\n\n  /**\n   * Expect a buffer to consist exclusively of rows of some repeated expected value. The size of\n   * `expectedValue` must be 1, 2, or any multiple of 4 bytes. Rows in the buffer are expected to be\n   * zero-padded out to `bytesPerRow`. `minBytesPerRow` is the number of bytes per row that contain\n   * actual (non-padding) data and must be an exact multiple of the byte-length of `expectedValue`.\n   */\n  expectGPUBufferRepeatsSingleValue(\n    buffer: GPUBuffer,\n    {\n      expectedValue,\n      numRows,\n      minBytesPerRow,\n      bytesPerRow,\n    }: {\n      expectedValue: ArrayBuffer;\n      numRows: number;\n      minBytesPerRow: number;\n      bytesPerRow: number;\n    }\n  ) {\n    const valueSize = expectedValue.byteLength;\n    assert(valueSize === 1 || valueSize === 2 || valueSize % 4 === 0);\n    assert(minBytesPerRow % valueSize === 0);\n    assert(bytesPerRow % 4 === 0);\n\n    // If the buffer is small enough, just generate the full expected buffer contents and check\n    // against them on the CPU.\n    const kMaxBufferSizeToCheckOnCpu = 256 * 1024;\n    const bufferSize = bytesPerRow * (numRows - 1) + minBytesPerRow;\n    if (bufferSize <= kMaxBufferSizeToCheckOnCpu) {\n      const valueBytes = Array.from(new Uint8Array(expectedValue));\n      const rowValues = new Array(minBytesPerRow / valueSize).fill(valueBytes);\n      const rowBytes = new Uint8Array([].concat(...rowValues));\n      const expectedContents = new Uint8Array(bufferSize);\n      range(numRows, row => expectedContents.set(rowBytes, row * bytesPerRow));\n      this.expectGPUBufferValuesEqual(buffer, expectedContents);\n      return;\n    }\n\n    // Copy into a buffer suitable for STORAGE usage.\n    const storageBuffer = this.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n    this.trackForCleanup(storageBuffer);\n\n    // This buffer conveys the data we expect to see for a single value read. Since we read 32 bits at\n    // a time, for values smaller than 32 bits we pad this expectation with repeated value data, or\n    // with zeroes if the width of a row in the buffer is less than 4 bytes. For value sizes larger\n    // than 32 bits, we assume they're a multiple of 32 bits and expect to read exact matches of\n    // `expectedValue` as-is.\n    const expectedDataSize = Math.max(4, valueSize);\n    const expectedDataBuffer = this.device.createBuffer({\n      size: expectedDataSize,\n      usage: GPUBufferUsage.STORAGE,\n      mappedAtCreation: true,\n    });\n    this.trackForCleanup(expectedDataBuffer);\n    const expectedData = new Uint32Array(expectedDataBuffer.getMappedRange());\n    if (valueSize === 1) {\n      const value = new Uint8Array(expectedValue)[0];\n      const values = new Array(Math.min(4, minBytesPerRow)).fill(value);\n      const padding = new Array(Math.max(0, 4 - values.length)).fill(0);\n      const expectedBytes = new Uint8Array(expectedData.buffer);\n      expectedBytes.set([...values, ...padding]);\n    } else if (valueSize === 2) {\n      const value = new Uint16Array(expectedValue)[0];\n      const expectedWords = new Uint16Array(expectedData.buffer);\n      expectedWords.set([value, minBytesPerRow > 2 ? value : 0]);\n    } else {\n      expectedData.set(new Uint32Array(expectedValue));\n    }\n    expectedDataBuffer.unmap();\n\n    // The output buffer has one 32-bit entry per buffer row. An entry's value will be 1 if every\n    // read from the corresponding row matches the expected data derived above, or 0 otherwise.\n    const resultBuffer = this.device.createBuffer({\n      size: numRows * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n    this.trackForCleanup(resultBuffer);\n\n    const readsPerRow = Math.ceil(minBytesPerRow / expectedDataSize);\n    const reducer = `\n    struct Buffer { data: array<u32>; };\n    @group(0) @binding(0) var<storage, read> expected: Buffer;\n    @group(0) @binding(1) var<storage, read> in: Buffer;\n    @group(0) @binding(2) var<storage, read_write> out: Buffer;\n    @stage(compute) @workgroup_size(1) fn reduce(\n        @builtin(global_invocation_id) id: vec3<u32>) {\n      let rowBaseIndex = id.x * ${bytesPerRow / 4}u;\n      let readSize = ${expectedDataSize / 4}u;\n      out.data[id.x] = 1u;\n      for (var i: u32 = 0u; i < ${readsPerRow}u; i = i + 1u) {\n        let elementBaseIndex = rowBaseIndex + i * readSize;\n        for (var j: u32 = 0u; j < readSize; j = j + 1u) {\n          if (in.data[elementBaseIndex + j] != expected.data[j]) {\n            out.data[id.x] = 0u;\n            return;\n          }\n        }\n      }\n    }\n    `;\n\n    const pipeline = this.device.createComputePipeline({\n      compute: {\n        module: this.device.createShaderModule({ code: reducer }),\n        entryPoint: 'reduce',\n      },\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: expectedDataBuffer } },\n        { binding: 1, resource: { buffer: storageBuffer } },\n        { binding: 2, resource: { buffer: resultBuffer } },\n      ],\n    });\n\n    const commandEncoder = this.device.createCommandEncoder();\n    commandEncoder.copyBufferToBuffer(buffer, 0, storageBuffer, 0, bufferSize);\n    const pass = commandEncoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatch(numRows);\n    pass.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n\n    const expectedResults = new Array(numRows).fill(1);\n    this.expectGPUBufferValuesEqual(resultBuffer, new Uint32Array(expectedResults));\n  }\n\n  // MAINTENANCE_TODO: add an expectContents for textures, which logs data: uris on failure\n\n  /**\n   * Expect a whole GPUTexture to have the single provided color.\n   */\n  expectSingleColor(\n    src: GPUTexture,\n    format: GPUTextureFormat,\n    {\n      size,\n      exp,\n      dimension = '2d',\n      slice = 0,\n      layout,\n    }: {\n      size: [number, number, number];\n      exp: PerTexelComponent<number>;\n      dimension?: GPUTextureDimension;\n      slice?: number;\n      layout?: TextureLayoutOptions;\n    }\n  ): void {\n    format = resolvePerAspectFormat(format, layout?.aspect);\n    const { byteLength, minBytesPerRow, bytesPerRow, rowsPerImage, mipSize } = getTextureCopyLayout(\n      format,\n      dimension,\n      size,\n      layout\n    );\n\n    const rep = kTexelRepresentationInfo[format as EncodableTextureFormat];\n    const expectedTexelData = rep.pack(rep.encode(exp));\n\n    const buffer = this.device.createBuffer({\n      size: byteLength,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    this.trackForCleanup(buffer);\n\n    const commandEncoder = this.device.createCommandEncoder();\n    commandEncoder.copyTextureToBuffer(\n      {\n        texture: src,\n        mipLevel: layout?.mipLevel,\n        origin: { x: 0, y: 0, z: slice },\n        aspect: layout?.aspect,\n      },\n      { buffer, bytesPerRow, rowsPerImage },\n      mipSize\n    );\n    this.queue.submit([commandEncoder.finish()]);\n\n    this.expectGPUBufferRepeatsSingleValue(buffer, {\n      expectedValue: expectedTexelData,\n      numRows: rowsPerImage,\n      minBytesPerRow,\n      bytesPerRow,\n    });\n  }\n\n  /** Return a GPUBuffer that data are going to be written into. */\n  private readSinglePixelFrom2DTexture(\n    src: GPUTexture,\n    format: SizedTextureFormat,\n    { x, y }: { x: number; y: number },\n    { slice = 0, layout }: { slice?: number; layout?: TextureLayoutOptions }\n  ): GPUBuffer {\n    const { byteLength, bytesPerRow, rowsPerImage } = getTextureSubCopyLayout(\n      format,\n      [1, 1],\n      layout\n    );\n    const buffer = this.device.createBuffer({\n      size: byteLength,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    this.trackForCleanup(buffer);\n\n    const commandEncoder = this.device.createCommandEncoder();\n    commandEncoder.copyTextureToBuffer(\n      { texture: src, mipLevel: layout?.mipLevel, origin: { x, y, z: slice } },\n      { buffer, bytesPerRow, rowsPerImage },\n      [1, 1]\n    );\n    this.queue.submit([commandEncoder.finish()]);\n\n    return buffer;\n  }\n\n  /**\n   * Expect a single pixel of a 2D texture to have a particular byte representation.\n   *\n   * MAINTENANCE_TODO: Add check for values of depth/stencil, probably through sampling of shader\n   * MAINTENANCE_TODO: Can refactor this and expectSingleColor to use a similar base expect\n   */\n  expectSinglePixelIn2DTexture(\n    src: GPUTexture,\n    format: SizedTextureFormat,\n    { x, y }: { x: number; y: number },\n    {\n      exp,\n      slice = 0,\n      layout,\n      generateWarningOnly = false,\n    }: {\n      exp: Uint8Array;\n      slice?: number;\n      layout?: TextureLayoutOptions;\n      generateWarningOnly?: boolean;\n    }\n  ): void {\n    const buffer = this.readSinglePixelFrom2DTexture(src, format, { x, y }, { slice, layout });\n    this.expectGPUBufferValuesEqual(buffer, exp, 0, {\n      mode: generateWarningOnly ? 'warn' : 'fail',\n    });\n  }\n\n  /**\n   * Take a single pixel of a 2D texture, interpret it using a TypedArray of the `expected` type,\n   * and expect each value in that array to be between the corresponding \"expected\" values\n   * (either `a[i] <= actual[i] <= b[i]` or `a[i] >= actual[i] => b[i]`).\n   */\n  expectSinglePixelBetweenTwoValuesIn2DTexture(\n    src: GPUTexture,\n    format: SizedTextureFormat,\n    { x, y }: { x: number; y: number },\n    {\n      exp,\n      slice = 0,\n      layout,\n      generateWarningOnly = false,\n      checkElementsBetweenFn = (act, [a, b]) => checkElementsBetween(act, [i => a[i], i => b[i]]),\n    }: {\n      exp: [TypedArrayBufferView, TypedArrayBufferView];\n      slice?: number;\n      layout?: TextureLayoutOptions;\n      generateWarningOnly?: boolean;\n      checkElementsBetweenFn?: (\n        actual: TypedArrayBufferView,\n        expected: readonly [TypedArrayBufferView, TypedArrayBufferView]\n      ) => Error | undefined;\n    }\n  ): void {\n    assert(exp[0].constructor === exp[1].constructor);\n    const constructor = exp[0].constructor as TypedArrayBufferViewConstructor;\n    assert(exp[0].length === exp[1].length);\n    const typedLength = exp[0].length;\n\n    const buffer = this.readSinglePixelFrom2DTexture(src, format, { x, y }, { slice, layout });\n    this.expectGPUBufferValuesPassCheck(buffer, a => checkElementsBetweenFn(a, exp), {\n      type: constructor,\n      typedLength,\n      mode: generateWarningOnly ? 'warn' : 'fail',\n    });\n  }\n\n  /**\n   * Equivalent to {@link expectSinglePixelBetweenTwoValuesIn2DTexture} but uses a special check func\n   * to interpret incoming values as float16\n   */\n  expectSinglePixelBetweenTwoValuesFloat16In2DTexture(\n    src: GPUTexture,\n    format: SizedTextureFormat,\n    { x, y }: { x: number; y: number },\n    {\n      exp,\n      slice = 0,\n      layout,\n      generateWarningOnly = false,\n    }: {\n      exp: [Uint16Array, Uint16Array];\n      slice?: number;\n      layout?: TextureLayoutOptions;\n      generateWarningOnly?: boolean;\n    }\n  ): void {\n    this.expectSinglePixelBetweenTwoValuesIn2DTexture(\n      src,\n      format,\n      { x, y },\n      {\n        exp,\n        slice,\n        layout,\n        generateWarningOnly,\n        checkElementsBetweenFn: checkElementsFloat16Between,\n      }\n    );\n  }\n\n  /**\n   * Expect the specified WebGPU error to be generated when running the provided function.\n   */\n  expectGPUError<R>(filter: GPUErrorFilter, fn: () => R, shouldError: boolean = true): R {\n    // If no error is expected, we let the scope surrounding the test catch it.\n    if (!shouldError) {\n      return fn();\n    }\n\n    this.device.pushErrorScope(filter);\n    const returnValue = fn();\n    const promise = this.device.popErrorScope();\n\n    this.eventualAsyncExpectation(async niceStack => {\n      const error = await promise;\n\n      let failed = false;\n      switch (filter) {\n        case 'out-of-memory':\n          failed = !(error instanceof GPUOutOfMemoryError);\n          break;\n        case 'validation':\n          failed = !(error instanceof GPUValidationError);\n          break;\n      }\n\n      if (failed) {\n        niceStack.message = `Expected ${filter} error`;\n        this.rec.expectationFailed(niceStack);\n      } else {\n        niceStack.message = `Captured ${filter} error`;\n        if (error instanceof GPUValidationError) {\n          niceStack.message += ` - ${error.message}`;\n        }\n        this.rec.debug(niceStack);\n      }\n    });\n\n    return returnValue;\n  }\n\n  /**\n   * Expect a validation error inside the callback.\n   *\n   * Tests should always do just one WebGPU call in the callback, to make sure that's what's tested.\n   */\n  expectValidationError(fn: () => void, shouldError: boolean = true): void {\n    // If no error is expected, we let the scope surrounding the test catch it.\n    if (shouldError) {\n      this.device.pushErrorScope('validation');\n    }\n\n    // Note: A return value is not allowed for the callback function. This is to avoid confusion\n    // about what the actual behavior would be; either of the following could be reasonable:\n    //   - Make expectValidationError async, and have it await on fn(). This causes an async split\n    //     between pushErrorScope and popErrorScope, so if the caller doesn't `await` on\n    //     expectValidationError (either accidentally or because it doesn't care to do so), then\n    //     other test code will be (nondeterministically) caught by the error scope.\n    //   - Make expectValidationError NOT await fn(), but just execute its first block (until the\n    //     first await) and return the return value (a Promise). This would be confusing because it\n    //     would look like the error scope includes the whole async function, but doesn't.\n    // If we do decide we need to return a value, we should use the latter semantic.\n    const returnValue = fn() as unknown;\n    assert(\n      returnValue === undefined,\n      'expectValidationError callback should not return a value (or be async)'\n    );\n\n    if (shouldError) {\n      const promise = this.device.popErrorScope();\n\n      this.eventualAsyncExpectation(async niceStack => {\n        const gpuValidationError = await promise;\n        if (!gpuValidationError) {\n          niceStack.message = 'Validation succeeded unexpectedly.';\n          this.rec.validationFailed(niceStack);\n        } else if (gpuValidationError instanceof GPUValidationError) {\n          niceStack.message = `Validation failed, as expected - ${gpuValidationError.message}`;\n          this.rec.debug(niceStack);\n        }\n      });\n    }\n  }\n\n  /**\n   * Expects that the device should be lost for a particular reason at the teardown of the test.\n   */\n  expectDeviceLost(reason: GPUDeviceLostReason): void {\n    assert(\n      this.provider !== undefined,\n      'No provider available right now; did you \"await\" selectDeviceOrSkipTestCase?'\n    );\n    this.provider.expectDeviceLost(reason);\n  }\n\n  /**\n   * Create a GPUBuffer with the specified contents and usage.\n   *\n   * MAINTENANCE_TODO: Several call sites would be simplified if this took ArrayBuffer as well.\n   */\n  makeBufferWithContents(dataArray: TypedArrayBufferView, usage: GPUBufferUsageFlags): GPUBuffer {\n    return this.trackForCleanup(makeBufferWithContents(this.device, dataArray, usage));\n  }\n\n  /**\n   * Creates a texture with the contents of a TexelView.\n   */\n  makeTextureWithContents(\n    texelView: TexelView,\n    desc: Omit<GPUTextureDescriptor, 'format'>\n  ): GPUTexture {\n    return this.trackForCleanup(makeTextureWithContents(this.device, texelView, desc));\n  }\n\n  /**\n   * Create a GPUTexture with multiple mip levels, each having the specified contents.\n   */\n  createTexture2DWithMipmaps(mipmapDataArray: TypedArrayBufferView[]): GPUTexture {\n    const format = 'rgba8unorm';\n    const mipLevelCount = mipmapDataArray.length;\n    const textureSizeMipmap0 = 1 << (mipLevelCount - 1);\n    const texture = this.device.createTexture({\n      mipLevelCount,\n      size: { width: textureSizeMipmap0, height: textureSizeMipmap0, depthOrArrayLayers: 1 },\n      format,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    });\n    this.trackForCleanup(texture);\n\n    const textureEncoder = this.device.createCommandEncoder();\n    for (let i = 0; i < mipLevelCount; i++) {\n      const { byteLength, bytesPerRow, rowsPerImage, mipSize } = getTextureCopyLayout(\n        format,\n        '2d',\n        [textureSizeMipmap0, textureSizeMipmap0, 1],\n        { mipLevel: i }\n      );\n\n      const data: Uint8Array = new Uint8Array(byteLength);\n      const mipLevelData = mipmapDataArray[i];\n      assert(rowsPerImage === mipSize[0]); // format is rgba8unorm and block size should be 1\n      for (let r = 0; r < rowsPerImage; r++) {\n        const o = r * bytesPerRow;\n        for (let c = o, end = o + mipSize[1] * 4; c < end; c += 4) {\n          data[c] = mipLevelData[0];\n          data[c + 1] = mipLevelData[1];\n          data[c + 2] = mipLevelData[2];\n          data[c + 3] = mipLevelData[3];\n        }\n      }\n      const buffer = this.makeBufferWithContents(\n        data,\n        GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n      );\n\n      textureEncoder.copyBufferToTexture(\n        { buffer, bytesPerRow, rowsPerImage },\n        { texture, mipLevel: i, origin: [0, 0, 0] },\n        mipSize\n      );\n    }\n    this.device.queue.submit([textureEncoder.finish()]);\n\n    return texture;\n  }\n\n  /**\n   * Returns a GPUCommandEncoder, GPUComputePassEncoder, GPURenderPassEncoder, or\n   * GPURenderBundleEncoder, and a `finish` method returning a GPUCommandBuffer.\n   * Allows testing methods which have the same signature across multiple encoder interfaces.\n   *\n   * @example\n   * ```\n   * g.test('popDebugGroup')\n   *   .params(u => u.combine('encoderType', kEncoderTypes))\n   *   .fn(t => {\n   *     const { encoder, finish } = t.createEncoder(t.params.encoderType);\n   *     encoder.popDebugGroup();\n   *   });\n   *\n   * g.test('writeTimestamp')\n   *   .params(u => u.combine('encoderType', ['non-pass', 'compute pass', 'render pass'] as const)\n   *   .fn(t => {\n   *     const { encoder, finish } = t.createEncoder(t.params.encoderType);\n   *     // Encoder type is inferred, so `writeTimestamp` can be used even though it doesn't exist\n   *     // on GPURenderBundleEncoder.\n   *     encoder.writeTimestamp(args);\n   *   });\n   * ```\n   */\n  createEncoder<T extends EncoderType>(\n    encoderType: T,\n    {\n      attachmentInfo,\n      occlusionQuerySet,\n    }: {\n      attachmentInfo?: GPURenderBundleEncoderDescriptor;\n      occlusionQuerySet?: GPUQuerySet;\n    } = {}\n  ): CommandBufferMaker<T> {\n    const fullAttachmentInfo = {\n      // Defaults if not overridden:\n      colorFormats: ['rgba8unorm'],\n      sampleCount: 1,\n      // Passed values take precedent.\n      ...attachmentInfo,\n    } as const;\n\n    switch (encoderType) {\n      case 'non-pass': {\n        const encoder = this.device.createCommandEncoder();\n\n        return new CommandBufferMaker(this, encoder, () => {\n          return encoder.finish();\n        });\n      }\n      case 'render bundle': {\n        const device = this.device;\n        const rbEncoder = device.createRenderBundleEncoder(fullAttachmentInfo);\n        const pass = this.createEncoder('render pass', { attachmentInfo });\n\n        return new CommandBufferMaker(this, rbEncoder, () => {\n          pass.encoder.executeBundles([rbEncoder.finish()]);\n          return pass.finish();\n        });\n      }\n      case 'compute pass': {\n        const commandEncoder = this.device.createCommandEncoder();\n        const encoder = commandEncoder.beginComputePass();\n\n        return new CommandBufferMaker(this, encoder, () => {\n          encoder.end();\n          return commandEncoder.finish();\n        });\n      }\n      case 'render pass': {\n        const makeAttachmentView = (format: GPUTextureFormat) =>\n          this.trackForCleanup(\n            this.device.createTexture({\n              size: [16, 16, 1],\n              format,\n              usage: GPUTextureUsage.RENDER_ATTACHMENT,\n              sampleCount: fullAttachmentInfo.sampleCount,\n            })\n          ).createView();\n\n        let depthStencilAttachment: GPURenderPassDepthStencilAttachment | undefined = undefined;\n        if (fullAttachmentInfo.depthStencilFormat !== undefined) {\n          depthStencilAttachment = {\n            view: makeAttachmentView(fullAttachmentInfo.depthStencilFormat),\n            depthReadOnly: fullAttachmentInfo.depthReadOnly,\n            stencilReadOnly: fullAttachmentInfo.stencilReadOnly,\n          };\n          if (\n            kTextureFormatInfo[fullAttachmentInfo.depthStencilFormat].depth &&\n            !fullAttachmentInfo.depthReadOnly\n          ) {\n            depthStencilAttachment.depthClearValue = 0;\n            depthStencilAttachment.depthLoadOp = 'clear';\n            depthStencilAttachment.depthStoreOp = 'discard';\n          }\n          if (\n            kTextureFormatInfo[fullAttachmentInfo.depthStencilFormat].stencil &&\n            !fullAttachmentInfo.stencilReadOnly\n          ) {\n            depthStencilAttachment.stencilClearValue = 1;\n            depthStencilAttachment.stencilLoadOp = 'clear';\n            depthStencilAttachment.stencilStoreOp = 'discard';\n          }\n        }\n        const passDesc: GPURenderPassDescriptor = {\n          colorAttachments: Array.from(fullAttachmentInfo.colorFormats, format =>\n            format\n              ? {\n                  view: makeAttachmentView(format),\n                  clearValue: [0, 0, 0, 0],\n                  loadOp: 'clear',\n                  storeOp: 'store',\n                }\n              : null\n          ),\n          depthStencilAttachment,\n          occlusionQuerySet,\n        };\n\n        const commandEncoder = this.device.createCommandEncoder();\n        const encoder = commandEncoder.beginRenderPass(passDesc);\n        return new CommandBufferMaker(this, encoder, () => {\n          encoder.end();\n          return commandEncoder.finish();\n        });\n      }\n    }\n    unreachable();\n  }\n}\n"],"file":"gpu_test.js"}