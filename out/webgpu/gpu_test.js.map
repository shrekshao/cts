{"version":3,"file":"gpu_test.js","names":["Fixture","SubcaseBatchState","assert","range","unreachable","kTextureFormatInfo","kQueryTypeInfo","resolvePerAspectFormat","makeBufferWithContents","checkElementsEqual","checkElementsBetween","checkElementsFloat16Between","CommandBufferMaker","DevicePool","align","roundDown","makeTextureWithContents","getTextureCopyLayout","getTextureSubCopyLayout","kTexelRepresentationInfo","devicePool","mismatchedDevicePool","kResourceStateValues","kResourceStates","initUncanonicalizedDeviceDescriptor","descriptor","requiredFeatures","Array","filter","f","undefined","GPUTestSubcaseBatchState","postInit","acquireProvider","finalize","Promise","all","provider","then","x","release","mismatchedProvider","selectDeviceOrSkipTestCase","acquire","catch","selectDeviceForTextureFormatOrSkipTestCase","formats","isArray","features","Set","format","add","feature","from","selectDeviceForQueryTypeOrSkipTestCase","types","map","t","acquireMismatchedProvider","selectMismatchedDeviceOrSkipTestCase","GPUTest","MakeSharedState","params","init","sharedState","device","mismatchedDevice","queue","createCopyForMapRead","src","srcOffset","size","dst","createBuffer","usage","GPUBufferUsage","MAP_READ","COPY_DST","trackForCleanup","c","createCommandEncoder","copyBufferToBuffer","submit","finish","createAlignedCopyForMapRead","offset","alignedOffset","subarrayByteStart","alignedSize","mappable","readGPUBufferRangeTyped","srcByteOffset","method","type","typedLength","BYTES_PER_ELEMENT","byteLength","mapOffset","mapSize","subarrayStart","mapAsync","GPUMapMode","READ","mapped","getMappedRange","data","subarray","cleanup","unmap","destroy","expectGPUBufferValuesPassCheck","check","mode","readbackPromise","eventualAsyncExpectation","niceStack","readback","expectOK","expectGPUBufferValuesEqual","expected","a","constructor","length","expectGPUBufferRepeatsSingleValue","buffer","expectedValue","numRows","minBytesPerRow","bytesPerRow","valueSize","kMaxBufferSizeToCheckOnCpu","bufferSize","valueBytes","Uint8Array","rowValues","fill","rowBytes","concat","expectedContents","row","set","storageBuffer","STORAGE","expectedDataSize","Math","max","expectedDataBuffer","mappedAtCreation","expectedData","Uint32Array","value","values","min","padding","expectedBytes","Uint16Array","expectedWords","resultBuffer","COPY_SRC","readsPerRow","ceil","reducer","pipeline","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","commandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","expectedResults","expectSingleColor","exp","dimension","slice","aspect","rowsPerImage","mipSize","rep","expectedTexelData","pack","encode","copyTextureToBuffer","texture","mipLevel","origin","y","z","readSinglePixelFrom2DTexture","expectSinglePixelIn2DTexture","generateWarningOnly","expectSinglePixelBetweenTwoValuesIn2DTexture","checkElementsBetweenFn","act","b","i","expectSinglePixelBetweenTwoValuesFloat16In2DTexture","expectGPUError","fn","shouldError","pushErrorScope","returnValue","promise","popErrorScope","error","failed","GPUOutOfMemoryError","GPUValidationError","message","rec","expectationFailed","debug","expectValidationError","gpuValidationError","validationFailed","expectDeviceLost","reason","dataArray","texelView","desc","createTexture2DWithMipmaps","mipmapDataArray","mipLevelCount","textureSizeMipmap0","createTexture","width","height","depthOrArrayLayers","GPUTextureUsage","TEXTURE_BINDING","textureEncoder","mipLevelData","r","o","copyBufferToTexture","createEncoder","encoderType","attachmentInfo","occlusionQuerySet","fullAttachmentInfo","colorFormats","sampleCount","encoder","rbEncoder","createRenderBundleEncoder","executeBundles","makeAttachmentView","RENDER_ATTACHMENT","createView","depthStencilAttachment","depthStencilFormat","view","depthReadOnly","stencilReadOnly","depth","depthClearValue","depthLoadOp","depthStoreOp","stencil","stencilClearValue","stencilLoadOp","stencilStoreOp","passDesc","colorAttachments","clearValue","loadOp","storeOp","beginRenderPass"],"sources":["../../src/webgpu/gpu_test.ts"],"sourcesContent":["import { Fixture, SubcaseBatchState, TestParams } from '../common/framework/fixture.js';\nimport {\n  assert,\n  range,\n  TypedArrayBufferView,\n  TypedArrayBufferViewConstructor,\n  unreachable,\n} from '../common/util/util.js';\n\nimport {\n  EncodableTextureFormat,\n  SizedTextureFormat,\n  kTextureFormatInfo,\n  kQueryTypeInfo,\n  resolvePerAspectFormat,\n} from './capability_info.js';\nimport { makeBufferWithContents } from './util/buffer.js';\nimport {\n  checkElementsEqual,\n  checkElementsBetween,\n  checkElementsFloat16Between,\n} from './util/check_contents.js';\nimport { CommandBufferMaker, EncoderType } from './util/command_buffer_maker.js';\nimport { DevicePool, DeviceProvider, UncanonicalizedDeviceDescriptor } from './util/device_pool.js';\nimport { align, roundDown } from './util/math.js';\nimport { makeTextureWithContents } from './util/texture.js';\nimport {\n  getTextureCopyLayout,\n  getTextureSubCopyLayout,\n  LayoutOptions as TextureLayoutOptions,\n} from './util/texture/layout.js';\nimport { PerTexelComponent, kTexelRepresentationInfo } from './util/texture/texel_data.js';\nimport { TexelView } from './util/texture/texel_view.js';\n\nconst devicePool = new DevicePool();\n\n// MAINTENANCE_TODO: When DevicePool becomes able to provide multiple devices at once, use the\n// usual one instead of a new one.\nconst mismatchedDevicePool = new DevicePool();\n\nconst kResourceStateValues = ['valid', 'invalid', 'destroyed'] as const;\nexport type ResourceState = typeof kResourceStateValues[number];\nexport const kResourceStates: readonly ResourceState[] = kResourceStateValues;\n\n/** Various \"convenient\" shorthands for GPUDeviceDescriptors for selectDevice functions. */\ntype DeviceSelectionDescriptor =\n  | UncanonicalizedDeviceDescriptor\n  | GPUFeatureName\n  | undefined\n  | Array<GPUFeatureName | undefined>;\n\nexport function initUncanonicalizedDeviceDescriptor(\n  descriptor: DeviceSelectionDescriptor\n): UncanonicalizedDeviceDescriptor | undefined {\n  if (typeof descriptor === 'string') {\n    return { requiredFeatures: [descriptor] };\n  } else if (descriptor instanceof Array) {\n    return {\n      requiredFeatures: descriptor.filter(f => f !== undefined) as GPUFeatureName[],\n    };\n  } else {\n    return descriptor;\n  }\n}\n\nexport class GPUTestSubcaseBatchState extends SubcaseBatchState {\n  /** Provider for default device. */\n  private provider: Promise<DeviceProvider> | undefined;\n  /** Provider for mismatched device. */\n  private mismatchedProvider: Promise<DeviceProvider> | undefined;\n\n  async postInit(): Promise<void> {\n    // Skip all subcases if there's no device.\n    await this.acquireProvider();\n  }\n\n  async finalize(): Promise<void> {\n    await super.finalize();\n\n    // Ensure devicePool.release is called for both providers even if one rejects.\n    await Promise.all([\n      this.provider?.then(x => devicePool.release(x)),\n      this.mismatchedProvider?.then(x => devicePool.release(x)),\n    ]);\n  }\n\n  /** @internal MAINTENANCE_TODO: Make this not visible to test code? */\n  acquireProvider(): Promise<DeviceProvider> {\n    if (this.provider === undefined) {\n      this.selectDeviceOrSkipTestCase(undefined);\n    }\n    assert(this.provider !== undefined);\n    return this.provider;\n  }\n\n  /**\n   * Some tests or cases need particular feature flags or limits to be enabled.\n   * Call this function with a descriptor or feature name (or `undefined`) to select a\n   * GPUDevice with matching capabilities. If this isn't called, a default device is provided.\n   *\n   * If the request isn't supported, throws a SkipTestCase exception to skip the entire test case.\n   */\n  selectDeviceOrSkipTestCase(descriptor: DeviceSelectionDescriptor): void {\n    assert(this.provider === undefined, \"Can't selectDeviceOrSkipTestCase() multiple times\");\n    this.provider = devicePool.acquire(initUncanonicalizedDeviceDescriptor(descriptor));\n    // Suppress uncaught promise rejection (we'll catch it later).\n    this.provider.catch(() => {});\n  }\n\n  /**\n   * Convenience function for {@link selectDeviceOrSkipTestCase}.\n   * Select a device with the features required by these texture format(s).\n   * If the device creation fails, then skip the test case.\n   */\n  selectDeviceForTextureFormatOrSkipTestCase(\n    formats: GPUTextureFormat | undefined | (GPUTextureFormat | undefined)[]\n  ): void {\n    if (!Array.isArray(formats)) {\n      formats = [formats];\n    }\n    const features = new Set<GPUFeatureName | undefined>();\n    for (const format of formats) {\n      if (format !== undefined) {\n        features.add(kTextureFormatInfo[format].feature);\n      }\n    }\n\n    this.selectDeviceOrSkipTestCase(Array.from(features));\n  }\n\n  /**\n   * Convenience function for {@link selectDeviceOrSkipTestCase}.\n   * Select a device with the features required by these query type(s).\n   * If the device creation fails, then skip the test case.\n   */\n  selectDeviceForQueryTypeOrSkipTestCase(types: GPUQueryType | GPUQueryType[]): void {\n    if (!Array.isArray(types)) {\n      types = [types];\n    }\n    const features = types.map(t => kQueryTypeInfo[t].feature);\n    this.selectDeviceOrSkipTestCase(features);\n  }\n\n  /** @internal MAINTENANCE_TODO: Make this not visible to test code? */\n  acquireMismatchedProvider(): Promise<DeviceProvider> | undefined {\n    return this.mismatchedProvider;\n  }\n\n  /**\n   * Some tests need a second device which is different from the first.\n   * This requests a second device so it will be available during the test. If it is not called,\n   * no second device will be available.\n   *\n   * If the request isn't supported, throws a SkipTestCase exception to skip the entire test case.\n   */\n  selectMismatchedDeviceOrSkipTestCase(descriptor: DeviceSelectionDescriptor): void {\n    assert(\n      this.mismatchedProvider === undefined,\n      \"Can't selectMismatchedDeviceOrSkipTestCase() multiple times\"\n    );\n\n    this.mismatchedProvider = mismatchedDevicePool.acquire(\n      initUncanonicalizedDeviceDescriptor(descriptor)\n    );\n    // Suppress uncaught promise rejection (we'll catch it later).\n    this.mismatchedProvider.catch(() => {});\n  }\n}\n\n/**\n * Base fixture for WebGPU tests.\n */\nexport class GPUTest extends Fixture<GPUTestSubcaseBatchState> {\n  public static MakeSharedState(params: TestParams): GPUTestSubcaseBatchState {\n    return new GPUTestSubcaseBatchState(params);\n  }\n\n  // Should never be undefined in a test. If it is, init() must not have run/finished.\n  private provider: DeviceProvider | undefined;\n  private mismatchedProvider: DeviceProvider | undefined;\n\n  async init() {\n    await super.init();\n\n    this.provider = await this.sharedState.acquireProvider();\n    this.mismatchedProvider = await this.sharedState.acquireMismatchedProvider();\n  }\n\n  /**\n   * GPUDevice for the test to use.\n   */\n  get device(): GPUDevice {\n    assert(this.provider !== undefined, 'internal error: GPUDevice missing?');\n    return this.provider.device;\n  }\n\n  /**\n   * GPUDevice for tests requiring a second device different from the default one,\n   * e.g. for creating objects for by device_mismatch validation tests.\n   */\n  get mismatchedDevice(): GPUDevice {\n    assert(\n      this.mismatchedProvider !== undefined,\n      'selectMismatchedDeviceOrSkipTestCase was not called in beforeAllSubcases'\n    );\n    return this.mismatchedProvider.device;\n  }\n\n  /** GPUQueue for the test to use. (Same as `t.device.queue`.) */\n  get queue(): GPUQueue {\n    return this.device.queue;\n  }\n\n  /** Snapshot a GPUBuffer's contents, returning a new GPUBuffer with the `MAP_READ` usage. */\n  private createCopyForMapRead(src: GPUBuffer, srcOffset: number, size: number): GPUBuffer {\n    assert(srcOffset % 4 === 0);\n    assert(size % 4 === 0);\n\n    const dst = this.device.createBuffer({\n      size,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    this.trackForCleanup(dst);\n\n    const c = this.device.createCommandEncoder();\n    c.copyBufferToBuffer(src, srcOffset, dst, 0, size);\n    this.queue.submit([c.finish()]);\n\n    return dst;\n  }\n\n  /**\n   * Offset and size passed to createCopyForMapRead must be divisible by 4. For that\n   * we might need to copy more bytes from the buffer than we want to map.\n   * begin and end values represent the part of the copied buffer that stores the contents\n   * we initially wanted to map.\n   * The copy will not cause an OOB error because the buffer size must be 4-aligned.\n   */\n  private createAlignedCopyForMapRead(\n    src: GPUBuffer,\n    size: number,\n    offset: number\n  ): { mappable: GPUBuffer; subarrayByteStart: number } {\n    const alignedOffset = roundDown(offset, 4);\n    const subarrayByteStart = offset - alignedOffset;\n    const alignedSize = align(size + subarrayByteStart, 4);\n    const mappable = this.createCopyForMapRead(src, alignedOffset, alignedSize);\n    return { mappable, subarrayByteStart };\n  }\n\n  /**\n   * Snapshot the current contents of a range of a GPUBuffer, and return them as a TypedArray.\n   * Also provides a cleanup() function to unmap and destroy the staging buffer.\n   */\n  async readGPUBufferRangeTyped<T extends TypedArrayBufferView>(\n    src: GPUBuffer,\n    {\n      srcByteOffset = 0,\n      method = 'copy',\n      type,\n      typedLength,\n    }: {\n      srcByteOffset?: number;\n      method?: 'copy' | 'map';\n      type: TypedArrayBufferViewConstructor<T>;\n      typedLength: number;\n    }\n  ): Promise<{ data: T; cleanup(): void }> {\n    assert(\n      srcByteOffset % type.BYTES_PER_ELEMENT === 0,\n      'srcByteOffset must be a multiple of BYTES_PER_ELEMENT'\n    );\n\n    const byteLength = typedLength * type.BYTES_PER_ELEMENT;\n    let mappable: GPUBuffer;\n    let mapOffset: number | undefined, mapSize: number | undefined, subarrayByteStart: number;\n    if (method === 'copy') {\n      ({ mappable, subarrayByteStart } = this.createAlignedCopyForMapRead(\n        src,\n        byteLength,\n        srcByteOffset\n      ));\n    } else if (method === 'map') {\n      mappable = src;\n      mapOffset = roundDown(srcByteOffset, 8);\n      mapSize = align(byteLength, 4);\n      subarrayByteStart = srcByteOffset - mapOffset;\n    } else {\n      unreachable();\n    }\n\n    assert(subarrayByteStart % type.BYTES_PER_ELEMENT === 0);\n    const subarrayStart = subarrayByteStart / type.BYTES_PER_ELEMENT;\n\n    // 2. Map the staging buffer, and create the TypedArray from it.\n    await mappable.mapAsync(GPUMapMode.READ, mapOffset, mapSize);\n    const mapped = new type(mappable.getMappedRange(mapOffset, mapSize));\n    const data = mapped.subarray(subarrayStart, typedLength) as T;\n\n    return {\n      data,\n      cleanup() {\n        mappable.unmap();\n        mappable.destroy();\n      },\n    };\n  }\n\n  /**\n   * Expect a GPUBuffer's contents to pass the provided check.\n   *\n   * A library of checks can be found in {@link webgpu/util/check_contents}.\n   */\n  expectGPUBufferValuesPassCheck<T extends TypedArrayBufferView>(\n    src: GPUBuffer,\n    check: (actual: T) => Error | undefined,\n    {\n      srcByteOffset = 0,\n      type,\n      typedLength,\n      method = 'copy',\n      mode = 'fail',\n    }: {\n      srcByteOffset?: number;\n      type: TypedArrayBufferViewConstructor<T>;\n      typedLength: number;\n      method?: 'copy' | 'map';\n      mode?: 'fail' | 'warn';\n    }\n  ) {\n    const readbackPromise = this.readGPUBufferRangeTyped(src, {\n      srcByteOffset,\n      type,\n      typedLength,\n      method,\n    });\n    this.eventualAsyncExpectation(async niceStack => {\n      const readback = await readbackPromise;\n      this.expectOK(check(readback.data), { mode, niceStack });\n      readback.cleanup();\n    });\n  }\n\n  /**\n   * Expect a GPUBuffer's contents to equal the values in the provided TypedArray.\n   */\n  expectGPUBufferValuesEqual(\n    src: GPUBuffer,\n    expected: TypedArrayBufferView,\n    srcByteOffset: number = 0,\n    { method = 'copy', mode = 'fail' }: { method?: 'copy' | 'map'; mode?: 'fail' | 'warn' } = {}\n  ): void {\n    this.expectGPUBufferValuesPassCheck(src, a => checkElementsEqual(a, expected), {\n      srcByteOffset,\n      type: expected.constructor as TypedArrayBufferViewConstructor,\n      typedLength: expected.length,\n      method,\n      mode,\n    });\n  }\n\n  /**\n   * Expect a buffer to consist exclusively of rows of some repeated expected value. The size of\n   * `expectedValue` must be 1, 2, or any multiple of 4 bytes. Rows in the buffer are expected to be\n   * zero-padded out to `bytesPerRow`. `minBytesPerRow` is the number of bytes per row that contain\n   * actual (non-padding) data and must be an exact multiple of the byte-length of `expectedValue`.\n   */\n  expectGPUBufferRepeatsSingleValue(\n    buffer: GPUBuffer,\n    {\n      expectedValue,\n      numRows,\n      minBytesPerRow,\n      bytesPerRow,\n    }: {\n      expectedValue: ArrayBuffer;\n      numRows: number;\n      minBytesPerRow: number;\n      bytesPerRow: number;\n    }\n  ) {\n    const valueSize = expectedValue.byteLength;\n    assert(valueSize === 1 || valueSize === 2 || valueSize % 4 === 0);\n    assert(minBytesPerRow % valueSize === 0);\n    assert(bytesPerRow % 4 === 0);\n\n    // If the buffer is small enough, just generate the full expected buffer contents and check\n    // against them on the CPU.\n    const kMaxBufferSizeToCheckOnCpu = 256 * 1024;\n    const bufferSize = bytesPerRow * (numRows - 1) + minBytesPerRow;\n    if (bufferSize <= kMaxBufferSizeToCheckOnCpu) {\n      const valueBytes = Array.from(new Uint8Array(expectedValue));\n      const rowValues = new Array(minBytesPerRow / valueSize).fill(valueBytes);\n      const rowBytes = new Uint8Array([].concat(...rowValues));\n      const expectedContents = new Uint8Array(bufferSize);\n      range(numRows, row => expectedContents.set(rowBytes, row * bytesPerRow));\n      this.expectGPUBufferValuesEqual(buffer, expectedContents);\n      return;\n    }\n\n    // Copy into a buffer suitable for STORAGE usage.\n    const storageBuffer = this.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n    this.trackForCleanup(storageBuffer);\n\n    // This buffer conveys the data we expect to see for a single value read. Since we read 32 bits at\n    // a time, for values smaller than 32 bits we pad this expectation with repeated value data, or\n    // with zeroes if the width of a row in the buffer is less than 4 bytes. For value sizes larger\n    // than 32 bits, we assume they're a multiple of 32 bits and expect to read exact matches of\n    // `expectedValue` as-is.\n    const expectedDataSize = Math.max(4, valueSize);\n    const expectedDataBuffer = this.device.createBuffer({\n      size: expectedDataSize,\n      usage: GPUBufferUsage.STORAGE,\n      mappedAtCreation: true,\n    });\n    this.trackForCleanup(expectedDataBuffer);\n    const expectedData = new Uint32Array(expectedDataBuffer.getMappedRange());\n    if (valueSize === 1) {\n      const value = new Uint8Array(expectedValue)[0];\n      const values = new Array(Math.min(4, minBytesPerRow)).fill(value);\n      const padding = new Array(Math.max(0, 4 - values.length)).fill(0);\n      const expectedBytes = new Uint8Array(expectedData.buffer);\n      expectedBytes.set([...values, ...padding]);\n    } else if (valueSize === 2) {\n      const value = new Uint16Array(expectedValue)[0];\n      const expectedWords = new Uint16Array(expectedData.buffer);\n      expectedWords.set([value, minBytesPerRow > 2 ? value : 0]);\n    } else {\n      expectedData.set(new Uint32Array(expectedValue));\n    }\n    expectedDataBuffer.unmap();\n\n    // The output buffer has one 32-bit entry per buffer row. An entry's value will be 1 if every\n    // read from the corresponding row matches the expected data derived above, or 0 otherwise.\n    const resultBuffer = this.device.createBuffer({\n      size: numRows * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n    this.trackForCleanup(resultBuffer);\n\n    const readsPerRow = Math.ceil(minBytesPerRow / expectedDataSize);\n    const reducer = `\n    struct Buffer { data: array<u32>, };\n    @group(0) @binding(0) var<storage, read> expected: Buffer;\n    @group(0) @binding(1) var<storage, read> in: Buffer;\n    @group(0) @binding(2) var<storage, read_write> out: Buffer;\n    @compute @workgroup_size(1) fn reduce(\n        @builtin(global_invocation_id) id: vec3<u32>) {\n      let rowBaseIndex = id.x * ${bytesPerRow / 4}u;\n      let readSize = ${expectedDataSize / 4}u;\n      out.data[id.x] = 1u;\n      for (var i: u32 = 0u; i < ${readsPerRow}u; i = i + 1u) {\n        let elementBaseIndex = rowBaseIndex + i * readSize;\n        for (var j: u32 = 0u; j < readSize; j = j + 1u) {\n          if (in.data[elementBaseIndex + j] != expected.data[j]) {\n            out.data[id.x] = 0u;\n            return;\n          }\n        }\n      }\n    }\n    `;\n\n    const pipeline = this.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: this.device.createShaderModule({ code: reducer }),\n        entryPoint: 'reduce',\n      },\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: expectedDataBuffer } },\n        { binding: 1, resource: { buffer: storageBuffer } },\n        { binding: 2, resource: { buffer: resultBuffer } },\n      ],\n    });\n\n    const commandEncoder = this.device.createCommandEncoder();\n    commandEncoder.copyBufferToBuffer(buffer, 0, storageBuffer, 0, bufferSize);\n    const pass = commandEncoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(numRows);\n    pass.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n\n    const expectedResults = new Array(numRows).fill(1);\n    this.expectGPUBufferValuesEqual(resultBuffer, new Uint32Array(expectedResults));\n  }\n\n  // MAINTENANCE_TODO: add an expectContents for textures, which logs data: uris on failure\n\n  /**\n   * Expect a whole GPUTexture to have the single provided color.\n   */\n  expectSingleColor(\n    src: GPUTexture,\n    format: GPUTextureFormat,\n    {\n      size,\n      exp,\n      dimension = '2d',\n      slice = 0,\n      layout,\n    }: {\n      size: [number, number, number];\n      exp: PerTexelComponent<number>;\n      dimension?: GPUTextureDimension;\n      slice?: number;\n      layout?: TextureLayoutOptions;\n    }\n  ): void {\n    format = resolvePerAspectFormat(format, layout?.aspect);\n    const { byteLength, minBytesPerRow, bytesPerRow, rowsPerImage, mipSize } = getTextureCopyLayout(\n      format,\n      dimension,\n      size,\n      layout\n    );\n\n    const rep = kTexelRepresentationInfo[format as EncodableTextureFormat];\n    const expectedTexelData = rep.pack(rep.encode(exp));\n\n    const buffer = this.device.createBuffer({\n      size: byteLength,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    this.trackForCleanup(buffer);\n\n    const commandEncoder = this.device.createCommandEncoder();\n    commandEncoder.copyTextureToBuffer(\n      {\n        texture: src,\n        mipLevel: layout?.mipLevel,\n        origin: { x: 0, y: 0, z: slice },\n        aspect: layout?.aspect,\n      },\n      { buffer, bytesPerRow, rowsPerImage },\n      mipSize\n    );\n    this.queue.submit([commandEncoder.finish()]);\n\n    this.expectGPUBufferRepeatsSingleValue(buffer, {\n      expectedValue: expectedTexelData,\n      numRows: rowsPerImage,\n      minBytesPerRow,\n      bytesPerRow,\n    });\n  }\n\n  /** Return a GPUBuffer that data are going to be written into. */\n  private readSinglePixelFrom2DTexture(\n    src: GPUTexture,\n    format: SizedTextureFormat,\n    { x, y }: { x: number; y: number },\n    { slice = 0, layout }: { slice?: number; layout?: TextureLayoutOptions }\n  ): GPUBuffer {\n    const { byteLength, bytesPerRow, rowsPerImage } = getTextureSubCopyLayout(\n      format,\n      [1, 1],\n      layout\n    );\n    const buffer = this.device.createBuffer({\n      size: byteLength,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    this.trackForCleanup(buffer);\n\n    const commandEncoder = this.device.createCommandEncoder();\n    commandEncoder.copyTextureToBuffer(\n      { texture: src, mipLevel: layout?.mipLevel, origin: { x, y, z: slice } },\n      { buffer, bytesPerRow, rowsPerImage },\n      [1, 1]\n    );\n    this.queue.submit([commandEncoder.finish()]);\n\n    return buffer;\n  }\n\n  /**\n   * Expect a single pixel of a 2D texture to have a particular byte representation.\n   *\n   * MAINTENANCE_TODO: Add check for values of depth/stencil, probably through sampling of shader\n   * MAINTENANCE_TODO: Can refactor this and expectSingleColor to use a similar base expect\n   */\n  expectSinglePixelIn2DTexture(\n    src: GPUTexture,\n    format: SizedTextureFormat,\n    { x, y }: { x: number; y: number },\n    {\n      exp,\n      slice = 0,\n      layout,\n      generateWarningOnly = false,\n    }: {\n      exp: Uint8Array;\n      slice?: number;\n      layout?: TextureLayoutOptions;\n      generateWarningOnly?: boolean;\n    }\n  ): void {\n    const buffer = this.readSinglePixelFrom2DTexture(src, format, { x, y }, { slice, layout });\n    this.expectGPUBufferValuesEqual(buffer, exp, 0, {\n      mode: generateWarningOnly ? 'warn' : 'fail',\n    });\n  }\n\n  /**\n   * Take a single pixel of a 2D texture, interpret it using a TypedArray of the `expected` type,\n   * and expect each value in that array to be between the corresponding \"expected\" values\n   * (either `a[i] <= actual[i] <= b[i]` or `a[i] >= actual[i] => b[i]`).\n   */\n  expectSinglePixelBetweenTwoValuesIn2DTexture(\n    src: GPUTexture,\n    format: SizedTextureFormat,\n    { x, y }: { x: number; y: number },\n    {\n      exp,\n      slice = 0,\n      layout,\n      generateWarningOnly = false,\n      checkElementsBetweenFn = (act, [a, b]) => checkElementsBetween(act, [i => a[i], i => b[i]]),\n    }: {\n      exp: [TypedArrayBufferView, TypedArrayBufferView];\n      slice?: number;\n      layout?: TextureLayoutOptions;\n      generateWarningOnly?: boolean;\n      checkElementsBetweenFn?: (\n        actual: TypedArrayBufferView,\n        expected: readonly [TypedArrayBufferView, TypedArrayBufferView]\n      ) => Error | undefined;\n    }\n  ): void {\n    assert(exp[0].constructor === exp[1].constructor);\n    const constructor = exp[0].constructor as TypedArrayBufferViewConstructor;\n    assert(exp[0].length === exp[1].length);\n    const typedLength = exp[0].length;\n\n    const buffer = this.readSinglePixelFrom2DTexture(src, format, { x, y }, { slice, layout });\n    this.expectGPUBufferValuesPassCheck(buffer, a => checkElementsBetweenFn(a, exp), {\n      type: constructor,\n      typedLength,\n      mode: generateWarningOnly ? 'warn' : 'fail',\n    });\n  }\n\n  /**\n   * Equivalent to {@link expectSinglePixelBetweenTwoValuesIn2DTexture} but uses a special check func\n   * to interpret incoming values as float16\n   */\n  expectSinglePixelBetweenTwoValuesFloat16In2DTexture(\n    src: GPUTexture,\n    format: SizedTextureFormat,\n    { x, y }: { x: number; y: number },\n    {\n      exp,\n      slice = 0,\n      layout,\n      generateWarningOnly = false,\n    }: {\n      exp: [Uint16Array, Uint16Array];\n      slice?: number;\n      layout?: TextureLayoutOptions;\n      generateWarningOnly?: boolean;\n    }\n  ): void {\n    this.expectSinglePixelBetweenTwoValuesIn2DTexture(\n      src,\n      format,\n      { x, y },\n      {\n        exp,\n        slice,\n        layout,\n        generateWarningOnly,\n        checkElementsBetweenFn: checkElementsFloat16Between,\n      }\n    );\n  }\n\n  /**\n   * Expect the specified WebGPU error to be generated when running the provided function.\n   */\n  expectGPUError<R>(filter: GPUErrorFilter, fn: () => R, shouldError: boolean = true): R {\n    // If no error is expected, we let the scope surrounding the test catch it.\n    if (!shouldError) {\n      return fn();\n    }\n\n    this.device.pushErrorScope(filter);\n    const returnValue = fn();\n    const promise = this.device.popErrorScope();\n\n    this.eventualAsyncExpectation(async niceStack => {\n      const error = await promise;\n\n      let failed = false;\n      switch (filter) {\n        case 'out-of-memory':\n          failed = !(error instanceof GPUOutOfMemoryError);\n          break;\n        case 'validation':\n          failed = !(error instanceof GPUValidationError);\n          break;\n      }\n\n      if (failed) {\n        niceStack.message = `Expected ${filter} error`;\n        this.rec.expectationFailed(niceStack);\n      } else {\n        niceStack.message = `Captured ${filter} error`;\n        if (error instanceof GPUValidationError) {\n          niceStack.message += ` - ${error.message}`;\n        }\n        this.rec.debug(niceStack);\n      }\n    });\n\n    return returnValue;\n  }\n\n  /**\n   * Expect a validation error inside the callback.\n   *\n   * Tests should always do just one WebGPU call in the callback, to make sure that's what's tested.\n   */\n  expectValidationError(fn: () => void, shouldError: boolean = true): void {\n    // If no error is expected, we let the scope surrounding the test catch it.\n    if (shouldError) {\n      this.device.pushErrorScope('validation');\n    }\n\n    // Note: A return value is not allowed for the callback function. This is to avoid confusion\n    // about what the actual behavior would be; either of the following could be reasonable:\n    //   - Make expectValidationError async, and have it await on fn(). This causes an async split\n    //     between pushErrorScope and popErrorScope, so if the caller doesn't `await` on\n    //     expectValidationError (either accidentally or because it doesn't care to do so), then\n    //     other test code will be (nondeterministically) caught by the error scope.\n    //   - Make expectValidationError NOT await fn(), but just execute its first block (until the\n    //     first await) and return the return value (a Promise). This would be confusing because it\n    //     would look like the error scope includes the whole async function, but doesn't.\n    // If we do decide we need to return a value, we should use the latter semantic.\n    const returnValue = fn() as unknown;\n    assert(\n      returnValue === undefined,\n      'expectValidationError callback should not return a value (or be async)'\n    );\n\n    if (shouldError) {\n      const promise = this.device.popErrorScope();\n\n      this.eventualAsyncExpectation(async niceStack => {\n        const gpuValidationError = await promise;\n        if (!gpuValidationError) {\n          niceStack.message = 'Validation succeeded unexpectedly.';\n          this.rec.validationFailed(niceStack);\n        } else if (gpuValidationError instanceof GPUValidationError) {\n          niceStack.message = `Validation failed, as expected - ${gpuValidationError.message}`;\n          this.rec.debug(niceStack);\n        }\n      });\n    }\n  }\n\n  /**\n   * Expects that the device should be lost for a particular reason at the teardown of the test.\n   */\n  expectDeviceLost(reason: GPUDeviceLostReason): void {\n    assert(this.provider !== undefined, 'internal error: GPUDevice missing?');\n    this.provider.expectDeviceLost(reason);\n  }\n\n  /**\n   * Create a GPUBuffer with the specified contents and usage.\n   *\n   * MAINTENANCE_TODO: Several call sites would be simplified if this took ArrayBuffer as well.\n   */\n  makeBufferWithContents(dataArray: TypedArrayBufferView, usage: GPUBufferUsageFlags): GPUBuffer {\n    return this.trackForCleanup(makeBufferWithContents(this.device, dataArray, usage));\n  }\n\n  /**\n   * Creates a texture with the contents of a TexelView.\n   */\n  makeTextureWithContents(\n    texelView: TexelView,\n    desc: Omit<GPUTextureDescriptor, 'format'>\n  ): GPUTexture {\n    return this.trackForCleanup(makeTextureWithContents(this.device, texelView, desc));\n  }\n\n  /**\n   * Create a GPUTexture with multiple mip levels, each having the specified contents.\n   */\n  createTexture2DWithMipmaps(mipmapDataArray: TypedArrayBufferView[]): GPUTexture {\n    const format = 'rgba8unorm';\n    const mipLevelCount = mipmapDataArray.length;\n    const textureSizeMipmap0 = 1 << (mipLevelCount - 1);\n    const texture = this.device.createTexture({\n      mipLevelCount,\n      size: { width: textureSizeMipmap0, height: textureSizeMipmap0, depthOrArrayLayers: 1 },\n      format,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    });\n    this.trackForCleanup(texture);\n\n    const textureEncoder = this.device.createCommandEncoder();\n    for (let i = 0; i < mipLevelCount; i++) {\n      const { byteLength, bytesPerRow, rowsPerImage, mipSize } = getTextureCopyLayout(\n        format,\n        '2d',\n        [textureSizeMipmap0, textureSizeMipmap0, 1],\n        { mipLevel: i }\n      );\n\n      const data: Uint8Array = new Uint8Array(byteLength);\n      const mipLevelData = mipmapDataArray[i];\n      assert(rowsPerImage === mipSize[0]); // format is rgba8unorm and block size should be 1\n      for (let r = 0; r < rowsPerImage; r++) {\n        const o = r * bytesPerRow;\n        for (let c = o, end = o + mipSize[1] * 4; c < end; c += 4) {\n          data[c] = mipLevelData[0];\n          data[c + 1] = mipLevelData[1];\n          data[c + 2] = mipLevelData[2];\n          data[c + 3] = mipLevelData[3];\n        }\n      }\n      const buffer = this.makeBufferWithContents(\n        data,\n        GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n      );\n\n      textureEncoder.copyBufferToTexture(\n        { buffer, bytesPerRow, rowsPerImage },\n        { texture, mipLevel: i, origin: [0, 0, 0] },\n        mipSize\n      );\n    }\n    this.device.queue.submit([textureEncoder.finish()]);\n\n    return texture;\n  }\n\n  /**\n   * Returns a GPUCommandEncoder, GPUComputePassEncoder, GPURenderPassEncoder, or\n   * GPURenderBundleEncoder, and a `finish` method returning a GPUCommandBuffer.\n   * Allows testing methods which have the same signature across multiple encoder interfaces.\n   *\n   * @example\n   * ```\n   * g.test('popDebugGroup')\n   *   .params(u => u.combine('encoderType', kEncoderTypes))\n   *   .fn(t => {\n   *     const { encoder, finish } = t.createEncoder(t.params.encoderType);\n   *     encoder.popDebugGroup();\n   *   });\n   *\n   * g.test('writeTimestamp')\n   *   .params(u => u.combine('encoderType', ['non-pass', 'compute pass', 'render pass'] as const)\n   *   .fn(t => {\n   *     const { encoder, finish } = t.createEncoder(t.params.encoderType);\n   *     // Encoder type is inferred, so `writeTimestamp` can be used even though it doesn't exist\n   *     // on GPURenderBundleEncoder.\n   *     encoder.writeTimestamp(args);\n   *   });\n   * ```\n   */\n  createEncoder<T extends EncoderType>(\n    encoderType: T,\n    {\n      attachmentInfo,\n      occlusionQuerySet,\n    }: {\n      attachmentInfo?: GPURenderBundleEncoderDescriptor;\n      occlusionQuerySet?: GPUQuerySet;\n    } = {}\n  ): CommandBufferMaker<T> {\n    const fullAttachmentInfo = {\n      // Defaults if not overridden:\n      colorFormats: ['rgba8unorm'],\n      sampleCount: 1,\n      // Passed values take precedent.\n      ...attachmentInfo,\n    } as const;\n\n    switch (encoderType) {\n      case 'non-pass': {\n        const encoder = this.device.createCommandEncoder();\n\n        return new CommandBufferMaker(this, encoder, () => {\n          return encoder.finish();\n        });\n      }\n      case 'render bundle': {\n        const device = this.device;\n        const rbEncoder = device.createRenderBundleEncoder(fullAttachmentInfo);\n        const pass = this.createEncoder('render pass', { attachmentInfo });\n\n        return new CommandBufferMaker(this, rbEncoder, () => {\n          pass.encoder.executeBundles([rbEncoder.finish()]);\n          return pass.finish();\n        });\n      }\n      case 'compute pass': {\n        const commandEncoder = this.device.createCommandEncoder();\n        const encoder = commandEncoder.beginComputePass();\n\n        return new CommandBufferMaker(this, encoder, () => {\n          encoder.end();\n          return commandEncoder.finish();\n        });\n      }\n      case 'render pass': {\n        const makeAttachmentView = (format: GPUTextureFormat) =>\n          this.trackForCleanup(\n            this.device.createTexture({\n              size: [16, 16, 1],\n              format,\n              usage: GPUTextureUsage.RENDER_ATTACHMENT,\n              sampleCount: fullAttachmentInfo.sampleCount,\n            })\n          ).createView();\n\n        let depthStencilAttachment: GPURenderPassDepthStencilAttachment | undefined = undefined;\n        if (fullAttachmentInfo.depthStencilFormat !== undefined) {\n          depthStencilAttachment = {\n            view: makeAttachmentView(fullAttachmentInfo.depthStencilFormat),\n            depthReadOnly: fullAttachmentInfo.depthReadOnly,\n            stencilReadOnly: fullAttachmentInfo.stencilReadOnly,\n          };\n          if (\n            kTextureFormatInfo[fullAttachmentInfo.depthStencilFormat].depth &&\n            !fullAttachmentInfo.depthReadOnly\n          ) {\n            depthStencilAttachment.depthClearValue = 0;\n            depthStencilAttachment.depthLoadOp = 'clear';\n            depthStencilAttachment.depthStoreOp = 'discard';\n          }\n          if (\n            kTextureFormatInfo[fullAttachmentInfo.depthStencilFormat].stencil &&\n            !fullAttachmentInfo.stencilReadOnly\n          ) {\n            depthStencilAttachment.stencilClearValue = 1;\n            depthStencilAttachment.stencilLoadOp = 'clear';\n            depthStencilAttachment.stencilStoreOp = 'discard';\n          }\n        }\n        const passDesc: GPURenderPassDescriptor = {\n          colorAttachments: Array.from(fullAttachmentInfo.colorFormats, format =>\n            format\n              ? {\n                  view: makeAttachmentView(format),\n                  clearValue: [0, 0, 0, 0],\n                  loadOp: 'clear',\n                  storeOp: 'store',\n                }\n              : null\n          ),\n          depthStencilAttachment,\n          occlusionQuerySet,\n        };\n\n        const commandEncoder = this.device.createCommandEncoder();\n        const encoder = commandEncoder.beginRenderPass(passDesc);\n        return new CommandBufferMaker(this, encoder, () => {\n          encoder.end();\n          return commandEncoder.finish();\n        });\n      }\n    }\n    unreachable();\n  }\n}\n"],"mappings":"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"}