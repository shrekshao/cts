{"version":3,"sources":["../../../../../src/webgpu/api/operation/vertex_state/correctness.spec.ts"],"names":["description","makeTestGroup","unreachable","kMaxVertexAttributes","kMaxVertexBufferArrayStride","kMaxVertexBuffers","kVertexFormatInfo","kVertexFormats","GPUTest","float32ToFloat16Bits","normalizedIntegerAsFloat","align","clamp","mapBufferAttribs","buffer","f","newAttributes","a","attributes","push","shaderLocation","mapStateAttribs","buffers","map","b","VertexStateTest","makeTestWGSL","vertexCount","instanceCount","vsInputs","vsChecks","vsBindings","format","shaderComponentCount","componentCount","i","shaderType","shaderBaseType","maxCount","indexBuiltin","stepMode","component","expected","attribComponent","providedData","type","floatTolerance","makeTestPipeline","module","device","createShaderModule","code","bufferLayouts","slot","createRenderPipeline","vertex","entryPoint","primitive","topology","fragment","targets","submitRenderPass","pipeline","expectedData","testTexture","createTexture","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","COPY_SRC","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","view","createView","loadValue","storeOp","setPipeline","setBindGroup","setVertexBuffer","vbOffset","draw","endPass","queue","submit","finish","expectSingleColor","exp","R","generateTestData","formatInfo","bitSize","bytesPerComponent","data","Float32Array","vertexData","Uint16Array","testComponentCount","length","Math","pow","Int32Array","Int16Array","Int8Array","Uint32Array","Uint8Array","v","expandTestData","vertexComponentSize","byteLength","expectedComponentSize","expandedVertexData","expandedExpectedData","index","targetVertexOffset","sourceVertexOffset","set","targetExpectedOffset","sourceExpectedOffset","interleaveVertexDataInto","target","source","targetStride","offset","t","sourceOffset","targetOffset","createPipelineAndTestData","state","pipelineAndTestState","attrib","testData","createExpectedBG","bgEntries","expectedDataBuffer","makeBufferWithContents","GPUBufferUsage","UNIFORM","binding","resource","createBindGroup","layout","getBindGroupLayout","entries","createVertexBuffers","vertexBuffers","ArrayBuffer","arrayStride","fill","VERTEX","runTest","expectedDataBG","g","test","desc","params","u","combine","beginSubcases","fn","expand","p","componentSize","formatSize","Set","min","max","paramsSubcasesOnly","stepModes"],"mappings":"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","sourcesContent":["export const description = `\n\nTODO: check overlap with api,operation,rendering,draw:vertex_attributes,basic before implementing\n\n- Tests that render N points, using a generated pipeline with:\n  (1) a vertex shader that has necessary vertex inputs and a static array of\n  expected data (as indexed by vertexID + instanceID * verticesPerInstance),\n  which checks they're equal and sends the bool to the fragment shader;\n  (2) a fragment shader which writes the result out to a storage buffer\n  (or renders a red/green fragment if we can't do fragmentStoresAndAtomics,\n  maybe with some depth or stencil test magic to do the '&&' of all fragments).\n    - Fill some GPUBuffers with testable data, e.g.\n      [[1.0, 2.0, ...], [-1.0, -2.0, ...]], for use as vertex buffers.\n    - With no/trivial indexing\n        - Either non-indexed, or indexed with a passthrough index buffer ([0, 1, 2, ...])\n            - Of either format\n            - If non-indexed, index format has no effect\n        - Vertex data is read from the buffer correctly\n            - Several vertex buffers with several attributes each\n                - Two setVertexBuffers pointing at the same GPUBuffer (if possible)\n                    - Overlapping, non-overlapping\n                - Overlapping attributes (iff that's supposed to work)\n                - Overlapping vertex buffer elements\n                  (an attribute offset + its size > arrayStride)\n                  (iff that's supposed to work)\n                - Discontiguous vertex buffer slots, e.g.\n                  [1, some large number (API doesn't practically allow huge numbers here)]\n                - Discontiguous shader locations, e.g.\n                  [2, some large number (max if possible)]\n             - Bind everything possible up to limits\n                 - Also with maxed out attributes?\n             - x= all vertex formats\n        - Maybe a test of one buffer with two attributes, with every possible\n          pair of vertex formats\n    - With indexing. For each index format:\n        - Indices are read from the buffer correctly\n            - setIndexBuffer offset\n        - For each vertex format:\n            - Basic test with several vertex buffers and several attributes\n\nTODO: Test more corner case values for Float16 / Float32 (INF, NaN, +-0, ...) and reduce the\nfloat tolerance.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { unreachable } from '../../../../common/util/util.js';\nimport {\n  kMaxVertexAttributes,\n  kMaxVertexBufferArrayStride,\n  kMaxVertexBuffers,\n  kVertexFormatInfo,\n  kVertexFormats,\n} from '../../../capability_info.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { float32ToFloat16Bits, normalizedIntegerAsFloat } from '../../../util/conversion.js';\nimport { align, clamp } from '../../../util/math.js';\n\n// These types mirror the structure of GPUVertexBufferLayout but allow defining the extra\n// dictionary members at the GPUVertexBufferLayout and GPUVertexAttribute level. The are used\n// like so:\n//\n//   VertexState<{arrayStride: number}, {format: VertexFormat}>\n//   VertexBuffer<{arrayStride: number}, {format: VertexFormat}>\n//   VertexAttrib<{format: VertexFormat}>\ntype VertexAttrib<A> = A & { shaderLocation: number };\ntype VertexBuffer<V, A> = V & {\n  slot: number;\n  attributes: VertexAttrib<A>[];\n};\ntype VertexState<V, A> = VertexBuffer<V, A>[];\n\ntype VertexLayoutState<V, A> = VertexState<\n  { stepMode: GPUInputStepMode; arrayStride: number } & V,\n  { format: GPUVertexFormat; offset: number } & A\n>;\n\nfunction mapBufferAttribs<V, A1, A2>(\n  buffer: VertexBuffer<V, A1>,\n  f: (v: V, a: VertexAttrib<A1>) => A2\n): VertexBuffer<V, A2> {\n  const newAttributes: VertexAttrib<A2>[] = [];\n  for (const a of buffer.attributes) {\n    newAttributes.push({\n      shaderLocation: a.shaderLocation,\n      ...f(buffer, a),\n    });\n  }\n\n  return { ...buffer, attributes: newAttributes };\n}\n\nfunction mapStateAttribs<V, A1, A2>(\n  buffers: VertexState<V, A1>,\n  f: (v: V, a: VertexAttrib<A1>) => A2\n): VertexState<V, A2> {\n  return buffers.map(b => mapBufferAttribs(b, f));\n}\n\ntype TestData = {\n  shaderBaseType: string;\n  floatTolerance?: number;\n  // The number of vertex components in the vertexData (expectedData might contain more because\n  // it is padded to 4 components).\n  testComponentCount: number;\n  // The data that will be in the uniform buffer and used to check the vertex inputs.\n  expectedData: ArrayBuffer;\n  // The data that will be in the vertex buffer.\n  vertexData: ArrayBuffer;\n};\n\nclass VertexStateTest extends GPUTest {\n  // Generate for VS + FS (entrypoints vsMain / fsMain) that for each attribute will check that its\n  // value corresponds to what's expected (as provided by a uniform buffer per attribute) and then\n  // renders each vertex at position (vertexIndex, instanceindex) with either 1 (success) or\n  // a negative number corresponding to the check number (in case you need to debug a failure).\n  makeTestWGSL(\n    buffers: VertexState<\n      { stepMode: GPUInputStepMode },\n      {\n        format: GPUVertexFormat;\n        shaderBaseType: string;\n        shaderComponentCount?: number;\n        floatTolerance?: number;\n      }\n    >,\n    vertexCount: number,\n    instanceCount: number\n  ): string {\n    let vsInputs = '';\n    let vsChecks = '';\n    let vsBindings = '';\n\n    for (const b of buffers) {\n      for (const a of b.attributes) {\n        const format = kVertexFormatInfo[a.format];\n        const shaderComponentCount = a.shaderComponentCount ?? format.componentCount;\n        const i = a.shaderLocation;\n\n        // shaderType is either a scalar type like f32 or a vecN<scalarType>\n        let shaderType = a.shaderBaseType;\n        if (shaderComponentCount !== 1) {\n          shaderType = `vec${shaderComponentCount}<${shaderType}>`;\n        }\n\n        let maxCount = `${vertexCount}`;\n        let indexBuiltin = `input.vertexIndex`;\n        if (b.stepMode === 'instance') {\n          maxCount = `${instanceCount}`;\n          indexBuiltin = `input.instanceIndex`;\n        }\n\n        vsInputs += `  [[location(${i})]] attrib${i} : ${shaderType};\\n`;\n        vsBindings += `[[block]] struct S${i} { data : array<vec4<${a.shaderBaseType}>, ${maxCount}>; };\\n`;\n        vsBindings += `[[group(0), binding(${i})]] var<uniform> providedData${i} : S${i};\\n`;\n\n        // Generate the all the checks for the attributes.\n        for (let component = 0; component < shaderComponentCount; component++) {\n          // Components are filled with (0, 0, 0, 1) if they aren't provided data from the pipeline.\n          if (component >= format.componentCount) {\n            const expected = component === 3 ? '1' : '0';\n            vsChecks += `  check(input.attrib${i}[${component}] == ${a.shaderBaseType}(${expected}));\\n`;\n            continue;\n          }\n\n          // Check each component individually, with special handling of tolerance for floats.\n          const attribComponent =\n            shaderComponentCount === 1 ? `input.attrib${i}` : `input.attrib${i}[${component}]`;\n          const providedData = `providedData${i}.data[${indexBuiltin}][${component}]`;\n          if (format.type === 'uint' || format.type === 'sint') {\n            vsChecks += `  check(${attribComponent} == ${providedData});\\n`;\n          } else {\n            vsChecks += `  check(floatsSimilar(${attribComponent}, ${providedData}, f32(${\n              a.floatTolerance ?? 0\n            })));\\n`;\n          }\n        }\n      }\n    }\n\n    return `\nstruct Inputs {\n${vsInputs}\n  [[builtin(vertex_index)]] vertexIndex: u32;\n  [[builtin(instance_index)]] instanceIndex: u32;\n};\n\n${vsBindings}\n\nvar<private> vsResult : i32 = 1;\nvar<private> checkIndex : i32 = 0;\nfn check(success : bool) {\n  if (!success) {\n    vsResult = -checkIndex;\n  }\n  checkIndex = checkIndex + 1;\n}\n\nfn floatsSimilar(a : f32, b : f32, tolerance : f32) -> bool {\n  if (isNan(a) && isNan(b)) {\n    return true;\n  }\n\n  if (isInf(a) && isInf(b) && sign(a) == sign(b)) {\n    return true;\n  }\n\n  if (isInf(a) || isInf(b)) {\n    return false;\n  }\n\n  // TODO do we check for + and - 0?\n  return abs(a - b) < tolerance;\n}\n\nfn doTest(input : Inputs) {\n${vsChecks}\n}\n\nstruct VSOutputs {\n  [[location(0)]] result : i32;\n  [[builtin(position)]] position : vec4<f32>;\n};\n\n[[stage(vertex)]] fn vsMain(input : Inputs) -> VSOutputs {\n  doTest(input);\n\n  // Place that point at pixel (vertexIndex, instanceIndex) in a framebuffer of size\n  // (vertexCount , instanceCount).\n  var output : VSOutputs;\n  output.position = vec4<f32>(\n    ((f32(input.vertexIndex) + 0.5) / ${vertexCount}.0 * 2.0) - 1.0,\n    ((f32(input.instanceIndex) + 0.5) / ${instanceCount}.0 * 2.0) - 1.0,\n    0.0, 1.0\n  );\n  output.result = vsResult;\n  return output;\n}\n\n[[stage(fragment)]] fn fsMain([[location(0)]] result : i32) -> [[location(0)]] i32 {\n  return result;\n}\n    `;\n  }\n\n  makeTestPipeline(\n    buffers: VertexState<\n      { stepMode: GPUInputStepMode; arrayStride: number },\n      {\n        offset: number;\n        format: GPUVertexFormat;\n        shaderBaseType: string;\n        shaderComponentCount?: number;\n        floatTolerance?: number;\n      }\n    >,\n    vertexCount: number,\n    instanceCount: number\n  ): GPURenderPipeline {\n    const module = this.device.createShaderModule({\n      code: this.makeTestWGSL(buffers, vertexCount, instanceCount),\n    });\n\n    const bufferLayouts: GPUVertexBufferLayout[] = [];\n    for (const b of buffers) {\n      bufferLayouts[b.slot] = b;\n    }\n\n    return this.device.createRenderPipeline({\n      vertex: {\n        module,\n        entryPoint: 'vsMain',\n        buffers: bufferLayouts,\n      },\n      primitive: {\n        topology: 'point-list',\n      },\n      fragment: {\n        module,\n        entryPoint: 'fsMain',\n        targets: [\n          {\n            format: 'r32sint',\n          },\n        ],\n      },\n    });\n  }\n\n  // Runs the render pass drawing points in a vertexCount*instanceCount rectangle, then check each\n  // of produced a value of 1 which means that the tests in the shader passed.\n  submitRenderPass(\n    pipeline: GPURenderPipeline,\n    buffers: VertexState<{ buffer: GPUBuffer; vbOffset?: number }, {}>,\n    expectedData: GPUBindGroup,\n    vertexCount: number,\n    instanceCount: number\n  ) {\n    const testTexture = this.device.createTexture({\n      format: 'r32sint',\n      size: [vertexCount, instanceCount],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    });\n\n    const encoder = this.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: testTexture.createView(),\n          loadValue: [0, 0, 0, 0],\n          storeOp: 'store',\n        },\n      ],\n    });\n\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, expectedData);\n    for (const buffer of buffers) {\n      pass.setVertexBuffer(buffer.slot, buffer.buffer, buffer.vbOffset ?? 0);\n    }\n    pass.draw(vertexCount, instanceCount);\n    pass.endPass();\n\n    this.device.queue.submit([encoder.finish()]);\n\n    this.expectSingleColor(testTexture, 'r32sint', {\n      size: [vertexCount, instanceCount, 1],\n      exp: { R: 1 },\n    });\n  }\n\n  // Generate TestData for the format with interesting test values.\n  // TODO cache the result on the fixture?\n  generateTestData(format: GPUVertexFormat): TestData {\n    const formatInfo = kVertexFormatInfo[format];\n    const bitSize = formatInfo.bytesPerComponent * 8;\n\n    switch (formatInfo.type) {\n      case 'float': {\n        const data = [0.0, 1.0, -1.0, 1000, 42.42, -18.7, 25.17];\n        const expectedData = new Float32Array(data).buffer;\n        const vertexData =\n          bitSize === 32\n            ? expectedData\n            : bitSize === 16\n            ? new Uint16Array(data.map(float32ToFloat16Bits)).buffer\n            : unreachable();\n\n        return {\n          shaderBaseType: 'f32',\n          testComponentCount: data.length,\n          expectedData,\n          vertexData,\n          floatTolerance: 0.05,\n        };\n      }\n\n      case 'sint': {\n        /* prettier-ignore */\n        const data = [\n          0, 1, 2, 3, 4, 5,\n          -1, -2, -3, -4, -5,\n          Math.pow(2, bitSize - 2),\n          Math.pow(2, bitSize - 1) - 1, // max value\n          -Math.pow(2, bitSize - 2),\n          -Math.pow(2, bitSize - 1), // min value\n        ];\n        const expectedData = new Int32Array(data).buffer;\n        const vertexData =\n          bitSize === 32\n            ? expectedData\n            : bitSize === 16\n            ? new Int16Array(data).buffer\n            : new Int8Array(data).buffer;\n\n        return {\n          shaderBaseType: 'i32',\n          testComponentCount: data.length,\n          expectedData,\n          vertexData,\n        };\n      }\n\n      case 'uint': {\n        /* prettier-ignore */\n        const data = [\n          0, 1, 2, 3, 4, 5,\n          Math.pow(2, bitSize - 1),\n          Math.pow(2, bitSize) - 1, // max value\n        ];\n        const expectedData = new Uint32Array(data).buffer;\n        const vertexData =\n          bitSize === 32\n            ? expectedData\n            : bitSize === 16\n            ? new Uint16Array(data).buffer\n            : new Uint8Array(data).buffer;\n\n        return {\n          shaderBaseType: 'u32',\n          testComponentCount: data.length,\n          expectedData,\n          vertexData,\n        };\n      }\n\n      case 'snorm': {\n        /* prettier-ignore */\n        const data = [\n          0, 1, 2, 3, 4, 5,\n          -1, -2, -3, -4, -5,\n          Math.pow(2,bitSize - 2),\n          Math.pow(2,bitSize - 1) - 1, // max value\n          -Math.pow(2,bitSize - 2),\n          -Math.pow(2,bitSize - 1), // min value\n        ];\n        const vertexData =\n          bitSize === 16\n            ? new Int16Array(data).buffer\n            : bitSize === 8\n            ? new Int8Array(data).buffer\n            : unreachable();\n\n        return {\n          shaderBaseType: 'f32',\n          testComponentCount: data.length,\n          expectedData: new Float32Array(data.map(v => normalizedIntegerAsFloat(v, bitSize, true)))\n            .buffer,\n          vertexData,\n          floatTolerance: 0.1 * normalizedIntegerAsFloat(1, bitSize, true),\n        };\n      }\n\n      case 'unorm': {\n        /* prettier-ignore */\n        const data = [\n          0, 1, 2, 3, 4, 5,\n          Math.pow(2, bitSize - 1),\n          Math.pow(2, bitSize) - 1, // max value\n        ];\n        const vertexData =\n          bitSize === 16\n            ? new Uint16Array(data).buffer\n            : bitSize === 8\n            ? new Uint8Array(data).buffer\n            : unreachable();\n\n        return {\n          shaderBaseType: 'f32',\n          testComponentCount: data.length,\n          expectedData: new Float32Array(data.map(v => normalizedIntegerAsFloat(v, bitSize, false)))\n            .buffer,\n          vertexData: vertexData!,\n          floatTolerance: 0.1 * normalizedIntegerAsFloat(1, bitSize, false),\n        };\n      }\n    }\n  }\n\n  // The TestData generated for a format might not contain enough data for all the vertices we are\n  // going to draw, so we expand them by adding additional copies of the vertexData as needed.\n  // expectedData is a bit different because it also needs to be unpacked to have `componentCount`\n  // components every 4 components (because the shader uses vec4 for the expected data).\n  expandTestData(data: TestData, maxCount: number, componentCount: number): TestData {\n    const vertexComponentSize = data.vertexData.byteLength / data.testComponentCount;\n    const expectedComponentSize = data.expectedData.byteLength / data.testComponentCount;\n\n    const expandedVertexData = new Uint8Array(maxCount * componentCount * vertexComponentSize);\n    const expandedExpectedData = new Uint8Array(4 * maxCount * expectedComponentSize);\n\n    for (let index = 0; index < maxCount; index++) {\n      for (let component = 0; component < componentCount; component++) {\n        // If only we had some builtin JS memcpy function between ArrayBuffers...\n        const targetVertexOffset = (index * componentCount + component) * vertexComponentSize;\n        const sourceVertexOffset = targetVertexOffset % data.vertexData.byteLength;\n        expandedVertexData.set(\n          new Uint8Array(data.vertexData, sourceVertexOffset, vertexComponentSize),\n          targetVertexOffset\n        );\n\n        const targetExpectedOffset = (index * 4 + component) * expectedComponentSize;\n        const sourceExpectedOffset =\n          ((index * componentCount + component) * expectedComponentSize) %\n          data.expectedData.byteLength;\n        expandedExpectedData.set(\n          new Uint8Array(data.expectedData, sourceExpectedOffset, expectedComponentSize),\n          targetExpectedOffset\n        );\n      }\n    }\n\n    return {\n      shaderBaseType: data.shaderBaseType,\n      testComponentCount: maxCount * componentCount,\n      floatTolerance: data.floatTolerance,\n      expectedData: expandedExpectedData.buffer,\n      vertexData: expandedVertexData.buffer,\n    };\n  }\n\n  // Copies `size` bytes from `source` to `target` starting at `offset` each `targetStride`.\n  // (the data in `source` is assumed packed)\n  interleaveVertexDataInto(\n    target: ArrayBuffer,\n    source: ArrayBuffer,\n    { targetStride, offset, size }: { targetStride: number; offset: number; size: number }\n  ) {\n    const t = new Uint8Array(target);\n    for (\n      let sourceOffset = 0, targetOffset = offset;\n      sourceOffset < source.byteLength;\n      sourceOffset += size, targetOffset += targetStride\n    ) {\n      const a = new Uint8Array(source, sourceOffset, size);\n      t.set(a, targetOffset);\n    }\n  }\n\n  createPipelineAndTestData<V, A>(\n    state: VertexLayoutState<V, A>,\n    vertexCount: number,\n    instanceCount: number\n  ): {\n    pipeline: GPURenderPipeline;\n    testData: VertexLayoutState<V, A & TestData>;\n  } {\n    // Gather the test data and some additional test state for attribs.\n    const pipelineAndTestState = mapStateAttribs(state, (buffer, attrib) => {\n      const maxCount = buffer.stepMode === 'instance' ? instanceCount : vertexCount;\n      const formatInfo = kVertexFormatInfo[attrib.format];\n\n      let testData = this.generateTestData(attrib.format);\n      // TODO this will not work for arrayStride 0\n      testData = this.expandTestData(testData, maxCount, formatInfo.componentCount);\n\n      return {\n        ...testData,\n        ...attrib,\n      };\n    });\n\n    // Create the pipeline from the test data.\n    return {\n      testData: pipelineAndTestState,\n      pipeline: this.makeTestPipeline(pipelineAndTestState, vertexCount, instanceCount),\n    };\n  }\n\n  createExpectedBG(state: VertexState<{}, TestData>, pipeline: GPURenderPipeline): GPUBindGroup {\n    // Create the bindgroups from that test data\n    const bgEntries: GPUBindGroupEntry[] = [];\n\n    for (const buffer of state) {\n      for (const attrib of buffer.attributes) {\n        const expectedDataBuffer = this.makeBufferWithContents(\n          new Uint8Array(attrib.expectedData),\n          GPUBufferUsage.UNIFORM\n        );\n        bgEntries.push({\n          binding: attrib.shaderLocation,\n          resource: { buffer: expectedDataBuffer },\n        });\n      }\n    }\n\n    return this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: bgEntries,\n    });\n  }\n\n  createVertexBuffers(\n    state: VertexLayoutState<{ vbOffset?: number }, TestData>,\n    vertexCount: number,\n    instanceCount: number\n  ): VertexState<{ buffer: GPUBuffer; vbOffset?: number }, {}> {\n    // Create the vertex buffers\n    const vertexBuffers: VertexState<{ buffer: GPUBuffer; vbOffset?: number }, {}> = [];\n\n    for (const buffer of state) {\n      const maxCount = buffer.stepMode === 'instance' ? instanceCount : vertexCount;\n\n      // Fill the vertex data with garbage so that we don't get `0` (which could be a test value)\n      // if the vertex shader loads the vertex data incorrectly.\n      const vertexData = new ArrayBuffer(buffer.arrayStride * maxCount + (buffer.vbOffset ?? 0));\n      new Uint8Array(vertexData).fill(0xc4);\n\n      for (const attrib of buffer.attributes) {\n        const formatInfo = kVertexFormatInfo[attrib.format];\n        this.interleaveVertexDataInto(vertexData, attrib.vertexData, {\n          targetStride: buffer.arrayStride,\n          offset: (buffer.vbOffset ?? 0) + attrib.offset,\n          size: formatInfo.componentCount * formatInfo.bytesPerComponent,\n        });\n      }\n\n      vertexBuffers.push({\n        slot: buffer.slot,\n        buffer: this.makeBufferWithContents(new Uint8Array(vertexData), GPUBufferUsage.VERTEX),\n        vbOffset: buffer.vbOffset,\n        attributes: [],\n      });\n    }\n\n    return vertexBuffers;\n  }\n\n  runTest(\n    buffers: VertexLayoutState<{ vbOffset?: number }, { shaderComponentCount?: number }>,\n    // Default to using 20 vertices and 20 instances so that we cover each of the test data at least\n    // once (at the time of writing the largest testData has 16 values).\n    vertexCount: number = 20,\n    instanceCount: number = 20\n  ) {\n    const { testData, pipeline } = this.createPipelineAndTestData(\n      buffers,\n      vertexCount,\n      instanceCount\n    );\n    const expectedDataBG = this.createExpectedBG(testData, pipeline);\n    const vertexBuffers = this.createVertexBuffers(testData, vertexCount, instanceCount);\n    this.submitRenderPass(pipeline, vertexBuffers, expectedDataBG, vertexCount, instanceCount);\n  }\n}\n\nexport const g = makeTestGroup(VertexStateTest);\n\ng.test('vertexFormat_to_shaderFormat_conversion')\n  .desc(\n    `Test that the raw data passed in vertex buffers is correctly converted to the input type in the shader. Test for:\n  - all formats\n  - 1 to 4 components in the shader's input type (unused components are filled with 0 and except the 4th with 1)\n  - various locations\n  - various slots`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .combine('shaderComponentCount', [1, 2, 3, 4])\n      .beginSubcases()\n      .combine('slot', [0, 1, kMaxVertexBuffers - 1])\n      .combine('shaderLocation', [0, 1, kMaxVertexAttributes - 1])\n  )\n  .fn(t => {\n    const { format, shaderComponentCount, slot, shaderLocation } = t.params;\n    t.runTest([\n      {\n        slot,\n        arrayStride: 16,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation,\n            format,\n            offset: 0,\n            shaderComponentCount,\n          },\n        ],\n      },\n    ]);\n  });\n\ng.test('setVertexBufferOffset_and_attributeOffset')\n  .desc(\n    `Test that the vertex buffer offset and attribute offset in the vertex state are applied correctly. Test for:\n  - all formats\n  - various setVertexBuffer offsets\n  - various attribute offsets in a fixed arrayStride`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .combine('vbOffset', [0, 4, 400, 1004])\n      .combine('arrayStride', [128])\n      .expand('offset', p => {\n        const formatInfo = kVertexFormatInfo[p.format];\n        const componentSize = formatInfo.bytesPerComponent;\n        const formatSize = componentSize * formatInfo.componentCount;\n        return [\n          0,\n          componentSize,\n          componentSize * 2,\n          componentSize * 3,\n          p.arrayStride / 2,\n          p.arrayStride - formatSize - componentSize * 3,\n          p.arrayStride - formatSize - componentSize * 2,\n          p.arrayStride - formatSize - componentSize,\n          p.arrayStride - formatSize,\n        ];\n      })\n  )\n  .fn(t => {\n    const { format, vbOffset, arrayStride, offset } = t.params;\n    t.runTest([\n      {\n        slot: 0,\n        arrayStride,\n        stepMode: 'vertex',\n        vbOffset,\n        attributes: [\n          {\n            shaderLocation: 0,\n            format,\n            offset,\n          },\n        ],\n      },\n    ]);\n  });\n\ng.test('nonZeroArrayStride_and_attributeOffset')\n  .desc(\n    `Test that the array stride and attribute offset in the vertex state are applied correctly. Test for:\n  - all formats\n  - various array strides\n  - various attribute offsets in a fixed arrayStride`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .expand('arrayStride', p => {\n        const formatInfo = kVertexFormatInfo[p.format];\n        const componentSize = formatInfo.bytesPerComponent;\n        const formatSize = componentSize * formatInfo.componentCount;\n\n        return [align(formatSize, 4), align(formatSize, 4) + 4, kMaxVertexBufferArrayStride];\n      })\n      .expand('offset', p => {\n        const formatInfo = kVertexFormatInfo[p.format];\n        const componentSize = formatInfo.bytesPerComponent;\n        const formatSize = componentSize * formatInfo.componentCount;\n        return new Set(\n          [\n            0,\n            componentSize,\n            p.arrayStride / 2,\n            p.arrayStride - formatSize - componentSize,\n            p.arrayStride - formatSize,\n          ].map(offset => clamp(offset, { min: 0, max: p.arrayStride - formatSize }))\n        );\n      })\n  )\n  .fn(t => {\n    const { format, arrayStride, offset } = t.params;\n    t.runTest([\n      {\n        slot: 0,\n        arrayStride,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: 0,\n            format,\n            offset,\n          },\n        ],\n      },\n    ]);\n  });\n\ng.test('buffersWithVaryingStepMode')\n  .desc(\n    `Test buffers with varying step modes in the same vertex state.\n  - Various combination of step modes`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('stepModes', [\n        ['instance'],\n        ['vertex', 'vertex', 'instance'],\n        ['instance', 'vertex', 'instance'],\n        ['vertex', 'instance', 'vertex', 'vertex'],\n      ])\n  )\n  .fn(t => {\n    const { stepModes } = t.params;\n    const state = (stepModes as GPUInputStepMode[]).map((stepMode, i) => ({\n      slot: i,\n      arrayStride: 4,\n      stepMode,\n      attributes: [\n        {\n          shaderLocation: i,\n          format: 'float32' as const,\n          offset: 0,\n        },\n      ],\n    }));\n    t.runTest(state);\n  });\n"],"file":"correctness.spec.js"}