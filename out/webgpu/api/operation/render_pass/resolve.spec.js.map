{"version":3,"sources":["../../../../../src/webgpu/api/operation/render_pass/resolve.spec.ts"],"names":["description","makeTestGroup","GPUTest","kSlotsToResolve","kSize","kFormat","g","test","params","u","combine","beginSubcases","fn","t","targets","i","numColorAttachments","push","format","pipeline","device","createRenderPipeline","layout","vertex","module","createShaderModule","code","entryPoint","fragment","primitive","topology","multisample","count","resolveTargets","renderPassColorAttachments","kResolveTargetSize","resolveTargetBaseMipLevel","colorAttachment","createTexture","size","width","height","depthOrArrayLayers","sampleCount","mipLevelCount","usage","GPUTextureUsage","COPY_DST","COPY_SRC","RENDER_ATTACHMENT","slotsToResolve","includes","resolveTarget","resolveTargetBaseArrayLayer","view","createView","clearValue","r","b","a","loadOp","storeOp","storeOperation","baseMipLevel","baseArrayLayer","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","setPipeline","draw","end","queue","submit","finish","expectSinglePixelIn2DTexture","x","y","exp","Uint8Array","slice","mipLevel","expectSinglePixelBetweenTwoValuesIn2DTexture"],"mappings":"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","sourcesContent":["export const description = `API Operation Tests for RenderPass StoreOp.\nTests a render pass with a resolveTarget resolves correctly for many combinations of:\n  - number of color attachments, some with and some without a resolveTarget\n  - renderPass storeOp set to {'store', 'discard'}\n  - resolveTarget mip level {0, >0} (TODO?: different mip level from colorAttachment)\n  - resolveTarget {2d array layer, TODO: 3d slice} {0, >0} with {2d, TODO: 3d} resolveTarget\n    (TODO?: different z from colorAttachment)\n  - TODO: test all renderable color formats\n  - TODO: test that any not-resolved attachments are rendered to correctly.\n  - TODO: test different loadOps\n  - TODO?: resolveTarget mip level {0, >0} (TODO?: different mip level from colorAttachment)\n  - TODO?: resolveTarget {2d array layer, TODO: 3d slice} {0, >0} with {2d, TODO: 3d} resolveTarget\n    (different z from colorAttachment)\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\nconst kSlotsToResolve = [\n  [0, 2],\n  [1, 3],\n  [0, 1, 2, 3],\n];\n\nconst kSize = 4;\nconst kFormat: GPUTextureFormat = 'rgba8unorm';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('render_pass_resolve')\n  .params(u =>\n    u\n      .combine('storeOperation', ['discard', 'store'] as const)\n      .beginSubcases()\n      .combine('numColorAttachments', [2, 4] as const)\n      .combine('slotsToResolve', kSlotsToResolve)\n      .combine('resolveTargetBaseMipLevel', [0, 1] as const)\n      .combine('resolveTargetBaseArrayLayer', [0, 1] as const)\n  )\n  .fn(t => {\n    const targets: GPUColorTargetState[] = [];\n    for (let i = 0; i < t.params.numColorAttachments; i++) {\n      targets.push({ format: kFormat });\n    }\n\n    // These shaders will draw a white triangle into a texture. After draw, the top left\n    // half of the texture will be white, and the bottom right half will be unchanged. When this\n    // texture is resolved, there will be two distinct colors in each portion of the texture, as\n    // well as a line between the portions that contain the midpoint color due to the multisample\n    // resolve.\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: t.device.createShaderModule({\n          code: `\n            @vertex fn main(\n              @builtin(vertex_index) VertexIndex : u32\n              ) -> @builtin(position) vec4<f32> {\n              var pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                  vec2<f32>(-1.0, -1.0),\n                  vec2<f32>(-1.0,  1.0),\n                  vec2<f32>( 1.0,  1.0));\n              return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: t.device.createShaderModule({\n          code: `\n            struct Output {\n              @location(0) fragColor0 : vec4<f32>,\n              @location(1) fragColor1 : vec4<f32>,\n              @location(2) fragColor2 : vec4<f32>,\n              @location(3) fragColor3 : vec4<f32>,\n            };\n\n            @fragment fn main() -> Output {\n              return Output(\n                vec4<f32>(1.0, 1.0, 1.0, 1.0),\n                vec4<f32>(1.0, 1.0, 1.0, 1.0),\n                vec4<f32>(1.0, 1.0, 1.0, 1.0),\n                vec4<f32>(1.0, 1.0, 1.0, 1.0)\n              );\n            }`,\n        }),\n        entryPoint: 'main',\n        targets,\n      },\n      primitive: { topology: 'triangle-list' },\n      multisample: { count: 4 },\n    });\n\n    const resolveTargets: GPUTexture[] = [];\n    const renderPassColorAttachments: GPURenderPassColorAttachment[] = [];\n\n    // The resolve target must be the same size as the color attachment. If we're resolving to mip\n    // level 1, the resolve target base mip level should be 2x the color attachment size.\n    const kResolveTargetSize = kSize << t.params.resolveTargetBaseMipLevel;\n\n    for (let i = 0; i < t.params.numColorAttachments; i++) {\n      const colorAttachment = t.device.createTexture({\n        format: kFormat,\n        size: { width: kSize, height: kSize, depthOrArrayLayers: 1 },\n        sampleCount: 4,\n        mipLevelCount: 1,\n        usage:\n          GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n      });\n\n      if (t.params.slotsToResolve.includes(i)) {\n        const colorAttachment = t.device.createTexture({\n          format: kFormat,\n          size: { width: kSize, height: kSize, depthOrArrayLayers: 1 },\n          sampleCount: 4,\n          mipLevelCount: 1,\n          usage:\n            GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        });\n\n        const resolveTarget = t.device.createTexture({\n          format: kFormat,\n          size: {\n            width: kResolveTargetSize,\n            height: kResolveTargetSize,\n            depthOrArrayLayers: t.params.resolveTargetBaseArrayLayer + 1,\n          },\n          sampleCount: 1,\n          mipLevelCount: t.params.resolveTargetBaseMipLevel + 1,\n          usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        });\n\n        // Clear to black for the load operation. After the draw, the top left half of the attachment\n        // will be white and the bottom right half will be black.\n        renderPassColorAttachments.push({\n          view: colorAttachment.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          loadOp: 'clear',\n          storeOp: t.params.storeOperation,\n          resolveTarget: resolveTarget.createView({\n            baseMipLevel: t.params.resolveTargetBaseMipLevel,\n            baseArrayLayer: t.params.resolveTargetBaseArrayLayer,\n          }),\n        });\n\n        resolveTargets.push(resolveTarget);\n      } else {\n        renderPassColorAttachments.push({\n          view: colorAttachment.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          loadOp: 'clear',\n          storeOp: t.params.storeOperation,\n        });\n      }\n    }\n\n    const encoder = t.device.createCommandEncoder();\n\n    const pass = encoder.beginRenderPass({\n      colorAttachments: renderPassColorAttachments,\n    });\n    pass.setPipeline(pipeline);\n    pass.draw(3);\n    pass.end();\n    t.device.queue.submit([encoder.finish()]);\n\n    // Verify the resolve targets contain the correct values.\n    for (const resolveTarget of resolveTargets) {\n      // Test top left pixel, which should be {255, 255, 255, 255}.\n      t.expectSinglePixelIn2DTexture(\n        resolveTarget,\n        kFormat,\n        { x: 0, y: 0 },\n        {\n          exp: new Uint8Array([0xff, 0xff, 0xff, 0xff]),\n          slice: t.params.resolveTargetBaseArrayLayer,\n          layout: { mipLevel: t.params.resolveTargetBaseMipLevel },\n        }\n      );\n\n      // Test bottom right pixel, which should be {0, 0, 0, 0}.\n      t.expectSinglePixelIn2DTexture(\n        resolveTarget,\n        kFormat,\n        { x: kSize - 1, y: kSize - 1 },\n        {\n          exp: new Uint8Array([0x00, 0x00, 0x00, 0x00]),\n          slice: t.params.resolveTargetBaseArrayLayer,\n          layout: { mipLevel: t.params.resolveTargetBaseMipLevel },\n        }\n      );\n\n      // Test top right pixel, which should be {127, 127, 127, 127} due to the multisampled resolve.\n      t.expectSinglePixelBetweenTwoValuesIn2DTexture(\n        resolveTarget,\n        kFormat,\n        { x: kSize - 1, y: 0 },\n        {\n          exp: [new Uint8Array([0x7f, 0x7f, 0x7f, 0x7f]), new Uint8Array([0x80, 0x80, 0x80, 0x80])],\n          slice: t.params.resolveTargetBaseArrayLayer,\n          layout: { mipLevel: t.params.resolveTargetBaseMipLevel },\n        }\n      );\n    }\n  });\n"],"file":"resolve.spec.js"}