{"version":3,"file":"sample_mask.spec.js","names":["description","makeTestGroup","assert","range","GPUTest","TextureTestMixin","checkElementsPassPredicate","checkElementsEqual","TypeF32","TypeU32","TexelView","kColors","Uint8Array","kDepthClearValue","kDepthWriteValue","kStencilClearValue","kStencilReferenceValue","format","depthStencilFormat","kRenderTargetSize","hasSample","rasterizationMask","sampleMask","fragmentShaderOutputMask","sampleIndex","getExpectedColorData","sampleCount","fragmentShaderOutputMaskOrAlphaToCoverageMask","expectedData","Float32Array","i","o","getExpectedDepthData","s","getExpectedStencilData","Uint32Array","kSampleMaskTestVertexShader","F","init","kSampleTextureSize","sampleTexture","createTextureFromTexelView","fromTexelsAsBytes","coord","id","x","y","size","usage","GPUTextureUsage","TEXTURE_BINDING","COPY_DST","RENDER_ATTACHMENT","sampler","device","createSampler","magFilter","minFilter","GetTargetTexture","pipeline","uniformBuffer","colorTargetsCount","undefined","uniformBindGroup","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","createView","buffer","renderTargetTextures","resolveTargetTextures","renderTargetTexture","createTexture","width","height","depthOrArrayLayers","mipLevelCount","push","resolveTargetTexture","COPY_SRC","depthStencilTexture","renderPassDescriptor","colorAttachments","map","index","view","resolveTarget","clearValue","r","g","b","a","loadOp","storeOp","depthStencilAttachment","depthClearValue","depthLoadOp","depthStoreOp","stencilClearValue","stencilLoadOp","stencilStoreOp","commandEncoder","createCommandEncoder","passEncoder","beginRenderPass","setPipeline","setBindGroup","setStencilReference","draw","end","queue","submit","finish","color","depthStencil","CheckColorAttachmentResult","texture","copySinglePixelTextureToBufferUsingComputePass","expected","expectGPUBufferValuesEqual","CheckDepthStencilResult","aspect","test","desc","params","u","combine","expand","p","len","beginSubcases","fn","t","fragmentMaskUniformBuffer","createBuffer","GPUBufferUsage","UNIFORM","trackForCleanup","writeBuffer","createRenderPipeline","vertex","module","createShaderModule","code","entryPoint","fragment","targets","primitive","topology","multisample","count","mask","alphaToCoverageEnabled","depthWriteEnabled","depthCompare","stencilFront","compare","passOp","stencilBack","alpha1","alphaValues","alphaValueUniformBuffer","byteLength","alpha0ParamsArray","colorResultPromises","depthResultPromises","stencilResultPromises","alpha0","colorBuffer","colorResult","readGPUBufferRangeTyped","type","typedLength","BYTES_PER_ELEMENT","depthBuffer","depthResult","stencilBuffer","stencilResult","resultsArray","Promise","all","checkResults","results","getExpectedDataFn","positiveCorrelation","length","result","check","data","expectOK","prevResult","value","cleanup"],"sources":["../../../../../src/webgpu/api/operation/render_pipeline/sample_mask.spec.ts"],"sourcesContent":["export const description = `\nTests that the final sample mask is the logical AND of all the relevant masks, including\nthe rasterization mask, sample mask, fragment output mask, and alpha to coverage mask (when alphaToCoverageEnabled === true)\n\nTODO: add a test without a 0th color attachment (sparse color attachment), with different color attachments and alpha value output.\nThe cross-platform behavior is unknown. could be any of:\n- coverage is always 100%\n- coverage is always 0%\n- it uses the first non-null attachment\n- it's an error\n\nDetails could be found at: https://github.com/gpuweb/cts/issues/2201\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, range } from '../../../../common/util/util.js';\nimport { GPUTest, TextureTestMixin } from '../../../gpu_test.js';\nimport { checkElementsPassPredicate, checkElementsEqual } from '../../../util/check_contents.js';\nimport { TypeF32, TypeU32 } from '../../../util/conversion.js';\nimport { TexelView } from '../../../util/texture/texel_view.js';\n\nconst kColors = [\n  // Red\n  new Uint8Array([0xff, 0, 0, 0xff]),\n  // Green\n  new Uint8Array([0, 0xff, 0, 0xff]),\n  // Blue\n  new Uint8Array([0, 0, 0xff, 0xff]),\n  // Yellow\n  new Uint8Array([0xff, 0xff, 0, 0xff]),\n];\n\nconst kDepthClearValue = 1.0;\nconst kDepthWriteValue = 0.0;\nconst kStencilClearValue = 0;\nconst kStencilReferenceValue = 0xff;\n\n// Format of the render target and resolve target\nconst format = 'rgba8unorm';\n\n// Format of depth stencil attachment\nconst depthStencilFormat = 'depth24plus-stencil8';\n\nconst kRenderTargetSize = 1;\n\nfunction hasSample(\n  rasterizationMask: number,\n  sampleMask: number,\n  fragmentShaderOutputMask: number,\n  sampleIndex: number = 0\n): boolean {\n  return (rasterizationMask & sampleMask & fragmentShaderOutputMask & (1 << sampleIndex)) > 0;\n}\n\nfunction getExpectedColorData(\n  sampleCount: number,\n  rasterizationMask: number,\n  sampleMask: number,\n  fragmentShaderOutputMaskOrAlphaToCoverageMask: number\n) {\n  const expectedData = new Float32Array(sampleCount * 4);\n  if (sampleCount === 1) {\n    if (hasSample(rasterizationMask, sampleMask, fragmentShaderOutputMaskOrAlphaToCoverageMask)) {\n      // Texel 3 is sampled at the pixel center\n      expectedData[0] = kColors[3][0] / 0xff;\n      expectedData[1] = kColors[3][1] / 0xff;\n      expectedData[2] = kColors[3][2] / 0xff;\n      expectedData[3] = kColors[3][3] / 0xff;\n    }\n  } else {\n    for (let i = 0; i < sampleCount; i++) {\n      if (\n        hasSample(rasterizationMask, sampleMask, fragmentShaderOutputMaskOrAlphaToCoverageMask, i)\n      ) {\n        const o = i * 4;\n        expectedData[o + 0] = kColors[i][0] / 0xff;\n        expectedData[o + 1] = kColors[i][1] / 0xff;\n        expectedData[o + 2] = kColors[i][2] / 0xff;\n        expectedData[o + 3] = kColors[i][3] / 0xff;\n      }\n    }\n  }\n  return expectedData;\n}\n\nfunction getExpectedDepthData(\n  sampleCount: number,\n  rasterizationMask: number,\n  sampleMask: number,\n  fragmentShaderOutputMaskOrAlphaToCoverageMask: number\n) {\n  const expectedData = new Float32Array(sampleCount);\n  for (let i = 0; i < sampleCount; i++) {\n    const s = hasSample(\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMaskOrAlphaToCoverageMask,\n      i\n    );\n    expectedData[i] = s ? kDepthWriteValue : kDepthClearValue;\n  }\n  return expectedData;\n}\n\nfunction getExpectedStencilData(\n  sampleCount: number,\n  rasterizationMask: number,\n  sampleMask: number,\n  fragmentShaderOutputMaskOrAlphaToCoverageMask: number\n) {\n  const expectedData = new Uint32Array(sampleCount);\n  for (let i = 0; i < sampleCount; i++) {\n    const s = hasSample(\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMaskOrAlphaToCoverageMask,\n      i\n    );\n    expectedData[i] = s ? kStencilReferenceValue : kStencilClearValue;\n  }\n  return expectedData;\n}\n\nconst kSampleMaskTestVertexShader = `\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) @interpolate(perspective, sample) fragUV : vec2<f32>,\n}\n\n@vertex\nfn main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n  var pos = array<vec2<f32>, 30>(\n      // center quad\n      // only covers pixel center which is sample point when sampleCount === 1\n      // small enough to avoid covering any multi sample points\n      vec2<f32>( 0.2,  0.2),\n      vec2<f32>( 0.2, -0.2),\n      vec2<f32>(-0.2, -0.2),\n      vec2<f32>( 0.2,  0.2),\n      vec2<f32>(-0.2, -0.2),\n      vec2<f32>(-0.2,  0.2),\n\n      // Sub quads are representing rasterization mask and\n      // are slightly scaled to avoid covering the pixel center\n\n      // top-left quad\n      vec2<f32>( -0.01, 1.0),\n      vec2<f32>( -0.01, 0.01),\n      vec2<f32>(-1.0, 0.01),\n      vec2<f32>( -0.01, 1.0),\n      vec2<f32>(-1.0, 0.01),\n      vec2<f32>(-1.0, 1.0),\n\n      // top-right quad\n      vec2<f32>(1.0, 1.0),\n      vec2<f32>(1.0, 0.01),\n      vec2<f32>(0.01, 0.01),\n      vec2<f32>(1.0, 1.0),\n      vec2<f32>(0.01, 0.01),\n      vec2<f32>(0.01, 1.0),\n\n      // bottom-left quad\n      vec2<f32>( -0.01,  -0.01),\n      vec2<f32>( -0.01, -1.0),\n      vec2<f32>(-1.0, -1.0),\n      vec2<f32>( -0.01,  -0.01),\n      vec2<f32>(-1.0, -1.0),\n      vec2<f32>(-1.0,  -0.01),\n\n      // bottom-right quad\n      vec2<f32>(1.0,  -0.01),\n      vec2<f32>(1.0, -1.0),\n      vec2<f32>(0.01, -1.0),\n      vec2<f32>(1.0,  -0.01),\n      vec2<f32>(0.01, -1.0),\n      vec2<f32>(0.01,  -0.01)\n    );\n\n  var uv = array<vec2<f32>, 30>(\n      // center quad\n      vec2<f32>(1.0, 0.0),\n      vec2<f32>(1.0, 1.0),\n      vec2<f32>(0.0, 1.0),\n      vec2<f32>(1.0, 0.0),\n      vec2<f32>(0.0, 1.0),\n      vec2<f32>(0.0, 0.0),\n\n      // top-left quad (texel 0)\n      vec2<f32>(0.5, 0.0),\n      vec2<f32>(0.5, 0.5),\n      vec2<f32>(0.0, 0.5),\n      vec2<f32>(0.5, 0.0),\n      vec2<f32>(0.0, 0.5),\n      vec2<f32>(0.0, 0.0),\n\n      // top-right quad (texel 1)\n      vec2<f32>(1.0, 0.0),\n      vec2<f32>(1.0, 0.5),\n      vec2<f32>(0.5, 0.5),\n      vec2<f32>(1.0, 0.0),\n      vec2<f32>(0.5, 0.5),\n      vec2<f32>(0.5, 0.0),\n\n      // bottom-left quad (texel 2)\n      vec2<f32>(0.5, 0.5),\n      vec2<f32>(0.5, 1.0),\n      vec2<f32>(0.0, 1.0),\n      vec2<f32>(0.5, 0.5),\n      vec2<f32>(0.0, 1.0),\n      vec2<f32>(0.0, 0.5),\n\n      // bottom-right quad (texel 3)\n      vec2<f32>(1.0, 0.5),\n      vec2<f32>(1.0, 1.0),\n      vec2<f32>(0.5, 1.0),\n      vec2<f32>(1.0, 0.5),\n      vec2<f32>(0.5, 1.0),\n      vec2<f32>(0.5, 0.5)\n    );\n\n  var output : VertexOutput;\n  output.Position = vec4<f32>(pos[VertexIndex], ${kDepthWriteValue}, 1.0);\n  output.fragUV = uv[VertexIndex];\n  return output;\n}`;\n\nclass F extends TextureTestMixin(GPUTest) {\n  private sampleTexture: GPUTexture | undefined;\n  private sampler: GPUSampler | undefined;\n\n  async init() {\n    await super.init();\n    // Create a 2x2 color texture to sample from\n    // texel 0 - Red\n    // texel 1 - Green\n    // texel 2 - Blue\n    // texel 3 - Yellow\n    const kSampleTextureSize = 2;\n    this.sampleTexture = this.createTextureFromTexelView(\n      TexelView.fromTexelsAsBytes(format, coord => {\n        const id = coord.x + coord.y * kSampleTextureSize;\n        return kColors[id];\n      }),\n      {\n        size: [kSampleTextureSize, kSampleTextureSize, 1],\n        usage:\n          GPUTextureUsage.TEXTURE_BINDING |\n          GPUTextureUsage.COPY_DST |\n          GPUTextureUsage.RENDER_ATTACHMENT,\n      }\n    );\n\n    this.sampler = this.device.createSampler({\n      magFilter: 'nearest',\n      minFilter: 'nearest',\n    });\n  }\n\n  GetTargetTexture(\n    sampleCount: number,\n    rasterizationMask: number,\n    pipeline: GPURenderPipeline,\n    uniformBuffer: GPUBuffer,\n    colorTargetsCount: number = 1\n  ): { color: GPUTexture; depthStencil: GPUTexture } {\n    assert(this.sampleTexture !== undefined);\n    assert(this.sampler !== undefined);\n\n    const uniformBindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: this.sampler,\n        },\n        {\n          binding: 1,\n          resource: this.sampleTexture.createView(),\n        },\n        {\n          binding: 2,\n          resource: {\n            buffer: uniformBuffer,\n          },\n        },\n      ],\n    });\n\n    const renderTargetTextures = [];\n    const resolveTargetTextures: (GPUTexture | null)[] = [];\n    for (let i = 0; i < colorTargetsCount; i++) {\n      const renderTargetTexture = this.device.createTexture({\n        format,\n        size: {\n          width: kRenderTargetSize,\n          height: kRenderTargetSize,\n          depthOrArrayLayers: 1,\n        },\n        sampleCount,\n        mipLevelCount: 1,\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n      });\n      renderTargetTextures.push(renderTargetTexture);\n\n      const resolveTargetTexture =\n        sampleCount === 1\n          ? null\n          : this.device.createTexture({\n              format,\n              size: {\n                width: kRenderTargetSize,\n                height: kRenderTargetSize,\n                depthOrArrayLayers: 1,\n              },\n              sampleCount: 1,\n              mipLevelCount: 1,\n              usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n            });\n      resolveTargetTextures.push(resolveTargetTexture);\n    }\n\n    const depthStencilTexture = this.device.createTexture({\n      size: {\n        width: kRenderTargetSize,\n        height: kRenderTargetSize,\n      },\n      format: depthStencilFormat,\n      sampleCount,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n    });\n\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      colorAttachments: renderTargetTextures.map((renderTargetTexture, index) => {\n        return {\n          view: renderTargetTexture.createView(),\n          resolveTarget: resolveTargetTextures[index]?.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        };\n      }),\n      depthStencilAttachment: {\n        view: depthStencilTexture.createView(),\n        depthClearValue: kDepthClearValue,\n        depthLoadOp: 'clear',\n        depthStoreOp: 'store',\n        stencilClearValue: kStencilClearValue,\n        stencilLoadOp: 'clear',\n        stencilStoreOp: 'store',\n      },\n    };\n    const commandEncoder = this.device.createCommandEncoder();\n    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n    passEncoder.setPipeline(pipeline);\n    passEncoder.setBindGroup(0, uniformBindGroup);\n    passEncoder.setStencilReference(kStencilReferenceValue);\n\n    if (sampleCount === 1) {\n      if ((rasterizationMask & 1) !== 0) {\n        // draw center quad\n        passEncoder.draw(6);\n      }\n    } else {\n      assert(sampleCount === 4);\n      if ((rasterizationMask & 1) !== 0) {\n        // draw top-left quad\n        passEncoder.draw(6, 1, 6);\n      }\n      if ((rasterizationMask & 2) !== 0) {\n        // draw top-right quad\n        passEncoder.draw(6, 1, 12);\n      }\n      if ((rasterizationMask & 4) !== 0) {\n        // draw bottom-left quad\n        passEncoder.draw(6, 1, 18);\n      }\n      if ((rasterizationMask & 8) !== 0) {\n        // draw bottom-right quad\n        passEncoder.draw(6, 1, 24);\n      }\n    }\n    passEncoder.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n\n    return {\n      color: renderTargetTextures[0],\n      depthStencil: depthStencilTexture,\n    };\n  }\n\n  CheckColorAttachmentResult(\n    texture: GPUTexture,\n    sampleCount: number,\n    rasterizationMask: number,\n    sampleMask: number,\n    fragmentShaderOutputMask: number\n  ) {\n    const buffer = this.copySinglePixelTextureToBufferUsingComputePass(\n      TypeF32, // correspond to 'rgba8unorm' format\n      4,\n      texture.createView(),\n      sampleCount\n    );\n\n    const expected = getExpectedColorData(\n      sampleCount,\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMask\n    );\n    this.expectGPUBufferValuesEqual(buffer, expected);\n  }\n\n  CheckDepthStencilResult(\n    aspect: 'depth-only' | 'stencil-only',\n    depthStencilTexture: GPUTexture,\n    sampleCount: number,\n    rasterizationMask: number,\n    sampleMask: number,\n    fragmentShaderOutputMask: number\n  ) {\n    const buffer = this.copySinglePixelTextureToBufferUsingComputePass(\n      // Use f32 as the scalar type for depth (depth24plus, depth32float)\n      // Use u32 as the scalar type for stencil (stencil8)\n      aspect === 'depth-only' ? TypeF32 : TypeU32,\n      1,\n      depthStencilTexture.createView({ aspect }),\n      sampleCount\n    );\n\n    const expected =\n      aspect === 'depth-only'\n        ? getExpectedDepthData(sampleCount, rasterizationMask, sampleMask, fragmentShaderOutputMask)\n        : getExpectedStencilData(\n            sampleCount,\n            rasterizationMask,\n            sampleMask,\n            fragmentShaderOutputMask\n          );\n    this.expectGPUBufferValuesEqual(buffer, expected);\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('fragment_output_mask')\n  .desc(\n    `\nTests that the final sample mask is the logical AND of all the relevant masks -- meaning that the samples\nnot included in the final mask are discarded on any attachments including\n- color outputs\n- depth tests\n- stencil operations\n\nThe test draws 0/1/1+ textured quads of which each sample in the standard 4-sample pattern results in a different color:\n- Sample 0, Texel 0, top-left: Red\n- Sample 1, Texel 1, top-left: Green\n- Sample 2, Texel 2, top-left: Blue\n- Sample 3, Texel 3, top-left: Yellow\n\nThe test checks each sample value of the render target texture and depth stencil texture using a compute pass to\ntextureLoad each sample index from the texture and write to a storage buffer to compare with expected values.\n\n- for sampleCount = { 1, 4 } and various combinations of:\n    - rasterization mask = { 0, ..., 2 ** sampleCount - 1 }\n    - sample mask = { 0, 0b0001, 0b0010, 0b0111, 0b1011, 0b1101, 0b1110, 0b1111, 0b11110 }\n    - fragment shader output @builtin(sample_mask) = { 0, 0b0001, 0b0010, 0b0111, 0b1011, 0b1101, 0b1110, 0b1111, 0b11110 }\n- [choosing 0b11110 because the 5th bit should be ignored]\n`\n  )\n  .params(u =>\n    u\n      .combine('sampleCount', [1, 4] as const)\n      .expand('rasterizationMask', function* (p) {\n        for (let i = 0, len = 2 ** p.sampleCount - 1; i <= len; i++) {\n          yield i;\n        }\n      })\n      .beginSubcases()\n      .combine('sampleMask', [\n        0,\n        0b0001,\n        0b0010,\n        0b0111,\n        0b1011,\n        0b1101,\n        0b1110,\n        0b1111,\n        0b11110,\n      ] as const)\n      .combine('fragmentShaderOutputMask', [\n        0,\n        0b0001,\n        0b0010,\n        0b0111,\n        0b1011,\n        0b1101,\n        0b1110,\n        0b1111,\n        0b11110,\n      ] as const)\n  )\n  .fn(t => {\n    const { sampleCount, rasterizationMask, sampleMask, fragmentShaderOutputMask } = t.params;\n\n    const fragmentMaskUniformBuffer = t.device.createBuffer({\n      size: 4,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n    t.trackForCleanup(fragmentMaskUniformBuffer);\n    t.device.queue.writeBuffer(\n      fragmentMaskUniformBuffer,\n      0,\n      new Uint32Array([fragmentShaderOutputMask])\n    );\n\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: t.device.createShaderModule({\n          code: kSampleMaskTestVertexShader,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: t.device.createShaderModule({\n          code: `\n          @group(0) @binding(0) var mySampler: sampler;\n          @group(0) @binding(1) var myTexture: texture_2d<f32>;\n          @group(0) @binding(2) var<uniform> fragMask: u32;\n\n          struct FragmentOutput {\n            @builtin(sample_mask) mask : u32,\n            @location(0) color : vec4<f32>,\n          }\n\n          @fragment\n          fn main(@location(0) @interpolate(perspective, sample) fragUV: vec2<f32>) -> FragmentOutput {\n            return FragmentOutput(fragMask, textureSample(myTexture, mySampler, fragUV));\n          }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format }],\n      },\n      primitive: { topology: 'triangle-list' },\n      multisample: {\n        count: sampleCount,\n        mask: sampleMask,\n        alphaToCoverageEnabled: false,\n      },\n      depthStencil: {\n        format: depthStencilFormat,\n        depthWriteEnabled: true,\n        depthCompare: 'always',\n\n        stencilFront: {\n          compare: 'always',\n          passOp: 'replace',\n        },\n        stencilBack: {\n          compare: 'always',\n          passOp: 'replace',\n        },\n      },\n    });\n\n    const { color, depthStencil } = t.GetTargetTexture(\n      sampleCount,\n      rasterizationMask,\n      pipeline,\n      fragmentMaskUniformBuffer\n    );\n\n    t.CheckColorAttachmentResult(\n      color,\n      sampleCount,\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMask\n    );\n\n    t.CheckDepthStencilResult(\n      'depth-only',\n      depthStencil,\n      sampleCount,\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMask\n    );\n\n    t.CheckDepthStencilResult(\n      'stencil-only',\n      depthStencil,\n      sampleCount,\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMask\n    );\n  });\n\ng.test('alpha_to_coverage_mask')\n  .desc(\n    `\nTest that alpha_to_coverage_mask is working properly with the alpha output of color target[0].\n\n- for sampleCount = 4, alphaToCoverageEnabled = true and various combinations of:\n  - rasterization masks\n  - increasing alpha0 values of the color0 output including { < 0, = 0, = 1/16, = 2/16, ..., = 15/16, = 1, > 1 }\n  - alpha1 values of the color1 output = { 0, 0.5, 1.0 }.\n- test that for a single pixel in { color0, color1 } { color0, depth, stencil } output the final sample mask is applied to it, moreover:\n  - if alpha0 is 0.0 or less then alpha to coverage mask is 0x0,\n  - if alpha0 is 1.0 or greater then alpha to coverage mask is 0xFFFFFFFF,\n  - that the number of bits in the alpha to coverage mask is non-decreasing,\n  - that the computation of alpha to coverage mask doesn't depend on any other color output than color0,\n  - (not included in the spec): that once a sample is included in the alpha to coverage sample mask\n    it will be included for any alpha greater than or equal to the current value.\n\nThe algorithm of producing the alpha-to-coverage mask is platform-dependent. The test draws a different color\nat each sample point. for any two alpha values (alpha and alpha') where 0 < alpha' < alpha < 1, the color values (color and color') must satisfy\ncolor' <= color.\n`\n  )\n  .params(u =>\n    u\n      .expand('rasterizationMask', function* (p) {\n        for (let i = 0, len = 0xf; i <= len; i++) {\n          yield i;\n        }\n      })\n      .beginSubcases()\n      .combine('alpha1', [0.0, 0.5, 1.0] as const)\n  )\n  .fn(async t => {\n    const sampleCount = 4;\n    const sampleMask = 0xffffffff;\n    const { rasterizationMask, alpha1 } = t.params;\n\n    const alphaValues = new Float32Array(4); // [alpha0, alpha1, 0, 0]\n    const alphaValueUniformBuffer = t.device.createBuffer({\n      size: alphaValues.byteLength,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n    t.trackForCleanup(alphaValueUniformBuffer);\n\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: t.device.createShaderModule({\n          code: kSampleMaskTestVertexShader,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: t.device.createShaderModule({\n          code: `\n          @group(0) @binding(0) var mySampler: sampler;\n          @group(0) @binding(1) var myTexture: texture_2d<f32>;\n          @group(0) @binding(2) var<uniform> alpha: vec4<f32>;\n\n          struct FragmentOutput {\n            @location(0) color0 : vec4<f32>,\n            @location(1) color1 : vec4<f32>,\n          }\n\n          @fragment\n          fn main(@location(0) @interpolate(perspective, sample) fragUV: vec2<f32>) -> FragmentOutput {\n            var c = textureSample(myTexture, mySampler, fragUV);\n            var output: FragmentOutput;\n            output.color0 = c;\n            output.color0.a = alpha[0];\n            output.color1 = c;\n            output.color1.a = alpha[1];\n            return output;\n          }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format }, { format }],\n      },\n      primitive: { topology: 'triangle-list' },\n      multisample: {\n        count: sampleCount,\n        mask: sampleMask,\n        alphaToCoverageEnabled: true,\n      },\n      depthStencil: {\n        format: depthStencilFormat,\n        depthWriteEnabled: true,\n        depthCompare: 'always',\n\n        stencilFront: {\n          compare: 'always',\n          passOp: 'replace',\n        },\n        stencilBack: {\n          compare: 'always',\n          passOp: 'replace',\n        },\n      },\n    });\n\n    // { < 0, = 0, = 1/16, = 2/16, ..., = 15/16, = 1, > 1 }\n    const alpha0ParamsArray = [-0.1, ...range(16, i => i / 16), 1.0, 1.1];\n\n    const colorResultPromises = [];\n    const depthResultPromises = [];\n    const stencilResultPromises = [];\n\n    for (const alpha0 of alpha0ParamsArray) {\n      alphaValues[0] = alpha0;\n      alphaValues[1] = alpha1;\n      t.device.queue.writeBuffer(alphaValueUniformBuffer, 0, alphaValues);\n\n      const { color, depthStencil } = t.GetTargetTexture(\n        sampleCount,\n        rasterizationMask,\n        pipeline,\n        alphaValueUniformBuffer,\n        2\n      );\n\n      const colorBuffer = t.copySinglePixelTextureToBufferUsingComputePass(\n        TypeF32, // correspond to 'rgba8unorm' format\n        4,\n        color.createView(),\n        sampleCount\n      );\n      const colorResult = t.readGPUBufferRangeTyped(colorBuffer, {\n        type: Float32Array,\n        typedLength: colorBuffer.size / Float32Array.BYTES_PER_ELEMENT,\n      });\n      colorResultPromises.push(colorResult);\n\n      const depthBuffer = t.copySinglePixelTextureToBufferUsingComputePass(\n        TypeF32, // correspond to 'depth24plus-stencil8' format\n        1,\n        depthStencil.createView({ aspect: 'depth-only' }),\n        sampleCount\n      );\n      const depthResult = t.readGPUBufferRangeTyped(depthBuffer, {\n        type: Float32Array,\n        typedLength: depthBuffer.size / Float32Array.BYTES_PER_ELEMENT,\n      });\n      depthResultPromises.push(depthResult);\n\n      const stencilBuffer = t.copySinglePixelTextureToBufferUsingComputePass(\n        TypeU32, // correspond to 'depth24plus-stencil8' format\n        1,\n        depthStencil.createView({ aspect: 'stencil-only' }),\n        sampleCount\n      );\n      const stencilResult = t.readGPUBufferRangeTyped(stencilBuffer, {\n        type: Uint32Array,\n        typedLength: stencilBuffer.size / Uint32Array.BYTES_PER_ELEMENT,\n      });\n      stencilResultPromises.push(stencilResult);\n    }\n\n    const resultsArray = await Promise.all([\n      Promise.all(colorResultPromises),\n      Promise.all(depthResultPromises),\n      Promise.all(stencilResultPromises),\n    ]);\n\n    const checkResults = (\n      results: { data: Float32Array | Uint32Array; cleanup(): void }[],\n      getExpectedDataFn: (\n        sampleCount: number,\n        rasterizationMask: number,\n        sampleMask: number,\n        alphaToCoverageMask: number\n      ) => Float32Array | Uint32Array,\n      // Alpha to coverage mask should be non-decreasing as the alpha value goes up\n      // Result value of color and stencil is in positive correlation to alpha\n      // Result value of depth is in negative correlation to alpha\n      positiveCorrelation: boolean\n    ) => {\n      for (let i = 0; i < results.length; i++) {\n        const result = results[i];\n        const alpha0 = alpha0ParamsArray[i];\n\n        if (alpha0 <= 0) {\n          const expected = getExpectedDataFn(sampleCount, rasterizationMask, sampleMask, 0x0);\n          const check = checkElementsEqual(result.data, expected);\n          t.expectOK(check);\n        } else if (alpha0 >= 1) {\n          const expected = getExpectedDataFn(\n            sampleCount,\n            rasterizationMask,\n            sampleMask,\n            0xffffffff\n          );\n          const check = checkElementsEqual(result.data, expected);\n          t.expectOK(check);\n        } else {\n          assert(i > 0);\n          const prevResult = results[i - 1];\n          const check = checkElementsPassPredicate(\n            result.data,\n            (index, value) =>\n              positiveCorrelation\n                ? value >= prevResult.data[index]\n                : value <= prevResult.data[index],\n            {}\n          );\n          t.expectOK(check);\n        }\n      }\n\n      for (const result of results) {\n        result.cleanup();\n      }\n    };\n\n    // Check color results\n    checkResults(resultsArray[0], getExpectedColorData, true);\n\n    // Check depth results\n    checkResults(resultsArray[1], getExpectedDepthData, false);\n\n    // Check stencil results\n    checkResults(resultsArray[2], getExpectedStencilData, true);\n  });\n"],"mappings":"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W,EAAEI,CAAC,EAAE,EAAE;IACpC,MAAMG,CAAC,GAAGb,SAAS;IACjBC,iBAAiB;IACjBC,UAAU;IACVK,6CAA6C;IAC7CG,CAAC,CACF;;IACDF,YAAY,CAACE,CAAC,CAAC,GAAGG,CAAC,GAAGnB,gBAAgB,GAAGD,gBAAgB;EAC3D;EACA,OAAOe,YAAY;AACrB;;AAEA,SAASM,sBAAsB;AAC7BR,WAAmB;AACnBL,iBAAyB;AACzBC,UAAkB;AAClBK,6CAAqD;AACrD;EACA,MAAMC,YAAY,GAAG,IAAIO,WAAW,CAACT,WAAW,CAAC;EACjD,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,EAAEI,CAAC,EAAE,EAAE;IACpC,MAAMG,CAAC,GAAGb,SAAS;IACjBC,iBAAiB;IACjBC,UAAU;IACVK,6CAA6C;IAC7CG,CAAC,CACF;;IACDF,YAAY,CAACE,CAAC,CAAC,GAAGG,CAAC,GAAGjB,sBAAsB,GAAGD,kBAAkB;EACnE;EACA,OAAOa,YAAY;AACrB;;AAEA,MAAMQ,2BAA2B,GAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkDtB,gBAAiB;AACnE;AACA;AACA,EAAE;;AAEF,MAAMuB,CAAC,SAAShC,gBAAgB,CAACD,OAAO,CAAC,CAAC;;;;EAIxC,MAAMk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"}