{"version":3,"sources":["../../../../../../src/webgpu/api/operation/memory_sync/texture/same_subresource.spec.ts"],"names":["description","makeTestGroup","GPUTest","kOperationBoundaries","kBoundaryInfo","kAllReadOps","kAllWriteOps","checkOpsValidForContext","g","test","desc","params","u","combine","expand","p","boundary","contexts","expandWithParams","_context","read","write","op","in","unimplemented","first","second"],"mappings":"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","sourcesContent":["export const description = `\nMemory Synchronization Tests for Texture: read before write, read after write, and write after write to the same subresource.\n\n- TODO: Test synchronization between multiple queues.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../../gpu_test.js';\n\nimport {\n  kOperationBoundaries,\n  kBoundaryInfo,\n  kAllReadOps,\n  kAllWriteOps,\n  checkOpsValidForContext,\n} from './texture_sync_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('rw')\n  .desc(\n    `\n    Perform a 'read' operations on a texture subresource, followed by a 'write' operation.\n    Operations are separated by a 'boundary' (pass, encoder, queue-op, etc.).\n    Test that the results are synchronized.\n    The read should not see the contents written by the subsequent write.`\n  )\n  .params(u =>\n    u\n      .combine('boundary', kOperationBoundaries)\n      .expand('_context', p => kBoundaryInfo[p.boundary].contexts)\n      .expandWithParams(function* ({ _context }) {\n        for (const read of kAllReadOps) {\n          for (const write of kAllWriteOps) {\n            if (checkOpsValidForContext([read, write], _context)) {\n              yield {\n                read: { op: read, in: _context[0] },\n                write: { op: write, in: _context[1] },\n              };\n            }\n          }\n        }\n      })\n  )\n  .unimplemented();\n\ng.test('wr')\n  .desc(\n    `\n    Perform a 'write' operation on a texture subresource, followed by a 'read' operation.\n    Operations are separated by a 'boundary' (pass, encoder, queue-op, etc.).\n    Test that the results are synchronized.\n    The read should see exactly the contents written by the previous write.`\n  )\n  .params(u =>\n    u\n      .combine('boundary', kOperationBoundaries)\n      .expand('_context', p => kBoundaryInfo[p.boundary].contexts)\n      .expandWithParams(function* ({ _context }) {\n        for (const read of kAllReadOps) {\n          for (const write of kAllWriteOps) {\n            if (checkOpsValidForContext([write, read], _context)) {\n              yield {\n                write: { op: write, in: _context[0] },\n                read: { op: read, in: _context[1] },\n              };\n            }\n          }\n        }\n      })\n  )\n  .unimplemented();\n\ng.test('ww')\n  .desc(\n    `\n    Perform a 'first' write operation on a texture subresource, followed by a 'second' write operation.\n    Operations are separated by a 'boundary' (pass, encoder, queue-op, etc.).\n    Test that the results are synchronized.\n    The second write should overwrite the contents of the first.`\n  )\n  .params(u =>\n    u\n      .combine('boundary', kOperationBoundaries)\n      .expand('_context', p => kBoundaryInfo[p.boundary].contexts)\n      .expandWithParams(function* ({ _context }) {\n        for (const first of kAllWriteOps) {\n          for (const second of kAllWriteOps) {\n            if (checkOpsValidForContext([first, second], _context)) {\n              yield {\n                first: { op: first, in: _context[0] },\n                second: { op: second, in: _context[1] },\n              };\n            }\n          }\n        }\n      })\n  )\n  .unimplemented();\n"],"file":"same_subresource.spec.js"}