{"version":3,"sources":["../../../../../../src/webgpu/api/operation/memory_sync/texture/same_subresource.spec.ts"],"names":["description","makeTestGroup","assert","memcpy","unreachable","GPUTest","align","getTextureCopyLayout","kTexelRepresentationInfo","kOperationBoundaries","kBoundaryInfo","OperationContextHelper","kAllReadOps","kAllWriteOps","checkOpsValidForContext","kOpInfo","g","fullscreenQuadWGSL","TextureSyncTestHelper","kTextureSize","kTextureFormat","constructor","t","textureCreationParams","texture","trackForCleanup","device","createTexture","size","format","performReadOp","op","in","context","ensureContext","usage","GPUTextureUsage","COPY_SRC","COPY_DST","commandEncoder","undefined","copyTextureToTexture","byteLength","bytesPerRow","buffer","createBuffer","GPUBufferUsage","copyTextureToBuffer","copyBufferToTexture","STORAGE_BINDING","bindGroupLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","FRAGMENT","COMPUTE","sampleType","storageTexture","access","bindGroup","createBindGroup","layout","resource","createView","module","createShaderModule","code","renderPipeline","createRenderPipeline","createPipelineLayout","bindGroupLayouts","vertex","entryPoint","fragment","targets","writeMask","renderBundleEncoder","setPipeline","setBindGroup","draw","renderPassEncoder","computePipeline","createComputePipeline","compute","computePassEncoder","dispatchWorkgroups","Math","ceil","performWriteOp","data","beginRenderPass","colorAttachments","view","clearValue","R","G","B","A","loadOp","storeOp","currentContext","rep","texelData","pack","encode","numTexels","fullTexelData","ArrayBuffer","i","src","dst","start","queue","writeTexture","j","writeBuffer","renderTarget","RENDER_ATTACHMENT","sampleCount","resolveTarget","storedValue","map","x","toFixed","join","test","desc","params","u","combine","expand","p","boundary","contexts","expandWithParams","_context","read","write","fn","helper","readUsage","writeUsage","texelValue1","texelValue2","readbackTexture","ensureBoundary","ensureSubmit","expectSingleColor","exp","texelValue","first","second","unimplemented"],"mappings":"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","sourcesContent":["export const description = `\nMemory Synchronization Tests for Texture: read before write, read after write, and write after write to the same subresource.\n\n- TODO: Test synchronization between multiple queues.\n- TODO: Test depth/stencil attachments.\n- TODO: Use non-solid-color texture contents [2]\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { assert, memcpy, unreachable } from '../../../../../common/util/util.js';\nimport { EncodableTextureFormat } from '../../../../capability_info.js';\nimport { GPUTest } from '../../../../gpu_test.js';\nimport { align } from '../../../../util/math.js';\nimport { getTextureCopyLayout } from '../../../../util/texture/layout.js';\nimport {\n  kTexelRepresentationInfo,\n  PerTexelComponent,\n} from '../../../../util/texture/texel_data.js';\nimport {\n  kOperationBoundaries,\n  OperationContext,\n  kBoundaryInfo,\n  OperationContextHelper,\n} from '../operation_context_helper.js';\n\nimport {\n  kAllReadOps,\n  kAllWriteOps,\n  checkOpsValidForContext,\n  Op,\n  kOpInfo,\n} from './texture_sync_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\nconst fullscreenQuadWGSL = `\n  struct VertexOutput {\n    @builtin(position) Position : vec4<f32>\n  };\n\n  @vertex fn vert_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n    var pos = array<vec2<f32>, 6>(\n        vec2<f32>( 1.0,  1.0),\n        vec2<f32>( 1.0, -1.0),\n        vec2<f32>(-1.0, -1.0),\n        vec2<f32>( 1.0,  1.0),\n        vec2<f32>(-1.0, -1.0),\n        vec2<f32>(-1.0,  1.0));\n\n    var output : VertexOutput;\n    output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n    return output;\n  }\n`;\n\nclass TextureSyncTestHelper extends OperationContextHelper {\n  private texture: GPUTexture;\n\n  public readonly kTextureSize = [4, 4] as const;\n  public readonly kTextureFormat: EncodableTextureFormat = 'rgba8unorm';\n\n  constructor(\n    t: GPUTest,\n    textureCreationParams: {\n      usage: GPUTextureUsageFlags;\n    }\n  ) {\n    super(t);\n    this.texture = t.trackForCleanup(\n      t.device.createTexture({\n        size: this.kTextureSize,\n        format: this.kTextureFormat,\n        ...textureCreationParams,\n      })\n    );\n  }\n\n  /**\n   * Perform a read operation on the test texture.\n   * @return GPUTexture copy containing the contents.\n   */\n  performReadOp({ op, in: context }: { op: Op; in: OperationContext }): GPUTexture {\n    this.ensureContext(context);\n    switch (op) {\n      case 't2t-copy': {\n        const texture = this.t.trackForCleanup(\n          this.device.createTexture({\n            size: this.kTextureSize,\n            format: this.kTextureFormat,\n            usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n          })\n        );\n\n        assert(this.commandEncoder !== undefined);\n        this.commandEncoder.copyTextureToTexture(\n          {\n            texture: this.texture,\n          },\n          { texture },\n          this.kTextureSize\n        );\n        return texture;\n      }\n      case 't2b-copy': {\n        const { byteLength, bytesPerRow } = getTextureCopyLayout(this.kTextureFormat, '2d', [\n          ...this.kTextureSize,\n          1,\n        ]);\n        const buffer = this.t.trackForCleanup(\n          this.device.createBuffer({\n            size: byteLength,\n            usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n          })\n        );\n\n        const texture = this.t.trackForCleanup(\n          this.device.createTexture({\n            size: this.kTextureSize,\n            format: this.kTextureFormat,\n            usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n          })\n        );\n\n        assert(this.commandEncoder !== undefined);\n        this.commandEncoder.copyTextureToBuffer(\n          {\n            texture: this.texture,\n          },\n          { buffer, bytesPerRow },\n          this.kTextureSize\n        );\n        this.commandEncoder.copyBufferToTexture(\n          { buffer, bytesPerRow },\n          { texture },\n          this.kTextureSize\n        );\n        return texture;\n      }\n      case 'sample': {\n        const texture = this.t.trackForCleanup(\n          this.device.createTexture({\n            size: this.kTextureSize,\n            format: this.kTextureFormat,\n            usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.STORAGE_BINDING,\n          })\n        );\n\n        const bindGroupLayout = this.device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE,\n              texture: {\n                sampleType: 'unfilterable-float',\n              },\n            },\n            {\n              binding: 1,\n              visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE,\n              storageTexture: {\n                access: 'write-only',\n                format: this.kTextureFormat,\n              },\n            },\n          ],\n        });\n\n        const bindGroup = this.device.createBindGroup({\n          layout: bindGroupLayout,\n          entries: [\n            {\n              binding: 0,\n              resource: this.texture.createView(),\n            },\n            {\n              binding: 1,\n              resource: texture.createView(),\n            },\n          ],\n        });\n\n        switch (context) {\n          case 'render-pass-encoder':\n          case 'render-bundle-encoder': {\n            const module = this.device.createShaderModule({\n              code: `${fullscreenQuadWGSL}\n\n                @group(0) @binding(0) var inputTex: texture_2d<f32>;\n                @group(0) @binding(1) var outputTex: texture_storage_2d<rgba8unorm, write>;\n\n                @fragment fn frag_main(@builtin(position) fragCoord: vec4<f32>) -> @location(0) vec4<f32> {\n                  let coord = vec2<i32>(fragCoord.xy);\n                  textureStore(outputTex, coord, textureLoad(inputTex, coord, 0));\n                  return vec4<f32>();\n                }\n              `,\n            });\n            const renderPipeline = this.device.createRenderPipeline({\n              layout: this.device.createPipelineLayout({\n                bindGroupLayouts: [bindGroupLayout],\n              }),\n              vertex: {\n                module,\n                entryPoint: 'vert_main',\n              },\n              fragment: {\n                module,\n                entryPoint: 'frag_main',\n\n                // Unused attachment since we can't use textureStore in the vertex shader.\n                // Set writeMask to zero.\n                targets: [\n                  {\n                    format: this.kTextureFormat,\n                    writeMask: 0,\n                  },\n                ],\n              },\n            });\n\n            switch (context) {\n              case 'render-bundle-encoder':\n                assert(this.renderBundleEncoder !== undefined);\n                this.renderBundleEncoder.setPipeline(renderPipeline);\n                this.renderBundleEncoder.setBindGroup(0, bindGroup);\n                this.renderBundleEncoder.draw(6);\n                break;\n              case 'render-pass-encoder':\n                assert(this.renderPassEncoder !== undefined);\n                this.renderPassEncoder.setPipeline(renderPipeline);\n                this.renderPassEncoder.setBindGroup(0, bindGroup);\n                this.renderPassEncoder.draw(6);\n                break;\n            }\n            break;\n          }\n          case 'compute-pass-encoder': {\n            const module = this.device.createShaderModule({\n              code: `\n                @group(0) @binding(0) var inputTex: texture_2d<f32>;\n                @group(0) @binding(1) var outputTex: texture_storage_2d<rgba8unorm, write>;\n\n                @compute @workgroup_size(8, 8)\n                fn main(@builtin(global_invocation_id) gid : vec3<u32>) {\n                  if (any(gid.xy >= vec2<u32>(textureDimensions(inputTex)))) {\n                    return;\n                  }\n                  let coord = vec2<i32>(gid.xy);\n                  textureStore(outputTex, coord, textureLoad(inputTex, coord, 0));\n                }\n              `,\n            });\n            const computePipeline = this.device.createComputePipeline({\n              layout: this.device.createPipelineLayout({\n                bindGroupLayouts: [bindGroupLayout],\n              }),\n              compute: {\n                module,\n                entryPoint: 'main',\n              },\n            });\n\n            assert(this.computePassEncoder !== undefined);\n            this.computePassEncoder.setPipeline(computePipeline);\n            this.computePassEncoder.setBindGroup(0, bindGroup);\n            this.computePassEncoder.dispatchWorkgroups(\n              Math.ceil(this.kTextureSize[0] / 8),\n              Math.ceil(this.kTextureSize[1] / 8)\n            );\n            break;\n          }\n          default:\n            unreachable();\n        }\n\n        return texture;\n      }\n      case 'b2t-copy':\n      case 'attachment-resolve':\n      case 'attachment-store':\n        unreachable();\n    }\n    unreachable();\n  }\n\n  performWriteOp(\n    { op, in: context }: { op: Op; in: OperationContext },\n    data: PerTexelComponent<number>\n  ) {\n    this.ensureContext(context);\n    switch (op) {\n      case 'attachment-store': {\n        assert(this.commandEncoder !== undefined);\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass({\n          colorAttachments: [\n            {\n              view: this.texture.createView(),\n              // [2] Use non-solid-color texture values\n              clearValue: [data.R ?? 0, data.G ?? 0, data.B ?? 0, data.A ?? 0],\n              loadOp: 'clear',\n              storeOp: 'store',\n            },\n          ],\n        });\n        this.currentContext = 'render-pass-encoder';\n        break;\n      }\n      case 'write-texture': {\n        // [2] Use non-solid-color texture values\n        const rep = kTexelRepresentationInfo[this.kTextureFormat];\n        const texelData = rep.pack(rep.encode(data));\n        const numTexels = this.kTextureSize[0] * this.kTextureSize[1];\n        const fullTexelData = new ArrayBuffer(texelData.byteLength * numTexels);\n        for (let i = 0; i < numTexels; ++i) {\n          memcpy({ src: texelData }, { dst: fullTexelData, start: i * texelData.byteLength });\n        }\n\n        this.queue.writeTexture(\n          { texture: this.texture },\n          fullTexelData,\n          {\n            bytesPerRow: texelData.byteLength * this.kTextureSize[0],\n          },\n          this.kTextureSize\n        );\n        break;\n      }\n      case 't2t-copy': {\n        const texture = this.device.createTexture({\n          size: this.kTextureSize,\n          format: this.kTextureFormat,\n          usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n        });\n\n        // [2] Use non-solid-color texture values\n        const rep = kTexelRepresentationInfo[this.kTextureFormat];\n        const texelData = rep.pack(rep.encode(data));\n        const numTexels = this.kTextureSize[0] * this.kTextureSize[1];\n        const fullTexelData = new ArrayBuffer(texelData.byteLength * numTexels);\n        for (let i = 0; i < numTexels; ++i) {\n          memcpy({ src: texelData }, { dst: fullTexelData, start: i * texelData.byteLength });\n        }\n\n        this.queue.writeTexture(\n          { texture },\n          fullTexelData,\n          {\n            bytesPerRow: texelData.byteLength * this.kTextureSize[0],\n          },\n          this.kTextureSize\n        );\n\n        assert(this.commandEncoder !== undefined);\n        this.commandEncoder.copyTextureToTexture(\n          { texture },\n          { texture: this.texture },\n          this.kTextureSize\n        );\n        break;\n      }\n      case 'b2t-copy': {\n        // [2] Use non-solid-color texture values\n        const rep = kTexelRepresentationInfo[this.kTextureFormat];\n        const texelData = rep.pack(rep.encode(data));\n        const bytesPerRow = align(texelData.byteLength, 256);\n        const fullTexelData = new ArrayBuffer(bytesPerRow * this.kTextureSize[1]);\n        for (let i = 0; i < this.kTextureSize[1]; ++i) {\n          for (let j = 0; j < this.kTextureSize[0]; ++j) {\n            memcpy(\n              { src: texelData },\n              {\n                dst: fullTexelData,\n                start: i * bytesPerRow + j * texelData.byteLength,\n              }\n            );\n          }\n        }\n\n        const buffer = this.t.trackForCleanup(\n          this.device.createBuffer({\n            size: fullTexelData.byteLength,\n            usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n          })\n        );\n\n        this.queue.writeBuffer(buffer, 0, fullTexelData);\n\n        assert(this.commandEncoder !== undefined);\n        this.commandEncoder.copyBufferToTexture(\n          { buffer, bytesPerRow },\n          { texture: this.texture },\n          this.kTextureSize\n        );\n        break;\n      }\n      case 'attachment-resolve': {\n        assert(this.commandEncoder !== undefined);\n        const renderTarget = this.t.trackForCleanup(\n          this.device.createTexture({\n            format: this.kTextureFormat,\n            size: this.kTextureSize,\n            usage: GPUTextureUsage.RENDER_ATTACHMENT,\n            sampleCount: 4,\n          })\n        );\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass({\n          colorAttachments: [\n            {\n              view: renderTarget.createView(),\n              resolveTarget: this.texture.createView(),\n              // [2] Use non-solid-color texture values\n              clearValue: [data.R ?? 0, data.G ?? 0, data.B ?? 0, data.A ?? 0],\n              loadOp: 'clear',\n              storeOp: 'discard',\n            },\n          ],\n        });\n        this.currentContext = 'render-pass-encoder';\n        break;\n      }\n      case 'storage': {\n        const bindGroupLayout = this.device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE,\n              storageTexture: {\n                access: 'write-only',\n                format: this.kTextureFormat,\n              },\n            },\n          ],\n        });\n\n        const bindGroup = this.device.createBindGroup({\n          layout: bindGroupLayout,\n          entries: [\n            {\n              binding: 0,\n              resource: this.texture.createView(),\n            },\n          ],\n        });\n\n        // [2] Use non-solid-color texture values\n        const storedValue = `vec4<f32>(${[data.R ?? 0, data.G ?? 0, data.B ?? 0, data.A ?? 0]\n          .map(x => x.toFixed(5))\n          .join(', ')})`;\n\n        switch (context) {\n          case 'render-pass-encoder':\n          case 'render-bundle-encoder': {\n            const module = this.device.createShaderModule({\n              code: `${fullscreenQuadWGSL}\n\n                @group(0) @binding(0) var outputTex: texture_storage_2d<rgba8unorm, write>;\n\n                @fragment fn frag_main(@builtin(position) fragCoord: vec4<f32>) -> @location(0) vec4<f32> {\n                  textureStore(outputTex, vec2<i32>(fragCoord.xy), ${storedValue});\n                  return vec4<f32>();\n                }\n              `,\n            });\n            const renderPipeline = this.device.createRenderPipeline({\n              layout: this.device.createPipelineLayout({\n                bindGroupLayouts: [bindGroupLayout],\n              }),\n              vertex: {\n                module,\n                entryPoint: 'vert_main',\n              },\n              fragment: {\n                module,\n                entryPoint: 'frag_main',\n\n                // Unused attachment since we can't use textureStore in the vertex shader.\n                // Set writeMask to zero.\n                targets: [\n                  {\n                    format: this.kTextureFormat,\n                    writeMask: 0,\n                  },\n                ],\n              },\n            });\n\n            switch (context) {\n              case 'render-bundle-encoder':\n                assert(this.renderBundleEncoder !== undefined);\n                this.renderBundleEncoder.setPipeline(renderPipeline);\n                this.renderBundleEncoder.setBindGroup(0, bindGroup);\n                this.renderBundleEncoder.draw(6);\n                break;\n              case 'render-pass-encoder':\n                assert(this.renderPassEncoder !== undefined);\n                this.renderPassEncoder.setPipeline(renderPipeline);\n                this.renderPassEncoder.setBindGroup(0, bindGroup);\n                this.renderPassEncoder.draw(6);\n                break;\n            }\n            break;\n          }\n          case 'compute-pass-encoder': {\n            const module = this.device.createShaderModule({\n              code: `\n                @group(0) @binding(0) var outputTex: texture_storage_2d<rgba8unorm, write>;\n\n                @compute @workgroup_size(8, 8)\n                fn main(@builtin(global_invocation_id) gid : vec3<u32>) {\n                  if (any(gid.xy >= vec2<u32>(textureDimensions(outputTex)))) {\n                    return;\n                  }\n                  let coord = vec2<i32>(gid.xy);\n                  textureStore(outputTex, coord, ${storedValue});\n                }\n              `,\n            });\n            const computePipeline = this.device.createComputePipeline({\n              layout: this.device.createPipelineLayout({\n                bindGroupLayouts: [bindGroupLayout],\n              }),\n              compute: {\n                module,\n                entryPoint: 'main',\n              },\n            });\n\n            assert(this.computePassEncoder !== undefined);\n            this.computePassEncoder.setPipeline(computePipeline);\n            this.computePassEncoder.setBindGroup(0, bindGroup);\n            this.computePassEncoder.dispatchWorkgroups(\n              Math.ceil(this.kTextureSize[0] / 8),\n              Math.ceil(this.kTextureSize[1] / 8)\n            );\n            break;\n          }\n          default:\n            unreachable();\n        }\n        break;\n      }\n      case 't2b-copy':\n      case 'sample':\n        unreachable();\n    }\n  }\n}\n\ng.test('rw')\n  .desc(\n    `\n    Perform a 'read' operations on a texture subresource, followed by a 'write' operation.\n    Operations are separated by a 'boundary' (pass, encoder, queue-op, etc.).\n    Test that the results are synchronized.\n    The read should not see the contents written by the subsequent write.`\n  )\n  .params(u =>\n    u\n      .combine('boundary', kOperationBoundaries)\n      .expand('_context', p => kBoundaryInfo[p.boundary].contexts)\n      .expandWithParams(function* ({ _context }) {\n        for (const read of kAllReadOps) {\n          for (const write of kAllWriteOps) {\n            if (checkOpsValidForContext([read, write], _context)) {\n              yield {\n                read: { op: read, in: _context[0] },\n                write: { op: write, in: _context[1] },\n              };\n            }\n          }\n        }\n      })\n  )\n  .fn(t => {\n    const helper = new TextureSyncTestHelper(t, {\n      usage:\n        GPUTextureUsage.COPY_DST |\n        kOpInfo[t.params.read.op].readUsage |\n        kOpInfo[t.params.write.op].writeUsage,\n    });\n    // [2] Use non-solid-color texture value.\n    const texelValue1 = { R: 0, G: 1, B: 0, A: 1 } as const;\n    const texelValue2 = { R: 1, G: 0, B: 0, A: 1 } as const;\n\n    // Initialize the texture with something.\n    helper.performWriteOp({ op: 'write-texture', in: 'queue' }, texelValue1);\n    const readbackTexture = helper.performReadOp(t.params.read);\n    helper.ensureBoundary(t.params.boundary);\n    helper.performWriteOp(t.params.write, texelValue2);\n    helper.ensureSubmit();\n\n    // Contents should be the first value written, not the second.\n    t.expectSingleColor(readbackTexture, helper.kTextureFormat, {\n      size: [...helper.kTextureSize, 1],\n      exp: texelValue1,\n    });\n  });\n\ng.test('wr')\n  .desc(\n    `\n    Perform a 'write' operation on a texture subresource, followed by a 'read' operation.\n    Operations are separated by a 'boundary' (pass, encoder, queue-op, etc.).\n    Test that the results are synchronized.\n    The read should see exactly the contents written by the previous write.\n\n    - TODO: Use non-solid-color texture contents [2]`\n  )\n  .params(u =>\n    u\n      .combine('boundary', kOperationBoundaries)\n      .expand('_context', p => kBoundaryInfo[p.boundary].contexts)\n      .expandWithParams(function* ({ _context }) {\n        for (const read of kAllReadOps) {\n          for (const write of kAllWriteOps) {\n            if (checkOpsValidForContext([write, read], _context)) {\n              yield {\n                write: { op: write, in: _context[0] },\n                read: { op: read, in: _context[1] },\n              };\n            }\n          }\n        }\n      })\n  )\n  .fn(t => {\n    const helper = new TextureSyncTestHelper(t, {\n      usage: kOpInfo[t.params.read.op].readUsage | kOpInfo[t.params.write.op].writeUsage,\n    });\n    // [2] Use non-solid-color texture value.\n    const texelValue = { R: 0, G: 1, B: 0, A: 1 } as const;\n\n    helper.performWriteOp(t.params.write, texelValue);\n    helper.ensureBoundary(t.params.boundary);\n    const readbackTexture = helper.performReadOp(t.params.read);\n    helper.ensureSubmit();\n\n    // Contents should be exactly the values written.\n    t.expectSingleColor(readbackTexture, helper.kTextureFormat, {\n      size: [...helper.kTextureSize, 1],\n      exp: texelValue,\n    });\n  });\n\ng.test('ww')\n  .desc(\n    `\n    Perform a 'first' write operation on a texture subresource, followed by a 'second' write operation.\n    Operations are separated by a 'boundary' (pass, encoder, queue-op, etc.).\n    Test that the results are synchronized.\n    The second write should overwrite the contents of the first.`\n  )\n  .params(u =>\n    u\n      .combine('boundary', kOperationBoundaries)\n      .expand('_context', p => kBoundaryInfo[p.boundary].contexts)\n      .expandWithParams(function* ({ _context }) {\n        for (const first of kAllWriteOps) {\n          for (const second of kAllWriteOps) {\n            if (checkOpsValidForContext([first, second], _context)) {\n              yield {\n                first: { op: first, in: _context[0] },\n                second: { op: second, in: _context[1] },\n              };\n            }\n          }\n        }\n      })\n  )\n  .fn(t => {\n    const helper = new TextureSyncTestHelper(t, {\n      usage:\n        GPUTextureUsage.COPY_SRC |\n        kOpInfo[t.params.first.op].writeUsage |\n        kOpInfo[t.params.second.op].writeUsage,\n    });\n    // [2] Use non-solid-color texture value.\n    const texelValue1 = { R: 1, G: 0, B: 0, A: 1 } as const;\n    const texelValue2 = { R: 0, G: 1, B: 0, A: 1 } as const;\n\n    helper.performWriteOp(t.params.first, texelValue1);\n    helper.ensureBoundary(t.params.boundary);\n    helper.performWriteOp(t.params.second, texelValue2);\n    helper.ensureSubmit();\n\n    // Read back the contents so we can test the result.\n    const readbackTexture = helper.performReadOp({ op: 't2t-copy', in: 'command-encoder' });\n    helper.ensureSubmit();\n\n    // Contents should be the second value written.\n    t.expectSingleColor(readbackTexture, helper.kTextureFormat, {\n      size: [...helper.kTextureSize, 1],\n      exp: texelValue2,\n    });\n  });\n\ng.test('rw,single_pass,load_store')\n  .desc(\n    `\n    TODO: Test memory synchronization when loading from a texture subresource in a single pass and storing to it.`\n  )\n  .unimplemented();\n\ng.test('rw,single_pass,load_resolve')\n  .desc(\n    `\n    TODO: Test memory synchronization when loading from a texture subresource in a single pass and resolving to it.`\n  )\n  .unimplemented();\n"],"file":"same_subresource.spec.js"}