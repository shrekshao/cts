{"version":3,"sources":["../../../../../../src/webgpu/api/operation/memory_sync/buffer/buffer_sync_test.ts"],"names":["assert","unreachable","GPUTest","checkElementsEqualEither","kAllWriteOps","kAllReadOps","kOpInfo","contexts","checkOpsValidForContext","ops","context","valid","includes","checkImpl","op1","op2","kDummyVertexShader","BufferSyncTest","tmpValueBuffers","undefined","tmpValueTextures","createIntermediateBuffersAndTexturesForWriteOp","writeOp","slot","value","createBufferWithValue","createTextureWithValue","createBuffersForReadOp","readOp","srcValue","opValue","vertexBuffer","createBufferWithValues","indexBuffer","srcBuffer","dstBuffer","trackForCleanup","device","createBuffer","size","Uint32Array","BYTES_PER_ELEMENT","usage","GPUBufferUsage","COPY_SRC","COPY_DST","STORAGE","VERTEX","INDEX","INDIRECT","UNIFORM","initValue","buffer","mappedAtCreation","getMappedRange","fill","unmap","queue","onSubmittedWorkDone","initValues","length","bufferView","set","data","texture","createTexture","width","height","depthOrArrayLayers","format","GPUTextureUsage","writeTexture","mipLevel","origin","x","y","z","offset","bytesPerRow","rowsPerImage","createBindGroup","pipeline","layout","getBindGroupLayout","entries","binding","resource","createStorageWriteComputePipeline","wgslCompute","createComputePipeline","compute","module","createShaderModule","code","entryPoint","createTrivialRenderPipeline","wgslShaders","createRenderPipeline","vertex","fragment","targets","primitive","topology","createStorageWriteRenderPipeline","beginSimpleRenderPass","encoder","view","RENDER_ATTACHMENT","createView","beginRenderPass","colorAttachments","clearValue","r","g","b","a","loadOp","storeOp","encodeWriteAsStorageBufferInRenderPass","renderer","bindGroup","setBindGroup","setPipeline","draw","encodeWriteAsStorageBufferInComputePass","pass","dispatchWorkgroups","encodeWriteByB2BCopy","tmpBuffer","copyBufferToBuffer","encodeWriteByT2BCopy","tmpTexture","copyTextureToBuffer","writeByWriteBuffer","writeBuffer","encodeWriteOp","helper","operation","writeOpSlot","ensureContext","renderPassEncoder","renderBundleEncoder","computePassEncoder","commandEncoder","createStorageReadComputePipeline","createBindGroupSrcDstBuffer","createVertexReadRenderPipeline","buffers","arrayStride","attributes","shaderLocation","createUniformReadRenderPipeline","createStorageReadRenderPipeline","encodeReadAsStorageBufferInComputePass","encodeReadAsIndirectBufferInComputePass","dispatchWorkgroupsIndirect","encodeReadAsVertexBufferInRenderPass","setVertexBuffer","encodeReadAsIndexBufferInRenderPass","setIndexBuffer","drawIndexed","encodeReadAsIndirectBufferInRenderPass","drawIndirect","encodeReadAsIndexedIndirectBufferInRenderPass","drawIndexedIndirect","encodeReadAsUniformBufferInRenderPass","encodeReadAsStorageBufferInRenderPass","encodeReadByB2BCopy","encodeReadByB2TCopy","copyBufferToTexture","encodeReadOp","computePass","verifyData","expectedValue","bufferData","expectGPUBufferValuesEqual","verifyDataTwoValidValues","expectedValue1","expectedValue2","bufferData1","bufferData2","expectGPUBufferValuesPassCheck","type","typedLength"],"mappings":"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","sourcesContent":["import { assert, unreachable } from '../../../../../common/util/util.js';\nimport { GPUTest } from '../../../../gpu_test.js';\nimport { checkElementsEqualEither } from '../../../../util/check_contents.js';\nimport { OperationContext, OperationContextHelper } from '../operation_context_helper.js';\n\nexport const kAllWriteOps = ['storage', 'b2b-copy', 't2b-copy', 'write-buffer'] as const;\n\nexport const kAllReadOps = [\n  'input-vertex',\n  'input-index',\n  'input-indirect',\n  'input-indirect-index',\n  'input-indirect-dispatch',\n\n  'constant-uniform',\n\n  'storage-read',\n\n  'b2b-copy',\n  'b2t-copy',\n] as const;\n\nexport type ReadOp = typeof kAllReadOps[number];\nexport type WriteOp = typeof kAllWriteOps[number];\n\nexport type Op = ReadOp | WriteOp;\n\ninterface OpInfo {\n  readonly contexts: OperationContext[];\n}\n\nconst kOpInfo: {\n  readonly [k in Op]: OpInfo;\n} = /* prettier-ignore */ {\n  'write-buffer': {\n    contexts: [ 'queue' ],\n  },\n  'b2t-copy': {\n    contexts: [ 'command-encoder' ],\n  },\n  'b2b-copy': {\n    contexts: [ 'command-encoder' ],\n  },\n  't2b-copy': {\n    contexts: [ 'command-encoder' ],\n  },\n  'storage': {\n    contexts: [ 'compute-pass-encoder', 'render-pass-encoder', 'render-bundle-encoder' ],\n  },\n  'storage-read': {\n    contexts: [ 'compute-pass-encoder', 'render-pass-encoder', 'render-bundle-encoder' ],\n  },\n  'input-vertex': {\n    contexts: [ 'render-pass-encoder', 'render-bundle-encoder' ],\n  },\n  'input-index': {\n    contexts: [ 'render-pass-encoder', 'render-bundle-encoder' ],\n  },\n  'input-indirect': {\n    contexts: [ 'render-pass-encoder', 'render-bundle-encoder' ],\n  },\n  'input-indirect-index': {\n    contexts: [ 'render-pass-encoder', 'render-bundle-encoder' ],\n  },\n  'input-indirect-dispatch': {\n    contexts: [ 'compute-pass-encoder' ],\n  },\n  'constant-uniform': {\n    contexts: [ 'render-pass-encoder', 'render-bundle-encoder' ],\n  },\n};\n\nexport function checkOpsValidForContext(\n  ops: [Op, Op],\n  context: [OperationContext, OperationContext]\n) {\n  const valid =\n    kOpInfo[ops[0]].contexts.includes(context[0]) && kOpInfo[ops[1]].contexts.includes(context[1]);\n  if (!valid) return false;\n\n  if (\n    context[0] === 'render-bundle-encoder' ||\n    context[0] === 'render-pass-encoder' ||\n    context[1] === 'render-bundle-encoder' ||\n    context[1] === 'render-pass-encoder'\n  ) {\n    // In a render pass, it is invalid to use a resource as both writable and another usage.\n    // Also, for storage+storage usage, the application is opting into racy behavior.\n    // The storage+storage case is also skipped as the results cannot be reliably tested.\n    const checkImpl = (op1: Op, op2: Op) => {\n      switch (op1) {\n        case 'storage':\n          switch (op2) {\n            case 'storage':\n            case 'storage-read':\n            case 'input-vertex':\n            case 'input-index':\n            case 'input-indirect':\n            case 'input-indirect-index':\n            case 'constant-uniform':\n              // Write+other, or racy.\n              return false;\n            case 'b2t-copy':\n            case 't2b-copy':\n            case 'b2b-copy':\n            case 'write-buffer':\n              // These don't occur in a render pass.\n              return true;\n          }\n          break;\n        case 'input-vertex':\n        case 'input-index':\n        case 'input-indirect':\n        case 'input-indirect-index':\n        case 'constant-uniform':\n        case 'b2t-copy':\n        case 't2b-copy':\n        case 'b2b-copy':\n        case 'write-buffer':\n          // These are not write usages, or don't occur in a render pass.\n          break;\n      }\n      return true;\n    };\n    return checkImpl(ops[0], ops[1]) && checkImpl(ops[1], ops[0]);\n  }\n  return true;\n}\n\nconst kDummyVertexShader = `\n@vertex fn vert_main() -> @builtin(position) vec4<f32> {\n  return vec4<f32>(0.5, 0.5, 0.0, 1.0);\n}\n`;\n\n// Note: If it would be useful to have any of these helpers be separate from the fixture,\n// they can be refactored into standalone functions.\nexport class BufferSyncTest extends GPUTest {\n  // Vertex and index buffers used in read render pass\n  vertexBuffer?: GPUBuffer;\n  indexBuffer?: GPUBuffer;\n\n  // Temp buffer and texture with values for buffer/texture copy write op\n  // There can be at most 2 write op\n  tmpValueBuffers: (GPUBuffer | undefined)[] = [undefined, undefined];\n  tmpValueTextures: (GPUTexture | undefined)[] = [undefined, undefined];\n\n  // These intermediate buffers/textures are created before any read/write op\n  // to avoid extra memory synchronization between ops introduced by await on buffer/texture creations.\n  // Create extra buffers/textures needed by write operation\n  async createIntermediateBuffersAndTexturesForWriteOp(\n    writeOp: WriteOp,\n    slot: number,\n    value: number\n  ) {\n    switch (writeOp) {\n      case 'b2b-copy':\n        this.tmpValueBuffers[slot] = await this.createBufferWithValue(value);\n        break;\n      case 't2b-copy':\n        this.tmpValueTextures[slot] = await this.createTextureWithValue(value);\n        break;\n      default:\n        break;\n    }\n  }\n\n  // Create extra buffers/textures needed by read operation\n  async createBuffersForReadOp(readOp: ReadOp, srcValue: number, opValue: number) {\n    // This helps create values that will be written into dst buffer by the readop\n    switch (readOp) {\n      case 'input-index':\n        // The index buffer will be the src buffer of the read op.\n        // The src value for readOp will be 0\n        // If the index buffer value is 0, the src value is written into the dst buffer.\n        // If the index buffer value is 1, the op value is written into the dst buffer.\n        this.vertexBuffer = await this.createBufferWithValues([srcValue, opValue]);\n        break;\n      case 'input-indirect':\n        // The indirect buffer for the draw cmd will be the src buffer of the read op.\n        // If the first value in the indirect buffer is 1, then the op value in vertex buffer will be written into dst buffer.\n        // If the first value in indirect buffer is 0, then nothing will be write into dst buffer.\n        this.vertexBuffer = await this.createBufferWithValues([opValue]);\n        break;\n      case 'input-indirect-index':\n        // The indirect buffer for draw indexed cmd will be the src buffer of the read op.\n        // If the first value in the indirect buffer is 1, then the opValue in vertex buffer will be written into dst buffer.\n        // If the first value in indirect buffer is 0, then nothing will be write into dst buffer.\n        this.vertexBuffer = await this.createBufferWithValues([opValue]);\n        this.indexBuffer = await this.createBufferWithValues([0]);\n        break;\n      default:\n        break;\n    }\n\n    let srcBuffer: GPUBuffer;\n    switch (readOp) {\n      case 'input-indirect':\n        // vertexCount = {0, 1}\n        // instanceCount = 1\n        // firstVertex = 0\n        // firstInstance = 0\n        srcBuffer = await this.createBufferWithValues([srcValue, 1, 0, 0]);\n        break;\n      case 'input-indirect-index':\n        // indexCount = {0, 1}\n        // instanceCount = 1\n        // firstIndex = 0\n        // baseVertex = 0\n        // firstInstance = 0\n        srcBuffer = await this.createBufferWithValues([srcValue, 1, 0, 0, 0]);\n        break;\n      case 'input-indirect-dispatch':\n        // workgroupCountX = {0, 1}\n        // workgroupCountY = 1\n        // workgroupCountZ = 1\n        srcBuffer = await this.createBufferWithValues([srcValue, 1, 1]);\n        break;\n      default:\n        srcBuffer = await this.createBufferWithValue(srcValue);\n        break;\n    }\n\n    const dstBuffer = this.trackForCleanup(\n      this.device.createBuffer({\n        size: Uint32Array.BYTES_PER_ELEMENT,\n        usage:\n          GPUBufferUsage.COPY_SRC |\n          GPUBufferUsage.COPY_DST |\n          GPUBufferUsage.STORAGE |\n          GPUBufferUsage.VERTEX |\n          GPUBufferUsage.INDEX |\n          GPUBufferUsage.INDIRECT |\n          GPUBufferUsage.UNIFORM,\n      })\n    );\n\n    return { srcBuffer, dstBuffer };\n  }\n\n  // Create a buffer with 1 uint32 element, and initialize it to a specified value.\n  async createBufferWithValue(initValue: number): Promise<GPUBuffer> {\n    const buffer = this.trackForCleanup(\n      this.device.createBuffer({\n        mappedAtCreation: true,\n        size: Uint32Array.BYTES_PER_ELEMENT,\n        usage:\n          GPUBufferUsage.COPY_SRC |\n          GPUBufferUsage.COPY_DST |\n          GPUBufferUsage.STORAGE |\n          GPUBufferUsage.VERTEX |\n          GPUBufferUsage.INDEX |\n          GPUBufferUsage.INDIRECT |\n          GPUBufferUsage.UNIFORM,\n      })\n    );\n    new Uint32Array(buffer.getMappedRange()).fill(initValue);\n    buffer.unmap();\n    await this.queue.onSubmittedWorkDone();\n    return buffer;\n  }\n\n  // Create a buffer, and initialize it to the specified values.\n  async createBufferWithValues(initValues: number[]): Promise<GPUBuffer> {\n    const buffer = this.trackForCleanup(\n      this.device.createBuffer({\n        mappedAtCreation: true,\n        size: Uint32Array.BYTES_PER_ELEMENT * initValues.length,\n        usage:\n          GPUBufferUsage.COPY_SRC |\n          GPUBufferUsage.COPY_DST |\n          GPUBufferUsage.STORAGE |\n          GPUBufferUsage.VERTEX |\n          GPUBufferUsage.INDEX |\n          GPUBufferUsage.INDIRECT |\n          GPUBufferUsage.UNIFORM,\n      })\n    );\n    const bufferView = new Uint32Array(buffer.getMappedRange());\n    bufferView.set(initValues);\n    buffer.unmap();\n    await this.queue.onSubmittedWorkDone();\n    return buffer;\n  }\n\n  // Create a 1x1 texture, and initialize it to a specified value for all elements.\n  async createTextureWithValue(initValue: number): Promise<GPUTexture> {\n    const data = new Uint32Array(1).fill(initValue);\n    const texture = this.trackForCleanup(\n      this.device.createTexture({\n        size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n        format: 'r32uint',\n        usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n      })\n    );\n    this.device.queue.writeTexture(\n      { texture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      data,\n      { offset: 0, bytesPerRow: 256, rowsPerImage: 1 },\n      { width: 1, height: 1, depthOrArrayLayers: 1 }\n    );\n    await this.queue.onSubmittedWorkDone();\n    return texture;\n  }\n\n  createBindGroup(\n    pipeline: GPURenderPipeline | GPUComputePipeline,\n    buffer: GPUBuffer\n  ): GPUBindGroup {\n    return this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer } }],\n    });\n  }\n\n  // Create a compute pipeline and write given data into storage buffer.\n  createStorageWriteComputePipeline(value: number): GPUComputePipeline {\n    const wgslCompute = `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<storage, read_write> data : Data;\n      @compute @workgroup_size(1) fn main() {\n        data.a = ${value}u;\n      }\n    `;\n\n    return this.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: this.device.createShaderModule({\n          code: wgslCompute,\n        }),\n        entryPoint: 'main',\n      },\n    });\n  }\n\n  createTrivialRenderPipeline(wgslShaders: { vertex: string; fragment: string }) {\n    return this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.vertex,\n        }),\n        entryPoint: 'vert_main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.fragment,\n        }),\n        entryPoint: 'frag_main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'point-list' },\n    });\n  }\n\n  // Create a render pipeline and write given data into storage buffer at fragment stage.\n  createStorageWriteRenderPipeline(value: number): GPURenderPipeline {\n    const wgslShaders = {\n      vertex: kDummyVertexShader,\n      fragment: `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<storage, read_write> data : Data;\n      @fragment fn frag_main() -> @location(0) vec4<f32> {\n        data.a = ${value}u;\n        return vec4<f32>();  // result does't matter\n      }\n    `,\n    };\n\n    return this.createTrivialRenderPipeline(wgslShaders);\n  }\n\n  beginSimpleRenderPass(encoder: GPUCommandEncoder): GPURenderPassEncoder {\n    const view = this.trackForCleanup(\n      this.device.createTexture({\n        size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n        format: 'rgba8unorm',\n        usage: GPUTextureUsage.RENDER_ATTACHMENT,\n      })\n    ).createView();\n    return encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view,\n          clearValue: { r: 0.0, g: 1.0, b: 0.0, a: 1.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n  }\n\n  // Write buffer via draw call in render pass. Use bundle if needed.\n  encodeWriteAsStorageBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    buffer: GPUBuffer,\n    value: number\n  ) {\n    const pipeline = this.createStorageWriteRenderPipeline(value);\n    const bindGroup = this.createBindGroup(pipeline, buffer);\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.draw(1, 1, 0, 0);\n  }\n\n  // Write buffer via dispatch call in compute pass.\n  encodeWriteAsStorageBufferInComputePass(\n    pass: GPUComputePassEncoder,\n    buffer: GPUBuffer,\n    value: number\n  ) {\n    const pipeline = this.createStorageWriteComputePipeline(value);\n    const bindGroup = this.createBindGroup(pipeline, buffer);\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(1);\n  }\n\n  // Write buffer via BufferToBuffer copy.\n  encodeWriteByB2BCopy(encoder: GPUCommandEncoder, buffer: GPUBuffer, slot: number) {\n    const tmpBuffer = this.tmpValueBuffers[slot];\n    assert(tmpBuffer !== undefined);\n    // The write operation via b2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyBufferToBuffer(tmpBuffer, 0, buffer, 0, Uint32Array.BYTES_PER_ELEMENT);\n  }\n\n  // Write buffer via TextureToBuffer copy.\n  encodeWriteByT2BCopy(encoder: GPUCommandEncoder, buffer: GPUBuffer, slot: number) {\n    const tmpTexture = this.tmpValueTextures[slot];\n    assert(tmpTexture !== undefined);\n    // The write operation via t2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyTextureToBuffer(\n      { texture: tmpTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      { buffer, bytesPerRow: 256 },\n      { width: 1, height: 1, depthOrArrayLayers: 1 }\n    );\n  }\n\n  // Write buffer via writeBuffer API on queue\n  writeByWriteBuffer(buffer: GPUBuffer, value: number) {\n    const data = new Uint32Array(1).fill(value);\n    this.device.queue.writeBuffer(buffer, 0, data);\n  }\n\n  // Issue write operation via render pass, compute pass, copy, etc.\n  encodeWriteOp(\n    helper: OperationContextHelper,\n    operation: WriteOp,\n    context: OperationContext,\n    buffer: GPUBuffer,\n    writeOpSlot: number,\n    value: number\n  ) {\n    helper.ensureContext(context);\n\n    switch (operation) {\n      case 'write-buffer':\n        this.writeByWriteBuffer(buffer, value);\n        break;\n      case 'storage':\n        switch (context) {\n          case 'render-pass-encoder':\n            assert(helper.renderPassEncoder !== undefined);\n            this.encodeWriteAsStorageBufferInRenderPass(helper.renderPassEncoder, buffer, value);\n            break;\n          case 'render-bundle-encoder':\n            assert(helper.renderBundleEncoder !== undefined);\n            this.encodeWriteAsStorageBufferInRenderPass(helper.renderBundleEncoder, buffer, value);\n            break;\n          case 'compute-pass-encoder':\n            assert(helper.computePassEncoder !== undefined);\n            this.encodeWriteAsStorageBufferInComputePass(helper.computePassEncoder, buffer, value);\n            break;\n          default:\n            unreachable();\n        }\n        break;\n      case 'b2b-copy':\n        assert(helper.commandEncoder !== undefined);\n        this.encodeWriteByB2BCopy(helper.commandEncoder, buffer, writeOpSlot);\n        break;\n      case 't2b-copy':\n        assert(helper.commandEncoder !== undefined);\n        this.encodeWriteByT2BCopy(helper.commandEncoder, buffer, writeOpSlot);\n        break;\n      default:\n        unreachable();\n    }\n  }\n\n  // Create a compute pipeline: read from src buffer and write it into the storage buffer.\n  createStorageReadComputePipeline(): GPUComputePipeline {\n    const wgslCompute = `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<storage, read> srcData : Data;\n      @group(0) @binding(1) var<storage, read_write> dstData : Data;\n\n      @compute @workgroup_size(1) fn main() {\n        dstData.a = srcData.a;\n      }\n    `;\n\n    return this.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: this.device.createShaderModule({\n          code: wgslCompute,\n        }),\n        entryPoint: 'main',\n      },\n    });\n  }\n\n  createBindGroupSrcDstBuffer(\n    pipeline: GPURenderPipeline | GPUComputePipeline,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ): GPUBindGroup {\n    return this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: srcBuffer } },\n        { binding: 1, resource: { buffer: dstBuffer } },\n      ],\n    });\n  }\n\n  // Create a render pipeline: read from vertex/index buffer and write it into the storage dst buffer at fragment stage.\n  createVertexReadRenderPipeline(): GPURenderPipeline {\n    const wgslShaders = {\n      vertex: `\n      struct VertexOutput {\n        @builtin(position) position : vec4<f32>,\n        @location(0) @interpolate(flat) data : u32,\n      };\n\n      @vertex fn vert_main(@location(0) input: u32) -> VertexOutput {\n        var output : VertexOutput;\n        output.position = vec4<f32>(0.5, 0.5, 0.0, 1.0);\n        output.data = input;\n        return output;\n      }\n      `,\n      fragment: `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<storage, read_write> data : Data;\n\n      @fragment fn frag_main(@location(0) @interpolate(flat) input : u32) -> @location(0) vec4<f32> {\n        data.a = input;\n        return vec4<f32>();  // result does't matter\n      }\n      `,\n    };\n\n    return this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.vertex,\n        }),\n        entryPoint: 'vert_main',\n        buffers: [\n          {\n            arrayStride: Uint32Array.BYTES_PER_ELEMENT,\n            attributes: [\n              {\n                shaderLocation: 0,\n                offset: 0,\n                format: 'uint32',\n              },\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.fragment,\n        }),\n        entryPoint: 'frag_main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'point-list' },\n    });\n  }\n\n  // Create a render pipeline: read from uniform buffer and write it into the storage dst buffer at fragment stage.\n  createUniformReadRenderPipeline(): GPURenderPipeline {\n    const wgslShaders = {\n      vertex: kDummyVertexShader,\n      fragment: `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<uniform> constant: Data;\n      @group(0) @binding(1) var<storage, read_write> data : Data;\n\n      @fragment fn frag_main() -> @location(0) vec4<f32> {\n        data.a = constant.a;\n        return vec4<f32>();  // result does't matter\n      }\n      `,\n    };\n\n    return this.createTrivialRenderPipeline(wgslShaders);\n  }\n\n  // Create a render pipeline: read from storage src buffer and write it into the storage dst buffer at fragment stage.\n  createStorageReadRenderPipeline(): GPURenderPipeline {\n    const wgslShaders = {\n      vertex: kDummyVertexShader,\n      fragment: `\n        struct Data {\n          a : u32\n        };\n\n        @group(0) @binding(0) var<storage, read> srcData : Data;\n        @group(0) @binding(1) var<storage, read_write> dstData : Data;\n\n        @fragment fn frag_main() -> @location(0) vec4<f32> {\n          dstData.a = srcData.a;\n          return vec4<f32>();  // result does't matter\n        }\n      `,\n    };\n\n    return this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.vertex,\n        }),\n        entryPoint: 'vert_main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.fragment,\n        }),\n        entryPoint: 'frag_main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'point-list' },\n    });\n  }\n\n  // Write buffer via dispatch call in compute pass.\n  encodeReadAsStorageBufferInComputePass(\n    pass: GPUComputePassEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createStorageReadComputePipeline();\n    const bindGroup = this.createBindGroupSrcDstBuffer(pipeline, srcBuffer, dstBuffer);\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(1);\n  }\n\n  // Write buffer via dispatchWorkgroupsIndirect call in compute pass.\n  encodeReadAsIndirectBufferInComputePass(\n    pass: GPUComputePassEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer,\n    value: number\n  ) {\n    const pipeline = this.createStorageWriteComputePipeline(value);\n    const bindGroup = this.createBindGroup(pipeline, dstBuffer);\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroupsIndirect(srcBuffer, 0);\n  }\n\n  // Read as vertex input and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsVertexBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createVertexReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: dstBuffer } }],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.setVertexBuffer(0, srcBuffer);\n    renderer.draw(1);\n  }\n\n  // Read as index input and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsIndexBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer,\n    vertexBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createVertexReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: dstBuffer } }],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.setVertexBuffer(0, vertexBuffer);\n    renderer.setIndexBuffer(srcBuffer, 'uint32');\n    renderer.drawIndexed(1);\n  }\n\n  // Read as indirect input and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsIndirectBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer,\n    vertexBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createVertexReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: dstBuffer } }],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.setVertexBuffer(0, vertexBuffer);\n    renderer.drawIndirect(srcBuffer, 0);\n  }\n\n  // Read as indexed indirect input and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsIndexedIndirectBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer,\n    vertexBuffer: GPUBuffer,\n    indexBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createVertexReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: dstBuffer } }],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.setVertexBuffer(0, vertexBuffer);\n    renderer.setIndexBuffer(indexBuffer, 'uint32');\n    renderer.drawIndexedIndirect(srcBuffer, 0);\n  }\n\n  // Read as uniform buffer and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsUniformBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createUniformReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: srcBuffer } },\n        { binding: 1, resource: { buffer: dstBuffer } },\n      ],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.draw(1);\n  }\n\n  // Read as storage buffer and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsStorageBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createStorageReadRenderPipeline();\n    const bindGroup = this.createBindGroupSrcDstBuffer(pipeline, srcBuffer, dstBuffer);\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.draw(1, 1, 0, 0);\n  }\n\n  // Read and write via BufferToBuffer copy.\n  encodeReadByB2BCopy(encoder: GPUCommandEncoder, srcBuffer: GPUBuffer, dstBuffer: GPUBuffer) {\n    // The b2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyBufferToBuffer(srcBuffer, 0, dstBuffer, 0, Uint32Array.BYTES_PER_ELEMENT);\n  }\n\n  // Read and Write texture via BufferToTexture copy.\n  encodeReadByB2TCopy(encoder: GPUCommandEncoder, srcBuffer: GPUBuffer, dstBuffer: GPUBuffer) {\n    const tmpTexture = this.trackForCleanup(\n      this.device.createTexture({\n        size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n        format: 'r32uint',\n        usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n      })\n    );\n\n    // The b2t copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyBufferToTexture(\n      { buffer: srcBuffer, bytesPerRow: 256 },\n      { texture: tmpTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      { width: 1, height: 1, depthOrArrayLayers: 1 }\n    );\n    // The t2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyTextureToBuffer(\n      { texture: tmpTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      { buffer: dstBuffer, bytesPerRow: 256 },\n      { width: 1, height: 1, depthOrArrayLayers: 1 }\n    );\n  }\n\n  encodeReadOp(\n    helper: OperationContextHelper,\n    operation: ReadOp,\n    context: OperationContext,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    helper.ensureContext(context);\n\n    const renderer =\n      context === 'render-bundle-encoder' ? helper.renderBundleEncoder : helper.renderPassEncoder;\n    const computePass = context === 'compute-pass-encoder' ? helper.computePassEncoder : undefined;\n\n    switch (operation) {\n      case 'input-vertex':\n        // The srcBuffer is used as vertexBuffer.\n        // draw writes the same value in srcBuffer[0] to dstBuffer[0].\n        assert(renderer !== undefined);\n        this.encodeReadAsVertexBufferInRenderPass(renderer, srcBuffer, dstBuffer);\n        break;\n      case 'input-index':\n        // The srcBuffer is used as indexBuffer.\n        // With this vertexBuffer, drawIndexed writes the same value in srcBuffer[0] to dstBuffer[0].\n        assert(renderer !== undefined);\n        assert(this.vertexBuffer !== undefined);\n        this.encodeReadAsIndexBufferInRenderPass(renderer, srcBuffer, dstBuffer, this.vertexBuffer);\n        break;\n      case 'input-indirect':\n        // The srcBuffer is used as indirectBuffer for drawIndirect.\n        // srcBuffer[0] = 0 or 1 (vertexCount), which will decide the value written into dstBuffer to be either 0 or 1.\n        assert(renderer !== undefined);\n        assert(this.vertexBuffer !== undefined);\n        this.encodeReadAsIndirectBufferInRenderPass(\n          renderer,\n          srcBuffer,\n          dstBuffer,\n          this.vertexBuffer\n        );\n        break;\n      case 'input-indirect-index':\n        // The srcBuffer is used as indirectBuffer for drawIndexedIndirect.\n        // srcBuffer[0] = 0 or 1 (indexCount), which will decide the value written into dstBuffer to be either 0 or 1.\n        assert(renderer !== undefined);\n        assert(this.vertexBuffer !== undefined);\n        assert(this.indexBuffer !== undefined);\n        this.encodeReadAsIndexedIndirectBufferInRenderPass(\n          renderer,\n          srcBuffer,\n          dstBuffer,\n          this.vertexBuffer,\n          this.indexBuffer\n        );\n        break;\n      case 'input-indirect-dispatch':\n        // The srcBuffer is used as indirectBuffer for dispatch.\n        // srcBuffer[0] = 0 or 1 (workgroupCountX), which will decide the value written into dstBuffer to be either 0 or 1.\n        assert(computePass !== undefined);\n        this.encodeReadAsIndirectBufferInComputePass(computePass, srcBuffer, dstBuffer, 1);\n        break;\n      case 'constant-uniform':\n        // The srcBuffer is used as uniform buffer.\n        assert(renderer !== undefined);\n        this.encodeReadAsUniformBufferInRenderPass(renderer, srcBuffer, dstBuffer);\n        break;\n      case 'storage-read':\n        switch (context) {\n          case 'render-pass-encoder':\n          case 'render-bundle-encoder':\n            assert(renderer !== undefined);\n            this.encodeReadAsStorageBufferInRenderPass(renderer, srcBuffer, dstBuffer);\n            break;\n          case 'compute-pass-encoder':\n            assert(computePass !== undefined);\n            this.encodeReadAsStorageBufferInComputePass(computePass, srcBuffer, dstBuffer);\n            break;\n          default:\n            unreachable();\n        }\n        break;\n      case 'b2b-copy':\n        assert(helper.commandEncoder !== undefined);\n        this.encodeReadByB2BCopy(helper.commandEncoder, srcBuffer, dstBuffer);\n        break;\n      case 'b2t-copy':\n        assert(helper.commandEncoder !== undefined);\n        this.encodeReadByB2TCopy(helper.commandEncoder, srcBuffer, dstBuffer);\n        break;\n      default:\n        unreachable();\n    }\n  }\n\n  verifyData(buffer: GPUBuffer, expectedValue: number) {\n    const bufferData = new Uint32Array(1);\n    bufferData[0] = expectedValue;\n    this.expectGPUBufferValuesEqual(buffer, bufferData);\n  }\n\n  verifyDataTwoValidValues(buffer: GPUBuffer, expectedValue1: number, expectedValue2: number) {\n    const bufferData1 = new Uint32Array(1);\n    bufferData1[0] = expectedValue1;\n    const bufferData2 = new Uint32Array(1);\n    bufferData2[0] = expectedValue2;\n    this.expectGPUBufferValuesPassCheck(\n      buffer,\n      a => checkElementsEqualEither(a, [bufferData1, bufferData2]),\n      { type: Uint32Array, typedLength: 1 }\n    );\n  }\n}\n"],"file":"buffer_sync_test.js"}