{"version":3,"sources":["../../../../../../src/webgpu/api/operation/memory_sync/buffer/buffer_sync_test.ts"],"names":["assert","GPUTest","kSize","kAllWriteOps","BufferSyncTest","createBufferWithValue","initValue","fence","queue","createFence","buffer","device","createBuffer","mappedAtCreation","size","usage","GPUBufferUsage","COPY_SRC","COPY_DST","STORAGE","Uint32Array","getMappedRange","fill","unmap","signal","onCompletion","createTextureWithValue","data","texture","createTexture","width","height","depth","format","GPUTextureUsage","defaultQueue","writeTexture","mipLevel","origin","x","y","z","offset","bytesPerRow","rowsPerImage","createBindGroup","pipeline","layout","getBindGroupLayout","entries","binding","resource","createStorageWriteComputePipeline","value","wgslCompute","createComputePipeline","computeStage","module","createShaderModule","code","entryPoint","createStorageWriteRenderPipeline","wgslShaders","vertex","fragment","createRenderPipeline","vertexStage","fragmentStage","primitiveTopology","colorStates","beginSimpleRenderPass","encoder","view","OUTPUT_ATTACHMENT","createView","beginRenderPass","colorAttachments","attachment","loadValue","r","g","b","a","encodeWriteAsStorageBufferInRenderPass","inBundle","bindGroup","pass","renderer","createRenderBundleEncoder","colorFormats","setBindGroup","setPipeline","draw","executeBundles","finish","endPass","encodeWriteAsStorageBufferInComputePass","beginComputePass","dispatch","encodeWriteByB2BCopy","tmpBuffer","copyBufferToBuffer","encodeWriteByT2BCopy","tmpTexture","copyTextureToBuffer","writeByWriteBuffer","writeBuffer","encodeWriteOp","writeOp","createCommandBufferWithWriteOp","createCommandEncoder","submitWriteOp","submit","verifyData","expectedValue","bufferData","expectContents","verifyDataTwoValidValues","expectedValue1","expectedValue2","bufferData1","bufferData2","expectContentsTwoValidValues"],"mappings":"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","sourcesContent":["import { assert } from '../../../../../common/framework/util/util.js';\nimport { GPUTest } from '../../../../gpu_test.js';\n\nconst kSize = 4;\n\nexport const kAllWriteOps = ['render', 'render-via-bundle', 'compute', 'b2b-copy', 't2b-copy'];\n\n// Note: If it would be useful to have any of these helpers be separate from the fixture,\n// they can be refactored into standalone functions.\nexport class BufferSyncTest extends GPUTest {\n  // Create a buffer, and initialize it to a specified value for all elements.\n  async createBufferWithValue(initValue: number): Promise<GPUBuffer> {\n    const fence = this.queue.createFence();\n    const buffer = this.device.createBuffer({\n      mappedAtCreation: true,\n      size: kSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n    });\n    new Uint32Array(buffer.getMappedRange()).fill(initValue);\n    buffer.unmap();\n    this.queue.signal(fence, 1);\n    await fence.onCompletion(1);\n    return buffer;\n  }\n\n  // Create a texture, and initialize it to a specified value for all elements.\n  async createTextureWithValue(initValue: number): Promise<GPUTexture> {\n    const fence = this.queue.createFence();\n    const data = new Uint32Array(kSize / 4).fill(initValue);\n    const texture = this.device.createTexture({\n      size: { width: kSize / 4, height: 1, depth: 1 },\n      format: 'r32uint',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n    this.device.defaultQueue.writeTexture(\n      { texture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      data,\n      { offset: 0, bytesPerRow: kSize, rowsPerImage: 1 },\n      { width: kSize / 4, height: 1, depth: 1 }\n    );\n    this.queue.signal(fence, 1);\n    await fence.onCompletion(1);\n    return texture;\n  }\n\n  createBindGroup(\n    pipeline: GPURenderPipeline | GPUComputePipeline,\n    buffer: GPUBuffer\n  ): GPUBindGroup {\n    return this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer } }],\n    });\n  }\n\n  // Create a compute pipeline and write given data into storage buffer.\n  createStorageWriteComputePipeline(value: number): GPUComputePipeline {\n    const wgslCompute = `\n      [[block]] struct Data {\n        [[offset(0)]] a : i32;\n      };\n\n      [[binding(0), set(0)]] var<storage_buffer> data : Data;\n      [[stage(compute)]] fn main() -> void {\n        data.a = ${value};\n        return;\n      }\n    `;\n\n    return this.device.createComputePipeline({\n      computeStage: {\n        module: this.device.createShaderModule({\n          code: wgslCompute,\n        }),\n        entryPoint: 'main',\n      },\n    });\n  }\n\n  // Create a render pipeline and write given data into storage buffer at fragment stage.\n  createStorageWriteRenderPipeline(value: number): GPURenderPipeline {\n    const wgslShaders = {\n      vertex: `\n      [[builtin(position)]] var<out> Position : vec4<f32>;\n      [[stage(vertex)]] fn vert_main() -> void {\n        Position = vec4<f32>(0.5, 0.5, 0.0, 1.0);\n        return;\n      }\n    `,\n\n      fragment: `\n      [[location(0)]] var<out> outColor : vec4<f32>;\n      [[block]] struct Data {\n        [[offset(0)]] a : i32;\n      };\n\n      [[binding(0), set(0)]] var<storage_buffer> data : Data;\n      [[stage(fragment)]] fn frag_main() -> void {\n        data.a = ${value};\n        outColor = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n        return;\n      }\n    `,\n    };\n\n    return this.device.createRenderPipeline({\n      vertexStage: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.vertex,\n        }),\n        entryPoint: 'vert_main',\n      },\n      fragmentStage: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.fragment,\n        }),\n        entryPoint: 'frag_main',\n      },\n      primitiveTopology: 'point-list',\n      colorStates: [{ format: 'rgba8unorm' }],\n    });\n  }\n\n  beginSimpleRenderPass(encoder: GPUCommandEncoder): GPURenderPassEncoder {\n    const view = this.device\n      .createTexture({\n        size: { width: 1, height: 1, depth: 1 },\n        format: 'rgba8unorm',\n        usage: GPUTextureUsage.OUTPUT_ATTACHMENT,\n      })\n      .createView();\n    return encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          attachment: view,\n          loadValue: { r: 0.0, g: 1.0, b: 0.0, a: 1.0 },\n        },\n      ],\n    });\n  }\n\n  // Write buffer via draw call in render pass. Use bundle if needed.\n  encodeWriteAsStorageBufferInRenderPass(\n    encoder: GPUCommandEncoder,\n    buffer: GPUBuffer,\n    value: number,\n    inBundle: boolean\n  ) {\n    const pipeline = this.createStorageWriteRenderPipeline(value);\n    const bindGroup = this.createBindGroup(pipeline, buffer);\n\n    const pass = this.beginSimpleRenderPass(encoder);\n    const renderer = inBundle\n      ? this.device.createRenderBundleEncoder({ colorFormats: ['rgba8unorm'] })\n      : pass;\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.draw(1, 1, 0, 0);\n\n    if (inBundle) pass.executeBundles([(renderer as GPURenderBundleEncoder).finish()]);\n    pass.endPass();\n  }\n\n  // Write buffer via dispatch call in compute pass.\n  encodeWriteAsStorageBufferInComputePass(\n    encoder: GPUCommandEncoder,\n    buffer: GPUBuffer,\n    value: number\n  ) {\n    const pipeline = this.createStorageWriteComputePipeline(value);\n    const bindGroup = this.createBindGroup(pipeline, buffer);\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatch(1);\n    pass.endPass();\n  }\n\n  /** Write buffer via BufferToBuffer copy. */\n  async encodeWriteByB2BCopy(encoder: GPUCommandEncoder, buffer: GPUBuffer, value: number) {\n    const tmpBuffer = await this.createBufferWithValue(value);\n\n    // The write operation via b2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyBufferToBuffer(tmpBuffer, 0, buffer, 0, kSize);\n  }\n\n  // Write buffer via TextureToBuffer copy.\n  async encodeWriteByT2BCopy(encoder: GPUCommandEncoder, buffer: GPUBuffer, value: number) {\n    const tmpTexture = await this.createTextureWithValue(value);\n\n    // The write operation via t2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyTextureToBuffer(\n      { texture: tmpTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      { buffer, bytesPerRow: 256 },\n      { width: 1, height: 1, depth: 1 }\n    );\n  }\n\n  // Write buffer via writeBuffer API on queue\n  writeByWriteBuffer(buffer: GPUBuffer, value: number) {\n    const data = new Uint32Array(kSize / 4).fill(value);\n    this.device.defaultQueue.writeBuffer(buffer, 0, data);\n  }\n\n  // Issue write operation via render pass, compute pass, copy, etc.\n  async encodeWriteOp(\n    encoder: GPUCommandEncoder,\n    writeOp: string,\n    buffer: GPUBuffer,\n    value: number\n  ) {\n    switch (writeOp) {\n      case 'render':\n        this.encodeWriteAsStorageBufferInRenderPass(encoder, buffer, value, false);\n        break;\n      case 'render-via-bundle':\n        this.encodeWriteAsStorageBufferInRenderPass(encoder, buffer, value, true);\n        break;\n      case 'compute':\n        this.encodeWriteAsStorageBufferInComputePass(encoder, buffer, value);\n        break;\n      case 'b2b-copy':\n        await this.encodeWriteByB2BCopy(encoder, buffer, value);\n        break;\n      case 't2b-copy':\n        await this.encodeWriteByT2BCopy(encoder, buffer, value);\n        break;\n      default:\n        assert(false);\n    }\n  }\n\n  async createCommandBufferWithWriteOp(\n    writeOp: string,\n    buffer: GPUBuffer,\n    value: number\n  ): Promise<GPUCommandBuffer> {\n    const encoder = this.device.createCommandEncoder();\n    await this.encodeWriteOp(encoder, writeOp, buffer, value);\n    return encoder.finish();\n  }\n\n  async submitWriteOp(writeOp: string, buffer: GPUBuffer, value: number) {\n    if (writeOp === 'write-buffer') {\n      this.writeByWriteBuffer(buffer, value);\n    } else {\n      const encoder = this.device.createCommandEncoder();\n      await this.encodeWriteOp(encoder, writeOp, buffer, value);\n      this.device.defaultQueue.submit([encoder.finish()]);\n    }\n  }\n\n  verifyData(buffer: GPUBuffer, expectedValue: number) {\n    const bufferData = new Uint32Array(1);\n    bufferData[0] = expectedValue;\n    this.expectContents(buffer, bufferData);\n  }\n\n  verifyDataTwoValidValues(buffer: GPUBuffer, expectedValue1: number, expectedValue2: number) {\n    const bufferData1 = new Uint32Array(1);\n    bufferData1[0] = expectedValue1;\n    const bufferData2 = new Uint32Array(1);\n    bufferData2[0] = expectedValue2;\n    this.expectContentsTwoValidValues(buffer, bufferData1, bufferData2);\n  }\n}\n"],"file":"buffer_sync_test.js"}