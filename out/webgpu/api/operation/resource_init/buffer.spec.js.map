{"version":3,"sources":["../../../../../src/webgpu/api/operation/resource_init/buffer.spec.ts"],"names":["makeTestGroup","unreachable","GPUConst","GPUTest","getTextureCopyLayout","description","kMapModeOptions","MapMode","READ","WRITE","kBufferUsagesForMappedAtCreationTests","BufferUsage","COPY_DST","MAP_READ","COPY_SRC","MAP_WRITE","F","GetBufferUsageFromMapMode","mapMode","GPUMapMode","GPUBufferUsage","CheckGPUBufferContent","buffer","bufferUsage","expectedData","mappable","expectGPUBufferValuesEqual","method","TestBufferZeroInitInBindGroup","computeShaderModule","bufferOffset","boundBufferSize","computePipeline","device","createComputePipeline","compute","module","entryPoint","outputTexture","createTexture","format","size","usage","GPUTextureUsage","STORAGE_BINDING","bindGroup","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","offset","createView","encoder","createCommandEncoder","computePass","beginComputePass","setBindGroup","setPipeline","dispatch","endPass","queue","submit","finish","CheckBufferAndOutputTexture","CreateRenderPipelineForTest","vertexShaderModule","testVertexBuffer","renderPipelineDescriptor","vertex","fragment","createShaderModule","code","targets","primitive","topology","buffers","arrayStride","attributes","shaderLocation","createRenderPipeline","RecordInitializeTextureColor","texture","color","renderPass","beginRenderPass","colorAttachments","view","loadValue","storeOp","bufferSize","outputTextureSize","outputTextureColor","R","G","B","A","expectSingleColor","exp","expectedBufferData","Uint8Array","g","test","desc","paramsSubcasesOnly","u","combine","fn","t","params","appliedOffset","createBuffer","copySize","writeData","i","writeBuffer","mapAsync","readData","getMappedRange","expect","unmap","beginSubcases","mapSize","mappedData","mappedAtCreation","mapped","mappedSize","textureSize","dstTextureFormat","dstTexture","srcBufferSize","byteLength","srcBufferUsage","srcBuffer","copyBufferToTexture","bytesPerRow","rowsPerImage","QUERY_RESOLVE","dstBuffer","querySet","createQuerySet","type","count","resolveQuerySet","filter","arrayLayerCount","copyMipLevel","srcTextureFormat","srcTexture","RENDER_ATTACHMENT","mipLevelCount","mipLevel","dstBufferSize","Math","abs","layer","baseArrayLayer","baseMipLevel","r","b","a","max","copyTextureToBuffer","mipSize","y","x","UNIFORM","STORAGE","renderPipeline","vertexBuffer","VERTEX","setVertexBuffer","draw","indexBuffer","INDEX","setIndexBuffer","drawIndexed","test_indexed_draw","kDrawIndirectParametersSize","kDrawIndexedIndirectParametersSize","indirectBuffer","INDIRECT","undefined","drawIndexedIndirect","drawIndirect","kDispatchIndirectParametersSize","dispatchIndirect"],"mappings":"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","sourcesContent":["import { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { unreachable } from '../../../../common/util/util.js';\nimport { GPUConst } from '../../../constants.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { getTextureCopyLayout } from '../../../util/texture/layout.js';\nimport { PerTexelComponent } from '../../../util/texture/texel_data.js';\n\nexport const description = `\nTest uninitialized buffers are initialized to zero when read\n(or read-written, e.g. with depth write or atomics).\n\nNote that:\n-  We don't need 'copy_buffer_to_buffer_copy_destination' here because there has already been an\n   operation test 'command_buffer.copyBufferToBuffer.single' that provides the same functionality.\n`;\n\nconst kMapModeOptions = [GPUConst.MapMode.READ, GPUConst.MapMode.WRITE];\nconst kBufferUsagesForMappedAtCreationTests = [\n  GPUConst.BufferUsage.COPY_DST | GPUConst.BufferUsage.MAP_READ,\n  GPUConst.BufferUsage.COPY_SRC | GPUConst.BufferUsage.MAP_WRITE,\n  GPUConst.BufferUsage.COPY_SRC,\n];\n\nclass F extends GPUTest {\n  GetBufferUsageFromMapMode(mapMode: GPUMapModeFlags): number {\n    switch (mapMode) {\n      case GPUMapMode.READ:\n        return GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\n      case GPUMapMode.WRITE:\n        return GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE;\n      default:\n        unreachable();\n        return 0;\n    }\n  }\n\n  async CheckGPUBufferContent(\n    buffer: GPUBuffer,\n    bufferUsage: GPUBufferUsageFlags,\n    expectedData: Uint8Array\n  ): Promise<void> {\n    const mappable = bufferUsage & GPUBufferUsage.MAP_READ;\n    this.expectGPUBufferValuesEqual(buffer, expectedData, 0, { method: mappable ? 'map' : 'copy' });\n  }\n\n  TestBufferZeroInitInBindGroup(\n    computeShaderModule: GPUShaderModule,\n    buffer: GPUBuffer,\n    bufferOffset: number,\n    boundBufferSize: number\n  ): void {\n    const computePipeline = this.device.createComputePipeline({\n      compute: {\n        module: computeShaderModule,\n        entryPoint: 'main',\n      },\n    });\n    const outputTexture = this.device.createTexture({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.STORAGE_BINDING,\n    });\n    const bindGroup = this.device.createBindGroup({\n      layout: computePipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer,\n            offset: bufferOffset,\n            size: boundBufferSize,\n          },\n        },\n        {\n          binding: 1,\n          resource: outputTexture.createView(),\n        },\n      ],\n    });\n\n    const encoder = this.device.createCommandEncoder();\n    const computePass = encoder.beginComputePass();\n    computePass.setBindGroup(0, bindGroup);\n    computePass.setPipeline(computePipeline);\n    computePass.dispatch(1);\n    computePass.endPass();\n    this.queue.submit([encoder.finish()]);\n\n    this.CheckBufferAndOutputTexture(buffer, boundBufferSize + bufferOffset, outputTexture);\n  }\n\n  CreateRenderPipelineForTest(\n    vertexShaderModule: GPUShaderModule,\n    testVertexBuffer: boolean\n  ): GPURenderPipeline {\n    const renderPipelineDescriptor: GPURenderPipelineDescriptor = {\n      vertex: {\n        module: vertexShaderModule,\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n        @stage(fragment)\n        fn main(@location(0) i_color : vec4<f32>) -> @location(0) vec4<f32> {\n            return i_color;\n        }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: {\n        topology: 'point-list',\n      },\n    };\n    if (testVertexBuffer) {\n      renderPipelineDescriptor.vertex.buffers = [\n        {\n          arrayStride: 16,\n          attributes: [{ format: 'float32x4', offset: 0, shaderLocation: 0 }],\n        },\n      ];\n    }\n\n    return this.device.createRenderPipeline(renderPipelineDescriptor);\n  }\n\n  RecordInitializeTextureColor(\n    encoder: GPUCommandEncoder,\n    texture: GPUTexture,\n    color: GPUColor\n  ): void {\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: texture.createView(),\n          loadValue: color,\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.endPass();\n  }\n\n  CheckBufferAndOutputTexture(\n    buffer: GPUBuffer,\n    bufferSize: number,\n    outputTexture: GPUTexture,\n    outputTextureSize: [number, number, number] = [1, 1, 1],\n    outputTextureColor: PerTexelComponent<number> = { R: 0.0, G: 1.0, B: 0.0, A: 1.0 }\n  ): void {\n    this.expectSingleColor(outputTexture, 'rgba8unorm', {\n      size: outputTextureSize,\n      exp: outputTextureColor,\n    });\n\n    const expectedBufferData = new Uint8Array(bufferSize);\n    this.expectGPUBufferValuesEqual(buffer, expectedBufferData);\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('partial_write_buffer')\n  .desc(\n    `Verify when we upload data to a part of a buffer with writeBuffer() just after the creation of\nthe buffer, the remaining part of that buffer will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('offset', [0, 8, -12]))\n  .fn(async t => {\n    const { offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const copySize = 12;\n    const writeData = new Uint8Array(copySize);\n    const expectedData = new Uint8Array(bufferSize);\n    for (let i = 0; i < copySize; ++i) {\n      expectedData[appliedOffset + i] = writeData[i] = i + 1;\n    }\n    t.queue.writeBuffer(buffer, appliedOffset, writeData, 0);\n\n    t.expectGPUBufferValuesEqual(buffer, expectedData);\n  });\n\ng.test('map_whole_buffer')\n  .desc(\n    `Verify when we map the whole range of a mappable GPUBuffer to a typed array buffer just after\ncreating the GPUBuffer, the contents of both the typed array buffer and the GPUBuffer itself\nhave already been initialized to 0.`\n  )\n  .params(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n\n    const bufferSize = 32;\n    const bufferUsage = t.GetBufferUsageFromMapMode(mapMode);\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    await buffer.mapAsync(mapMode);\n    const readData = new Uint8Array(buffer.getMappedRange());\n    for (let i = 0; i < bufferSize; ++i) {\n      t.expect(readData[i] === 0);\n    }\n    buffer.unmap();\n\n    const expectedData = new Uint8Array(bufferSize);\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('map_partial_buffer')\n  .desc(\n    `Verify when we map a subrange of a mappable GPUBuffer to a typed array buffer just after the\ncreation of the GPUBuffer, the contents of both the typed array buffer and the GPUBuffer have\nalready been initialized to 0.`\n  )\n  .params(u => u.combine('mapMode', kMapModeOptions).beginSubcases().combine('offset', [0, 8, -16]))\n  .fn(async t => {\n    const { mapMode, offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const bufferUsage = t.GetBufferUsageFromMapMode(mapMode);\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const expectedData = new Uint8Array(bufferSize);\n    {\n      const mapSize = 16;\n      await buffer.mapAsync(mapMode, appliedOffset, mapSize);\n      const mappedData = new Uint8Array(buffer.getMappedRange(appliedOffset, mapSize));\n      for (let i = 0; i < mapSize; ++i) {\n        t.expect(mappedData[i] === 0);\n        if (mapMode === GPUMapMode.WRITE) {\n          mappedData[i] = expectedData[appliedOffset + i] = i + 1;\n        }\n      }\n      buffer.unmap();\n    }\n\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('mapped_at_creation_whole_buffer')\n  .desc(\n    `Verify when we call getMappedRange() at the whole range of a GPUBuffer created with\nmappedAtCreation === true just after its creation, the contents of both the returned typed\narray buffer of getMappedRange() and the GPUBuffer itself have all been initialized to 0.`\n  )\n  .params(u => u.combine('bufferUsage', kBufferUsagesForMappedAtCreationTests))\n  .fn(async t => {\n    const { bufferUsage } = t.params;\n\n    const bufferSize = 32;\n    const buffer = t.device.createBuffer({\n      mappedAtCreation: true,\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const mapped = new Uint8Array(buffer.getMappedRange());\n    for (let i = 0; i < bufferSize; ++i) {\n      t.expect(mapped[i] === 0);\n    }\n    buffer.unmap();\n\n    const expectedData = new Uint8Array(bufferSize);\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('mapped_at_creation_partial_buffer')\n  .desc(\n    `Verify when we call getMappedRange() at a subrange of a GPUBuffer created with\nmappedAtCreation === true just after its creation, the contents of both the returned typed\narray buffer of getMappedRange() and the GPUBuffer itself have all been initialized to 0.`\n  )\n  .params(u =>\n    u\n      .combine('bufferUsage', kBufferUsagesForMappedAtCreationTests)\n      .beginSubcases()\n      .combine('offset', [0, 8, -16])\n  )\n  .fn(async t => {\n    const { bufferUsage, offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const buffer = t.device.createBuffer({\n      mappedAtCreation: true,\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const expectedData = new Uint8Array(bufferSize);\n    {\n      const mappedSize = 12;\n      const mapped = new Uint8Array(buffer.getMappedRange(appliedOffset, mappedSize));\n      for (let i = 0; i < mappedSize; ++i) {\n        t.expect(mapped[i] === 0);\n        if (!(bufferUsage & GPUBufferUsage.MAP_READ)) {\n          mapped[i] = expectedData[appliedOffset + i] = i + 1;\n        }\n      }\n      buffer.unmap();\n    }\n\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('copy_buffer_to_buffer_copy_source')\n  .desc(\n    `Verify when the first usage of a GPUBuffer is being used as the source buffer of\nCopyBufferToBuffer(), the contents of the GPUBuffer have already been initialized to 0.`\n  )\n  .fn(async t => {\n    const bufferSize = 32;\n    const bufferUsage = GPUBufferUsage.COPY_SRC;\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const expectedData = new Uint8Array(bufferSize);\n    // copyBufferToBuffer() is called inside t.CheckGPUBufferContent().\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('copy_buffer_to_texture')\n  .desc(\n    `Verify when the first usage of a GPUBuffer is being used as the source buffer of\nCopyBufferToTexture(), the contents of the GPUBuffer have already been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 8]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n    const textureSize: [number, number, number] = [8, 8, 1];\n    const dstTextureFormat = 'rgba8unorm';\n\n    const dstTexture = t.device.createTexture({\n      size: textureSize,\n      format: dstTextureFormat,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n    const layout = getTextureCopyLayout(dstTextureFormat, '2d', textureSize);\n    const srcBufferSize = layout.byteLength + bufferOffset;\n    const srcBufferUsage = GPUBufferUsage.COPY_SRC;\n    const srcBuffer = t.device.createBuffer({\n      size: srcBufferSize,\n      usage: srcBufferUsage,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    encoder.copyBufferToTexture(\n      {\n        buffer: srcBuffer,\n        offset: bufferOffset,\n        bytesPerRow: layout.bytesPerRow,\n        rowsPerImage: layout.rowsPerImage,\n      },\n      { texture: dstTexture },\n      textureSize\n    );\n    t.queue.submit([encoder.finish()]);\n\n    t.CheckBufferAndOutputTexture(srcBuffer, srcBufferSize, dstTexture, textureSize, {\n      R: 0.0,\n      G: 0.0,\n      B: 0.0,\n      A: 0.0,\n    });\n  });\n\ng.test('resolve_query_set_to_partial_buffer')\n  .desc(\n    `Verify when we resolve a query set into a GPUBuffer just after creating that GPUBuffer, the\nremaining part of it will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n    const bufferSize = bufferOffset + 8;\n    const bufferUsage = GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE;\n    const dstBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const querySet = t.device.createQuerySet({ type: 'occlusion', count: 1 });\n    const encoder = t.device.createCommandEncoder();\n    encoder.resolveQuerySet(querySet, 0, 1, dstBuffer, bufferOffset);\n    t.queue.submit([encoder.finish()]);\n\n    const expectedBufferData = new Uint8Array(bufferSize);\n    await t.CheckGPUBufferContent(dstBuffer, bufferUsage, expectedBufferData);\n  });\n\ng.test('copy_texture_to_partial_buffer')\n  .desc(\n    `Verify when we copy from a GPUTexture into a GPUBuffer just after creating that GPUBuffer, the\nremaining part of it will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('bufferOffset', [0, 8, -16])\n      .combine('arrayLayerCount', [1, 3])\n      .combine('copyMipLevel', [0, 2])\n      .combine('rowsPerImage', [16, 20])\n      .filter(t => {\n        // We don't need to test the copies that will cover the whole GPUBuffer.\n        return !(t.bufferOffset === 0 && t.rowsPerImage === 16);\n      })\n  )\n  .fn(async t => {\n    const { bufferOffset, arrayLayerCount, copyMipLevel, rowsPerImage } = t.params;\n    const srcTextureFormat = 'r8uint';\n    const textureSize = [32, 16, arrayLayerCount] as const;\n\n    const srcTexture = t.device.createTexture({\n      format: srcTextureFormat,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n      size: textureSize,\n      mipLevelCount: copyMipLevel + 1,\n    });\n\n    const bytesPerRow = 256;\n    const layout = getTextureCopyLayout(srcTextureFormat, '2d', textureSize, {\n      mipLevel: copyMipLevel,\n      bytesPerRow,\n      rowsPerImage,\n    });\n\n    const dstBufferSize = layout.byteLength + Math.abs(bufferOffset);\n    const dstBuffer = t.device.createBuffer({\n      size: dstBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n\n    // Initialize srcTexture\n    for (let layer = 0; layer < arrayLayerCount; ++layer) {\n      const renderPass = encoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: srcTexture.createView({\n              baseArrayLayer: layer,\n              arrayLayerCount: 1,\n              baseMipLevel: copyMipLevel,\n            }),\n            loadValue: { r: layer + 1, g: 0, b: 0, a: 0 },\n            storeOp: 'store',\n          },\n        ],\n      });\n      renderPass.endPass();\n    }\n\n    // Do texture-to-buffer copy\n    const appliedOffset = Math.max(bufferOffset, 0);\n    encoder.copyTextureToBuffer(\n      { texture: srcTexture, mipLevel: copyMipLevel },\n      { buffer: dstBuffer, offset: appliedOffset, bytesPerRow, rowsPerImage },\n      layout.mipSize\n    );\n    t.queue.submit([encoder.finish()]);\n\n    // Check if the contents of the destination bufer are what we expect.\n    const expectedData = new Uint8Array(dstBufferSize);\n    for (let layer = 0; layer < arrayLayerCount; ++layer) {\n      for (let y = 0; y < layout.mipSize[1]; ++y) {\n        for (let x = 0; x < layout.mipSize[0]; ++x) {\n          expectedData[appliedOffset + layer * bytesPerRow * rowsPerImage + y * bytesPerRow + x] =\n            layer + 1;\n        }\n      }\n    }\n    t.expectGPUBufferValuesEqual(dstBuffer, expectedData);\n  });\n\ng.test('uniform_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a uniform buffer just after the creation of that GPUBuffer,\n    all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n\n    const boundBufferSize = 16;\n    const buffer = t.device.createBuffer({\n      size: bufferOffset + boundBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.UNIFORM,\n    });\n\n    const computeShaderModule = t.device.createShaderModule({\n      code: `\n  struct UBO {\n      value : vec4<u32>;\n  };\n  @group(0) @binding(0) var<uniform> ubo : UBO;\n  @group(0) @binding(1) var outImage : texture_storage_2d<rgba8unorm, write>;\n\n  @stage(compute) @workgroup_size(1) fn main() {\n      if (all(ubo.value == vec4<u32>(0u, 0u, 0u, 0u))) {\n          textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(0.0, 1.0, 0.0, 1.0));\n      } else {\n          textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n      }\n  }`,\n    });\n\n    // Verify the whole range of the buffer has been initialized to 0 in a compute shader.\n    t.TestBufferZeroInitInBindGroup(computeShaderModule, buffer, bufferOffset, boundBufferSize);\n  });\n\ng.test('readonly_storage_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a read-only storage buffer just after the creation of that\n    GPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n    const boundBufferSize = 16;\n    const buffer = t.device.createBuffer({\n      size: bufferOffset + boundBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n    });\n\n    const computeShaderModule = t.device.createShaderModule({\n      code: `\n    struct SSBO {\n        value : vec4<u32>;\n    };\n    @group(0) @binding(0) var<storage, read> ssbo : SSBO;\n    @group(0) @binding(1) var outImage : texture_storage_2d<rgba8unorm, write>;\n\n    @stage(compute) @workgroup_size(1) fn main() {\n        if (all(ssbo.value == vec4<u32>(0u, 0u, 0u, 0u))) {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(0.0, 1.0, 0.0, 1.0));\n        } else {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n        }\n    }`,\n    });\n\n    // Verify the whole range of the buffer has been initialized to 0 in a compute shader.\n    t.TestBufferZeroInitInBindGroup(computeShaderModule, buffer, bufferOffset, boundBufferSize);\n  });\n\ng.test('storage_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a storage buffer just after the creation of that\n    GPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n    const boundBufferSize = 16;\n    const buffer = t.device.createBuffer({\n      size: bufferOffset + boundBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n    });\n\n    const computeShaderModule = t.device.createShaderModule({\n      code: `\n    struct SSBO {\n        value : vec4<u32>;\n    };\n    @group(0) @binding(0) var<storage, read_write> ssbo : SSBO;\n    @group(0) @binding(1) var outImage : texture_storage_2d<rgba8unorm, write>;\n\n    @stage(compute) @workgroup_size(1) fn main() {\n        if (all(ssbo.value == vec4<u32>(0u, 0u, 0u, 0u))) {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(0.0, 1.0, 0.0, 1.0));\n        } else {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n        }\n    }`,\n    });\n\n    // Verify the whole range of the buffer has been initialized to 0 in a compute shader.\n    t.TestBufferZeroInitInBindGroup(computeShaderModule, buffer, bufferOffset, boundBufferSize);\n  });\n\ng.test('vertex_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a vertex buffer just after the creation of that\n  GPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 16]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n\n    const renderPipeline = t.CreateRenderPipelineForTest(\n      t.device.createShaderModule({\n        code: `\n      struct VertexOut {\n        @location(0) color : vec4<f32>;\n        @builtin(position) position : vec4<f32>;\n      };\n\n      @stage(vertex) fn main(@location(0) pos : vec4<f32>) -> VertexOut {\n        var output : VertexOut;\n        if (all(pos == vec4<f32>(0.0, 0.0, 0.0, 0.0))) {\n          output.color = vec4<f32>(0.0, 1.0, 0.0, 1.0);\n        } else {\n          output.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n        }\n        output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n        return output;\n      }`,\n      }),\n      true\n    );\n\n    const bufferSize = 16 + bufferOffset;\n    const vertexBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC,\n    });\n\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setVertexBuffer(0, vertexBuffer, bufferOffset);\n    renderPass.setPipeline(renderPipeline);\n    renderPass.draw(1);\n    renderPass.endPass();\n    t.queue.submit([encoder.finish()]);\n\n    t.CheckBufferAndOutputTexture(vertexBuffer, bufferSize, outputTexture);\n  });\n\ng.test('index_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as an index buffer just after the creation of that\nGPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 16]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n\n    const renderPipeline = t.CreateRenderPipelineForTest(\n      t.device.createShaderModule({\n        code: `\n    struct VertexOut {\n      @location(0) color : vec4<f32>;\n      @builtin(position) position : vec4<f32>;\n    };\n\n    @stage(vertex)\n    fn main(@builtin(vertex_index) VertexIndex : u32) -> VertexOut {\n      var output : VertexOut;\n      if (VertexIndex == 0u) {\n        output.color = vec4<f32>(0.0, 1.0, 0.0, 1.0);\n      } else {\n        output.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n      }\n      output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n      return output;\n    }`,\n      }),\n      false\n    );\n\n    // The size of GPUBuffer must be at least 4.\n    const bufferSize = 4 + bufferOffset;\n    const indexBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC,\n    });\n\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setPipeline(renderPipeline);\n    renderPass.setIndexBuffer(indexBuffer, 'uint16', bufferOffset, 4);\n    renderPass.drawIndexed(1);\n    renderPass.endPass();\n    t.queue.submit([encoder.finish()]);\n\n    t.CheckBufferAndOutputTexture(indexBuffer, bufferSize, outputTexture);\n  });\n\ng.test('indirect_buffer_for_draw_indirect')\n  .desc(\n    `Verify when we use a GPUBuffer as an indirect buffer for drawIndirect() or\ndrawIndexedIndirect() just after the creation of that GPUBuffer, all the contents in that GPUBuffer\nhave been initialized to 0.`\n  )\n  .params(u =>\n    u.combine('test_indexed_draw', [true, false]).beginSubcases().combine('bufferOffset', [0, 16])\n  )\n  .fn(async t => {\n    const { test_indexed_draw, bufferOffset } = t.params;\n\n    const renderPipeline = t.CreateRenderPipelineForTest(\n      t.device.createShaderModule({\n        code: `\n    struct VertexOut {\n      @location(0) color : vec4<f32>;\n      @builtin(position) position : vec4<f32>;\n    };\n\n    @stage(vertex) fn main() -> VertexOut {\n      var output : VertexOut;\n      output.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n      output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n      return output;\n    }`,\n      }),\n      false\n    );\n\n    const kDrawIndirectParametersSize = 16;\n    const kDrawIndexedIndirectParametersSize = 20;\n    const bufferSize =\n      Math.max(kDrawIndirectParametersSize, kDrawIndexedIndirectParametersSize) + bufferOffset;\n    const indirectBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT,\n    });\n\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    // Initialize outputTexture to green.\n    const encoder = t.device.createCommandEncoder();\n    t.RecordInitializeTextureColor(encoder, outputTexture, { r: 0.0, g: 1.0, b: 0.0, a: 1.0 });\n\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          loadValue: 'load',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setPipeline(renderPipeline);\n\n    let indexBuffer = undefined;\n    if (test_indexed_draw) {\n      indexBuffer = t.device.createBuffer({\n        size: 4,\n        usage: GPUBufferUsage.INDEX,\n      });\n      renderPass.setIndexBuffer(indexBuffer, 'uint16');\n      renderPass.drawIndexedIndirect(indirectBuffer, bufferOffset);\n    } else {\n      renderPass.drawIndirect(indirectBuffer, bufferOffset);\n    }\n\n    renderPass.endPass();\n    t.queue.submit([encoder.finish()]);\n\n    // The indirect buffer should be lazily cleared to 0, so we actually draw nothing and the color\n    // attachment will keep its original color (green) after we end the render pass.\n    t.CheckBufferAndOutputTexture(indirectBuffer, bufferSize, outputTexture);\n  });\n\ng.test('indirect_buffer_for_dispatch_indirect')\n  .desc(\n    `Verify when we use a GPUBuffer as an indirect buffer for dispatchIndirect() just after the\ncreation of that GPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 16]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n\n    const computePipeline = t.device.createComputePipeline({\n      compute: {\n        module: t.device.createShaderModule({\n          code: `\n        @group(0) @binding(0) var outImage : texture_storage_2d<rgba8unorm, write>;\n\n        @stage(compute) @workgroup_size(1) fn main() {\n          textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n        }`,\n        }),\n        entryPoint: 'main',\n      },\n    });\n\n    const kDispatchIndirectParametersSize = 12;\n    const bufferSize = kDispatchIndirectParametersSize + bufferOffset;\n    const indirectBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT,\n    });\n\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage:\n        GPUTextureUsage.COPY_SRC |\n        GPUTextureUsage.RENDER_ATTACHMENT |\n        GPUTextureUsage.STORAGE_BINDING,\n    });\n\n    // Initialize outputTexture to green.\n    const encoder = t.device.createCommandEncoder();\n    t.RecordInitializeTextureColor(encoder, outputTexture, { r: 0.0, g: 1.0, b: 0.0, a: 1.0 });\n\n    const bindGroup = t.device.createBindGroup({\n      layout: computePipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: outputTexture.createView(),\n        },\n      ],\n    });\n\n    // The indirect buffer should be lazily cleared to 0, so we actually don't execute the compute\n    // shader and the output texture should keep its original color (green).\n    const computePass = encoder.beginComputePass();\n    computePass.setBindGroup(0, bindGroup);\n    computePass.setPipeline(computePipeline);\n    computePass.dispatchIndirect(indirectBuffer, bufferOffset);\n    computePass.endPass();\n    t.queue.submit([encoder.finish()]);\n\n    // The indirect buffer should be lazily cleared to 0, so we actually draw nothing and the color\n    // attachment will keep its original color (green) after we end the compute pass.\n    t.CheckBufferAndOutputTexture(indirectBuffer, bufferSize, outputTexture);\n  });\n"],"file":"buffer.spec.js"}