{"version":3,"sources":["../../../../../src/webgpu/api/operation/texture_view/format_reinterpretation.spec.ts"],"names":["description","makeTestGroup","kRenderableColorTextureFormats","kRegularTextureFormats","viewCompatible","GPUTest","TexelView","textureContentIsOKByT2B","g","kColors","R","G","B","A","kTextureSize","makeInputTexelView","format","fromTexelsAsColors","coords","pixelPos","y","x","length","clampToFormatRange","makeBlitPipeline","device","multisample","createRenderPipeline","vertex","module","createShaderModule","code","entryPoint","fragment","sample","targets","count","render","test","desc","params","u","combine","filter","viewFormat","fn","t","inputTexelView","texture","makeTextureWithContents","size","usage","GPUTextureUsage","TEXTURE_BINDING","viewFormats","reinterpretedView","createView","reinterpretedTexelView","fromTexelsAsBytes","bytes","pipeline","createComputePipeline","compute","outputTexture","trackForCleanup","createTexture","STORAGE_BINDING","COPY_SRC","commandEncoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","dispatchWorkgroups","end","queue","submit","finish","result","expTexelView","color","maxDiffULPsForNormFormat","expectOK","sampleCount","renderTexture","RENDER_ATTACHMENT","resolveTexture","undefined","sampleSource","reinterpretedRenderView","reinterpretedResolveView","beginRenderPass","colorAttachments","view","resolveTarget","loadOp","storeOp","draw","singleSampleRenderTexture","renderViewTexels","resolveView"],"mappings":"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","sourcesContent":["export const description = `\nTest texture views can reinterpret the format of the original texture.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport {\n  EncodableTextureFormat,\n  kRenderableColorTextureFormats,\n  kRegularTextureFormats,\n  viewCompatible,\n} from '../../../capability_info.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { TexelView } from '../../../util/texture/texel_view.js';\nimport { textureContentIsOKByT2B } from '../../../util/texture/texture_ok.js';\n\nexport const g = makeTestGroup(GPUTest);\n\nconst kColors = [\n  { R: 1.0, G: 0.0, B: 0.0, A: 0.8 },\n  { R: 0.0, G: 1.0, B: 0.0, A: 0.7 },\n  { R: 0.0, G: 0.0, B: 0.0, A: 0.6 },\n  { R: 0.0, G: 0.0, B: 0.0, A: 0.5 },\n  { R: 1.0, G: 1.0, B: 1.0, A: 0.4 },\n  { R: 0.7, G: 0.0, B: 0.0, A: 0.3 },\n  { R: 0.0, G: 0.8, B: 0.0, A: 0.2 },\n  { R: 0.0, G: 0.0, B: 0.9, A: 0.1 },\n  { R: 0.1, G: 0.2, B: 0.0, A: 0.3 },\n  { R: 0.4, G: 0.3, B: 0.6, A: 0.8 },\n];\n\nconst kTextureSize = 16;\n\nfunction makeInputTexelView(format: EncodableTextureFormat) {\n  return TexelView.fromTexelsAsColors(\n    format,\n    coords => {\n      const pixelPos = coords.y * kTextureSize + coords.x;\n      return kColors[pixelPos % kColors.length];\n    },\n    { clampToFormatRange: true }\n  );\n}\n\nfunction makeBlitPipeline(\n  device: GPUDevice,\n  format: GPUTextureFormat,\n  multisample: { sample: number; render: number }\n) {\n  return device.createRenderPipeline({\n    vertex: {\n      module: device.createShaderModule({\n        code: `\n          @stage(vertex) fn main(@builtin(vertex_index) VertexIndex : u32) -> @builtin(position) vec4<f32> {\n            var pos = array<vec2<f32>, 6>(\n                                        vec2<f32>(-1.0, -1.0),\n                                        vec2<f32>(-1.0,  1.0),\n                                        vec2<f32>( 1.0, -1.0),\n                                        vec2<f32>(-1.0,  1.0),\n                                        vec2<f32>( 1.0, -1.0),\n                                        vec2<f32>( 1.0,  1.0));\n            return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n          }`,\n      }),\n      entryPoint: 'main',\n    },\n    fragment: {\n      module:\n        multisample.sample > 1\n          ? device.createShaderModule({\n              code: `\n            @group(0) @binding(0) var src: texture_multisampled_2d<f32>;\n            @stage(fragment) fn main(@builtin(position) coord: vec4<f32>) -> @location(0) vec4<f32> {\n              var result : vec4<f32>;\n              for (var i = 0; i < ${multisample.sample}; i = i + 1) {\n                result = result + textureLoad(src, vec2<i32>(coord.xy), i);\n              }\n              return result * ${1 / multisample.sample};\n            }`,\n            })\n          : device.createShaderModule({\n              code: `\n            @group(0) @binding(0) var src: texture_2d<f32>;\n            @stage(fragment) fn main(@builtin(position) coord: vec4<f32>) -> @location(0) vec4<f32> {\n              return textureLoad(src, vec2<i32>(coord.xy), 0);\n            }`,\n            }),\n      entryPoint: 'main',\n      targets: [{ format }],\n    },\n    multisample: {\n      count: multisample.render,\n    },\n  });\n}\n\ng.test('texture_binding')\n  .desc(`Test that a regular texture allocated as 'format' is correctly sampled as 'viewFormat'.`)\n  .params(u =>\n    u //\n      .combine('format', kRegularTextureFormats)\n      .combine('viewFormat', kRegularTextureFormats)\n      .filter(\n        ({ format, viewFormat }) => format !== viewFormat && viewCompatible(format, viewFormat)\n      )\n  )\n  .fn(async t => {\n    const { format, viewFormat } = t.params;\n\n    // Make an input texel view.\n    const inputTexelView = makeInputTexelView(format);\n\n    // Create the initial texture with the contents if the input texel view.\n    const texture = t.makeTextureWithContents(inputTexelView, {\n      size: [kTextureSize, kTextureSize],\n      usage: GPUTextureUsage.TEXTURE_BINDING,\n      viewFormats: [viewFormat],\n    });\n\n    // Reinterepret the texture as the view format.\n    // Make a texel view of the format that also reinterprets the data.\n    const reinterpretedView = texture.createView({ format: viewFormat });\n    const reinterpretedTexelView = TexelView.fromTexelsAsBytes(viewFormat, inputTexelView.bytes);\n\n    // Create a pipeline to write data out to rgba8unorm.\n    const pipeline = t.device.createComputePipeline({\n      compute: {\n        module: t.device.createShaderModule({\n          code: `\n          @group(0) @binding(0) var src: texture_2d<f32>;\n          @group(0) @binding(1) var dst: texture_storage_2d<rgba8unorm, write>;\n          @stage(compute) @workgroup_size(1, 1) fn main(\n            @builtin(global_invocation_id) global_id: vec3<u32>,\n          ) {\n            var coord = vec2<i32>(global_id.xy);\n            textureStore(dst, coord, textureLoad(src, coord, 0));\n          }`,\n        }),\n        entryPoint: 'main',\n      },\n    });\n\n    // Create an rgba8unorm output texture.\n    const outputTexture = t.trackForCleanup(\n      t.device.createTexture({\n        format: 'rgba8unorm',\n        size: [kTextureSize, kTextureSize],\n        usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n      })\n    );\n\n    // Execute a compute pass to load data from the reinterpreted view and\n    // write out to the rgba8unorm texture.\n    const commandEncoder = t.device.createCommandEncoder();\n    const pass = commandEncoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(\n      0,\n      t.device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [\n          {\n            binding: 0,\n            resource: reinterpretedView,\n          },\n          {\n            binding: 1,\n            resource: outputTexture.createView(),\n          },\n        ],\n      })\n    );\n    pass.dispatchWorkgroups(kTextureSize, kTextureSize);\n    pass.end();\n    t.device.queue.submit([commandEncoder.finish()]);\n\n    const result = await textureContentIsOKByT2B(\n      t,\n      { texture: outputTexture },\n      [kTextureSize, kTextureSize],\n      {\n        expTexelView: TexelView.fromTexelsAsColors('rgba8unorm', reinterpretedTexelView.color, {\n          clampToFormatRange: true,\n        }),\n      },\n      { maxDiffULPsForNormFormat: 1 }\n    );\n    t.expectOK(result);\n  });\n\ng.test('render_and_resolve_attachment')\n  .desc(\n    `Test that a color render attachment allocated as 'format' is correctly rendered to as 'viewFormat',\nand resolved to an attachment allocated as 'format' viewed as 'viewFormat'.\n\nOther combinations aren't possible because the render and resolve targets must both match\nin view format and match in base format.`\n  )\n  .params(u =>\n    u //\n      .combine('format', kRenderableColorTextureFormats)\n      .combine('viewFormat', kRenderableColorTextureFormats)\n      .filter(\n        ({ format, viewFormat }) => format !== viewFormat && viewCompatible(format, viewFormat)\n      )\n      .combine('sampleCount', [1, 4])\n  )\n  .fn(async t => {\n    const { format, viewFormat, sampleCount } = t.params;\n\n    // Make an input texel view.\n    const inputTexelView = makeInputTexelView(format);\n\n    // Create the renderTexture as |format|.\n    const renderTexture = t.trackForCleanup(\n      t.device.createTexture({\n        format,\n        size: [kTextureSize, kTextureSize],\n        usage:\n          GPUTextureUsage.RENDER_ATTACHMENT |\n          (sampleCount > 1 ? GPUTextureUsage.TEXTURE_BINDING : GPUTextureUsage.COPY_SRC),\n        viewFormats: [viewFormat],\n        sampleCount,\n      })\n    );\n\n    const resolveTexture =\n      sampleCount === 1\n        ? undefined\n        : t.trackForCleanup(\n            t.device.createTexture({\n              format,\n              size: [kTextureSize, kTextureSize],\n              usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n              viewFormats: [viewFormat],\n            })\n          );\n\n    // Create the sample source with the contents of the input texel view.\n    // We will sample this texture into |renderTexture|. It uses the same format to keep the same\n    // number of bits of precision.\n    const sampleSource = t.makeTextureWithContents(inputTexelView, {\n      size: [kTextureSize, kTextureSize],\n      usage: GPUTextureUsage.TEXTURE_BINDING,\n    });\n\n    // Reinterpret the renderTexture as |viewFormat|.\n    const reinterpretedRenderView = renderTexture.createView({ format: viewFormat });\n    const reinterpretedResolveView =\n      resolveTexture && resolveTexture.createView({ format: viewFormat });\n\n    // Create a pipeline to blit a src texture to the render attachment.\n    const pipeline = makeBlitPipeline(t.device, viewFormat, {\n      sample: 1,\n      render: sampleCount,\n    });\n\n    // Execute a render pass to sample |sampleSource| into |texture| viewed as |viewFormat|.\n    const commandEncoder = t.device.createCommandEncoder();\n    const pass = commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: reinterpretedRenderView,\n          resolveTarget: reinterpretedResolveView,\n          loadOp: 'load',\n          storeOp: 'store',\n        },\n      ],\n    });\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(\n      0,\n      t.device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [\n          {\n            binding: 0,\n            resource: sampleSource.createView(),\n          },\n        ],\n      })\n    );\n    pass.draw(6);\n    pass.end();\n\n    // If the render target is multisampled, we'll manually resolve it to check\n    // the contents.\n    const singleSampleRenderTexture = resolveTexture\n      ? t.trackForCleanup(\n          t.device.createTexture({\n            format,\n            size: [kTextureSize, kTextureSize],\n            usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n          })\n        )\n      : renderTexture;\n\n    if (resolveTexture) {\n      // Create a pipeline to blit the multisampled render texture to a non-multisample texture.\n      // We are basically performing a manual resolve step to the same format as the original\n      // render texture to check its contents.\n      const pipeline = makeBlitPipeline(t.device, format, { sample: sampleCount, render: 1 });\n      const pass = commandEncoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: singleSampleRenderTexture.createView(),\n            loadOp: 'load',\n            storeOp: 'store',\n          },\n        ],\n      });\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(\n        0,\n        t.device.createBindGroup({\n          layout: pipeline.getBindGroupLayout(0),\n          entries: [\n            {\n              binding: 0,\n              resource: renderTexture.createView(),\n            },\n          ],\n        })\n      );\n      pass.draw(6);\n      pass.end();\n    }\n\n    // Submit the commands.\n    t.device.queue.submit([commandEncoder.finish()]);\n\n    // Check the rendered contents.\n    const renderViewTexels = TexelView.fromTexelsAsColors(viewFormat, inputTexelView.color, {\n      clampToFormatRange: true,\n    });\n    t.expectOK(\n      await textureContentIsOKByT2B(\n        t,\n        { texture: singleSampleRenderTexture },\n        [kTextureSize, kTextureSize],\n        { expTexelView: renderViewTexels },\n        { maxDiffULPsForNormFormat: 2 }\n      )\n    );\n\n    // Check the resolved contents.\n    if (resolveTexture) {\n      const resolveView = TexelView.fromTexelsAsColors(viewFormat, renderViewTexels.color, {\n        clampToFormatRange: true,\n      });\n\n      const result = await textureContentIsOKByT2B(\n        t,\n        { texture: resolveTexture },\n        [kTextureSize, kTextureSize],\n        { expTexelView: resolveView },\n        { maxDiffULPsForNormFormat: 2 }\n      );\n      t.expectOK(result);\n    }\n  });\n"],"file":"format_reinterpretation.spec.js"}