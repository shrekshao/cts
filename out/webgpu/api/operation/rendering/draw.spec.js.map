{"version":3,"sources":["../../../../../src/webgpu/api/operation/rendering/draw.spec.ts"],"names":["description","makeTestGroup","assert","GPUTest","g","test","desc","params","u","combine","expand","p","indexed","undefined","beforeAllSubcases","t","first_instance","indirect","selectDeviceOrSkipTestCase","fn","renderTargetSize","numX","numY","tileSizeX","tileSizeY","triangleVertices","renderTarget","device","createTexture","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","COPY_SRC","format","vertexModule","createShaderModule","code","fragmentModule","pipeline","createRenderPipeline","layout","vertex","module","entryPoint","buffers","attributes","shaderLocation","offset","arrayStride","Float32Array","BYTES_PER_ELEMENT","fragment","targets","resultBuffer","createBuffer","Uint32Array","GPUBufferUsage","STORAGE","resultBindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","commandEncoder","createCommandEncoder","renderPass","beginRenderPass","colorAttachments","view","createView","clearValue","loadOp","storeOp","setPipeline","setBindGroup","base_vertex","index_buffer_offset","setIndexBuffer","makeBufferWithContents","Array","INDEX","setVertexBuffer","vertex_buffer_offset","VERTEX","args","count","instance_count","first","drawIndexedIndirect","INDIRECT","drawIndexed","apply","drawIndirect","draw","end","queue","submit","finish","green","Uint8Array","transparentBlack","didDraw","expectGPUBufferValuesEqual","baseVertex","primitiveId","instanceId","expectedColor","expectSinglePixelIn2DTexture","x","y","exp","unimplemented","unless","vertex_attribute_count","vertex_buffer_count","step_mode","vertexCount","instanceCount","attributesPerVertexBuffer","Math","round","attributeValue","bufferLayouts","ExpectedDataConstructor","vertex_format","vertexBuffers","vertexBufferData","b","vertexBufferValues","stepMode","vertexOrInstanceCount","a","attribute","push","v","data","vertexInputShaderLocations","fill","map","_","i","expectedData","length","vertexIndex","instanceIndex","forEach","bufferLayout","outputIndex","vertexOrInstanceIndex","wgslFormat","interStageScalarShaderLocation","min","interStageScalarShaderLocations","accumulateVariableDeclarationsInVertexShader","accumulateVariableAssignmentsInVertexShader","accumulateVariableDeclarationsInFragmentShader","accumulateVariableAssignmentsInFragmentShader","join","writeMask","primitive","topology"],"mappings":"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","sourcesContent":["export const description = `\nTests for the general aspects of draw/drawIndexed/drawIndirect/drawIndexedIndirect.\n\nPrimitive topology tested in api/operation/render_pipeline/primitive_topology.spec.ts.\nIndex format tested in api/operation/command_buffer/render/state_tracking.spec.ts.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport {\n  assert,\n  TypedArrayBufferView,\n  TypedArrayBufferViewConstructor,\n} from '../../../../common/util/util.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('arguments')\n  .desc(\n    `Test that draw arguments are passed correctly by drawing triangles in a grid.\nHorizontally across the texture are triangles with increasing \"primitive id\".\nVertically down the screen are triangles with increasing instance id.\nIncreasing the |first| param should skip some of the beginning triangles on the horizontal axis.\nIncreasing the |first_instance| param should skip of the beginning triangles on the vertical axis.\nThe vertex buffer contains two sets of disjoint triangles, and base_vertex is used to select the second set.\nThe test checks that the center of all of the expected triangles is drawn, and the others are empty.\nThe fragment shader also writes out to a storage buffer. If the draw is zero-sized, check that no value is written.\n\nParams:\n  - first= {0, 3} - either the firstVertex or firstIndex\n  - count= {0, 3, 6} - either the vertexCount or indexCount\n  - first_instance= {0, 2}\n  - instance_count= {0, 1, 4}\n  - indexed= {true, false}\n  - indirect= {true, false}\n  - vertex_buffer_offset= {0, 32}\n  - index_buffer_offset= {0, 16} - only for indexed draws\n  - base_vertex= {0, 9} - only for indexed draws\n  `\n  )\n  .params(u =>\n    u\n      .combine('first', [0, 3] as const)\n      .combine('count', [0, 3, 6] as const)\n      .combine('first_instance', [0, 2] as const)\n      .combine('instance_count', [0, 1, 4] as const)\n      .combine('indexed', [false, true])\n      .combine('indirect', [false, true])\n      .combine('vertex_buffer_offset', [0, 32] as const)\n      .expand('index_buffer_offset', p => (p.indexed ? ([0, 16] as const) : [undefined]))\n      .expand('base_vertex', p => (p.indexed ? ([0, 9] as const) : [undefined]))\n  )\n  .beforeAllSubcases(t => {\n    if (t.params.first_instance > 0 && t.params.indirect) {\n      t.selectDeviceOrSkipTestCase('indirect-first-instance');\n    }\n  })\n  .fn(async t => {\n    const renderTargetSize = [72, 36];\n\n    // The test will split up the render target into a grid where triangles of\n    // increasing primitive id will be placed along the X axis, and triangles\n    // of increasing instance id will be placed along the Y axis. The size of the\n    // grid is based on the max primitive id and instance id used.\n    const numX = 6;\n    const numY = 6;\n    const tileSizeX = renderTargetSize[0] / numX;\n    const tileSizeY = renderTargetSize[1] / numY;\n\n    // |\\\n    // |   \\\n    // |______\\\n    // Unit triangle shaped like this. 0-1 Y-down.\n    const triangleVertices = /* prettier-ignore */ [\n      0.0, 0.0,\n      0.0, 1.0,\n      1.0, 1.0,\n    ];\n\n    const renderTarget = t.device.createTexture({\n      size: renderTargetSize,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n    });\n\n    const vertexModule = t.device.createShaderModule({\n      code: `\nstruct Inputs {\n  @builtin(vertex_index) vertex_index : u32,\n  @builtin(instance_index) instance_id : u32,\n  @location(0) vertexPosition : vec2<f32>,\n};\n\n@vertex fn vert_main(input : Inputs\n  ) -> @builtin(position) vec4<f32> {\n  // 3u is the number of points in a triangle to convert from index\n  // to id.\n  var vertex_id : u32 = input.vertex_index / 3u;\n\n  var x : f32 = (input.vertexPosition.x + f32(vertex_id)) / ${numX}.0;\n  var y : f32 = (input.vertexPosition.y + f32(input.instance_id)) / ${numY}.0;\n\n  // (0,1) y-down space to (-1,1) y-up NDC\n  x = 2.0 * x - 1.0;\n  y = -2.0 * y + 1.0;\n  return vec4<f32>(x, y, 0.0, 1.0);\n}\n`,\n    });\n\n    const fragmentModule = t.device.createShaderModule({\n      code: `\nstruct Output {\n  value : u32\n};\n\n@group(0) @binding(0) var<storage, read_write> output : Output;\n\n@fragment fn frag_main() -> @location(0) vec4<f32> {\n  output.value = 1u;\n  return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n}\n`,\n    });\n\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: vertexModule,\n        entryPoint: 'vert_main',\n        buffers: [\n          {\n            attributes: [\n              {\n                shaderLocation: 0,\n                format: 'float32x2',\n                offset: 0,\n              },\n            ],\n            arrayStride: 2 * Float32Array.BYTES_PER_ELEMENT,\n          },\n        ],\n      },\n      fragment: {\n        module: fragmentModule,\n        entryPoint: 'frag_main',\n        targets: [\n          {\n            format: 'rgba8unorm',\n          },\n        ],\n      },\n    });\n\n    const resultBuffer = t.device.createBuffer({\n      size: Uint32Array.BYTES_PER_ELEMENT,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    const resultBindGroup = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: resultBuffer,\n          },\n        },\n      ],\n    });\n\n    const commandEncoder = t.device.createCommandEncoder();\n    const renderPass = commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          clearValue: [0, 0, 0, 0],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n\n    renderPass.setPipeline(pipeline);\n    renderPass.setBindGroup(0, resultBindGroup);\n\n    if (t.params.indexed) {\n      // INDEXED DRAW\n      assert(t.params.base_vertex !== undefined);\n      assert(t.params.index_buffer_offset !== undefined);\n\n      renderPass.setIndexBuffer(\n        t.makeBufferWithContents(\n          /* prettier-ignore */ new Uint32Array([\n            // Offset the index buffer contents by empty data.\n            ...new Array(t.params.index_buffer_offset / Uint32Array.BYTES_PER_ELEMENT),\n\n            0,  1,  2, //\n            3,  4,  5, //\n            6,  7,  8, //\n          ]),\n          GPUBufferUsage.INDEX\n        ),\n        'uint32',\n        t.params.index_buffer_offset\n      );\n\n      renderPass.setVertexBuffer(\n        0,\n        t.makeBufferWithContents(\n          /* prettier-ignore */ new Float32Array([\n            // Offset the vertex buffer contents by empty data.\n            ...new Array(t.params.vertex_buffer_offset / Float32Array.BYTES_PER_ELEMENT),\n\n            // selected with base_vertex=0\n                                 // count=6\n            ...triangleVertices, //   |   count=6;first=3\n            ...triangleVertices, //   |       |\n            ...triangleVertices, //           |\n\n            // selected with base_vertex=9\n                                 // count=6\n            ...triangleVertices, //   |   count=6;first=3\n            ...triangleVertices, //   |       |\n            ...triangleVertices, //           |\n          ]),\n          GPUBufferUsage.VERTEX\n        ),\n        t.params.vertex_buffer_offset\n      );\n\n      const args = [\n        t.params.count,\n        t.params.instance_count,\n        t.params.first,\n        t.params.base_vertex,\n        t.params.first_instance,\n      ] as const;\n      if (t.params.indirect) {\n        renderPass.drawIndexedIndirect(\n          t.makeBufferWithContents(new Uint32Array(args), GPUBufferUsage.INDIRECT),\n          0\n        );\n      } else {\n        renderPass.drawIndexed.apply(renderPass, [...args]);\n      }\n    } else {\n      // NON-INDEXED DRAW\n      renderPass.setVertexBuffer(\n        0,\n        t.makeBufferWithContents(\n          /* prettier-ignore */ new Float32Array([\n            // Offset the vertex buffer contents by empty data.\n            ...new Array(t.params.vertex_buffer_offset / Float32Array.BYTES_PER_ELEMENT),\n\n                                 // count=6\n            ...triangleVertices, //   |   count=6;first=3\n            ...triangleVertices, //   |       |\n            ...triangleVertices, //           |\n          ]),\n          GPUBufferUsage.VERTEX\n        ),\n        t.params.vertex_buffer_offset\n      );\n\n      const args = [\n        t.params.count,\n        t.params.instance_count,\n        t.params.first,\n        t.params.first_instance,\n      ] as const;\n      if (t.params.indirect) {\n        renderPass.drawIndirect(\n          t.makeBufferWithContents(new Uint32Array(args), GPUBufferUsage.INDIRECT),\n          0\n        );\n      } else {\n        renderPass.draw.apply(renderPass, [...args]);\n      }\n    }\n\n    renderPass.end();\n    t.queue.submit([commandEncoder.finish()]);\n\n    const green = new Uint8Array([0, 255, 0, 255]);\n    const transparentBlack = new Uint8Array([0, 0, 0, 0]);\n\n    const didDraw = t.params.count && t.params.instance_count;\n\n    t.expectGPUBufferValuesEqual(resultBuffer, new Uint32Array([didDraw ? 1 : 0]));\n\n    const baseVertex = t.params.base_vertex ?? 0;\n    for (let primitiveId = 0; primitiveId < numX; ++primitiveId) {\n      for (let instanceId = 0; instanceId < numY; ++instanceId) {\n        let expectedColor = didDraw ? green : transparentBlack;\n        if (\n          primitiveId * 3 < t.params.first + baseVertex ||\n          primitiveId * 3 >= t.params.first + baseVertex + t.params.count\n        ) {\n          expectedColor = transparentBlack;\n        }\n\n        if (\n          instanceId < t.params.first_instance ||\n          instanceId >= t.params.first_instance + t.params.instance_count\n        ) {\n          expectedColor = transparentBlack;\n        }\n\n        t.expectSinglePixelIn2DTexture(\n          renderTarget,\n          'rgba8unorm',\n          {\n            x: (1 / 3 + primitiveId) * tileSizeX,\n            y: (2 / 3 + instanceId) * tileSizeY,\n          },\n          {\n            exp: expectedColor,\n          }\n        );\n      }\n    }\n  });\n\ng.test('default_arguments')\n  .desc(\n    `TODO: Test defaults to draw / drawIndexed. Maybe merge with the 'arguments' test.\n- arg= {instance_count, first, first_instance, base_vertex}\n- mode= {draw, drawIndexed}\n  `\n  )\n  .unimplemented();\n\ng.test('vertex_attributes,basic')\n  .desc(\n    `Test basic fetching of vertex attributes.\n  Each vertex attribute is a single value and written out into a storage buffer.\n  Tests that vertices with offsets/strides for instanced/non-instanced attributes are\n  fetched correctly. Not all vertex formats are tested.\n\n  Params:\n  - vertex_attribute_count= {1, 4, 8, 16}\n  - vertex_buffer_count={1, 4, 8} - where # attributes is > 0\n  - vertex_format={uint32, float32}\n  - step_mode= {undefined, vertex, instance, mixed} - where mixed only applies for vertex_buffer_count > 1\n  `\n  )\n  .params(u =>\n    u\n      .combine('vertex_attribute_count', [1, 4, 8, 16])\n      .combine('vertex_buffer_count', [1, 4, 8])\n      .combine('vertex_format', ['uint32', 'float32'] as const)\n      .combine('step_mode', [undefined, 'vertex', 'instance', 'mixed'] as const)\n      .unless(p => p.vertex_attribute_count < p.vertex_buffer_count)\n      .unless(p => p.step_mode === 'mixed' && p.vertex_buffer_count <= 1)\n  )\n  .fn(t => {\n    const vertexCount = 4;\n    const instanceCount = 4;\n\n    const attributesPerVertexBuffer =\n      t.params.vertex_attribute_count / t.params.vertex_buffer_count;\n    assert(Math.round(attributesPerVertexBuffer) === attributesPerVertexBuffer);\n\n    let shaderLocation = 0;\n    let attributeValue = 0;\n    const bufferLayouts: GPUVertexBufferLayout[] = [];\n\n    let ExpectedDataConstructor: TypedArrayBufferViewConstructor;\n    switch (t.params.vertex_format) {\n      case 'uint32':\n        ExpectedDataConstructor = Uint32Array;\n        break;\n      case 'float32':\n        ExpectedDataConstructor = Float32Array;\n        break;\n    }\n\n    // Populate |bufferLayouts|, |vertexBufferData|, and |vertexBuffers|.\n    // We will use this to both create the render pipeline, and produce the\n    // expected data on the CPU.\n    // Attributes in each buffer will be interleaved.\n    const vertexBuffers: GPUBuffer[] = [];\n    const vertexBufferData: TypedArrayBufferView[] = [];\n    for (let b = 0; b < t.params.vertex_buffer_count; ++b) {\n      const vertexBufferValues: number[] = [];\n\n      let offset = 0;\n      let stepMode = t.params.step_mode;\n\n      // If stepMode is mixed, alternate between vertex and instance.\n      if (stepMode === 'mixed') {\n        stepMode = (['vertex', 'instance'] as const)[b % 2];\n      }\n\n      let vertexOrInstanceCount: number;\n      switch (stepMode) {\n        case undefined:\n        case 'vertex':\n          vertexOrInstanceCount = vertexCount;\n          break;\n        case 'instance':\n          vertexOrInstanceCount = instanceCount;\n          break;\n      }\n\n      const attributes: GPUVertexAttribute[] = [];\n      for (let a = 0; a < attributesPerVertexBuffer; ++a) {\n        const attribute: GPUVertexAttribute = {\n          format: t.params.vertex_format,\n          shaderLocation,\n          offset,\n        };\n        attributes.push(attribute);\n\n        offset += ExpectedDataConstructor.BYTES_PER_ELEMENT;\n        shaderLocation += 1;\n      }\n\n      for (let v = 0; v < vertexOrInstanceCount; ++v) {\n        for (let a = 0; a < attributesPerVertexBuffer; ++a) {\n          vertexBufferValues.push(attributeValue);\n          attributeValue += 1.234; // Values will get rounded later if we make a Uint32Array.\n        }\n      }\n\n      bufferLayouts.push({\n        attributes,\n        arrayStride: offset,\n        stepMode,\n      });\n\n      const data = new ExpectedDataConstructor(vertexBufferValues);\n      vertexBufferData.push(data);\n      vertexBuffers.push(t.makeBufferWithContents(data, GPUBufferUsage.VERTEX));\n    }\n\n    // Create an array of shader locations [0, 1, 2, 3, ...] for easy iteration.\n    const vertexInputShaderLocations = new Array(shaderLocation).fill(0).map((_, i) => i);\n\n    // Create the expected data buffer.\n    const expectedData = new ExpectedDataConstructor(\n      vertexCount * instanceCount * vertexInputShaderLocations.length\n    );\n\n    // Populate the expected data. This is a CPU-side version of what we expect the shader\n    // to do.\n    for (let vertexIndex = 0; vertexIndex < vertexCount; ++vertexIndex) {\n      for (let instanceIndex = 0; instanceIndex < instanceCount; ++instanceIndex) {\n        bufferLayouts.forEach((bufferLayout, b) => {\n          for (const attribute of bufferLayout.attributes) {\n            const primitiveId = vertexCount * instanceIndex + vertexIndex;\n            const outputIndex =\n              primitiveId * vertexInputShaderLocations.length + attribute.shaderLocation;\n\n            let vertexOrInstanceIndex: number;\n            switch (bufferLayout.stepMode) {\n              case undefined:\n              case 'vertex':\n                vertexOrInstanceIndex = vertexIndex;\n                break;\n              case 'instance':\n                vertexOrInstanceIndex = instanceIndex;\n                break;\n            }\n\n            const view = new ExpectedDataConstructor(\n              vertexBufferData[b].buffer,\n              bufferLayout.arrayStride * vertexOrInstanceIndex + attribute.offset,\n              1\n            );\n            expectedData[outputIndex] = view[0];\n          }\n        });\n      }\n    }\n\n    let wgslFormat: string;\n    switch (t.params.vertex_format) {\n      case 'uint32':\n        wgslFormat = 'u32';\n        break;\n      case 'float32':\n        wgslFormat = 'f32';\n        break;\n    }\n\n    // Maximum inter-stage shader location is 14, and we need to consume one for primitiveId, 12 for\n    // location 0 to 11,  and combine the remaining vertex inputs into one location (one\n    // vec4<wgslFormat> when vertex_attribute_count === 16).\n    const interStageScalarShaderLocation = Math.min(shaderLocation, 12);\n    const interStageScalarShaderLocations = new Array(interStageScalarShaderLocation)\n      .fill(0)\n      .map((_, i) => i);\n\n    let accumulateVariableDeclarationsInVertexShader = '';\n    let accumulateVariableAssignmentsInVertexShader = '';\n    let accumulateVariableDeclarationsInFragmentShader = '';\n    let accumulateVariableAssignmentsInFragmentShader = '';\n    // The remaining 3 vertex attributes\n    if (t.params.vertex_attribute_count === 16) {\n      accumulateVariableDeclarationsInVertexShader = `\n        @location(13) @interpolate(flat) outAttrib13 : vec4<${wgslFormat}>,\n      `;\n      accumulateVariableAssignmentsInVertexShader = `\n      output.outAttrib13 =\n          vec4<${wgslFormat}>(input.attrib12, input.attrib13, input.attrib14, input.attrib15);\n      `;\n      accumulateVariableDeclarationsInFragmentShader = `\n      @location(13) @interpolate(flat) attrib13 : vec4<${wgslFormat}>,\n      `;\n      accumulateVariableAssignmentsInFragmentShader = `\n      outBuffer.primitives[input.primitiveId].attrib12 = input.attrib13.x;\n      outBuffer.primitives[input.primitiveId].attrib13 = input.attrib13.y;\n      outBuffer.primitives[input.primitiveId].attrib14 = input.attrib13.z;\n      outBuffer.primitives[input.primitiveId].attrib15 = input.attrib13.w;\n      `;\n    }\n\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: t.device.createShaderModule({\n          code: `\nstruct Inputs {\n  @builtin(vertex_index) vertexIndex : u32,\n  @builtin(instance_index) instanceIndex : u32,\n${vertexInputShaderLocations.map(i => `  @location(${i}) attrib${i} : ${wgslFormat},`).join('\\n')}\n};\n\nstruct Outputs {\n  @builtin(position) Position : vec4<f32>,\n${interStageScalarShaderLocations\n  .map(i => `  @location(${i}) @interpolate(flat) outAttrib${i} : ${wgslFormat},`)\n  .join('\\n')}\n  @location(${interStageScalarShaderLocations.length}) @interpolate(flat) primitiveId : u32,\n${accumulateVariableDeclarationsInVertexShader}\n};\n\n@vertex fn main(input : Inputs) -> Outputs {\n  var output : Outputs;\n${interStageScalarShaderLocations.map(i => `  output.outAttrib${i} = input.attrib${i};`).join('\\n')}\n${accumulateVariableAssignmentsInVertexShader}\n\n  output.primitiveId = input.instanceIndex * ${instanceCount}u + input.vertexIndex;\n  output.Position = vec4<f32>(0.0, 0.0, 0.5, 1.0);\n  return output;\n}\n          `,\n        }),\n        entryPoint: 'main',\n        buffers: bufferLayouts,\n      },\n      fragment: {\n        module: t.device.createShaderModule({\n          code: `\nstruct Inputs {\n${interStageScalarShaderLocations\n  .map(i => `  @location(${i}) @interpolate(flat) attrib${i} : ${wgslFormat},`)\n  .join('\\n')}\n  @location(${interStageScalarShaderLocations.length}) @interpolate(flat) primitiveId : u32,\n${accumulateVariableDeclarationsInFragmentShader}\n};\n\nstruct OutPrimitive {\n${vertexInputShaderLocations.map(i => `  attrib${i} : ${wgslFormat},`).join('\\n')}\n};\nstruct OutBuffer {\n  primitives : array<OutPrimitive>\n};\n@group(0) @binding(0) var<storage, read_write> outBuffer : OutBuffer;\n\n@fragment fn main(input : Inputs) {\n${interStageScalarShaderLocations\n  .map(i => `  outBuffer.primitives[input.primitiveId].attrib${i} = input.attrib${i};`)\n  .join('\\n')}\n${accumulateVariableAssignmentsInFragmentShader}\n}\n          `,\n        }),\n        entryPoint: 'main',\n        targets: [\n          {\n            format: 'rgba8unorm',\n            writeMask: 0,\n          },\n        ],\n      },\n      primitive: {\n        topology: 'point-list',\n      },\n    });\n\n    const resultBuffer = t.device.createBuffer({\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n      size: vertexCount * instanceCount * vertexInputShaderLocations.length * 4,\n    });\n\n    const resultBindGroup = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: resultBuffer,\n          },\n        },\n      ],\n    });\n\n    const commandEncoder = t.device.createCommandEncoder();\n    const renderPass = commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          // Dummy render attachment - not used (WebGPU doesn't allow using a render pass with no\n          // attachments)\n          view: t.device\n            .createTexture({\n              usage: GPUTextureUsage.RENDER_ATTACHMENT,\n              size: [1],\n              format: 'rgba8unorm',\n            })\n            .createView(),\n          clearValue: [0, 0, 0, 0],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n\n    renderPass.setPipeline(pipeline);\n    renderPass.setBindGroup(0, resultBindGroup);\n    for (let i = 0; i < t.params.vertex_buffer_count; ++i) {\n      renderPass.setVertexBuffer(i, vertexBuffers[i]);\n    }\n    renderPass.draw(vertexCount, instanceCount);\n    renderPass.end();\n    t.device.queue.submit([commandEncoder.finish()]);\n\n    t.expectGPUBufferValuesEqual(resultBuffer, expectedData);\n  });\n\ng.test('vertex_attributes,formats')\n  .desc(\n    `Test all vertex formats are fetched correctly.\n\n    Runs a basic vertex shader which loads vertex data from two attributes which\n    may have different formats. Write data out to a storage buffer and check that\n    it was loaded correctly.\n\n    Params:\n      - vertex_format_1={...all_vertex_formats}\n      - vertex_format_2={...all_vertex_formats}\n  `\n  )\n  .unimplemented();\n\ng.test(`largeish_buffer`)\n  .desc(\n    `\n    Test a very large range of buffer is bound.\n    For a render pipeline that use a vertex step mode and a instance step mode vertex buffer, test\n    that :\n    - For draw, drawIndirect, drawIndexed and drawIndexedIndirect:\n        - The bound range of vertex step mode vertex buffer is significantly larger than necessary\n        - The bound range of instance step mode vertex buffer is significantly larger than necessary\n        - A large buffer is bound to an unused slot\n    - For drawIndexed and drawIndexedIndirect:\n        - The bound range of index buffer is significantly larger than necessary\n    - For drawIndirect and drawIndexedIndirect:\n        - The indirect buffer is significantly larger than necessary\n`\n  )\n  .unimplemented();\n"],"file":"draw.spec.js"}