{"version":3,"sources":["../../../../../src/webgpu/api/operation/rendering/depth_clip_clamp.spec.ts"],"names":["description","makeTestGroup","kDepthStencilFormats","kTextureFormatInfo","GPUTest","checkElementsBetween","checkElementsPassPredicate","g","test","desc","params","u","combine","filter","p","format","depth","undefined","beforeAllSubcases","t","info","selectDeviceOrSkipTestCase","unclippedDepth","feature","fn","writeDepth","multisampled","kNumDepthValues","kNumTestPoints","kViewportMinDepth","kViewportMaxDepth","shaderSource","module","device","createShaderModule","code","testPipeline","createRenderPipeline","layout","vertex","entryPoint","primitive","topology","depthStencil","depthWriteEnabled","multisample","count","fragment","targets","checkPipeline","depthCompare","dsTexture","createTexture","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","COPY_SRC","sampleCount","dsTextureView","createView","checkTextureDesc","checkTexture","checkTextureView","checkTextureMSView","dsActual","bytesPerBlock","createBuffer","GPUBufferUsage","COPY_DST","MAP_READ","dsExpected","checkBuffer","fragInputZFailedBuffer","STORAGE","testBindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","enc","createCommandEncoder","pass","beginRenderPass","colorAttachments","depthStencilAttachment","view","depthClearValue","depthLoadOp","depthStoreOp","stencilClearValue","stencil","stencilLoadOp","stencilStoreOp","setPipeline","setBindGroup","setViewport","draw","end","copyTextureToBuffer","texture","clearValue","resolveTarget","loadOp","storeOp","queue","submit","finish","expectGPUBufferValuesPassCheck","a","type","Float32Array","typedLength","kCheckPassedValue","predicatePrinter","leftHeader","getValueForCell","index","Promise","all","mapAsync","GPUMapMode","READ","act","getMappedRange","exp","push","toFixed","value","Uint8Array","method","initPipeline","testTextureDesc","testTexture","testTextureView","testTextureMSView","resultBuffer","expectGPUBufferValuesEqual"],"mappings":"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","sourcesContent":["export const description = `\nTests for depth clipping, depth clamping (at various points in the pipeline), and maybe extended\ndepth ranges as well.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { kDepthStencilFormats, kTextureFormatInfo } from '../../../capability_info.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport {\n  checkElementsBetween,\n  checkElementsPassPredicate,\n  CheckElementsSupplementalTableRows,\n} from '../../../util/check_contents.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('depth_clamp_and_clip')\n  .desc(\n    `\nDepth written to the depth attachment should always be in the range of the viewport depth,\neven if it was written by the fragment shader (using frag_depth). If depth clipping is enabled,\nprimitives should be clipped to the viewport depth before rasterization; if not, these fragments\nshould be rasterized, and the fragment shader should receive out-of-viewport position.z values.\n\nTo test this, render NxN points, with N vertex depth values, by (if writeDepth=true) N\nfrag_depth values with the viewport depth set to [0.25,0.75].\n\nWhile rendering, check the fragment input position.z has the expected value (for all fragments that\nwere produced by the rasterizer) by writing the diff to a storage buffer, which is later checked to\nbe all (near) 0.\n\nThen, run another pass (which outputs every point at z=0.5 to avoid clipping) to verify the depth\nbuffer contents by outputting the expected depth with depthCompare:'not-equal': any fragments that\nhave unexpected values then get drawn to the color buffer, which is later checked to be empty.`\n  )\n  .params(u =>\n    u //\n      .combine('format', kDepthStencilFormats)\n      .filter(p => kTextureFormatInfo[p.format].depth)\n      .combine('unclippedDepth', [undefined, false, true])\n      .combine('writeDepth', [false, true])\n      .combine('multisampled', [false, true])\n  )\n  .beforeAllSubcases(t => {\n    const info = kTextureFormatInfo[t.params.format];\n\n    t.selectDeviceOrSkipTestCase([\n      t.params.unclippedDepth ? 'depth-clip-control' : undefined,\n      info.feature,\n    ]);\n  })\n  .fn(async t => {\n    const { format, unclippedDepth, writeDepth, multisampled } = t.params;\n    const info = kTextureFormatInfo[format];\n\n    /** Number of depth values to test for both vertex output and frag_depth output. */\n    const kNumDepthValues = 8;\n    /** Test every combination of vertex output and frag_depth output. */\n    const kNumTestPoints = kNumDepthValues * kNumDepthValues;\n    const kViewportMinDepth = 0.25;\n    const kViewportMaxDepth = 0.75;\n\n    const shaderSource = `\n      // Test depths, with viewport range corresponding to [0,1].\n      var<private> kDepths: array<f32, ${kNumDepthValues}> = array<f32, ${kNumDepthValues}>(\n          -1.0, -0.5, 0.0, 0.25, 0.75, 1.0, 1.5, 2.0);\n\n      const vpMin: f32 = ${kViewportMinDepth};\n      const vpMax: f32 = ${kViewportMaxDepth};\n\n      // Draw the points in a straight horizontal row, one per pixel.\n      fn vertexX(idx: u32) -> f32 {\n        return (f32(idx) + 0.5) * 2.0 / ${kNumTestPoints}.0 - 1.0;\n      }\n\n      // Test vertex shader's position.z output.\n      // Here, the viewport range corresponds to position.z in [0,1].\n      fn vertexZ(idx: u32) -> f32 {\n        return kDepths[idx / ${kNumDepthValues}u];\n      }\n\n      // Test fragment shader's expected position.z input.\n      // Here, the viewport range corresponds to position.z in [vpMin,vpMax], but\n      // unclipped values extend beyond that range.\n      fn expectedFragPosZ(idx: u32) -> f32 {\n        return vpMin + vertexZ(idx) * (vpMax - vpMin);\n      }\n\n      //////// \"Test\" entry points\n\n      struct VFTest {\n        @builtin(position) pos: vec4<f32>,\n        @location(0) @interpolate(flat) vertexIndex: u32,\n      };\n\n      @vertex\n      fn vtest(@builtin(vertex_index) idx: u32) -> VFTest {\n        var vf: VFTest;\n        vf.pos = vec4<f32>(vertexX(idx), 0.0, vertexZ(idx), 1.0);\n        vf.vertexIndex = idx;\n        return vf;\n      }\n\n      struct Output {\n        // Each fragment (that didn't get clipped) writes into one element of this output.\n        // (Anything that doesn't get written is already zero.)\n        fragInputZDiff: array<f32, ${kNumTestPoints}>\n      };\n      @group(0) @binding(0) var <storage, read_write> output: Output;\n\n      fn checkZ(vf: VFTest) {\n        output.fragInputZDiff[vf.vertexIndex] = vf.pos.z - expectedFragPosZ(vf.vertexIndex);\n      }\n\n      @fragment\n      fn ftest_WriteDepth(vf: VFTest) -> @builtin(frag_depth) f32 {\n        checkZ(vf);\n        return kDepths[vf.vertexIndex % ${kNumDepthValues}u];\n      }\n\n      @fragment\n      fn ftest_NoWriteDepth(vf: VFTest) {\n        checkZ(vf);\n      }\n\n      //////// \"Check\" entry points\n\n      struct VFCheck {\n        @builtin(position) pos: vec4<f32>,\n        @location(0) @interpolate(flat) vertexIndex: u32,\n      };\n\n      @vertex\n      fn vcheck(@builtin(vertex_index) idx: u32) -> VFCheck {\n        var vf: VFCheck;\n        // Depth=0.5 because we want to render every point, not get clipped.\n        vf.pos = vec4<f32>(vertexX(idx), 0.0, 0.5, 1.0);\n        vf.vertexIndex = idx;\n        return vf;\n      }\n\n      struct FCheck {\n        @builtin(frag_depth) depth: f32,\n        @location(0) color: f32,\n      };\n\n      @fragment\n      fn fcheck(vf: VFCheck) -> FCheck {\n        let vertZ = vertexZ(vf.vertexIndex);\n        let outOfRange = vertZ < 0.0 || vertZ > 1.0;\n        let expFragPosZ = expectedFragPosZ(vf.vertexIndex);\n\n        let writtenDepth = kDepths[vf.vertexIndex % ${kNumDepthValues}u];\n\n        let expectedDepthWriteInput = ${writeDepth ? 'writtenDepth' : 'expFragPosZ'};\n        var expectedDepthBufferValue = clamp(expectedDepthWriteInput, vpMin, vpMax);\n        if (${!unclippedDepth} && outOfRange) {\n          // Test fragment should have been clipped; expect the depth attachment to\n          // have its clear value (0.5).\n          expectedDepthBufferValue = 0.5;\n        }\n\n        var f: FCheck;\n        f.depth = expectedDepthBufferValue;\n        f.color = 1.0; // Color written if the resulting depth is unexpected.\n        return f;\n      }\n    `;\n    const module = t.device.createShaderModule({ code: shaderSource });\n\n    // Draw points at different vertex depths and fragment depths into the depth attachment,\n    // with a viewport of [0.25,0.75].\n    const testPipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module, entryPoint: 'vtest' },\n      primitive: {\n        topology: 'point-list',\n        unclippedDepth,\n      },\n      depthStencil: { format, depthWriteEnabled: true },\n      multisample: multisampled ? { count: 4 } : undefined,\n      fragment: {\n        module,\n        entryPoint: writeDepth ? 'ftest_WriteDepth' : 'ftest_NoWriteDepth',\n        targets: [],\n      },\n    });\n\n    // Use depth comparison to check that the depth attachment now has the expected values.\n    const checkPipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module, entryPoint: 'vcheck' },\n      primitive: { topology: 'point-list' },\n      depthStencil: {\n        format,\n        // NOTE: This check is probably very susceptible to floating point error. If it fails, maybe\n        // replace it with two checks (less + greater) with an epsilon applied in the check shader?\n        depthCompare: 'not-equal', // Expect every depth value to be exactly equal.\n        depthWriteEnabled: true, // If the check failed, overwrite with the expected result.\n      },\n      multisample: multisampled ? { count: 4 } : undefined,\n      fragment: { module, entryPoint: 'fcheck', targets: [{ format: 'r8unorm' }] },\n    });\n\n    const dsTexture = t.device.createTexture({\n      format,\n      size: [kNumTestPoints],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      sampleCount: multisampled ? 4 : 1,\n    });\n    const dsTextureView = dsTexture.createView();\n\n    const checkTextureDesc = {\n      format: 'r8unorm' as const,\n      size: [kNumTestPoints],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    };\n    const checkTexture = t.device.createTexture(checkTextureDesc);\n    const checkTextureView = checkTexture.createView();\n    const checkTextureMSView = multisampled\n      ? t.device.createTexture({ ...checkTextureDesc, sampleCount: 4 }).createView()\n      : undefined;\n\n    const dsActual =\n      !multisampled && info.bytesPerBlock\n        ? t.device.createBuffer({\n            size: kNumTestPoints * info.bytesPerBlock,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n          })\n        : undefined;\n    const dsExpected =\n      !multisampled && info.bytesPerBlock\n        ? t.device.createBuffer({\n            size: kNumTestPoints * info.bytesPerBlock,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n          })\n        : undefined;\n    const checkBuffer = t.device.createBuffer({\n      size: kNumTestPoints,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n    });\n\n    const fragInputZFailedBuffer = t.device.createBuffer({\n      size: 4 * kNumTestPoints,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n    const testBindGroup = t.device.createBindGroup({\n      layout: testPipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: fragInputZFailedBuffer } }],\n    });\n\n    const enc = t.device.createCommandEncoder();\n    {\n      const pass = enc.beginRenderPass({\n        colorAttachments: [],\n        depthStencilAttachment: {\n          view: dsTextureView,\n          depthClearValue: 0.5, // Will see this depth value if the fragment was clipped.\n          depthLoadOp: 'clear',\n          depthStoreOp: 'store',\n          stencilClearValue: info.stencil ? 0 : undefined,\n          stencilLoadOp: info.stencil ? 'clear' : undefined,\n          stencilStoreOp: info.stencil ? 'discard' : undefined,\n        },\n      });\n      pass.setPipeline(testPipeline);\n      pass.setBindGroup(0, testBindGroup);\n      pass.setViewport(0, 0, kNumTestPoints, 1, kViewportMinDepth, kViewportMaxDepth);\n      pass.draw(kNumTestPoints);\n      pass.end();\n    }\n    if (dsActual) {\n      enc.copyTextureToBuffer({ texture: dsTexture }, { buffer: dsActual }, [kNumTestPoints]);\n    }\n    {\n      const clearValue = [0, 0, 0, 0]; // Will see this color if the check passed.\n      const pass = enc.beginRenderPass({\n        colorAttachments: [\n          checkTextureMSView\n            ? {\n                view: checkTextureMSView,\n                resolveTarget: checkTextureView,\n                clearValue,\n                loadOp: 'clear',\n                storeOp: 'discard',\n              }\n            : { view: checkTextureView, clearValue, loadOp: 'clear', storeOp: 'store' },\n        ],\n        depthStencilAttachment: {\n          view: dsTextureView,\n          depthLoadOp: 'load',\n          depthStoreOp: 'store',\n          stencilClearValue: info.stencil ? 0 : undefined,\n          stencilLoadOp: info.stencil ? 'clear' : undefined,\n          stencilStoreOp: info.stencil ? 'discard' : undefined,\n        },\n      });\n      pass.setPipeline(checkPipeline);\n      pass.setViewport(0, 0, kNumTestPoints, 1, 0.0, 1.0);\n      pass.draw(kNumTestPoints);\n      pass.end();\n    }\n    enc.copyTextureToBuffer({ texture: checkTexture }, { buffer: checkBuffer }, [kNumTestPoints]);\n    if (dsExpected) {\n      enc.copyTextureToBuffer({ texture: dsTexture }, { buffer: dsExpected }, [kNumTestPoints]);\n    }\n    t.device.queue.submit([enc.finish()]);\n\n    t.expectGPUBufferValuesPassCheck(\n      fragInputZFailedBuffer,\n      a => checkElementsBetween(a, [() => -1e-5, () => 1e-5]),\n      { type: Float32Array, typedLength: kNumTestPoints }\n    );\n\n    const kCheckPassedValue = 0;\n    const predicatePrinter: CheckElementsSupplementalTableRows = [\n      { leftHeader: 'expected ==', getValueForCell: index => kCheckPassedValue },\n    ];\n    if (dsActual && dsExpected && format === 'depth32float') {\n      await Promise.all([dsActual.mapAsync(GPUMapMode.READ), dsExpected.mapAsync(GPUMapMode.READ)]);\n      const act = new Float32Array(dsActual.getMappedRange());\n      const exp = new Float32Array(dsExpected.getMappedRange());\n      predicatePrinter.push(\n        { leftHeader: 'act ==', getValueForCell: index => act[index].toFixed(2) },\n        { leftHeader: 'exp ==', getValueForCell: index => exp[index].toFixed(2) }\n      );\n    }\n    t.expectGPUBufferValuesPassCheck(\n      checkBuffer,\n      a =>\n        checkElementsPassPredicate(a, (index, value) => value === kCheckPassedValue, {\n          predicatePrinter,\n        }),\n      { type: Uint8Array, typedLength: kNumTestPoints, method: 'map' }\n    );\n  });\n\ng.test('depth_test_input_clamped')\n  .desc(\n    `\nInput to the depth test should always be in the range of viewport depth, even if it was written by\nthe fragment shader (using frag_depth).\n\nTo test this, first initialize the depth buffer with N expected values (by writing frag_depth, with\nthe default viewport). These expected values are clamped by the shader to [0.25, 0.75].\n\nThen, run another pass with the viewport depth set to [0.25,0.75], and output various (unclamped)\nfrag_depth values from its fragment shader with depthCompare:'not-equal'. These should get clamped;\nany fragments that have unexpected values then get drawn to the color buffer, which is later checked\nto be empty.`\n  )\n  .params(u =>\n    u //\n      .combine('format', kDepthStencilFormats)\n      .filter(p => kTextureFormatInfo[p.format].depth)\n      .combine('unclippedDepth', [false, true])\n      .combine('multisampled', [false, true])\n  )\n  .beforeAllSubcases(t => {\n    const info = kTextureFormatInfo[t.params.format];\n\n    t.selectDeviceOrSkipTestCase([\n      t.params.unclippedDepth ? 'depth-clip-control' : undefined,\n      info.feature,\n    ]);\n  })\n  .fn(async t => {\n    const { format, unclippedDepth, multisampled } = t.params;\n    const info = kTextureFormatInfo[format];\n\n    const kNumDepthValues = 8;\n    const kViewportMinDepth = 0.25;\n    const kViewportMaxDepth = 0.75;\n\n    const shaderSource = `\n      // Test depths, with viewport range corresponding to [0,1].\n      var<private> kDepths: array<f32, ${kNumDepthValues}> = array<f32, ${kNumDepthValues}>(\n          -1.0, -0.5, 0.0, 0.25, 0.75, 1.0, 1.5, 2.0);\n\n      const vpMin: f32 = ${kViewportMinDepth};\n      const vpMax: f32 = ${kViewportMaxDepth};\n\n      // Draw the points in a straight horizontal row, one per pixel.\n      fn vertexX(idx: u32) -> f32 {\n        return (f32(idx) + 0.5) * 2.0 / ${kNumDepthValues}.0 - 1.0;\n      }\n\n      struct VF {\n        @builtin(position) pos: vec4<f32>,\n        @location(0) @interpolate(flat) vertexIndex: u32,\n      };\n\n      @vertex\n      fn vmain(@builtin(vertex_index) idx: u32) -> VF {\n        var vf: VF;\n        // Depth=0.5 because we want to render every point, not get clipped.\n        vf.pos = vec4<f32>(vertexX(idx), 0.0, 0.5, 1.0);\n        vf.vertexIndex = idx;\n        return vf;\n      }\n\n      @fragment\n      fn finit(vf: VF) -> @builtin(frag_depth) f32 {\n        // Expected values of the ftest pipeline.\n        return clamp(kDepths[vf.vertexIndex], vpMin, vpMax);\n      }\n\n      struct FTest {\n        @builtin(frag_depth) depth: f32,\n        @location(0) color: f32,\n      };\n\n      @fragment\n      fn ftest(vf: VF) -> FTest {\n        var f: FTest;\n        f.depth = kDepths[vf.vertexIndex]; // Should get clamped to the viewport.\n        f.color = 1.0; // Color written if the resulting depth is unexpected.\n        return f;\n      }\n    `;\n\n    const module = t.device.createShaderModule({ code: shaderSource });\n\n    // Initialize depth attachment with expected values, in [0.25,0.75].\n    const initPipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module, entryPoint: 'vmain' },\n      primitive: { topology: 'point-list' },\n      depthStencil: { format, depthWriteEnabled: true },\n      multisample: multisampled ? { count: 4 } : undefined,\n      fragment: { module, entryPoint: 'finit', targets: [] },\n    });\n\n    // With a viewport set to [0.25,0.75], output values in [0.0,1.0] and check they're clamped\n    // before the depth test, regardless of whether unclippedDepth is enabled.\n    const testPipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module, entryPoint: 'vmain' },\n      primitive: {\n        topology: 'point-list',\n        unclippedDepth,\n      },\n      depthStencil: { format, depthCompare: 'not-equal' },\n      multisample: multisampled ? { count: 4 } : undefined,\n      fragment: { module, entryPoint: 'ftest', targets: [{ format: 'r8unorm' }] },\n    });\n\n    const dsTexture = t.device.createTexture({\n      format,\n      size: [kNumDepthValues],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      sampleCount: multisampled ? 4 : 1,\n    });\n    const dsTextureView = dsTexture.createView();\n\n    const testTextureDesc = {\n      format: 'r8unorm' as const,\n      size: [kNumDepthValues],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    };\n    const testTexture = t.device.createTexture(testTextureDesc);\n    const testTextureView = testTexture.createView();\n    const testTextureMSView = multisampled\n      ? t.device.createTexture({ ...testTextureDesc, sampleCount: 4 }).createView()\n      : undefined;\n\n    const resultBuffer = t.device.createBuffer({\n      size: kNumDepthValues,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n    });\n\n    const enc = t.device.createCommandEncoder();\n    {\n      const pass = enc.beginRenderPass({\n        colorAttachments: [],\n        depthStencilAttachment: {\n          view: dsTextureView,\n          depthClearValue: 1.0,\n          depthLoadOp: 'clear',\n          depthStoreOp: 'store',\n          stencilClearValue: info.stencil ? 0 : undefined,\n          stencilLoadOp: info.stencil ? 'clear' : undefined,\n          stencilStoreOp: info.stencil ? 'discard' : undefined,\n        },\n      });\n      pass.setPipeline(initPipeline);\n      pass.draw(kNumDepthValues);\n      pass.end();\n    }\n    {\n      const clearValue = [0, 0, 0, 0]; // Will see this color if the test passed.\n      const pass = enc.beginRenderPass({\n        colorAttachments: [\n          testTextureMSView\n            ? {\n                view: testTextureMSView,\n                resolveTarget: testTextureView,\n                clearValue,\n                loadOp: 'clear',\n                storeOp: 'discard',\n              }\n            : { view: testTextureView, clearValue, loadOp: 'clear', storeOp: 'store' },\n        ],\n        depthStencilAttachment: {\n          view: dsTextureView,\n          depthLoadOp: 'load',\n          depthStoreOp: 'store',\n          stencilClearValue: info.stencil ? 0 : undefined,\n          stencilLoadOp: info.stencil ? 'clear' : undefined,\n          stencilStoreOp: info.stencil ? 'discard' : undefined,\n        },\n      });\n      pass.setPipeline(testPipeline);\n      pass.setViewport(0, 0, kNumDepthValues, 1, kViewportMinDepth, kViewportMaxDepth);\n      pass.draw(kNumDepthValues);\n      pass.end();\n    }\n    enc.copyTextureToBuffer({ texture: testTexture }, { buffer: resultBuffer }, [kNumDepthValues]);\n    t.device.queue.submit([enc.finish()]);\n\n    t.expectGPUBufferValuesEqual(resultBuffer, new Uint8Array(kNumDepthValues), 0, {\n      method: 'map',\n    });\n  });\n"],"file":"depth_clip_clamp.spec.js"}