{"version":3,"sources":["../../../../../src/webgpu/api/operation/rendering/indirect_draw.spec.ts"],"names":["description","makeTestGroup","GPUTest","g","filled","Uint8Array","notFilled","kDrawIndirectParametersSize","Uint32Array","BYTES_PER_ELEMENT","test","desc","paramsSubcasesOnly","u","combine","fn","t","indirectOffset","params","o","arraySize","indirectBuffer","Array","map","Math","floor","random","kRenderTargetFormat","pipeline","device","createRenderPipeline","vertex","module","createShaderModule","code","entryPoint","buffers","attributes","shaderLocation","format","offset","arrayStride","Float32Array","fragment","targets","renderTarget","createTexture","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","COPY_SRC","commandEncoder","createCommandEncoder","renderPass","beginRenderPass","colorAttachments","view","createView","loadValue","storeOp","setPipeline","setVertexBuffer","makeBufferWithContents","GPUBufferUsage","VERTEX","drawIndirect","INDIRECT","endPass","queue","submit","finish","expectSinglePixelIn2DTexture","x","y","exp","unimplemented"],"mappings":"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","sourcesContent":["export const description = `\nTests for the indirect-specific aspects of drawIndirect/drawIndexedIndirect.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\nconst filled = new Uint8Array([0, 255, 0, 255]);\nconst notFilled = new Uint8Array([0, 0, 0, 0]);\n\nconst kDrawIndirectParametersSize = 4 * Uint32Array.BYTES_PER_ELEMENT;\n\ng.test('basics,drawIndirect')\n  .desc(\n    `Test that the indirect draw parameters are tightly packed for drawIndirect.\nAn indirectBuffer is created based on indirectOffset. The actual draw args being used indicated by the\nindirectOffset is going to draw a left bottom triangle.\nWhile the remaining indirectBuffer is populated with random numbers or draw args\nthat draw right top triangle, both, or nothing which will fail the color check.\nThe test will check render target to see if only the left bottom area is filled,\nmeaning the expected draw args is uploaded correctly by the indirectBuffer and indirectOffset.\n\nParams:\n    - indirectOffset= {0, 4, k * sizeof(args struct), k * sizeof(args struct) + 4}\n    `\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('indirectOffset', [\n        0,\n        Uint32Array.BYTES_PER_ELEMENT,\n        1 * kDrawIndirectParametersSize,\n        1 * kDrawIndirectParametersSize + Uint32Array.BYTES_PER_ELEMENT,\n        3 * kDrawIndirectParametersSize,\n        3 * kDrawIndirectParametersSize + Uint32Array.BYTES_PER_ELEMENT,\n        99 * kDrawIndirectParametersSize,\n        99 * kDrawIndirectParametersSize + Uint32Array.BYTES_PER_ELEMENT,\n      ] as const)\n  )\n  .fn(t => {\n    const { indirectOffset } = t.params;\n\n    const o = indirectOffset / Uint32Array.BYTES_PER_ELEMENT;\n    const arraySize = o + 8;\n    const indirectBuffer = [...Array(arraySize)].map(() => Math.floor(Math.random() * 100));\n\n    // draw args that will draw the left bottom triangle (expected call)\n    indirectBuffer[o] = 3; // vertexCount\n    indirectBuffer[o + 1] = 1; // instanceCount\n    indirectBuffer[o + 2] = 0; // firstVertex\n    indirectBuffer[o + 3] = 0; // firstInstance\n\n    // draw args that will draw both triangles\n    indirectBuffer[o + 4] = 6; // vertexCount\n    indirectBuffer[o + 5] = 1; // instanceCount\n    indirectBuffer[o + 6] = 0; // firstVertex\n    indirectBuffer[o + 7] = 0; // firstInstance\n\n    if (o >= 4) {\n      // draw args that will draw the right top triangle\n      indirectBuffer[o - 4] = 3; // vertexCount\n      indirectBuffer[o - 3] = 1; // instanceCount\n      indirectBuffer[o - 2] = 3; // firstVertex\n      indirectBuffer[o - 1] = 0; // firstInstance\n    }\n\n    if (o >= 8) {\n      // draw args that will draw nothing\n      indirectBuffer[0] = 0; // vertexCount\n      indirectBuffer[1] = 0; // instanceCount\n      indirectBuffer[2] = 0; // firstVertex\n      indirectBuffer[3] = 0; // firstInstance\n    }\n\n    const kRenderTargetFormat = 'rgba8unorm';\n    const pipeline = t.device.createRenderPipeline({\n      vertex: {\n        module: t.device.createShaderModule({\n          code: `[[stage(vertex)]] fn main([[location(0)]] pos : vec2<f32>) -> [[builtin(position)]] vec4<f32> {\n              return vec4<f32>(pos, 0.0, 1.0);\n          }`,\n        }),\n        entryPoint: 'main',\n        buffers: [\n          {\n            attributes: [\n              {\n                shaderLocation: 0,\n                format: 'float32x2',\n                offset: 0,\n              },\n            ],\n            arrayStride: 2 * Float32Array.BYTES_PER_ELEMENT,\n          },\n        ],\n      },\n      fragment: {\n        module: t.device.createShaderModule({\n          code: `[[stage(fragment)]] fn main() -> [[location(0)]] vec4<f32> {\n            return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n        }`,\n        }),\n        entryPoint: 'main',\n        targets: [\n          {\n            format: kRenderTargetFormat,\n          },\n        ],\n      },\n    });\n\n    const renderTarget = t.device.createTexture({\n      size: [4, 4],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      format: kRenderTargetFormat,\n    });\n\n    const commandEncoder = t.device.createCommandEncoder();\n    const renderPass = commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          loadValue: [0, 0, 0, 0],\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setPipeline(pipeline);\n    renderPass.setVertexBuffer(\n      0,\n      t.makeBufferWithContents(\n        /* prettier-ignore */\n        new Float32Array([\n          // The bottom left triangle\n          -1.0, 1.0,\n           1.0, -1.0,\n          -1.0, -1.0,\n\n          // The top right triangle\n          -1.0, 1.0,\n           1.0, -1.0,\n           1.0, 1.0,\n        ]),\n        GPUBufferUsage.VERTEX\n      ),\n      0\n    );\n    renderPass.drawIndirect(\n      t.makeBufferWithContents(new Uint32Array(indirectBuffer), GPUBufferUsage.INDIRECT),\n      indirectOffset\n    );\n    renderPass.endPass();\n    t.queue.submit([commandEncoder.finish()]);\n\n    // The bottom left area is filled\n    t.expectSinglePixelIn2DTexture(\n      renderTarget,\n      kRenderTargetFormat,\n      { x: 0, y: 1 },\n      { exp: filled }\n    );\n    // The top right area is not filled\n    t.expectSinglePixelIn2DTexture(\n      renderTarget,\n      kRenderTargetFormat,\n      { x: 1, y: 0 },\n      { exp: notFilled }\n    );\n  });\n\ng.test('basics,drawIndexedIndirect')\n  .desc(\n    `Test that the indirect draw parameters are tightly packed for drawIndexedIndirect.\n    `\n  )\n  .unimplemented();\n"],"file":"indirect_draw.spec.js"}