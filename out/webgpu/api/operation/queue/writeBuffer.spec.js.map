{"version":3,"sources":["../../../../../src/webgpu/api/operation/queue/writeBuffer.spec.ts"],"names":["description","makeTestGroup","memcpy","range","GPUTest","align","kTypedArrays","F","calculateRequiredBufferSize","writes","bufferSize","bufferOffset","data","arrayType","useArrayBuffer","dataOffset","dataSize","TypedArrayConstructor","globalThis","bytesPerElement","BYTES_PER_ELEMENT","bytesWritten","length","Math","min","requiredBufferSize","max","testWriteBuffer","expectedData","Uint8Array","fill","buffer","makeBufferWithContents","GPUBufferUsage","COPY_SRC","COPY_DST","writeData","writeSrc","queue","writeBuffer","src","start","dst","debug","join","expectGPUBufferValuesEqual","g","kTestData","i","test","desc","params","u","combine","fn","t","paramsSubcasesOnly","Uint32Array"],"mappings":"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","sourcesContent":["export const description = 'Operation tests for GPUQueue.writeBuffer()';\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { memcpy, range } from '../../../../common/util/util.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { align } from '../../../util/math.js';\n\nconst kTypedArrays = [\n  'Uint8Array',\n  'Uint16Array',\n  'Uint32Array',\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Float32Array',\n  'Float64Array',\n] as const;\n\ntype WriteBufferSignature = {\n  bufferOffset: number;\n  data: readonly number[];\n  arrayType: typeof kTypedArrays[number];\n  useArrayBuffer: boolean;\n  dataOffset?: number; // In elements when useArrayBuffer === false, bytes otherwise\n  dataSize?: number; // In elements when useArrayBuffer === false, bytes otherwise\n};\n\nclass F extends GPUTest {\n  calculateRequiredBufferSize(writes: WriteBufferSignature[]): number {\n    let bufferSize = 0;\n    // Calculate size of final buffer\n    for (const { bufferOffset, data, arrayType, useArrayBuffer, dataOffset, dataSize } of writes) {\n      const TypedArrayConstructor = globalThis[arrayType];\n\n      // When passing data as an ArrayBuffer, dataOffset and dataSize use byte instead of number of\n      // elements. bytesPerElement is used to convert dataOffset and dataSize from elements to bytes\n      // when useArrayBuffer === false.\n      const bytesPerElement = useArrayBuffer ? 1 : TypedArrayConstructor.BYTES_PER_ELEMENT;\n\n      // Calculate the number of bytes written to the buffer. data is always an array of elements.\n      let bytesWritten =\n        data.length * TypedArrayConstructor.BYTES_PER_ELEMENT - (dataOffset || 0) * bytesPerElement;\n\n      if (dataSize) {\n        // When defined, dataSize clamps the number of bytes written\n        bytesWritten = Math.min(bytesWritten, dataSize * bytesPerElement);\n      }\n\n      // The minimum buffer size required for the write to succeed is the number of bytes written +\n      // the bufferOffset\n      const requiredBufferSize = bufferOffset + bytesWritten;\n\n      // Find the largest required size by all writes\n      bufferSize = Math.max(bufferSize, requiredBufferSize);\n    }\n    // writeBuffer requires buffers to be a multiple of 4\n    return align(bufferSize, 4);\n  }\n\n  testWriteBuffer(...writes: WriteBufferSignature[]) {\n    const bufferSize = this.calculateRequiredBufferSize(writes);\n\n    // Initialize buffer to non-zero data (0xff) for easier debug.\n    const expectedData = new Uint8Array(bufferSize).fill(0xff);\n\n    const buffer = this.makeBufferWithContents(\n      expectedData,\n      GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n    );\n\n    for (const { bufferOffset, data, arrayType, useArrayBuffer, dataOffset, dataSize } of writes) {\n      const TypedArrayConstructor = globalThis[arrayType];\n      const writeData = new TypedArrayConstructor(data);\n      const writeSrc = useArrayBuffer ? writeData.buffer : writeData;\n      this.queue.writeBuffer(buffer, bufferOffset, writeSrc, dataOffset, dataSize);\n      memcpy(\n        { src: writeSrc, start: dataOffset, length: dataSize },\n        { dst: expectedData, start: bufferOffset }\n      );\n    }\n\n    this.debug(`expectedData: [${expectedData.join(', ')}]`);\n    this.expectGPUBufferValuesEqual(buffer, expectedData);\n  }\n}\n\nexport const g = makeTestGroup(F);\n\nconst kTestData = range<number>(16, i => i);\n\ng.test('array_types')\n  .desc('Tests that writeBuffer correctly handles different TypedArrays and ArrayBuffer.')\n  .params(u =>\n    u //\n      .combine('arrayType', kTypedArrays)\n      .combine('useArrayBuffer', [false, true])\n  )\n  .fn(t => {\n    const { arrayType, useArrayBuffer } = t.params;\n    const dataOffset = 1;\n    const dataSize = 8;\n    t.testWriteBuffer({\n      bufferOffset: 0,\n      arrayType,\n      data: kTestData,\n      dataOffset,\n      dataSize,\n      useArrayBuffer,\n    });\n  });\n\ng.test('multiple_writes_at_different_offsets_and_sizes')\n  .desc(\n    `\nTests that writeBuffer currently handles different offsets and writes. This includes:\n- Non-overlapping TypedArrays and ArrayLists\n- Overlapping TypedArrays and ArrayLists\n- Writing zero data\n- Writing on zero sized buffers\n- Unaligned source\n- Multiple overlapping writes with decreasing sizes\n    `\n  )\n  .paramsSubcasesOnly([\n    {\n      // Concatenate 2 Uint32Arrays\n      writes: [\n        {\n          bufferOffset: 0,\n          data: kTestData,\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n          dataOffset: 2,\n          dataSize: 2,\n        }, // [2, 3]\n        {\n          bufferOffset: 2 * Uint32Array.BYTES_PER_ELEMENT,\n          data: kTestData,\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n          dataOffset: 0,\n          dataSize: 2,\n        }, // [0, 1]\n      ], // Expected [2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]\n    },\n    {\n      // Concatenate 2 Uint8Arrays\n      writes: [\n        { bufferOffset: 0, data: [0, 1, 2, 3], arrayType: 'Uint8Array', useArrayBuffer: false },\n        { bufferOffset: 4, data: [4, 5, 6, 7], arrayType: 'Uint8Array', useArrayBuffer: false },\n      ], // Expected [0, 1, 2, 3, 4, 5, 6, 7]\n    },\n    {\n      // Overlap in the middle\n      writes: [\n        { bufferOffset: 0, data: kTestData, arrayType: 'Uint8Array', useArrayBuffer: false },\n        { bufferOffset: 4, data: [0], arrayType: 'Uint32Array', useArrayBuffer: false },\n      ], // Expected [0, 1, 2, 3, 0, 0 ,0 ,0, 8, 9, 10, 11, 12, 13, 14, 15]\n    },\n    {\n      // Overlapping arrayLists\n      writes: [\n        {\n          bufferOffset: 0,\n          data: kTestData,\n          arrayType: 'Uint32Array',\n          useArrayBuffer: true,\n          dataOffset: 2,\n          dataSize: 4 * Uint32Array.BYTES_PER_ELEMENT,\n        },\n        { bufferOffset: 4, data: [0x04030201], arrayType: 'Uint32Array', useArrayBuffer: true },\n      ], // Expected [0, 0, 1, 0, 1, 2, 3, 4, 0, 0, 3, 0, 0, 0, 4, 0]\n    },\n    {\n      // Write over with empty buffer\n      writes: [\n        { bufferOffset: 0, data: kTestData, arrayType: 'Uint8Array', useArrayBuffer: false },\n        { bufferOffset: 0, data: [], arrayType: 'Uint8Array', useArrayBuffer: false },\n      ], // Expected [0, 1, 2, 3, 4, 5 ,6 ,7, 8, 9, 10, 11, 12, 13, 14, 15]\n    },\n    {\n      // Zero buffer\n      writes: [{ bufferOffset: 0, data: [], arrayType: 'Uint8Array', useArrayBuffer: false }],\n    }, // Expected []\n    {\n      // Unaligned source\n      writes: [\n        {\n          bufferOffset: 0,\n          data: [0x77, ...kTestData],\n          arrayType: 'Uint8Array',\n          useArrayBuffer: false,\n          dataOffset: 1,\n        },\n      ], // Expected [0, 1, 2, 3, 4, 5 ,6 ,7, 8, 9, 10, 11, 12, 13, 14, 15]\n    },\n    {\n      // Multiple overlapping writes\n      writes: [\n        {\n          bufferOffset: 0,\n          data: [0x05050505, 0x05050505, 0x05050505, 0x05050505, 0x05050505],\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n        },\n        {\n          bufferOffset: 0,\n          data: [0x04040404, 0x04040404, 0x04040404, 0x04040404],\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n        },\n        {\n          bufferOffset: 0,\n          data: [0x03030303, 0x03030303, 0x03030303],\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n        },\n        {\n          bufferOffset: 0,\n          data: [0x02020202, 0x02020202],\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n        },\n        {\n          bufferOffset: 0,\n          data: [0x01010101],\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n        },\n      ], // Expected [1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5]\n    },\n  ] as const)\n  .fn(t => {\n    t.testWriteBuffer(...t.params.writes);\n  });\n"],"file":"writeBuffer.spec.js"}