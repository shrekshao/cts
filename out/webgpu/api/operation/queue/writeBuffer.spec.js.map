{"version":3,"sources":["../../../../../src/webgpu/api/operation/queue/writeBuffer.spec.ts"],"names":["description","makeTestGroup","range","GPUTest","align","kTypedArrays","F","calculateRequiredBufferSize","writes","bufferSize","bufferOffset","data","arrayType","useArrayBuffer","dataOffset","dataSize","TypedArrayConstructor","globalThis","bytesPerElement","BYTES_PER_ELEMENT","bytesWritten","length","Math","min","requiredBufferSize","max","testWriteBuffer","buffer","device","createBuffer","size","usage","GPUBufferUsage","COPY_SRC","COPY_DST","mappedAtCreation","expectedData","Uint8Array","fill","bufferData","getMappedRange","set","unmap","writeData","queue","writeBuffer","begin","slice","undefined","debug","join","expectGPUBufferValuesEqual","g","kTestData","i","test","desc","params","u","combine","fn","t","paramsSubcasesOnly","Uint32Array"],"mappings":"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","sourcesContent":["export const description = 'Operation tests for GPUQueue.writeBuffer()';\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { range } from '../../../../common/util/util.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { align } from '../../../util/math.js';\n\nconst kTypedArrays = [\n  'Uint8Array',\n  'Uint16Array',\n  'Uint32Array',\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Float32Array',\n  'Float64Array',\n] as const;\n\ntype WriteBufferSignature = {\n  bufferOffset: number;\n  data: readonly number[];\n  arrayType: typeof kTypedArrays[number];\n  useArrayBuffer: boolean;\n  dataOffset?: number; // In elements when useArrayBuffer === false, bytes otherwise\n  dataSize?: number; // In elements when useArrayBuffer === false, bytes otherwise\n};\n\nclass F extends GPUTest {\n  calculateRequiredBufferSize(writes: WriteBufferSignature[]): number {\n    let bufferSize = 0;\n    // Calculate size of final buffer\n    for (const { bufferOffset, data, arrayType, useArrayBuffer, dataOffset, dataSize } of writes) {\n      const TypedArrayConstructor = globalThis[arrayType];\n\n      // When passing data as an ArrayBuffer, dataOffset and dataSize use byte instead of number of\n      // elements. bytesPerElement is used to convert dataOffset and dataSize from elements to bytes\n      // when useArrayBuffer === false.\n      const bytesPerElement = useArrayBuffer ? 1 : TypedArrayConstructor.BYTES_PER_ELEMENT;\n\n      // Calculate the number of bytes written to the buffer. data is always an array of elements.\n      let bytesWritten =\n        data.length * TypedArrayConstructor.BYTES_PER_ELEMENT - (dataOffset || 0) * bytesPerElement;\n\n      if (dataSize) {\n        // When defined, dataSize clamps the number of bytes written\n        bytesWritten = Math.min(bytesWritten, dataSize * bytesPerElement);\n      }\n\n      // The minimum buffer size required for the write to succeed is the number of bytes written +\n      // the bufferOffset\n      const requiredBufferSize = bufferOffset + bytesWritten;\n\n      // Find the largest required size by all writes\n      bufferSize = Math.max(bufferSize, requiredBufferSize);\n    }\n    // writeBuffer requires buffers to be a multiple of 4\n    return align(bufferSize, 4);\n  }\n\n  testWriteBuffer(...writes: WriteBufferSignature[]) {\n    const bufferSize = this.calculateRequiredBufferSize(writes);\n    const buffer = this.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n      mappedAtCreation: true,\n    });\n\n    // Initialize buffer to non-zero data (0xff) for easier debug.\n    const expectedData = new Uint8Array(bufferSize).fill(0xff);\n    const bufferData = buffer.getMappedRange();\n    new Uint8Array(bufferData).set(expectedData);\n    buffer.unmap();\n\n    for (const { bufferOffset, data, arrayType, useArrayBuffer, dataOffset, dataSize } of writes) {\n      const TypedArrayConstructor = globalThis[arrayType];\n      const writeData = new TypedArrayConstructor(data);\n      this.queue.writeBuffer(\n        buffer,\n        bufferOffset,\n        useArrayBuffer ? writeData.buffer : writeData,\n        dataOffset,\n        dataSize\n      );\n      const bytesPerElement = useArrayBuffer ? 1 : TypedArrayConstructor.BYTES_PER_ELEMENT;\n      const begin = dataOffset ? dataOffset * bytesPerElement : 0;\n      expectedData.set(\n        new Uint8Array(\n          writeData.buffer.slice(begin, dataSize ? begin + dataSize * bytesPerElement : undefined)\n        ),\n        bufferOffset\n      );\n    }\n\n    this.debug(`expectedData: [${expectedData.join(', ')}]`);\n    this.expectGPUBufferValuesEqual(buffer, expectedData);\n  }\n}\n\nexport const g = makeTestGroup(F);\n\nconst kTestData = range<number>(16, i => i);\n\ng.test('array_types')\n  .desc('Tests that writeBuffer correctly handles different TypedArrays and ArrayBuffer.')\n  .params(u =>\n    u //\n      .combine('arrayType', kTypedArrays)\n      .combine('useArrayBuffer', [false, true])\n  )\n  .fn(t => {\n    const { arrayType, useArrayBuffer } = t.params;\n    const dataOffset = 1;\n    const dataSize = 8;\n    t.testWriteBuffer({\n      bufferOffset: 0,\n      arrayType,\n      data: kTestData,\n      dataOffset,\n      dataSize,\n      useArrayBuffer,\n    });\n  });\n\ng.test('multiple_writes_at_different_offsets_and_sizes')\n  .desc(\n    `\nTests that writeBuffer currently handles different offsets and writes. This includes:\n- Non-overlapping TypedArrays and ArrayLists\n- Overlapping TypedArrays and ArrayLists\n- Writing zero data\n- Writing on zero sized buffers\n- Unaligned source\n- Multiple overlapping writes with decreasing sizes\n    `\n  )\n  .paramsSubcasesOnly([\n    {\n      // Concatenate 2 Uint32Arrays\n      writes: [\n        {\n          bufferOffset: 0,\n          data: kTestData,\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n          dataOffset: 2,\n          dataSize: 2,\n        }, // [2, 3]\n        {\n          bufferOffset: 2 * Uint32Array.BYTES_PER_ELEMENT,\n          data: kTestData,\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n          dataOffset: 0,\n          dataSize: 2,\n        }, // [0, 1]\n      ], // Expected [2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]\n    },\n    {\n      // Concatenate 2 Uint8Arrays\n      writes: [\n        { bufferOffset: 0, data: [0, 1, 2, 3], arrayType: 'Uint8Array', useArrayBuffer: false },\n        { bufferOffset: 4, data: [4, 5, 6, 7], arrayType: 'Uint8Array', useArrayBuffer: false },\n      ], // Expected [0, 1, 2, 3, 4, 5, 6, 7]\n    },\n    {\n      // Overlap in the middle\n      writes: [\n        { bufferOffset: 0, data: kTestData, arrayType: 'Uint8Array', useArrayBuffer: false },\n        { bufferOffset: 4, data: [0], arrayType: 'Uint32Array', useArrayBuffer: false },\n      ], // Expected [0, 1, 2, 3, 0, 0 ,0 ,0, 8, 9, 10, 11, 12, 13, 14, 15]\n    },\n    {\n      // Overlapping arrayLists\n      writes: [\n        {\n          bufferOffset: 0,\n          data: kTestData,\n          arrayType: 'Uint32Array',\n          useArrayBuffer: true,\n          dataOffset: 2,\n          dataSize: 4 * Uint32Array.BYTES_PER_ELEMENT,\n        },\n        { bufferOffset: 4, data: [0x04030201], arrayType: 'Uint32Array', useArrayBuffer: true },\n      ], // Expected [0, 0, 1, 0, 1, 2, 3, 4, 0, 0, 3, 0, 0, 0, 4, 0]\n    },\n    {\n      // Write over with empty buffer\n      writes: [\n        { bufferOffset: 0, data: kTestData, arrayType: 'Uint8Array', useArrayBuffer: false },\n        { bufferOffset: 0, data: [], arrayType: 'Uint8Array', useArrayBuffer: false },\n      ], // Expected [0, 1, 2, 3, 4, 5 ,6 ,7, 8, 9, 10, 11, 12, 13, 14, 15]\n    },\n    {\n      // Zero buffer\n      writes: [{ bufferOffset: 0, data: [], arrayType: 'Uint8Array', useArrayBuffer: false }],\n    }, // Expected []\n    {\n      // Unaligned source\n      writes: [\n        {\n          bufferOffset: 0,\n          data: [0x77, ...kTestData],\n          arrayType: 'Uint8Array',\n          useArrayBuffer: false,\n          dataOffset: 1,\n        },\n      ], // Expected [0, 1, 2, 3, 4, 5 ,6 ,7, 8, 9, 10, 11, 12, 13, 14, 15]\n    },\n    {\n      // Multiple overlapping writes\n      writes: [\n        {\n          bufferOffset: 0,\n          data: [0x05050505, 0x05050505, 0x05050505, 0x05050505, 0x05050505],\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n        },\n        {\n          bufferOffset: 0,\n          data: [0x04040404, 0x04040404, 0x04040404, 0x04040404],\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n        },\n        {\n          bufferOffset: 0,\n          data: [0x03030303, 0x03030303, 0x03030303],\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n        },\n        {\n          bufferOffset: 0,\n          data: [0x02020202, 0x02020202],\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n        },\n        {\n          bufferOffset: 0,\n          data: [0x01010101],\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n        },\n      ], // Expected [1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5]\n    },\n  ] as const)\n  .fn(t => {\n    t.testWriteBuffer(...t.params.writes);\n  });\n"],"file":"writeBuffer.spec.js"}