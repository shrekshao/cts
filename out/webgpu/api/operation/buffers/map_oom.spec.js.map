{"version":3,"file":"map_oom.spec.js","names":["description","kUnitCaseParamsBuilder","makeTestGroup","kBufferUsages","GPUTest","kMaxSafeMultipleOf8","oomAndSizeParams","combine","expand","oom","g","test","desc","params","beginSubcases","fn","t","write","size","unmapBeforeResolve","buffer","expectGPUError","device","createBuffer","usage","GPUBufferUsage","MAP_WRITE","MAP_READ","promise","expectValidationError","mapAsync","GPUMapMode","WRITE","READ","shouldReject","Error","shouldThrow","getMappedRange","unmap","arraybuffer","expect","byteLength","f","mappedAtCreation","mapping"],"sources":["../../../../../src/webgpu/api/operation/buffers/map_oom.spec.ts"],"sourcesContent":["export const description =\n  'Test out-of-memory conditions creating large mappable/mappedAtCreation buffers.';\n\nimport { kUnitCaseParamsBuilder } from '../../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { kBufferUsages } from '../../../capability_info.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { kMaxSafeMultipleOf8 } from '../../../util/math.js';\n\nconst oomAndSizeParams = kUnitCaseParamsBuilder\n  .combine('oom', [false, true])\n  .expand('size', ({ oom }) => {\n    return oom\n      ? [\n          kMaxSafeMultipleOf8,\n          0x20_0000_0000, // 128 GB\n        ]\n      : [16];\n  });\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('mapAsync')\n  .desc(\n    `Test creating a large mappable buffer should produce an out-of-memory error if allocation fails.\n  - The resulting buffer is an error buffer, so mapAsync rejects and produces a validation error.\n  - Calling getMappedRange should throw an OperationError because the buffer is not in the mapped state.\n  - unmap() doesn't throw an error even if mapping failed, and otherwise should detach the ArrayBuffer.\n`\n  )\n  .params(\n    oomAndSizeParams //\n      .beginSubcases()\n      .combine('write', [false, true])\n      .combine('unmapBeforeResolve', [false, true])\n  )\n  .fn(async t => {\n    const { oom, write, size, unmapBeforeResolve } = t.params;\n\n    const buffer = t.expectGPUError(\n      'out-of-memory',\n      () =>\n        t.device.createBuffer({\n          size,\n          usage: write ? GPUBufferUsage.MAP_WRITE : GPUBufferUsage.MAP_READ,\n        }),\n      oom\n    );\n\n    let promise: Promise<void>;\n    // Should be a validation error since the buffer is invalid.\n    // Unmap abort error shouldn't cause a validation error.\n    t.expectValidationError(() => {\n      promise = buffer.mapAsync(write ? GPUMapMode.WRITE : GPUMapMode.READ);\n    }, oom);\n\n    if (oom) {\n      if (unmapBeforeResolve) {\n        // Should reject with abort error because buffer will be unmapped\n        // before validation check finishes.\n        t.shouldReject('AbortError', promise!);\n      } else {\n        // Should also reject in addition to the validation error.\n        t.shouldReject('OperationError', promise!);\n\n        // Wait for validation error before unmap to ensure validation check\n        // ends before unmap.\n        try {\n          await promise!;\n          throw new Error('The promise should be rejected.');\n        } catch {\n          // Should cause an exception because the promise should be rejected.\n        }\n      }\n\n      // Should throw an OperationError because the buffer is not mapped.\n      // Note: not a RangeError because the state of the buffer is checked first.\n      t.shouldThrow('OperationError', () => {\n        buffer.getMappedRange();\n      });\n\n      // Should't be a validation error even if the buffer failed to be mapped.\n      buffer.unmap();\n    } else {\n      await promise!;\n      const arraybuffer = buffer.getMappedRange();\n      t.expect(arraybuffer.byteLength === size);\n      buffer.unmap();\n      t.expect(arraybuffer.byteLength === 0, 'Mapping should be detached');\n    }\n  });\n\ng.test('mappedAtCreation')\n  .desc(\n    `Test creating a very large buffer mappedAtCreation buffer should throw a RangeError only\n     because such a large allocation cannot be created when we initialize an active buffer mapping.\n`\n  )\n  .params(\n    oomAndSizeParams //\n      .beginSubcases()\n      .combine('usage', kBufferUsages)\n  )\n  .fn(t => {\n    const { oom, usage, size } = t.params;\n\n    const f = () => t.device.createBuffer({ mappedAtCreation: true, size, usage });\n\n    if (oom) {\n      // getMappedRange is normally valid on OOM buffers, but this one fails because the\n      // (default) range is too large to create the returned ArrayBuffer.\n      t.shouldThrow('RangeError', f);\n    } else {\n      const buffer = f();\n      const mapping = buffer.getMappedRange();\n      t.expect(mapping.byteLength === size, 'Mapping should be successful');\n      buffer.unmap();\n      t.expect(mapping.byteLength === 0, 'Mapping should be detached');\n    }\n  });\n"],"mappings":"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"}