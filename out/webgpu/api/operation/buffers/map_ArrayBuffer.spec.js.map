{"version":3,"sources":["../../../../../src/webgpu/api/operation/buffers/map_ArrayBuffer.spec.ts"],"names":["description","makeTestGroup","resolveOnTimeout","GPUTest","g","test","desc","params","u","combine","fn","t","transfer","mapWrite","kSize","buf","device","createBuffer","size","usage","GPUBufferUsage","MAP_WRITE","MAP_READ","mapAsync","GPUMapMode","WRITE","READ","ab1","getMappedRange","expect","byteLength","mc","MessageChannel","ab2Promise","Promise","resolve","port2","onmessage","ev","data","shouldThrow","port1","postMessage","undefined","unmap","ab2","race"],"mappings":";AAAA;AACA,GADA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,CAPO,CASP,SAASC,aAAT,QAA8B,4CAA9B;AACA,SAASC,gBAAT,QAAiC,iCAAjC;AACA,SAASC,OAAT,QAAwB,sBAAxB;;AAEA,OAAO,MAAMC,CAAC,GAAGH,aAAa,CAACE,OAAD,CAAvB;;AAEPC,CAAC,CAACC,IAAF,CAAO,aAAP;AACGC,IADH;AAEK;AACL;AACA;AACA,iEALA;;AAOGC,MAPH,CAOU,CAAAC,CAAC;AACPA,CAAC,CAAC;AAAD,CACEC,OADH,CACW,UADX,EACuB,CAAC,KAAD,EAAQ,IAAR,CADvB;AAEGA,OAFH,CAEW,UAFX,EAEuB,CAAC,KAAD,EAAQ,IAAR,CAFvB,CARJ;;AAYGC,EAZH,CAYM,MAAMC,CAAN,IAAW;AACb,QAAM,EAAEC,QAAF,EAAYC,QAAZ,KAAyBF,CAAC,CAACJ,MAAjC;AACA,QAAMO,KAAK,GAAG,IAAd;;AAEA,QAAMC,GAAG,GAAGJ,CAAC,CAACK,MAAF,CAASC,YAAT,CAAsB;AAChCC,IAAAA,IAAI,EAAEJ,KAD0B;AAEhCK,IAAAA,KAAK,EAAEN,QAAQ,GAAGO,cAAc,CAACC,SAAlB,GAA8BD,cAAc,CAACE,QAF5B,EAAtB,CAAZ;;AAIA,QAAMP,GAAG,CAACQ,QAAJ,CAAaV,QAAQ,GAAGW,UAAU,CAACC,KAAd,GAAsBD,UAAU,CAACE,IAAtD,CAAN;AACA,QAAMC,GAAG,GAAGZ,GAAG,CAACa,cAAJ,EAAZ;AACAjB,EAAAA,CAAC,CAACkB,MAAF,CAASF,GAAG,CAACG,UAAJ,KAAmBhB,KAA5B,EAAmC,gCAAnC;;AAEA,QAAMiB,EAAE,GAAG,IAAIC,cAAJ,EAAX;AACA,QAAMC,UAAU,GAAG,IAAIC,OAAJ,CAAyBC,OAAO,IAAI;AACrDJ,IAAAA,EAAE,CAACK,KAAH,CAASC,SAAT,GAAqBC,EAAE,IAAIH,OAAO,CAACG,EAAE,CAACC,IAAJ,CAAlC;AACD,GAFkB,CAAnB;AAGA;AACA;AACA5B,EAAAA,CAAC,CAAC6B,WAAF;AACE5B,EAAAA,QAAQ,GAAG,IAAH,GAAU,KADpB;AAEE,QAAM;AACJmB,IAAAA,EAAE,CAACU,KAAH,CAASC,WAAT,CAAqBf,GAArB,EAA0Bf,QAAQ,GAAG,CAACe,GAAD,CAAH,GAAWgB,SAA7C;AACD,GAJH;AAKE,kBALF;;AAOAhC,EAAAA,CAAC,CAACkB,MAAF,CAASF,GAAG,CAACG,UAAJ,KAAmBhB,KAA5B,EAAmC,+CAAnC;;AAEAC,EAAAA,GAAG,CAAC6B,KAAJ;AACAjC,EAAAA,CAAC,CAACkB,MAAF,CAASF,GAAG,CAACG,UAAJ,KAAmB,CAA5B,EAA+B,qCAA/B;;AAEA,QAAMe,GAAG,GAAG,MAAMX,OAAO,CAACY,IAAR,CAAa;AAC7B;AACA;AACA5C,EAAAA,gBAAgB,CAAC,GAAD,CAHa;AAI7B;AACA;AACA+B,EAAAA,UAN6B,CAAb,CAAlB;;;AASA,MAAIY,GAAJ,EAAS;AACPlC,IAAAA,CAAC,CAACkB,MAAF,CAAS,CAACjB,QAAV,EAAoB,sDAApB;AACA;AACAD,IAAAA,CAAC,CAACkB,MAAF,CAASgB,GAAG,CAACf,UAAJ,KAAmBhB,KAA5B,EAAmC,6BAAnC;AACD;AACF,CAxDH","sourcesContent":["export const description = `\nTests for the behavior of ArrayBuffers returned by getMappedRange.\n\nTODO: Update these tests if we make this not an error, but instead \"fake\" the transfer:\n  https://github.com/gpuweb/gpuweb/issues/747#issuecomment-623712878\nTODO: Add tests that transfer to another thread instead of just using MessageChannel.\nTODO: Add tests for any other Web APIs that can detach ArrayBuffers.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { resolveOnTimeout } from '../../../../common/util/util.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('postMessage')\n  .desc(\n    `Using postMessage to send a getMappedRange-returned ArrayBuffer should throw an exception iff\n    the ArrayBuffer is in the transfer list (x= map read, map write).\n\n  TODO: Determine what the exception.name is expected to be. [1]`\n  )\n  .params(u =>\n    u //\n      .combine('transfer', [false, true])\n      .combine('mapWrite', [false, true])\n  )\n  .fn(async t => {\n    const { transfer, mapWrite } = t.params;\n    const kSize = 1024;\n\n    const buf = t.device.createBuffer({\n      size: kSize,\n      usage: mapWrite ? GPUBufferUsage.MAP_WRITE : GPUBufferUsage.MAP_READ,\n    });\n    await buf.mapAsync(mapWrite ? GPUMapMode.WRITE : GPUMapMode.READ);\n    const ab1 = buf.getMappedRange();\n    t.expect(ab1.byteLength === kSize, 'ab1 should have size of buffer');\n\n    const mc = new MessageChannel();\n    const ab2Promise = new Promise<ArrayBuffer>(resolve => {\n      mc.port2.onmessage = ev => resolve(ev.data);\n    });\n    // [1]: Pass an exception name here instead of `true`, once we figure out what the exception\n    // is supposed to be.\n    t.shouldThrow(\n      transfer ? true : false,\n      () => {\n        mc.port1.postMessage(ab1, transfer ? [ab1] : undefined);\n      },\n      'in postMessage'\n    );\n    t.expect(ab1.byteLength === kSize, 'after postMessage, ab1 should not be detached');\n\n    buf.unmap();\n    t.expect(ab1.byteLength === 0, 'after unmap, ab1 should be detached');\n\n    const ab2 = await Promise.race([\n      // If `transfer` is true, this resolveOnTimeout is _supposed_ to win the race, because the\n      // postMessage should have errored and no message should have been received.\n      resolveOnTimeout(100),\n      // Either way, if postMessage succeeded, then we'll receive an ArrayBuffer on port2, and this\n      // will win the race.\n      ab2Promise,\n    ]);\n\n    if (ab2) {\n      t.expect(!transfer, 'postMessage should have failed if it transferred ab1');\n      // If `transfer` is false, this is a deep copy, and it shouldn't be affected by the unmap.\n      t.expect(ab2.byteLength === kSize, 'ab2 should be the same size');\n    }\n  });\n"],"file":"map_ArrayBuffer.spec.js"}