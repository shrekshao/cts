{"version":3,"sources":["../../../../../src/webgpu/api/operation/command_buffer/image_copy.spec.ts"],"names":["description","makeTestGroup","assert","memcpy","unreachable","kTextureFormatInfo","kSizedTextureFormats","kDepthStencilFormats","kMinDynamicBufferOffsetAlignment","kBufferSizeAlignment","depthStencilBufferTextureCopySupported","depthStencilFormatAspectSize","GPUTest","makeBufferWithContents","align","bytesInACompleteRow","dataBytesForCopyOrFail","getTextureCopyLayout","kBytesPerRowAlignment","kMethodsToTest","initMethod","checkMethod","kExcludedFormats","Set","kWorkingTextureFormats","filter","x","has","ImageCopyTest","getTexelOffsetInBytes","textureDataLayout","format","texel","origin","y","z","offset","bytesPerRow","rowsPerImage","info","blockWidth","blockHeight","bytesPerImage","bytesPerBlock","iterateBlockRows","size","width","height","depthOrArrayLayers","generateData","byteSize","start","arr","Uint8Array","i","undefDataLayoutIfNeeded","changeBeforePass","undefined","undefOrArrayCopyViewIfNeeded","texture","origin_x","origin_y","origin_z","mipLevel","arrayCopySizeIfNeeded","copyTextureToBufferWithAppliedArguments","buffer","appliedCopyView","appliedDataLayout","appliedCheckSize","encoder","device","createCommandEncoder","copyTextureToBuffer","queue","submit","finish","uploadLinearTextureDataToTextureSubBox","textureCopyView","copySize","partialData","method","appliedCopySize","writeTexture","GPUBufferUsage","COPY_SRC","copyBufferToTexture","copyPartialTextureToBufferAndCheckContents","checkSize","expected","expectedDataLayout","bufferSize","byteLength","bufferData","COPY_DST","updateLinearTextureDataSubBox","expectGPUBufferValuesEqual","copyWholeTextureToNewBuffer","resultDataLayout","mipSize","createBuffer","usage","destinationDataLayout","sourceDataLayout","destinationOrigin","sourceOrigin","destination","source","srcOffsetElements","dstOffsetElements","rowLength","src","length","dst","copyWholeTextureToBufferAndCheckContentsWithUpdatedData","fullTextureCopyLayout","texturePartialDataLayout","fullData","readbackPromise","readGPUBufferRangeTyped","type","typedLength","eventualAsyncExpectation","readback","data","cleanup","uploadTextureAndVerifyCopy","dataSize","textureSize","dimension","createTexture","mipLevelCount","GPUTextureUsage","DoUploadToStencilTest","uploadMethod","initialDataSize","initialDataOffset","srcTexture","RENDER_ATTACHMENT","initialData","aspect","stagingBuffer","checkStencilTextureContent","DoCopyFromStencilTest","outputBufferSize","layout","outputBuffer","expectedData","baseExpectedOffset","baseInitialiDataOffset","stencilTexture","stencilTextureSize","stencilTextureFormat","expectedStencilTextureData","expectedStencilTextureDataOffset","expectedStencilTextureDataBytesPerRow","expectedStencilTextureDataRowsPerImage","stencilTextureMipLevel","stencilBitCount","uniformBufferSize","uniformBufferData","Uint32Array","uniformBuffer","UNIFORM","bindGroupLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","FRAGMENT","minBindingSize","hasDynamicOffset","renderPipelineDescriptorBase","createPipelineLayout","bindGroupLayouts","vertex","module","createShaderModule","code","entryPoint","fragment","targets","blend","color","srcFactor","dstFactor","operation","alpha","primitive","topology","depthStencil","stencilFront","compare","stencilBack","bindGroup","createBindGroup","resource","copyFromOutputTextureLayout","outputTextureSize","outputTexture","stencilTextureLayer","renderPass","beginRenderPass","colorAttachments","view","createView","loadValue","r","g","b","a","storeOp","depthStencilAttachment","baseMipLevel","baseArrayLayer","arrayLayerCount","stencilLoadValue","stencilStoreOp","depthLoadValue","depthStoreOp","stencilBitIndex","renderPipelineDescriptor","stencilReadMask","renderPipeline","createRenderPipeline","setPipeline","setStencilReference","setBindGroup","draw","endPass","outputStagingBuffer","slice","initializeDepthAspectWithRendering","depthTexture","depthFormat","copyMipLevel","depth","inputTexture","TEXTURE_BINDING","depthWriteEnabled","depthCompare","getBindGroupLayout","DoCopyTextureToBufferWithDepthAspectTest","bytesPerRowPadding","rowsPerImagePadding","dataPaddingInBytes","Float32Array","baseValue","Math","floor","aspectBytesPerBlock","destinationBufferSize","destinationBuffer","copyEncoder","formatCanBeTested","copyDst","copySrc","kRowsPerImageAndBytesPerRowParams","paddings","copySizes","copyWidthInBlocks","copyHeightInBlocks","copyDepth","test","desc","params","u","combineWithParams","combine","beginSubcases","fn","t","selectDeviceOrSkipTestCase","feature","bytesPerRowAlignment","copyWidth","copyHeight","max","kOffsetsAndSizesParams","offsetsAndPaddings","offsetInBlocks","minDataSize","unless","p","copySizeValueInBlocks","originValueInBlocks","textureSizePaddingValueInBlocks","originBlocks","copySizeBlocks","texSizeBlocks","ctt","coordinateToTest","generateTestTextureSizes","_mipSizeInBlocks","widthAtThisLevel","heightAtThisLevel","widthAtPrevLevel","heightAtPrevLevel","modifiedWidth","modifiedHeight","modifyWidth","modifyHeight","copySizeInBlocks","originInBlocks","expand","UND","CopyMethodSupportedWithDepthStencilFormat","copyMethod","stencil"],"mappings":"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","sourcesContent":["export const description = `writeTexture + copyBufferToTexture + copyTextureToBuffer operation tests.\n\n* copy_with_various_rows_per_image_and_bytes_per_row: test that copying data with various bytesPerRow (including { ==, > } bytesInACompleteRow) and\\\n rowsPerImage (including { ==, > } copyExtent.height) values and minimum required bytes in copy works for every format. Also covers special code paths:\n  - bufferSize - offset < bytesPerImage * copyExtent.depthOrArrayLayers\n  - when bytesPerRow is not a multiple of 512 and copyExtent.depthOrArrayLayers > 1: copyExtent.depthOrArrayLayers % 2 == { 0, 1 }\n  - bytesPerRow == bytesInACompleteCopyImage\n\n* copy_with_various_offsets_and_data_sizes: test that copying data with various offset (including { ==, > } 0 and is/isn't power of 2) values and additional\\\n data paddings works for every format with 2d and 2d-array textures. Also covers special code paths:\n  - offset + bytesInCopyExtentPerRow { ==, > } bytesPerRow\n  - offset > bytesInACompleteCopyImage\n\n* copy_with_various_origins_and_copy_extents: test that copying slices of a texture works with various origin (including { origin.x, origin.y, origin.z }\\\n { ==, > } 0 and is/isn't power of 2) and copyExtent (including { copyExtent.x, copyExtent.y, copyExtent.z } { ==, > } 0 and is/isn't power of 2) values\\\n (also including {origin._ + copyExtent._ { ==, < } the subresource size of textureCopyView) works for all formats. origin and copyExtent values are passed\\\n as [number, number, number] instead of GPUExtent3DDict.\n\n* copy_various_mip_levels: test that copying various mip levels works for all formats. Also covers special code paths:\n  - the physical size of the subresouce is not equal to the logical size\n  - bufferSize - offset < bytesPerImage * copyExtent.depthOrArrayLayers and copyExtent needs to be clamped\n\n* copy_with_no_image_or_slice_padding_and_undefined_values: test that when copying a single row we can set any bytesPerRow value and when copying a single\\\n slice we can set rowsPerImage to 0. Also test setting offset, rowsPerImage, mipLevel, origin, origin.{x,y,z} to undefined.\n\n* TODO:\n  - add another initMethod which renders the texture [3]\n  - test copyT2B with buffer size not divisible by 4 (not done because expectContents 4-byte alignment)\n  - add tests for 1d / 3d textures\n  - Convert the float32 values in initialData into the ones compatible to the depth aspect of\n    depthFormats when depth16unorm and depth24unorm-stencil8 are supported by the browsers in\n    DoCopyTextureToBufferWithDepthAspectTest().\n\nTODO: Expand tests of GPUExtent3D [1]\n\nTODO: Fix this test for the various skipped formats [2]:\n- snorm tests failing due to rounding\n- float tests failing because float values are not byte-preserved\n- compressed formats\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, memcpy, unreachable } from '../../../../common/util/util.js';\nimport {\n  kTextureFormatInfo,\n  SizedTextureFormat,\n  kSizedTextureFormats,\n  kDepthStencilFormats,\n  kMinDynamicBufferOffsetAlignment,\n  kBufferSizeAlignment,\n  DepthStencilFormat,\n  depthStencilBufferTextureCopySupported,\n  depthStencilFormatAspectSize,\n} from '../../../capability_info.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { makeBufferWithContents } from '../../../util/buffer.js';\nimport { align } from '../../../util/math.js';\nimport {\n  bytesInACompleteRow,\n  dataBytesForCopyOrFail,\n  getTextureCopyLayout,\n  kBytesPerRowAlignment,\n  TextureCopyLayout,\n} from '../../../util/texture/layout.js';\n\ninterface TextureCopyViewWithRequiredOrigin {\n  texture: GPUTexture;\n  mipLevel: number | undefined;\n  origin: Required<GPUOrigin3DDict>;\n}\n\n/** Describes the function used to copy the initial data into the texture. */\ntype InitMethod = 'WriteTexture' | 'CopyB2T';\n/**\n * - PartialCopyT2B: do CopyT2B to check that the part of the texture we copied to with InitMethod\n *   matches the data we were copying and that we don't overwrite any data in the target buffer that\n *   we're not supposed to - that's primarily for testing CopyT2B functionality.\n * - FullCopyT2B: do CopyT2B on the whole texture and check wether the part we copied to matches\n *   the data we were copying and that the nothing else was modified - that's primarily for testing\n *   WriteTexture and CopyB2T.\n */\ntype CheckMethod = 'PartialCopyT2B' | 'FullCopyT2B';\n\n/**\n * This describes in what form the arguments will be passed to WriteTexture/CopyB2T/CopyT2B. If\n * undefined, then default values are passed as undefined instead of default values. If arrays, then\n * `GPUOrigin3D` and `GPUExtent3D` are passed as `[number, number, number]`. *\n *\n * [1]: Try to expand this with something like:\n * ```ts\n * function encodeExtent3D(\n *   mode: 'partial-array' | 'full-array' | 'extra-array' | 'partial-dict' | 'full-dict',\n *   value: GPUExtent3D\n * ): GPUExtent3D { ... }\n * ```\n */\ntype ChangeBeforePass = 'none' | 'undefined' | 'arrays';\n\n/** Each combination of methods assume that the ones before it were tested and work correctly. */\nconst kMethodsToTest = [\n  // Then we make sure that WriteTexture works for all formats:\n  { initMethod: 'WriteTexture', checkMethod: 'FullCopyT2B' },\n  // Then we make sure that CopyB2T works for all formats:\n  { initMethod: 'CopyB2T', checkMethod: 'FullCopyT2B' },\n  // Then we make sure that CopyT2B works for all formats:\n  { initMethod: 'WriteTexture', checkMethod: 'PartialCopyT2B' },\n] as const;\n\n// [2]: Fix things so this list can be reduced to zero (see file description)\nconst kExcludedFormats: Set<SizedTextureFormat> = new Set([\n  'r8snorm',\n  'rg8snorm',\n  'rgba8snorm',\n  'rg11b10ufloat',\n  'rg16float',\n  'rgba16float',\n  'r32float',\n  'rg32float',\n  'rgba32float',\n]);\nconst kWorkingTextureFormats = kSizedTextureFormats.filter(x => !kExcludedFormats.has(x));\n\nclass ImageCopyTest extends GPUTest {\n  /** Offset for a particular texel in the linear texture data */\n  getTexelOffsetInBytes(\n    textureDataLayout: Required<GPUImageDataLayout>,\n    format: SizedTextureFormat,\n    texel: Required<GPUOrigin3DDict>,\n    origin: Required<GPUOrigin3DDict> = { x: 0, y: 0, z: 0 }\n  ): number {\n    const { offset, bytesPerRow, rowsPerImage } = textureDataLayout;\n    const info = kTextureFormatInfo[format];\n\n    assert(texel.x >= origin.x && texel.y >= origin.y && texel.z >= origin.z);\n    assert(texel.x % info.blockWidth === 0);\n    assert(texel.y % info.blockHeight === 0);\n    assert(origin.x % info.blockWidth === 0);\n    assert(origin.y % info.blockHeight === 0);\n\n    const bytesPerImage = rowsPerImage * bytesPerRow;\n\n    return (\n      offset +\n      (texel.z - origin.z) * bytesPerImage +\n      ((texel.y - origin.y) / info.blockHeight) * bytesPerRow +\n      ((texel.x - origin.x) / info.blockWidth) * info.bytesPerBlock\n    );\n  }\n\n  *iterateBlockRows(\n    size: Required<GPUExtent3DDict>,\n    origin: Required<GPUOrigin3DDict>,\n    format: SizedTextureFormat\n  ): Generator<Required<GPUOrigin3DDict>> {\n    if (size.width === 0 || size.height === 0 || size.depthOrArrayLayers === 0) {\n      // do not iterate anything for an empty region\n      return;\n    }\n    const info = kTextureFormatInfo[format];\n    assert(size.height % info.blockHeight === 0);\n    for (let y = 0; y < size.height; y += info.blockHeight) {\n      for (let z = 0; z < size.depthOrArrayLayers; ++z) {\n        yield {\n          x: origin.x,\n          y: origin.y + y,\n          z: origin.z + z,\n        };\n      }\n    }\n  }\n\n  generateData(byteSize: number, start: number = 0, offset: number = 0): Uint8Array {\n    const arr = new Uint8Array(byteSize);\n    for (let i = 0; i < byteSize; ++i) {\n      arr[i + offset] = (i ** 3 + i + start) % 251;\n    }\n    return arr;\n  }\n\n  /**\n   * This is used for testing passing undefined members of `GPUImageDataLayout` instead of actual\n   * values where possible. Passing arguments as values and not as objects so that they are passed\n   * by copy and not by reference.\n   */\n  undefDataLayoutIfNeeded(\n    offset: number | undefined,\n    rowsPerImage: number | undefined,\n    bytesPerRow: number | undefined,\n    changeBeforePass: ChangeBeforePass\n  ): GPUImageDataLayout {\n    if (changeBeforePass === 'undefined') {\n      if (offset === 0) {\n        offset = undefined;\n      }\n      if (bytesPerRow === 0) {\n        bytesPerRow = undefined;\n      }\n      if (rowsPerImage === 0) {\n        rowsPerImage = undefined;\n      }\n    }\n    return { offset, bytesPerRow, rowsPerImage };\n  }\n\n  /**\n   * This is used for testing passing undefined members of `GPUImageCopyTexture` instead of actual\n   * values where possible and also for testing passing the origin as `[number, number, number]`.\n   * Passing arguments as values and not as objects so that they are passed by copy and not by\n   * reference.\n   */\n  undefOrArrayCopyViewIfNeeded(\n    texture: GPUTexture,\n    origin_x: number | undefined,\n    origin_y: number | undefined,\n    origin_z: number | undefined,\n    mipLevel: number | undefined,\n    changeBeforePass: ChangeBeforePass\n  ): GPUImageCopyTexture {\n    let origin: GPUOrigin3D | undefined = { x: origin_x, y: origin_y, z: origin_z };\n\n    if (changeBeforePass === 'undefined') {\n      if (origin_x === 0 && origin_y === 0 && origin_z === 0) {\n        origin = undefined;\n      } else {\n        if (origin_x === 0) {\n          origin_x = undefined;\n        }\n        if (origin_y === 0) {\n          origin_y = undefined;\n        }\n        if (origin_z === 0) {\n          origin_z = undefined;\n        }\n        origin = { x: origin_x, y: origin_y, z: origin_z };\n      }\n\n      if (mipLevel === 0) {\n        mipLevel = undefined;\n      }\n    }\n\n    if (changeBeforePass === 'arrays') {\n      origin = [origin_x!, origin_y!, origin_z!];\n    }\n\n    return { texture, origin, mipLevel };\n  }\n\n  /**\n   * This is used for testing passing `GPUExtent3D` as `[number, number, number]` instead of\n   * `GPUExtent3DDict`. Passing arguments as values and not as objects so that they are passed by\n   * copy and not by reference.\n   */\n  arrayCopySizeIfNeeded(\n    width: number,\n    height: number,\n    depthOrArrayLayers: number,\n    changeBeforePass: ChangeBeforePass\n  ): GPUExtent3D {\n    if (changeBeforePass === 'arrays') {\n      return [width, height, depthOrArrayLayers];\n    } else {\n      return { width, height, depthOrArrayLayers };\n    }\n  }\n\n  /** Run a CopyT2B command with appropriate arguments corresponding to `ChangeBeforePass` */\n  copyTextureToBufferWithAppliedArguments(\n    buffer: GPUBuffer,\n    { offset, rowsPerImage, bytesPerRow }: Required<GPUImageDataLayout>,\n    { width, height, depthOrArrayLayers }: Required<GPUExtent3DDict>,\n    { texture, mipLevel, origin }: TextureCopyViewWithRequiredOrigin,\n    changeBeforePass: ChangeBeforePass\n  ): void {\n    const { x, y, z } = origin;\n\n    const appliedCopyView = this.undefOrArrayCopyViewIfNeeded(\n      texture,\n      x,\n      y,\n      z,\n      mipLevel,\n      changeBeforePass\n    );\n    const appliedDataLayout = this.undefDataLayoutIfNeeded(\n      offset,\n      rowsPerImage,\n      bytesPerRow,\n      changeBeforePass\n    );\n    const appliedCheckSize = this.arrayCopySizeIfNeeded(\n      width,\n      height,\n      depthOrArrayLayers,\n      changeBeforePass\n    );\n\n    const encoder = this.device.createCommandEncoder();\n    encoder.copyTextureToBuffer(\n      appliedCopyView,\n      { buffer, ...appliedDataLayout },\n      appliedCheckSize\n    );\n    this.device.queue.submit([encoder.finish()]);\n  }\n\n  /** Put data into a part of the texture with an appropriate method. */\n  uploadLinearTextureDataToTextureSubBox(\n    textureCopyView: TextureCopyViewWithRequiredOrigin,\n    textureDataLayout: GPUImageDataLayout & { bytesPerRow: number },\n    copySize: Required<GPUExtent3DDict>,\n    partialData: Uint8Array,\n    method: InitMethod,\n    changeBeforePass: ChangeBeforePass\n  ): void {\n    const { texture, mipLevel, origin } = textureCopyView;\n    const { offset, rowsPerImage, bytesPerRow } = textureDataLayout;\n    const { x, y, z } = origin;\n    const { width, height, depthOrArrayLayers } = copySize;\n\n    const appliedCopyView = this.undefOrArrayCopyViewIfNeeded(\n      texture,\n      x,\n      y,\n      z,\n      mipLevel,\n      changeBeforePass\n    );\n    const appliedDataLayout = this.undefDataLayoutIfNeeded(\n      offset,\n      rowsPerImage,\n      bytesPerRow,\n      changeBeforePass\n    );\n    const appliedCopySize = this.arrayCopySizeIfNeeded(\n      width,\n      height,\n      depthOrArrayLayers,\n      changeBeforePass\n    );\n\n    switch (method) {\n      case 'WriteTexture': {\n        this.device.queue.writeTexture(\n          appliedCopyView,\n          partialData,\n          appliedDataLayout,\n          appliedCopySize\n        );\n\n        break;\n      }\n      case 'CopyB2T': {\n        const buffer = this.makeBufferWithContents(partialData, GPUBufferUsage.COPY_SRC);\n        const encoder = this.device.createCommandEncoder();\n        encoder.copyBufferToTexture(\n          { buffer, ...appliedDataLayout },\n          appliedCopyView,\n          appliedCopySize\n        );\n        this.device.queue.submit([encoder.finish()]);\n\n        break;\n      }\n      default:\n        unreachable();\n    }\n  }\n\n  /**\n   * We check an appropriate part of the texture against the given data.\n   * Used directly with PartialCopyT2B check method (for a subpart of the texture)\n   * and by `copyWholeTextureToBufferAndCheckContentsWithUpdatedData` with FullCopyT2B check method\n   * (for the whole texture). We also ensure that CopyT2B doesn't overwrite bytes it's not supposed\n   * to if validateOtherBytesInBuffer is set to true.\n   */\n  copyPartialTextureToBufferAndCheckContents(\n    { texture, mipLevel, origin }: TextureCopyViewWithRequiredOrigin,\n    checkSize: Required<GPUExtent3DDict>,\n    format: SizedTextureFormat,\n    expected: Uint8Array,\n    expectedDataLayout: Required<GPUImageDataLayout>,\n    changeBeforePass: ChangeBeforePass = 'none'\n  ): void {\n    // The alignment is necessary because we need to copy and map data from this buffer.\n    const bufferSize = align(expected.byteLength, 4);\n    // The start value ensures generated data here doesn't match the expected data.\n    const bufferData = this.generateData(bufferSize, 17);\n\n    const buffer = this.makeBufferWithContents(\n      bufferData,\n      GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n    );\n\n    this.copyTextureToBufferWithAppliedArguments(\n      buffer,\n      expectedDataLayout,\n      checkSize,\n      { texture, mipLevel, origin },\n      changeBeforePass\n    );\n\n    this.updateLinearTextureDataSubBox(\n      expectedDataLayout,\n      expectedDataLayout,\n      checkSize,\n      origin,\n      origin,\n      format,\n      bufferData,\n      expected\n    );\n\n    this.expectGPUBufferValuesEqual(buffer, bufferData);\n  }\n\n  /**\n   * Copies the whole texture into linear data stored in a buffer for further checks.\n   *\n   * Used for `copyWholeTextureToBufferAndCheckContentsWithUpdatedData`.\n   */\n  copyWholeTextureToNewBuffer(\n    { texture, mipLevel }: { texture: GPUTexture; mipLevel: number | undefined },\n    resultDataLayout: TextureCopyLayout\n  ): GPUBuffer {\n    const { mipSize, byteLength, bytesPerRow, rowsPerImage } = resultDataLayout;\n    const buffer = this.device.createBuffer({\n      size: align(byteLength, 4), // this is necessary because we need to copy and map data from this buffer\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const encoder = this.device.createCommandEncoder();\n    encoder.copyTextureToBuffer(\n      { texture, mipLevel },\n      { buffer, bytesPerRow, rowsPerImage },\n      mipSize\n    );\n    this.device.queue.submit([encoder.finish()]);\n\n    return buffer;\n  }\n\n  /**\n   * Takes the data returned by `copyWholeTextureToNewBuffer` and updates it after a copy operation\n   * on the texture by emulating the copy behaviour here directly.\n   */\n  updateLinearTextureDataSubBox(\n    destinationDataLayout: Required<GPUImageDataLayout>,\n    sourceDataLayout: Required<GPUImageDataLayout>,\n    copySize: Required<GPUExtent3DDict>,\n    destinationOrigin: Required<GPUOrigin3DDict>,\n    sourceOrigin: Required<GPUOrigin3DDict>,\n    format: SizedTextureFormat,\n    destination: Uint8Array,\n    source: Uint8Array\n  ): void {\n    for (const texel of this.iterateBlockRows(copySize, sourceOrigin, format)) {\n      const srcOffsetElements = this.getTexelOffsetInBytes(\n        sourceDataLayout,\n        format,\n        texel,\n        sourceOrigin\n      );\n      const dstOffsetElements = this.getTexelOffsetInBytes(\n        destinationDataLayout,\n        format,\n        texel,\n        destinationOrigin\n      );\n      const rowLength = bytesInACompleteRow(copySize.width, format);\n      memcpy(\n        { src: source, start: srcOffsetElements, length: rowLength },\n        { dst: destination, start: dstOffsetElements }\n      );\n    }\n  }\n\n  /**\n   * Used for checking whether the whole texture was updated correctly by\n   * `uploadLinearTextureDataToTextureSubpart`. Takes fullData returned by\n   * `copyWholeTextureToNewBuffer` before the copy operation which is the original texture data,\n   * then updates it with `updateLinearTextureDataSubpart` and checks the texture against the\n   * updated data after the copy operation.\n   */\n  copyWholeTextureToBufferAndCheckContentsWithUpdatedData(\n    { texture, mipLevel, origin }: TextureCopyViewWithRequiredOrigin,\n    fullTextureCopyLayout: TextureCopyLayout,\n    texturePartialDataLayout: Required<GPUImageDataLayout>,\n    copySize: Required<GPUExtent3DDict>,\n    format: SizedTextureFormat,\n    fullData: GPUBuffer,\n    partialData: Uint8Array\n  ): void {\n    const { mipSize, bytesPerRow, rowsPerImage, byteLength } = fullTextureCopyLayout;\n    const readbackPromise = this.readGPUBufferRangeTyped(fullData, {\n      type: Uint8Array,\n      typedLength: byteLength,\n    });\n\n    const destinationOrigin = { x: 0, y: 0, z: 0 };\n\n    // We add an eventual async expectation which will update the full data and then add\n    // other eventual async expectations to ensure it will be correct.\n    this.eventualAsyncExpectation(async () => {\n      const readback = await readbackPromise;\n      this.updateLinearTextureDataSubBox(\n        { offset: 0, ...fullTextureCopyLayout },\n        texturePartialDataLayout,\n        copySize,\n        destinationOrigin,\n        origin,\n        format,\n        readback.data,\n        partialData\n      );\n      this.copyPartialTextureToBufferAndCheckContents(\n        { texture, mipLevel, origin: destinationOrigin },\n        { width: mipSize[0], height: mipSize[1], depthOrArrayLayers: mipSize[2] },\n        format,\n        readback.data,\n        { bytesPerRow, rowsPerImage, offset: 0 }\n      );\n      readback.cleanup();\n    });\n  }\n\n  /**\n   * Tests copy between linear data and texture by creating a texture, putting some data into it\n   * with WriteTexture/CopyB2T, then getting data for the whole texture/for a part of it back and\n   * comparing it with the expectation.\n   */\n  uploadTextureAndVerifyCopy({\n    textureDataLayout,\n    copySize,\n    dataSize,\n    mipLevel = 0,\n    origin = { x: 0, y: 0, z: 0 },\n    textureSize,\n    format,\n    dimension = '2d',\n    initMethod,\n    checkMethod,\n    changeBeforePass = 'none',\n  }: {\n    textureDataLayout: Required<GPUImageDataLayout>;\n    copySize: Required<GPUExtent3DDict>;\n    dataSize: number;\n    mipLevel?: number;\n    origin?: Required<GPUOrigin3DDict>;\n    textureSize: readonly [number, number, number];\n    format: SizedTextureFormat;\n    dimension?: GPUTextureDimension;\n    initMethod: InitMethod;\n    checkMethod: CheckMethod;\n    changeBeforePass?: ChangeBeforePass;\n  }): void {\n    const texture = this.device.createTexture({\n      size: textureSize as [number, number, number],\n      format,\n      dimension,\n      mipLevelCount: mipLevel + 1,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const data = this.generateData(dataSize);\n\n    switch (checkMethod) {\n      case 'PartialCopyT2B': {\n        this.uploadLinearTextureDataToTextureSubBox(\n          { texture, mipLevel, origin },\n          textureDataLayout,\n          copySize,\n          data,\n          initMethod,\n          changeBeforePass\n        );\n\n        this.copyPartialTextureToBufferAndCheckContents(\n          { texture, mipLevel, origin },\n          copySize,\n          format,\n          data,\n          textureDataLayout,\n          changeBeforePass\n        );\n\n        break;\n      }\n      case 'FullCopyT2B': {\n        const fullTextureCopyLayout = getTextureCopyLayout(format, dimension, textureSize, {\n          mipLevel,\n        });\n\n        const fullData = this.copyWholeTextureToNewBuffer(\n          { texture, mipLevel },\n          fullTextureCopyLayout\n        );\n\n        this.uploadLinearTextureDataToTextureSubBox(\n          { texture, mipLevel, origin },\n          textureDataLayout,\n          copySize,\n          data,\n          initMethod,\n          changeBeforePass\n        );\n\n        this.copyWholeTextureToBufferAndCheckContentsWithUpdatedData(\n          { texture, mipLevel, origin },\n          fullTextureCopyLayout,\n          textureDataLayout,\n          copySize,\n          format,\n          fullData,\n          data\n        );\n\n        break;\n      }\n      default:\n        unreachable();\n    }\n  }\n\n  async DoUploadToStencilTest(\n    format: DepthStencilFormat,\n    textureSize: readonly [number, number, number],\n    uploadMethod: 'WriteTexture' | 'CopyB2T',\n    bytesPerRow: number,\n    rowsPerImage: number,\n    initialDataSize: number,\n    initialDataOffset: number,\n    mipLevel: number\n  ): Promise<void> {\n    const srcTexture = this.device.createTexture({\n      size: textureSize,\n      usage:\n        GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n      format,\n      mipLevelCount: mipLevel + 1,\n    });\n\n    const copySize = [textureSize[0] >> mipLevel, textureSize[1] >> mipLevel, textureSize[2]];\n    const initialData = this.generateData(\n      align(initialDataSize, kBufferSizeAlignment),\n      0,\n      initialDataOffset\n    );\n    switch (uploadMethod) {\n      case 'WriteTexture':\n        this.queue.writeTexture(\n          { texture: srcTexture, aspect: 'stencil-only', mipLevel },\n          initialData,\n          {\n            offset: initialDataOffset,\n            bytesPerRow,\n            rowsPerImage,\n          },\n          copySize\n        );\n        break;\n      case 'CopyB2T':\n        {\n          const stagingBuffer = makeBufferWithContents(\n            this.device,\n            initialData,\n            GPUBufferUsage.COPY_SRC\n          );\n          const encoder = this.device.createCommandEncoder();\n          encoder.copyBufferToTexture(\n            { buffer: stagingBuffer, offset: initialDataOffset, bytesPerRow, rowsPerImage },\n            { texture: srcTexture, aspect: 'stencil-only', mipLevel },\n            copySize\n          );\n          this.queue.submit([encoder.finish()]);\n        }\n        break;\n      default:\n        unreachable();\n    }\n\n    await this.checkStencilTextureContent(\n      srcTexture,\n      textureSize,\n      format,\n      initialData,\n      initialDataOffset,\n      bytesPerRow,\n      rowsPerImage,\n      mipLevel\n    );\n  }\n\n  async DoCopyFromStencilTest(\n    format: DepthStencilFormat,\n    textureSize: readonly [number, number, number],\n    bytesPerRow: number,\n    rowsPerImage: number,\n    offset: number,\n    mipLevel: number\n  ): Promise<void> {\n    const srcTexture = this.device.createTexture({\n      size: textureSize,\n      usage:\n        GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n      format,\n      mipLevelCount: mipLevel + 1,\n    });\n\n    // Initialize srcTexture with queue.writeTexture()\n    const copySize = [textureSize[0] >> mipLevel, textureSize[1] >> mipLevel, textureSize[2]];\n    const initialData = this.generateData(\n      align(copySize[0] * copySize[1] * copySize[2], kBufferSizeAlignment)\n    );\n    this.queue.writeTexture(\n      { texture: srcTexture, aspect: 'stencil-only', mipLevel },\n      initialData,\n      { bytesPerRow: copySize[0], rowsPerImage: copySize[1] },\n      copySize\n    );\n\n    // Copy the stencil aspect from srcTexture into outputBuffer.\n    const outputBufferSize = align(\n      offset +\n        dataBytesForCopyOrFail({\n          layout: { bytesPerRow, rowsPerImage },\n          format: 'stencil8',\n          copySize,\n          method: 'CopyT2B',\n        }),\n      kBufferSizeAlignment\n    );\n    const outputBuffer = this.device.createBuffer({\n      size: outputBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    const encoder = this.device.createCommandEncoder();\n    encoder.copyTextureToBuffer(\n      { texture: srcTexture, aspect: 'stencil-only', mipLevel },\n      { buffer: outputBuffer, offset, bytesPerRow, rowsPerImage },\n      copySize\n    );\n    this.queue.submit([encoder.finish()]);\n\n    // Validate the data in outputBuffer is what we expect.\n    const expectedData = new Uint8Array(outputBufferSize);\n    for (let z = 0; z < copySize[2]; ++z) {\n      const baseExpectedOffset = offset + z * bytesPerRow * rowsPerImage;\n      const baseInitialiDataOffset = z * copySize[0] * copySize[1];\n      for (let y = 0; y < copySize[1]; ++y) {\n        memcpy(\n          {\n            src: initialData,\n            start: baseInitialiDataOffset + y * copySize[0],\n            length: copySize[0],\n          },\n          { dst: expectedData, start: baseExpectedOffset + y * bytesPerRow }\n        );\n      }\n    }\n    this.expectGPUBufferValuesEqual(outputBuffer, expectedData);\n  }\n\n  // MAINTENANCE_TODO(crbug.com/dawn/868): Revisit this when consolidating texture helpers.\n  async checkStencilTextureContent(\n    stencilTexture: GPUTexture,\n    stencilTextureSize: readonly [number, number, number],\n    stencilTextureFormat: GPUTextureFormat,\n    expectedStencilTextureData: Uint8Array,\n    expectedStencilTextureDataOffset: number,\n    expectedStencilTextureDataBytesPerRow: number,\n    expectedStencilTextureDataRowsPerImage: number,\n    stencilTextureMipLevel: number\n  ): Promise<void> {\n    const stencilBitCount = 8;\n\n    // Prepare the uniform buffer that stores the bit indices (from 0 to 7) at stride 256 (required\n    // by Dynamic Buffer Offset).\n    const uniformBufferSize = kMinDynamicBufferOffsetAlignment * (stencilBitCount - 1) + 4;\n    const uniformBufferData = new Uint32Array(uniformBufferSize / 4);\n    for (let i = 1; i < stencilBitCount; ++i) {\n      uniformBufferData[(kMinDynamicBufferOffsetAlignment / 4) * i] = i;\n    }\n    const uniformBuffer = makeBufferWithContents(\n      this.device,\n      uniformBufferData,\n      GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM\n    );\n\n    // Prepare the base render pipeline descriptor (all the settings expect stencilReadMask).\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.FRAGMENT,\n          buffer: {\n            type: 'uniform',\n            minBindingSize: 4,\n            hasDynamicOffset: true,\n          },\n        },\n      ],\n    });\n    const renderPipelineDescriptorBase: GPURenderPipelineDescriptor = {\n      layout: this.device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),\n      vertex: {\n        module: this.device.createShaderModule({\n          code: `\n            [[stage(vertex)]]\n            fn main([[builtin(vertex_index)]] VertexIndex : u32)-> [[builtin(position)]] vec4<f32> {\n              var pos : array<vec2<f32>, 6> = array<vec2<f32>, 6>(\n                  vec2<f32>(-1.0,  1.0),\n                  vec2<f32>(-1.0, -1.0),\n                  vec2<f32>( 1.0,  1.0),\n                  vec2<f32>(-1.0, -1.0),\n                  vec2<f32>( 1.0,  1.0),\n                  vec2<f32>( 1.0, -1.0));\n              return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n            struct Params {\n              stencilBitIndex: u32;\n            };\n            [[group(0), binding(0)]] var<uniform> param: Params;\n            [[stage(fragment)]]\n            fn main() -> [[location(0)]] vec4<f32> {\n              return vec4<f32>(f32(1u << param.stencilBitIndex) / 255.0, 0.0, 0.0, 0.0);\n            }`,\n        }),\n        entryPoint: 'main',\n        targets: [\n          {\n            // As we implement \"rendering one bit in each draw() call\" with blending operation\n            // 'add', the format of outputTexture must support blending.\n            format: 'r8unorm',\n            blend: {\n              color: { srcFactor: 'one', dstFactor: 'one', operation: 'add' },\n              alpha: {},\n            },\n          },\n        ],\n      },\n\n      primitive: {\n        topology: 'triangle-list',\n      },\n\n      depthStencil: {\n        format: stencilTextureFormat,\n        stencilFront: {\n          compare: 'equal',\n        },\n        stencilBack: {\n          compare: 'equal',\n        },\n      },\n    };\n\n    // Prepare the bindGroup that contains uniformBuffer and referenceTexture.\n    const bindGroup = this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: uniformBuffer,\n            size: 4,\n          },\n        },\n      ],\n    });\n\n    // \"Copy\" the stencil value into the color attachment with 8 draws in one render pass. Each draw\n    // will \"Copy\" one bit of the stencil value into the color attachment. The bit of the stencil\n    // value is specified by setStencilReference().\n    const copyFromOutputTextureLayout = getTextureCopyLayout(\n      'stencil8',\n      '2d',\n      [stencilTextureSize[0], stencilTextureSize[1], 1],\n      {\n        mipLevel: stencilTextureMipLevel,\n      }\n    );\n    const outputTextureSize = [\n      copyFromOutputTextureLayout.mipSize[0],\n      copyFromOutputTextureLayout.mipSize[1],\n      1,\n    ];\n    const outputTexture = this.device.createTexture({\n      format: 'r8unorm',\n      size: outputTextureSize,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    for (\n      let stencilTextureLayer = 0;\n      stencilTextureLayer < stencilTextureSize[2];\n      ++stencilTextureLayer\n    ) {\n      const encoder = this.device.createCommandEncoder();\n      const renderPass = encoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: outputTexture.createView(),\n            loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n            storeOp: 'store',\n          },\n        ],\n        depthStencilAttachment: {\n          view: stencilTexture.createView({\n            baseMipLevel: stencilTextureMipLevel,\n            mipLevelCount: 1,\n            baseArrayLayer: stencilTextureLayer,\n            arrayLayerCount: 1,\n          }),\n          stencilLoadValue: 'load',\n          stencilStoreOp: 'store',\n          depthLoadValue: 0,\n          depthStoreOp: 'store',\n        },\n      });\n\n      for (let stencilBitIndex = 0; stencilBitIndex < stencilBitCount; ++stencilBitIndex) {\n        const renderPipelineDescriptor = renderPipelineDescriptorBase;\n        assert(renderPipelineDescriptor.depthStencil !== undefined);\n        renderPipelineDescriptor.depthStencil.stencilReadMask = 1 << stencilBitIndex;\n        const renderPipeline = this.device.createRenderPipeline(renderPipelineDescriptor);\n\n        renderPass.setPipeline(renderPipeline);\n        renderPass.setStencilReference(1 << stencilBitIndex);\n        renderPass.setBindGroup(0, bindGroup, [stencilBitIndex * kMinDynamicBufferOffsetAlignment]);\n        renderPass.draw(6);\n      }\n      renderPass.endPass();\n\n      // Check outputTexture by copying the content of outputTexture into outputStagingBuffer and\n      // checking all the data in outputStagingBuffer.\n      const outputStagingBuffer = this.device.createBuffer({\n        size: copyFromOutputTextureLayout.byteLength,\n        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n      });\n      encoder.copyTextureToBuffer(\n        {\n          texture: outputTexture,\n        },\n        {\n          buffer: outputStagingBuffer,\n          bytesPerRow: copyFromOutputTextureLayout.bytesPerRow,\n          rowsPerImage: copyFromOutputTextureLayout.rowsPerImage,\n        },\n        outputTextureSize\n      );\n\n      this.queue.submit([encoder.finish()]);\n\n      // Check the valid data in outputStagingBuffer once per row.\n      for (let y = 0; y < copyFromOutputTextureLayout.mipSize[1]; ++y) {\n        this.expectGPUBufferValuesEqual(\n          outputStagingBuffer,\n          expectedStencilTextureData.slice(\n            expectedStencilTextureDataOffset +\n              expectedStencilTextureDataBytesPerRow *\n                expectedStencilTextureDataRowsPerImage *\n                stencilTextureLayer +\n              expectedStencilTextureDataBytesPerRow * y,\n            copyFromOutputTextureLayout.mipSize[0]\n          )\n        );\n      }\n    }\n  }\n\n  // MAINTENANCE_TODO(crbug.com/dawn/868): Revisit this when consolidating texture helpers.\n  initializeDepthAspectWithRendering(\n    depthTexture: GPUTexture,\n    depthFormat: GPUTextureFormat,\n    copySize: readonly [number, number, number],\n    copyMipLevel: number,\n    initialData: Float32Array\n  ): void {\n    assert(kTextureFormatInfo[depthFormat].depth);\n\n    const inputTexture = this.device.createTexture({\n      size: copySize,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      format: 'r32float',\n    });\n    this.queue.writeTexture(\n      { texture: inputTexture },\n      initialData,\n      {\n        bytesPerRow: copySize[0] * 4,\n        rowsPerImage: copySize[1],\n      },\n      copySize\n    );\n\n    const renderPipeline = this.device.createRenderPipeline({\n      vertex: {\n        module: this.device.createShaderModule({\n          code: `\n          [[stage(vertex)]]\n          fn main([[builtin(vertex_index)]] VertexIndex : u32)-> [[builtin(position)]] vec4<f32> {\n            var pos : array<vec2<f32>, 6> = array<vec2<f32>, 6>(\n                vec2<f32>(-1.0,  1.0),\n                vec2<f32>(-1.0, -1.0),\n                vec2<f32>( 1.0,  1.0),\n                vec2<f32>(-1.0, -1.0),\n                vec2<f32>( 1.0,  1.0),\n                vec2<f32>( 1.0, -1.0));\n            return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n          }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n            [[group(0), binding(0)]] var inputTexture: texture_2d<f32>;\n            [[stage(fragment)]] fn main([[builtin(position)]] fragcoord : vec4<f32>) ->\n              [[builtin(frag_depth)]] f32 {\n              var depthValue : vec4<f32> = textureLoad(inputTexture, vec2<i32>(fragcoord.xy), 0);\n              return depthValue.x;\n            }`,\n        }),\n        entryPoint: 'main',\n        targets: [],\n      },\n      primitive: {\n        topology: 'triangle-list',\n      },\n      depthStencil: {\n        format: depthFormat,\n        depthWriteEnabled: true,\n        depthCompare: 'always',\n      },\n    });\n\n    const encoder = this.device.createCommandEncoder();\n    for (let z = 0; z < copySize[2]; ++z) {\n      const renderPass = encoder.beginRenderPass({\n        colorAttachments: [],\n        depthStencilAttachment: {\n          view: depthTexture.createView({\n            baseArrayLayer: z,\n            arrayLayerCount: 1,\n            baseMipLevel: copyMipLevel,\n            mipLevelCount: 1,\n          }),\n          depthLoadValue: 0.0,\n          depthStoreOp: 'store',\n          stencilLoadValue: 'load',\n          stencilStoreOp: 'store',\n        },\n      });\n      renderPass.setPipeline(renderPipeline);\n\n      const bindGroup = this.device.createBindGroup({\n        layout: renderPipeline.getBindGroupLayout(0),\n        entries: [\n          {\n            binding: 0,\n            resource: inputTexture.createView({\n              baseArrayLayer: z,\n              arrayLayerCount: 1,\n              baseMipLevel: 0,\n              mipLevelCount: 1,\n            }),\n          },\n        ],\n      });\n      renderPass.setBindGroup(0, bindGroup);\n      renderPass.draw(6);\n      renderPass.endPass();\n    }\n\n    this.queue.submit([encoder.finish()]);\n  }\n\n  DoCopyTextureToBufferWithDepthAspectTest(\n    format: DepthStencilFormat,\n    copySize: readonly [number, number, number],\n    bytesPerRowPadding: number,\n    rowsPerImagePadding: number,\n    offset: number,\n    dataPaddingInBytes: number,\n    mipLevel: number\n  ): void {\n    // [2]: need to convert the float32 values in initialData into the ones compatible\n    // to the depth aspect of depthFormats when depth16unorm and depth24unorm-stencil8 are supported\n    // by the browsers.\n    assert(format !== 'depth16unorm' && format !== 'depth24unorm-stencil8');\n\n    // Generate the initial depth data\n    const initialData = new Float32Array(copySize[0] * copySize[1] * copySize[2]);\n    for (let i = 0; i < initialData.length; ++i) {\n      const baseValue = 0.05 * i;\n\n      // We expect there are both 1's and 0's in initialData.\n      initialData[i] = i % 40 === 0 ? 1 : baseValue - Math.floor(baseValue);\n      assert(initialData[i] >= 0 && initialData[i] <= 1);\n    }\n\n    // Initialize the depth aspect of the source texture\n    const depthTexture = this.device.createTexture({\n      format,\n      size: [copySize[0] << mipLevel, copySize[1] << mipLevel, copySize[2]] as const,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n      mipLevelCount: mipLevel + 1,\n    });\n    this.initializeDepthAspectWithRendering(depthTexture, format, copySize, mipLevel, initialData);\n\n    // Copy the depth aspect of the texture into the destination buffer.\n    const aspectBytesPerBlock = depthStencilFormatAspectSize(format, 'depth-only');\n    const bytesPerRow =\n      align(aspectBytesPerBlock * copySize[0], kBytesPerRowAlignment) +\n      bytesPerRowPadding * kBytesPerRowAlignment;\n    const rowsPerImage = copySize[1] + rowsPerImagePadding;\n\n    const destinationBufferSize = align(\n      bytesPerRow * rowsPerImage * copySize[2] +\n        bytesPerRow * (copySize[1] - 1) +\n        aspectBytesPerBlock * copySize[0] +\n        offset +\n        dataPaddingInBytes,\n      kBufferSizeAlignment\n    );\n    const destinationBuffer = this.device.createBuffer({\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n      size: destinationBufferSize,\n    });\n    const copyEncoder = this.device.createCommandEncoder();\n    copyEncoder.copyTextureToBuffer(\n      {\n        texture: depthTexture,\n        mipLevel,\n      },\n      {\n        buffer: destinationBuffer,\n        offset,\n        bytesPerRow,\n        rowsPerImage,\n      },\n      copySize\n    );\n    this.queue.submit([copyEncoder.finish()]);\n\n    // Validate the data in destinationBuffer is what we expect.\n    const expectedData = new Uint8Array(destinationBufferSize);\n    for (let z = 0; z < copySize[2]; ++z) {\n      const baseExpectedOffset = z * bytesPerRow * rowsPerImage + offset;\n      const baseInitialiDataOffset = z * copySize[0] * copySize[1];\n      for (let y = 0; y < copySize[1]; ++y) {\n        memcpy(\n          {\n            src: initialData,\n            start: baseInitialiDataOffset + y * copySize[0],\n            length: copySize[0],\n          },\n          { dst: expectedData, start: baseExpectedOffset + y * bytesPerRow }\n        );\n      }\n    }\n    this.expectGPUBufferValuesEqual(destinationBuffer, expectedData);\n  }\n}\n\n/**\n * This is a helper function used for filtering test parameters\n *\n * [3]: Modify this after introducing tests with rendering.\n */\nfunction formatCanBeTested({ format }: { format: SizedTextureFormat }): boolean {\n  return kTextureFormatInfo[format].copyDst && kTextureFormatInfo[format].copySrc;\n}\n\nexport const g = makeTestGroup(ImageCopyTest);\n\nconst kRowsPerImageAndBytesPerRowParams = {\n  paddings: [\n    { bytesPerRowPadding: 0, rowsPerImagePadding: 0 }, // no padding\n    { bytesPerRowPadding: 0, rowsPerImagePadding: 6 }, // rowsPerImage padding\n    { bytesPerRowPadding: 6, rowsPerImagePadding: 0 }, // bytesPerRow padding\n    { bytesPerRowPadding: 15, rowsPerImagePadding: 17 }, // both paddings\n  ],\n\n  copySizes: [\n    // In the two cases below, for (WriteTexture, PartialCopyB2T) and (CopyB2T, FullCopyT2B)\n    // sets of methods we will have bytesPerRow = 256 and copyDepth % 2 == { 0, 1 }\n    // respectively. This covers a special code path for D3D12.\n    { copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 5 }, // standard copy\n    { copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 2 }, // standard copy\n\n    { copyWidthInBlocks: 0, copyHeightInBlocks: 4, copyDepth: 5 }, // empty copy because of width\n    { copyWidthInBlocks: 3, copyHeightInBlocks: 0, copyDepth: 5 }, // empty copy because of height\n    { copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 0 }, // empty copy because of depthOrArrayLayers\n    { copyWidthInBlocks: 256, copyHeightInBlocks: 3, copyDepth: 2 }, // copyWidth is 256-aligned\n    { copyWidthInBlocks: 1, copyHeightInBlocks: 3, copyDepth: 5 }, // copyWidth = 1\n\n    // The two cases below cover another special code path for D3D12.\n    //   - For (WriteTexture, FullCopyT2B) with r8unorm:\n    //         bytesPerRow = 15 = 3 * 5 = bytesInACompleteCopyImage.\n    { copyWidthInBlocks: 32, copyHeightInBlocks: 1, copyDepth: 8 }, // copyHeight = 1\n    //   - For (CopyB2T, FullCopyT2B) and (WriteTexture, PartialCopyT2B) with r8unorm:\n    //         bytesPerRow = 256 = 8 * 32 = bytesInACompleteCopyImage.\n    { copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 1 }, // copyDepth = 1\n\n    { copyWidthInBlocks: 7, copyHeightInBlocks: 1, copyDepth: 1 }, // copyHeight = 1 and copyDepth = 1\n  ],\n};\n\ng.test('rowsPerImage_and_bytesPerRow')\n  .desc(\n    `Test that copying data with various bytesPerRow and rowsPerImage values and minimum required\nbytes in copy works for every format.\n\n  Covers a special code path for Metal:\n    bufferSize - offset < bytesPerImage * copyExtent.depthOrArrayLayers\n  Covers a special code path for D3D12:\n    when bytesPerRow is not a multiple of 512 and copyExtent.depthOrArrayLayers > 1: copyExtent.depthOrArrayLayers % 2 == { 0, 1 }\n    bytesPerRow == bytesInACompleteCopyImage\n  `\n  )\n  .params(u =>\n    u\n      .combineWithParams(kMethodsToTest)\n      .combine('format', kWorkingTextureFormats)\n      .filter(formatCanBeTested)\n      .beginSubcases()\n      .combineWithParams(kRowsPerImageAndBytesPerRowParams.paddings)\n      .combineWithParams(kRowsPerImageAndBytesPerRowParams.copySizes)\n  )\n  .fn(async t => {\n    const {\n      bytesPerRowPadding,\n      rowsPerImagePadding,\n      copyWidthInBlocks,\n      copyHeightInBlocks,\n      copyDepth,\n      format,\n      initMethod,\n      checkMethod,\n    } = t.params;\n    const info = kTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.feature);\n\n    // For CopyB2T and CopyT2B we need to have bytesPerRow 256-aligned,\n    // to make this happen we align the bytesInACompleteRow value and multiply\n    // bytesPerRowPadding by 256.\n    const bytesPerRowAlignment =\n      initMethod === 'WriteTexture' && checkMethod === 'FullCopyT2B' ? 1 : 256;\n\n    const copyWidth = copyWidthInBlocks * info.blockWidth;\n    const copyHeight = copyHeightInBlocks * info.blockHeight;\n    const rowsPerImage = copyHeightInBlocks + rowsPerImagePadding;\n    const bytesPerRow =\n      align(bytesInACompleteRow(copyWidth, format), bytesPerRowAlignment) +\n      bytesPerRowPadding * bytesPerRowAlignment;\n    const copySize = { width: copyWidth, height: copyHeight, depthOrArrayLayers: copyDepth };\n\n    const dataSize = dataBytesForCopyOrFail({\n      layout: { offset: 0, bytesPerRow, rowsPerImage },\n      format,\n      copySize,\n      method: initMethod,\n    });\n\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: { offset: 0, bytesPerRow, rowsPerImage },\n      copySize,\n      dataSize,\n      textureSize: [\n        Math.max(copyWidth, info.blockWidth),\n        Math.max(copyHeight, info.blockHeight),\n        Math.max(copyDepth, 1),\n      ] /* making sure the texture is non-empty */,\n      format,\n      initMethod,\n      checkMethod,\n    });\n  });\n\nconst kOffsetsAndSizesParams = {\n  offsetsAndPaddings: [\n    { offsetInBlocks: 0, dataPaddingInBytes: 0 }, // no offset and no padding\n    { offsetInBlocks: 1, dataPaddingInBytes: 0 }, // offset = 1\n    { offsetInBlocks: 2, dataPaddingInBytes: 0 }, // offset = 2\n    { offsetInBlocks: 15, dataPaddingInBytes: 0 }, // offset = 15\n    { offsetInBlocks: 16, dataPaddingInBytes: 0 }, // offset = 16\n    { offsetInBlocks: 242, dataPaddingInBytes: 0 }, // for rgba8unorm format: offset + bytesInCopyExtentPerRow = 242 + 12 = 256 = bytesPerRow\n    { offsetInBlocks: 243, dataPaddingInBytes: 0 }, // for rgba8unorm format: offset + bytesInCopyExtentPerRow = 243 + 12 > 256 = bytesPerRow\n    { offsetInBlocks: 768, dataPaddingInBytes: 0 }, // for copyDepth = 1, blockWidth = 1 and bytesPerBlock = 1: offset = 768 = 3 * 256 = bytesInACompleteCopyImage\n    { offsetInBlocks: 769, dataPaddingInBytes: 0 }, // for copyDepth = 1, blockWidth = 1 and bytesPerBlock = 1: offset = 769 > 768 = bytesInACompleteCopyImage\n    { offsetInBlocks: 0, dataPaddingInBytes: 1 }, // dataPaddingInBytes > 0\n    { offsetInBlocks: 1, dataPaddingInBytes: 8 }, // offset > 0 and dataPaddingInBytes > 0\n  ],\n  copyDepth: [1, 2],\n};\n\ng.test('offsets_and_sizes')\n  .desc(\n    `Test that copying data with various offset values and additional data paddings\nworks for every format with 2d and 2d-array textures.\n\n  Covers two special code paths for D3D12:\n    offset + bytesInCopyExtentPerRow { ==, > } bytesPerRow\n    offset > bytesInACompleteCopyImage\n`\n  )\n  .params(\n    u =>\n      u\n        .combineWithParams(kMethodsToTest)\n        .combine('format', kWorkingTextureFormats)\n        .filter(formatCanBeTested)\n        .beginSubcases()\n        .combineWithParams(kOffsetsAndSizesParams.offsetsAndPaddings)\n        .combine('copyDepth', kOffsetsAndSizesParams.copyDepth) // 2d and 2d-array textures\n  )\n  .fn(async t => {\n    const {\n      offsetInBlocks,\n      dataPaddingInBytes,\n      copyDepth,\n      format,\n      initMethod,\n      checkMethod,\n    } = t.params;\n    const info = kTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.feature);\n\n    const offset = offsetInBlocks * info.bytesPerBlock;\n    const copySize = {\n      width: 3 * info.blockWidth,\n      height: 3 * info.blockHeight,\n      depthOrArrayLayers: copyDepth,\n    };\n    const rowsPerImage = 3;\n    const bytesPerRow = 256;\n\n    const minDataSize = dataBytesForCopyOrFail({\n      layout: { offset, bytesPerRow, rowsPerImage },\n      format,\n      copySize,\n      method: initMethod,\n    });\n    const dataSize = minDataSize + dataPaddingInBytes;\n\n    // We're copying a (3 x 3 x copyDepth) (in texel blocks) part of a (4 x 4 x copyDepth)\n    // (in texel blocks) texture with no origin.\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: { offset, bytesPerRow, rowsPerImage },\n      copySize,\n      dataSize,\n      textureSize: [4 * info.blockWidth, 4 * info.blockHeight, copyDepth],\n      format,\n      initMethod,\n      checkMethod,\n    });\n  });\n\ng.test('origins_and_extents')\n  .desc(\n    `Test that copying slices of a texture works with various origin and copyExtent values\nfor all formats. We pass origin and copyExtent as [number, number, number].`\n  )\n  .params(u =>\n    u\n      .combineWithParams(kMethodsToTest)\n      .combine('format', kWorkingTextureFormats)\n      .filter(formatCanBeTested)\n      .beginSubcases()\n      .combine('originValueInBlocks', [0, 7, 8])\n      .combine('copySizeValueInBlocks', [0, 7, 8])\n      .combine('textureSizePaddingValueInBlocks', [0, 7, 8])\n      .unless(\n        p =>\n          // we can't create an empty texture\n          p.copySizeValueInBlocks + p.originValueInBlocks + p.textureSizePaddingValueInBlocks === 0\n      )\n      .combine('coordinateToTest', [0, 1, 2] as const)\n  )\n  .fn(async t => {\n    const {\n      originValueInBlocks,\n      copySizeValueInBlocks,\n      textureSizePaddingValueInBlocks,\n      format,\n      initMethod,\n      checkMethod,\n    } = t.params;\n    const info = kTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.feature);\n\n    const originBlocks = [1, 1, 1];\n    const copySizeBlocks = [2, 2, 2];\n    const texSizeBlocks = [3, 3, 3];\n\n    {\n      const ctt = t.params.coordinateToTest;\n      originBlocks[ctt] = originValueInBlocks;\n      copySizeBlocks[ctt] = copySizeValueInBlocks;\n      texSizeBlocks[ctt] =\n        originBlocks[ctt] + copySizeBlocks[ctt] + textureSizePaddingValueInBlocks;\n    }\n\n    const origin: Required<GPUOrigin3DDict> = {\n      x: originBlocks[0] * info.blockWidth,\n      y: originBlocks[1] * info.blockHeight,\n      z: originBlocks[2],\n    };\n    const copySize = {\n      width: copySizeBlocks[0] * info.blockWidth,\n      height: copySizeBlocks[1] * info.blockHeight,\n      depthOrArrayLayers: copySizeBlocks[2],\n    };\n    const textureSize = [\n      texSizeBlocks[0] * info.blockWidth,\n      texSizeBlocks[1] * info.blockHeight,\n      texSizeBlocks[2],\n    ] as const;\n\n    const rowsPerImage = copySizeBlocks[1];\n    const bytesPerRow = align(copySizeBlocks[0] * info.bytesPerBlock, 256);\n\n    const dataSize = dataBytesForCopyOrFail({\n      layout: { offset: 0, bytesPerRow, rowsPerImage },\n      format,\n      copySize,\n      method: initMethod,\n    });\n\n    // For testing width: we copy a (_ x 2 x 2) (in texel blocks) part of a (_ x 3 x 3)\n    // (in texel blocks) texture with origin (_, 1, 1) (in texel blocks).\n    // Similarly for other coordinates.\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: { offset: 0, bytesPerRow, rowsPerImage },\n      copySize,\n      dataSize,\n      origin,\n      textureSize,\n      format,\n      initMethod,\n      checkMethod,\n      changeBeforePass: 'arrays',\n    });\n  });\n\n/**\n * Generates textureSizes which correspond to the same physicalSizeAtMipLevel including virtual\n * sizes at mip level different from the physical ones.\n */\nfunction* generateTestTextureSizes({\n  format,\n  mipLevel,\n  _mipSizeInBlocks,\n}: {\n  format: SizedTextureFormat;\n  mipLevel: number;\n  _mipSizeInBlocks: Required<GPUExtent3DDict>;\n}): Generator<[number, number, number]> {\n  const info = kTextureFormatInfo[format];\n\n  const widthAtThisLevel = _mipSizeInBlocks.width * info.blockWidth;\n  const heightAtThisLevel = _mipSizeInBlocks.height * info.blockHeight;\n  const textureSize: [number, number, number] = [\n    widthAtThisLevel << mipLevel,\n    heightAtThisLevel << mipLevel,\n    _mipSizeInBlocks.depthOrArrayLayers,\n  ];\n  yield textureSize;\n\n  // We choose width and height of the texture so that the values are divisible by blockWidth and\n  // blockHeight respectively and so that the virtual size at mip level corresponds to the same\n  // physical size.\n  // Virtual size at mip level with modified width has width = (physical size width) - (blockWidth / 2).\n  // Virtual size at mip level with modified height has height = (physical size height) - (blockHeight / 2).\n  const widthAtPrevLevel = widthAtThisLevel << 1;\n  const heightAtPrevLevel = heightAtThisLevel << 1;\n  assert(mipLevel > 0);\n  assert(widthAtPrevLevel >= info.blockWidth && heightAtPrevLevel >= info.blockHeight);\n  const modifiedWidth = (widthAtPrevLevel - info.blockWidth) << (mipLevel - 1);\n  const modifiedHeight = (heightAtPrevLevel - info.blockHeight) << (mipLevel - 1);\n\n  const modifyWidth = info.blockWidth > 1 && modifiedWidth !== textureSize[0];\n  const modifyHeight = info.blockHeight > 1 && modifiedHeight !== textureSize[1];\n\n  if (modifyWidth) {\n    yield [modifiedWidth, textureSize[1], textureSize[2]];\n  }\n  if (modifyHeight) {\n    yield [textureSize[0], modifiedHeight, textureSize[2]];\n  }\n  if (modifyWidth && modifyHeight) {\n    yield [modifiedWidth, modifiedHeight, textureSize[2]];\n  }\n}\n\ng.test('mip_levels')\n  .desc(\n    `Test that copying various mip levels works. Covers two special code paths:\n  - The physical size of the subresource is not equal to the logical size.\n  - bufferSize - offset < bytesPerImage * copyExtent.depthOrArrayLayers, and copyExtent needs to be clamped for all block formats.\n  `\n  )\n  .params(u =>\n    u\n      .combineWithParams(kMethodsToTest)\n      .combine('format', kWorkingTextureFormats)\n      .filter(formatCanBeTested)\n      .beginSubcases()\n      .combineWithParams([\n        // origin + copySize = texturePhysicalSizeAtMipLevel for all coordinates, 2d texture */\n        {\n          copySizeInBlocks: { width: 5, height: 4, depthOrArrayLayers: 1 },\n          originInBlocks: { x: 3, y: 2, z: 0 },\n          _mipSizeInBlocks: { width: 8, height: 6, depthOrArrayLayers: 1 },\n          mipLevel: 1,\n        },\n        // origin + copySize = texturePhysicalSizeAtMipLevel for all coordinates, 2d-array texture\n        {\n          copySizeInBlocks: { width: 5, height: 4, depthOrArrayLayers: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _mipSizeInBlocks: { width: 8, height: 6, depthOrArrayLayers: 3 },\n          mipLevel: 2,\n        },\n        // origin.x + copySize.width = texturePhysicalSizeAtMipLevel.width\n        {\n          copySizeInBlocks: { width: 5, height: 4, depthOrArrayLayers: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _mipSizeInBlocks: { width: 8, height: 7, depthOrArrayLayers: 4 },\n          mipLevel: 3,\n        },\n        // origin.y + copySize.height = texturePhysicalSizeAtMipLevel.height\n        {\n          copySizeInBlocks: { width: 5, height: 4, depthOrArrayLayers: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _mipSizeInBlocks: { width: 9, height: 6, depthOrArrayLayers: 4 },\n          mipLevel: 4,\n        },\n        // origin.z + copySize.depthOrArrayLayers = texturePhysicalSizeAtMipLevel.depthOrArrayLayers\n        {\n          copySizeInBlocks: { width: 5, height: 4, depthOrArrayLayers: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _mipSizeInBlocks: { width: 9, height: 7, depthOrArrayLayers: 3 },\n          mipLevel: 5,\n        },\n        // origin + copySize < texturePhysicalSizeAtMipLevel for all coordinates\n        {\n          copySizeInBlocks: { width: 5, height: 4, depthOrArrayLayers: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _mipSizeInBlocks: { width: 9, height: 7, depthOrArrayLayers: 4 },\n          mipLevel: 6,\n        },\n      ])\n      .expand('textureSize', generateTestTextureSizes)\n  )\n  .fn(async t => {\n    const {\n      copySizeInBlocks,\n      originInBlocks,\n      textureSize,\n      mipLevel,\n      format,\n      initMethod,\n      checkMethod,\n    } = t.params;\n    const info = kTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.feature);\n\n    const origin = {\n      x: originInBlocks.x * info.blockWidth,\n      y: originInBlocks.y * info.blockHeight,\n      z: originInBlocks.z,\n    };\n    const copySize = {\n      width: copySizeInBlocks.width * info.blockWidth,\n      height: copySizeInBlocks.height * info.blockHeight,\n      depthOrArrayLayers: copySizeInBlocks.depthOrArrayLayers,\n    };\n\n    const rowsPerImage = copySizeInBlocks.height + 1;\n    const bytesPerRow = align(copySize.width, 256);\n\n    const dataSize = dataBytesForCopyOrFail({\n      layout: { offset: 0, bytesPerRow, rowsPerImage },\n      format,\n      copySize,\n      method: initMethod,\n    });\n\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: { offset: 0, bytesPerRow, rowsPerImage },\n      copySize,\n      dataSize,\n      origin,\n      mipLevel,\n      textureSize,\n      format,\n      initMethod,\n      checkMethod,\n    });\n  });\n\nconst UND = undefined;\ng.test('undefined_params')\n  .desc(\n    `Tests undefined values of bytesPerRow, rowsPerImage, and origin.x/y/z.\n  Ensures bytesPerRow/rowsPerImage=undefined are valid and behave as expected.\n  Ensures origin.x/y/z undefined default to 0.`\n  )\n  .params(u =>\n    u\n      .combineWithParams(kMethodsToTest)\n      .beginSubcases()\n      .combineWithParams([\n        // copying one row: bytesPerRow and rowsPerImage can be undefined\n        { copySize: [3, 1, 1], origin: [UND, UND, UND], bytesPerRow: UND, rowsPerImage: UND },\n        // copying one slice: rowsPerImage can be undefined\n        { copySize: [3, 3, 1], origin: [UND, UND, UND], bytesPerRow: 256, rowsPerImage: UND },\n        // copying two slices\n        { copySize: [3, 3, 2], origin: [UND, UND, UND], bytesPerRow: 256, rowsPerImage: 3 },\n        // origin.x = undefined\n        { copySize: [1, 1, 1], origin: [UND, 1, 1], bytesPerRow: UND, rowsPerImage: UND },\n        // origin.y = undefined\n        { copySize: [1, 1, 1], origin: [1, UND, 1], bytesPerRow: UND, rowsPerImage: UND },\n        // origin.z = undefined\n        { copySize: [1, 1, 1], origin: [1, 1, UND], bytesPerRow: UND, rowsPerImage: UND },\n      ])\n  )\n  .fn(async t => {\n    const { bytesPerRow, rowsPerImage, copySize, origin, initMethod, checkMethod } = t.params;\n\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: {\n        offset: 0,\n        // Zero will get turned back into undefined later.\n        bytesPerRow: bytesPerRow ?? 0,\n        // Zero will get turned back into undefined later.\n        rowsPerImage: rowsPerImage ?? 0,\n      },\n      copySize: { width: copySize[0], height: copySize[1], depthOrArrayLayers: copySize[2] },\n      dataSize: 2000,\n      textureSize: [100, 3, 2],\n      // Zeros will get turned back into undefined later.\n      origin: { x: origin[0] ?? 0, y: origin[1] ?? 0, z: origin[2] ?? 0 },\n      format: 'rgba8unorm',\n      initMethod,\n      checkMethod,\n      changeBeforePass: 'undefined',\n    });\n  });\n\nfunction CopyMethodSupportedWithDepthStencilFormat(\n  aspect: 'depth-only' | 'stencil-only',\n  format: DepthStencilFormat,\n  copyMethod: 'WriteTexture' | 'CopyB2T' | 'CopyT2B'\n): boolean {\n  {\n    return (\n      (aspect === 'stencil-only' && kTextureFormatInfo[format].stencil) ||\n      (aspect === 'depth-only' &&\n        kTextureFormatInfo[format].depth &&\n        copyMethod === 'CopyT2B' &&\n        depthStencilBufferTextureCopySupported('CopyT2B', format, aspect))\n    );\n  }\n}\n\ng.test('rowsPerImage_and_bytesPerRow_depth_stencil')\n  .desc(\n    `Test that copying data with various bytesPerRow and rowsPerImage values and minimum required\nbytes in copy works for copyBufferToTexture(), copyTextureToBuffer() and writeTexture() with stencil\naspect and copyTextureToBuffer() with depth aspect.\n\n  Covers a special code path for Metal:\n    bufferSize - offset < bytesPerImage * copyExtent.depthOrArrayLayers\n  Covers a special code path for D3D12:\n    when bytesPerRow is not a multiple of 512 and copyExtent.depthOrArrayLayers > 1:\n      copyExtent.depthOrArrayLayers % 2 == { 0, 1 }\n      bytesPerRow == bytesInACompleteCopyImage\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kDepthStencilFormats)\n      .combine('copyMethod', ['WriteTexture', 'CopyB2T', 'CopyT2B'] as const)\n      .combine('aspect', ['depth-only', 'stencil-only'] as const)\n      .filter(t => CopyMethodSupportedWithDepthStencilFormat(t.aspect, t.format, t.copyMethod))\n      .beginSubcases()\n      .combineWithParams(kRowsPerImageAndBytesPerRowParams.paddings)\n      .combineWithParams(kRowsPerImageAndBytesPerRowParams.copySizes)\n      .filter(t => {\n        return t.copyWidthInBlocks * t.copyHeightInBlocks * t.copyDepth > 0;\n      })\n      .combine('mipLevel', [0, 2])\n  )\n  .fn(async t => {\n    const {\n      format,\n      copyMethod,\n      aspect,\n      bytesPerRowPadding,\n      rowsPerImagePadding,\n      copyWidthInBlocks,\n      copyHeightInBlocks,\n      copyDepth,\n      mipLevel,\n    } = t.params;\n\n    await t.selectDeviceOrSkipTestCase(kTextureFormatInfo[format].feature);\n\n    const bytesPerBlock = depthStencilFormatAspectSize(format, aspect);\n    const rowsPerImage = copyHeightInBlocks + rowsPerImagePadding;\n\n    const bytesPerRowAlignment = copyMethod === 'WriteTexture' ? 1 : kBytesPerRowAlignment;\n    const bytesPerRow =\n      align(bytesPerBlock * copyWidthInBlocks, bytesPerRowAlignment) +\n      bytesPerRowPadding * bytesPerRowAlignment;\n\n    const copySize = [copyWidthInBlocks, copyHeightInBlocks, copyDepth] as const;\n    const textureSize = [\n      copyWidthInBlocks << mipLevel,\n      copyHeightInBlocks << mipLevel,\n      copyDepth,\n    ] as const;\n    if (copyMethod === 'CopyT2B') {\n      if (aspect === 'depth-only') {\n        t.DoCopyTextureToBufferWithDepthAspectTest(\n          format,\n          copySize,\n          bytesPerRowPadding,\n          rowsPerImagePadding,\n          0,\n          0,\n          mipLevel\n        );\n      } else {\n        await t.DoCopyFromStencilTest(format, textureSize, bytesPerRow, rowsPerImage, 0, mipLevel);\n      }\n    } else {\n      assert(\n        aspect === 'stencil-only' && (copyMethod === 'CopyB2T' || copyMethod === 'WriteTexture')\n      );\n      const initialDataSize = dataBytesForCopyOrFail({\n        layout: { bytesPerRow, rowsPerImage },\n        format: 'stencil8',\n        copySize,\n        method: copyMethod,\n      });\n\n      await t.DoUploadToStencilTest(\n        format,\n        textureSize,\n        copyMethod,\n        bytesPerRow,\n        rowsPerImage,\n        initialDataSize,\n        0,\n        mipLevel\n      );\n    }\n  });\n\ng.test('offsets_and_sizes_copy_depth_stencil')\n  .desc(\n    `Test that copying data with various offset values and additional data paddings\nworks for copyBufferToTexture(), copyTextureToBuffer() and writeTexture() with stencil aspect and\ncopyTextureToBuffer() with depth aspect.\n\n  Covers two special code paths for D3D12:\n    offset + bytesInCopyExtentPerRow { ==, > } bytesPerRow\n    offset > bytesInACompleteCopyImage\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kDepthStencilFormats)\n      .combine('copyMethod', ['WriteTexture', 'CopyB2T', 'CopyT2B'] as const)\n      .combine('aspect', ['depth-only', 'stencil-only'] as const)\n      .filter(t => CopyMethodSupportedWithDepthStencilFormat(t.aspect, t.format, t.copyMethod))\n      .beginSubcases()\n      .combineWithParams(kOffsetsAndSizesParams.offsetsAndPaddings)\n      .filter(t => t.offsetInBlocks % 4 === 0)\n      .combine('copyDepth', kOffsetsAndSizesParams.copyDepth)\n      .combine('mipLevel', [0, 2])\n  )\n  .fn(async t => {\n    const {\n      format,\n      copyMethod,\n      aspect,\n      offsetInBlocks,\n      dataPaddingInBytes,\n      copyDepth,\n      mipLevel,\n    } = t.params;\n    await t.selectDeviceOrSkipTestCase(kTextureFormatInfo[format].feature);\n\n    const bytesPerBlock = depthStencilFormatAspectSize(format, aspect);\n    const initialDataOffset = offsetInBlocks * bytesPerBlock;\n    const copySize = [3, 3, copyDepth] as const;\n    const rowsPerImage = 3;\n    const bytesPerRow = 256;\n\n    const textureSize = [copySize[0] << mipLevel, copySize[1] << mipLevel, copyDepth] as const;\n    if (copyMethod === 'CopyT2B') {\n      if (aspect === 'depth-only') {\n        t.DoCopyTextureToBufferWithDepthAspectTest(format, copySize, 0, 0, 0, 0, mipLevel);\n      } else {\n        await t.DoCopyFromStencilTest(\n          format,\n          textureSize,\n          bytesPerRow,\n          rowsPerImage,\n          initialDataOffset,\n          mipLevel\n        );\n      }\n    } else {\n      assert(\n        aspect === 'stencil-only' && (copyMethod === 'CopyB2T' || copyMethod === 'WriteTexture')\n      );\n      const minDataSize = dataBytesForCopyOrFail({\n        layout: { offset: initialDataOffset, bytesPerRow, rowsPerImage },\n        format: 'stencil8',\n        copySize,\n        method: copyMethod,\n      });\n      const initialDataSize = minDataSize + dataPaddingInBytes;\n      await t.DoUploadToStencilTest(\n        format,\n        textureSize,\n        copyMethod,\n        bytesPerRow,\n        rowsPerImage,\n        initialDataSize,\n        initialDataOffset,\n        mipLevel\n      );\n    }\n  });\n"],"file":"image_copy.spec.js"}