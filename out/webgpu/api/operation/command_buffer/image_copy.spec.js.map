{"version":3,"sources":["../../../../../src/webgpu/api/operation/command_buffer/image_copy.spec.ts"],"names":["description","makeTestGroup","assert","unreachable","kTextureFormatInfo","kSizedTextureFormats","GPUTest","align","bytesInACompleteRow","dataBytesForCopyOrFail","getTextureCopyLayout","kMethodsToTest","initMethod","checkMethod","kExcludedFormats","Set","kWorkingTextureFormats","filter","x","has","ImageCopyTest","getTexelOffsetInBytes","textureDataLayout","format","texel","origin","y","z","offset","bytesPerRow","rowsPerImage","info","blockWidth","blockHeight","bytesPerImage","bytesPerBlock","iterateBlockRows","size","width","height","depthOrArrayLayers","generateData","byteSize","start","arr","Uint8Array","i","undefDataLayoutIfNeeded","changeBeforePass","undefined","undefOrArrayCopyViewIfNeeded","texture","origin_x","origin_y","origin_z","mipLevel","arrayCopySizeIfNeeded","copyTextureToBufferWithAppliedArguments","buffer","appliedCopyView","appliedDataLayout","appliedCheckSize","encoder","device","createCommandEncoder","copyTextureToBuffer","queue","submit","finish","uploadLinearTextureDataToTextureSubBox","textureCopyView","copySize","partialData","method","appliedCopySize","writeTexture","createBuffer","mappedAtCreation","byteLength","usage","GPUBufferUsage","COPY_SRC","getMappedRange","set","unmap","copyBufferToTexture","copyPartialTextureToBufferAndCheckContents","checkSize","expected","expectedDataLayout","bufferSize","bufferData","COPY_DST","updateLinearTextureDataSubBox","expectGPUBufferValuesEqual","copyWholeTextureToNewBuffer","resultDataLayout","mipSize","copyFromArrayToArray","src","srcOffset","dst","dstOffset","subarray","destinationDataLayout","sourceDataLayout","destinationOrigin","sourceOrigin","destination","source","sourceOffset","destinationOffset","rowLength","copyWholeTextureToBufferAndCheckContentsWithUpdatedData","fullTextureCopyLayout","texturePartialDataLayout","fullData","readbackPromise","readGPUBufferRangeTyped","type","typedLength","eventualAsyncExpectation","readback","data","cleanup","uploadTextureAndVerifyCopy","dataSize","textureSize","dimension","createTexture","mipLevelCount","GPUTextureUsage","formatCanBeTested","copyDst","copySrc","g","test","desc","params","u","combineWithParams","combine","beginSubcases","bytesPerRowPadding","rowsPerImagePadding","copyWidthInBlocks","copyHeightInBlocks","copyDepth","fn","t","selectDeviceOrSkipTestCase","feature","bytesPerRowAlignment","copyWidth","copyHeight","layout","Math","max","offsetInBlocks","dataPaddingInBytes","minDataSize","unless","p","copySizeValueInBlocks","originValueInBlocks","textureSizePaddingValueInBlocks","originBlocks","copySizeBlocks","texSizeBlocks","ctt","coordinateToTest","generateTestTextureSizes","_mipSizeInBlocks","widthAtThisLevel","heightAtThisLevel","widthAtPrevLevel","heightAtPrevLevel","modifiedWidth","modifiedHeight","modifyWidth","modifyHeight","copySizeInBlocks","originInBlocks","expand","UND","unimplemented"],"mappings":"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","sourcesContent":["export const description = `writeTexture + copyBufferToTexture + copyTextureToBuffer operation tests.\n\n* copy_with_various_rows_per_image_and_bytes_per_row: test that copying data with various bytesPerRow (including { ==, > } bytesInACompleteRow) and\\\n rowsPerImage (including { ==, > } copyExtent.height) values and minimum required bytes in copy works for every format. Also covers special code paths:\n  - bufferSize - offset < bytesPerImage * copyExtent.depthOrArrayLayers\n  - when bytesPerRow is not a multiple of 512 and copyExtent.depthOrArrayLayers > 1: copyExtent.depthOrArrayLayers % 2 == { 0, 1 }\n  - bytesPerRow == bytesInACompleteCopyImage\n\n* copy_with_various_offsets_and_data_sizes: test that copying data with various offset (including { ==, > } 0 and is/isn't power of 2) values and additional\\\n data paddings works for every format with 2d and 2d-array textures. Also covers special code paths:\n  - offset + bytesInCopyExtentPerRow { ==, > } bytesPerRow\n  - offset > bytesInACompleteCopyImage\n\n* copy_with_various_origins_and_copy_extents: test that copying slices of a texture works with various origin (including { origin.x, origin.y, origin.z }\\\n { ==, > } 0 and is/isn't power of 2) and copyExtent (including { copyExtent.x, copyExtent.y, copyExtent.z } { ==, > } 0 and is/isn't power of 2) values\\\n (also including {origin._ + copyExtent._ { ==, < } the subresource size of textureCopyView) works for all formats. origin and copyExtent values are passed\\\n as [number, number, number] instead of GPUExtent3DDict.\n\n* copy_various_mip_levels: test that copying various mip levels works for all formats. Also covers special code paths:\n  - the physical size of the subresouce is not equal to the logical size\n  - bufferSize - offset < bytesPerImage * copyExtent.depthOrArrayLayers and copyExtent needs to be clamped\n\n* copy_with_no_image_or_slice_padding_and_undefined_values: test that when copying a single row we can set any bytesPerRow value and when copying a single\\\n slice we can set rowsPerImage to 0. Also test setting offset, rowsPerImage, mipLevel, origin, origin.{x,y,z} to undefined.\n\n* TODO:\n  - add another initMethod which renders the texture\n  - test copyT2B with buffer size not divisible by 4 (not done because expectContents 4-byte alignment)\n  - add tests for 1d / 3d textures\n\nTODO: Fix this test for the various skipped formats:\n- snorm tests failing due to rounding\n- float tests failing because float values are not byte-preserved\n- compressed formats\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, unreachable } from '../../../../common/util/util.js';\nimport {\n  kTextureFormatInfo,\n  SizedTextureFormat,\n  kSizedTextureFormats,\n} from '../../../capability_info.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { align } from '../../../util/math.js';\nimport {\n  bytesInACompleteRow,\n  dataBytesForCopyOrFail,\n  getTextureCopyLayout,\n  TextureCopyLayout,\n} from '../../../util/texture/layout.js';\n\ninterface TextureCopyViewWithRequiredOrigin {\n  texture: GPUTexture;\n  mipLevel: number | undefined;\n  origin: Required<GPUOrigin3DDict>;\n}\n\n/** Describes the function used to copy the initial data into the texture. */\ntype InitMethod = 'WriteTexture' | 'CopyB2T';\n/**\n * - PartialCopyT2B: do CopyT2B to check that the part of the texture we copied to with InitMethod\n *   matches the data we were copying and that we don't overwrite any data in the target buffer that\n *   we're not supposed to - that's primarily for testing CopyT2B functionality.\n * - FullCopyT2B: do CopyT2B on the whole texture and check wether the part we copied to matches\n *   the data we were copying and that the nothing else was modified - that's primarily for testing\n *   WriteTexture and CopyB2T.\n */\ntype CheckMethod = 'PartialCopyT2B' | 'FullCopyT2B';\n\n/**\n * This describes in what form the arguments will be passed to WriteTexture/CopyB2T/CopyT2B. If\n * undefined, then default values are passed as undefined instead of default values. If arrays, then\n * `GPUOrigin3D` and `GPUExtent3D` are passed as `[number, number, number]`. *\n *\n * TODO: Try to expand this with something like:\n * ```ts\n * function encodeExtent3D(\n *   mode: 'partial-array' | 'full-array' | 'extra-array' | 'partial-dict' | 'full-dict',\n *   value: GPUExtent3D\n * ): GPUExtent3D { ... }\n * ```\n */\ntype ChangeBeforePass = 'none' | 'undefined' | 'arrays';\n\n/** Each combination of methods assume that the ones before it were tested and work correctly. */\nconst kMethodsToTest = [\n  // We make sure that CopyT2B works when copying the whole texture for renderable formats:\n  // TODO\n  // Then we make sure that WriteTexture works for all formats:\n  { initMethod: 'WriteTexture', checkMethod: 'FullCopyT2B' },\n  // Then we make sure that CopyB2T works for all formats:\n  { initMethod: 'CopyB2T', checkMethod: 'FullCopyT2B' },\n  // Then we make sure that CopyT2B works for all formats:\n  { initMethod: 'WriteTexture', checkMethod: 'PartialCopyT2B' },\n] as const;\n\n// TODO: Fix things so this list can be reduced to zero (see file description)\nconst kExcludedFormats: Set<SizedTextureFormat> = new Set([\n  'r8snorm',\n  'rg8snorm',\n  'rgba8snorm',\n  'rg11b10ufloat',\n  'rg16float',\n  'rgba16float',\n  'r32float',\n  'rg32float',\n  'rgba32float',\n]);\nconst kWorkingTextureFormats = kSizedTextureFormats.filter(x => !kExcludedFormats.has(x));\n\nclass ImageCopyTest extends GPUTest {\n  /** Offset for a particular texel in the linear texture data */\n  getTexelOffsetInBytes(\n    textureDataLayout: Required<GPUImageDataLayout>,\n    format: SizedTextureFormat,\n    texel: Required<GPUOrigin3DDict>,\n    origin: Required<GPUOrigin3DDict> = { x: 0, y: 0, z: 0 }\n  ): number {\n    const { offset, bytesPerRow, rowsPerImage } = textureDataLayout;\n    const info = kTextureFormatInfo[format];\n\n    assert(texel.x >= origin.x && texel.y >= origin.y && texel.z >= origin.z);\n    assert(texel.x % info.blockWidth === 0);\n    assert(texel.y % info.blockHeight === 0);\n    assert(origin.x % info.blockWidth === 0);\n    assert(origin.y % info.blockHeight === 0);\n\n    const bytesPerImage = rowsPerImage * bytesPerRow;\n\n    return (\n      offset +\n      (texel.z - origin.z) * bytesPerImage +\n      ((texel.y - origin.y) / info.blockHeight) * bytesPerRow +\n      ((texel.x - origin.x) / info.blockWidth) * info.bytesPerBlock\n    );\n  }\n\n  *iterateBlockRows(\n    size: Required<GPUExtent3DDict>,\n    origin: Required<GPUOrigin3DDict>,\n    format: SizedTextureFormat\n  ): Generator<Required<GPUOrigin3DDict>> {\n    if (size.width === 0 || size.height === 0 || size.depthOrArrayLayers === 0) {\n      // do not iterate anything for an empty region\n      return;\n    }\n    const info = kTextureFormatInfo[format];\n    assert(size.height % info.blockHeight === 0);\n    for (let y = 0; y < size.height; y += info.blockHeight) {\n      for (let z = 0; z < size.depthOrArrayLayers; ++z) {\n        yield {\n          x: origin.x,\n          y: origin.y + y,\n          z: origin.z + z,\n        };\n      }\n    }\n  }\n\n  generateData(byteSize: number, start: number = 0): Uint8Array {\n    const arr = new Uint8Array(byteSize);\n    for (let i = 0; i < byteSize; ++i) {\n      arr[i] = (i ** 3 + i + start) % 251;\n    }\n    return arr;\n  }\n\n  /**\n   * This is used for testing passing undefined members of `GPUImageDataLayout` instead of actual\n   * values where possible. Passing arguments as values and not as objects so that they are passed\n   * by copy and not by reference.\n   */\n  undefDataLayoutIfNeeded(\n    offset: number | undefined,\n    rowsPerImage: number | undefined,\n    bytesPerRow: number | undefined,\n    changeBeforePass: ChangeBeforePass\n  ): GPUImageDataLayout {\n    if (changeBeforePass === 'undefined') {\n      if (offset === 0) {\n        offset = undefined;\n      }\n      if (bytesPerRow === 0) {\n        bytesPerRow = undefined;\n      }\n      if (rowsPerImage === 0) {\n        rowsPerImage = undefined;\n      }\n    }\n    return { offset, bytesPerRow, rowsPerImage };\n  }\n\n  /**\n   * This is used for testing passing undefined members of `GPUImageCopyTexture` instead of actual\n   * values where possible and also for testing passing the origin as `[number, number, number]`.\n   * Passing arguments as values and not as objects so that they are passed by copy and not by\n   * reference.\n   */\n  undefOrArrayCopyViewIfNeeded(\n    texture: GPUTexture,\n    origin_x: number | undefined,\n    origin_y: number | undefined,\n    origin_z: number | undefined,\n    mipLevel: number | undefined,\n    changeBeforePass: ChangeBeforePass\n  ): GPUImageCopyTexture {\n    let origin: GPUOrigin3D | undefined = { x: origin_x, y: origin_y, z: origin_z };\n\n    if (changeBeforePass === 'undefined') {\n      if (origin_x === 0 && origin_y === 0 && origin_z === 0) {\n        origin = undefined;\n      } else {\n        if (origin_x === 0) {\n          origin_x = undefined;\n        }\n        if (origin_y === 0) {\n          origin_y = undefined;\n        }\n        if (origin_z === 0) {\n          origin_z = undefined;\n        }\n        origin = { x: origin_x, y: origin_y, z: origin_z };\n      }\n\n      if (mipLevel === 0) {\n        mipLevel = undefined;\n      }\n    }\n\n    if (changeBeforePass === 'arrays') {\n      origin = [origin_x!, origin_y!, origin_z!];\n    }\n\n    return { texture, origin, mipLevel };\n  }\n\n  /**\n   * This is used for testing passing `GPUExtent3D` as `[number, number, number]` instead of\n   * `GPUExtent3DDict`. Passing arguments as values and not as objects so that they are passed by\n   * copy and not by reference.\n   */\n  arrayCopySizeIfNeeded(\n    width: number,\n    height: number,\n    depthOrArrayLayers: number,\n    changeBeforePass: ChangeBeforePass\n  ): GPUExtent3D {\n    if (changeBeforePass === 'arrays') {\n      return [width, height, depthOrArrayLayers];\n    } else {\n      return { width, height, depthOrArrayLayers };\n    }\n  }\n\n  /** Run a CopyT2B command with appropriate arguments corresponding to `ChangeBeforePass` */\n  copyTextureToBufferWithAppliedArguments(\n    buffer: GPUBuffer,\n    { offset, rowsPerImage, bytesPerRow }: Required<GPUImageDataLayout>,\n    { width, height, depthOrArrayLayers }: Required<GPUExtent3DDict>,\n    { texture, mipLevel, origin }: TextureCopyViewWithRequiredOrigin,\n    changeBeforePass: ChangeBeforePass\n  ): void {\n    const { x, y, z } = origin;\n\n    const appliedCopyView = this.undefOrArrayCopyViewIfNeeded(\n      texture,\n      x,\n      y,\n      z,\n      mipLevel,\n      changeBeforePass\n    );\n    const appliedDataLayout = this.undefDataLayoutIfNeeded(\n      offset,\n      rowsPerImage,\n      bytesPerRow,\n      changeBeforePass\n    );\n    const appliedCheckSize = this.arrayCopySizeIfNeeded(\n      width,\n      height,\n      depthOrArrayLayers,\n      changeBeforePass\n    );\n\n    const encoder = this.device.createCommandEncoder();\n    encoder.copyTextureToBuffer(\n      appliedCopyView,\n      { buffer, ...appliedDataLayout },\n      appliedCheckSize\n    );\n    this.device.queue.submit([encoder.finish()]);\n  }\n\n  /** Put data into a part of the texture with an appropriate method. */\n  uploadLinearTextureDataToTextureSubBox(\n    textureCopyView: TextureCopyViewWithRequiredOrigin,\n    textureDataLayout: GPUImageDataLayout & { bytesPerRow: number },\n    copySize: Required<GPUExtent3DDict>,\n    partialData: Uint8Array,\n    method: InitMethod,\n    changeBeforePass: ChangeBeforePass\n  ): void {\n    const { texture, mipLevel, origin } = textureCopyView;\n    const { offset, rowsPerImage, bytesPerRow } = textureDataLayout;\n    const { x, y, z } = origin;\n    const { width, height, depthOrArrayLayers } = copySize;\n\n    const appliedCopyView = this.undefOrArrayCopyViewIfNeeded(\n      texture,\n      x,\n      y,\n      z,\n      mipLevel,\n      changeBeforePass\n    );\n    const appliedDataLayout = this.undefDataLayoutIfNeeded(\n      offset,\n      rowsPerImage,\n      bytesPerRow,\n      changeBeforePass\n    );\n    const appliedCopySize = this.arrayCopySizeIfNeeded(\n      width,\n      height,\n      depthOrArrayLayers,\n      changeBeforePass\n    );\n\n    switch (method) {\n      case 'WriteTexture': {\n        this.device.queue.writeTexture(\n          appliedCopyView,\n          partialData,\n          appliedDataLayout,\n          appliedCopySize\n        );\n\n        break;\n      }\n      case 'CopyB2T': {\n        const buffer = this.device.createBuffer({\n          mappedAtCreation: true,\n          size: align(partialData.byteLength, 4),\n          usage: GPUBufferUsage.COPY_SRC,\n        });\n        new Uint8Array(buffer.getMappedRange()).set(partialData);\n        buffer.unmap();\n\n        const encoder = this.device.createCommandEncoder();\n        encoder.copyBufferToTexture(\n          { buffer, ...appliedDataLayout },\n          appliedCopyView,\n          appliedCopySize\n        );\n        this.device.queue.submit([encoder.finish()]);\n\n        break;\n      }\n      default:\n        unreachable();\n    }\n  }\n\n  /**\n   * We check an appropriate part of the texture against the given data.\n   * Used directly with PartialCopyT2B check method (for a subpart of the texture)\n   * and by `copyWholeTextureToBufferAndCheckContentsWithUpdatedData` with FullCopyT2B check method\n   * (for the whole texture). We also ensure that CopyT2B doesn't overwrite bytes it's not supposed\n   * to if validateOtherBytesInBuffer is set to true.\n   */\n  copyPartialTextureToBufferAndCheckContents(\n    { texture, mipLevel, origin }: TextureCopyViewWithRequiredOrigin,\n    checkSize: Required<GPUExtent3DDict>,\n    format: SizedTextureFormat,\n    expected: Uint8Array,\n    expectedDataLayout: Required<GPUImageDataLayout>,\n    changeBeforePass: ChangeBeforePass = 'none'\n  ): void {\n    // The alignment is necessary because we need to copy and map data from this buffer.\n    const bufferSize = align(expected.byteLength, 4);\n    // The start value ensures generated data here doesn't match the expected data.\n    const bufferData = this.generateData(bufferSize, 17);\n\n    const buffer = this.device.createBuffer({\n      mappedAtCreation: true,\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    new Uint8Array(buffer.getMappedRange()).set(bufferData);\n    buffer.unmap();\n\n    this.copyTextureToBufferWithAppliedArguments(\n      buffer,\n      expectedDataLayout,\n      checkSize,\n      { texture, mipLevel, origin },\n      changeBeforePass\n    );\n\n    this.updateLinearTextureDataSubBox(\n      expectedDataLayout,\n      expectedDataLayout,\n      checkSize,\n      origin,\n      origin,\n      format,\n      bufferData,\n      expected\n    );\n\n    this.expectGPUBufferValuesEqual(buffer, bufferData);\n  }\n\n  /**\n   * Copies the whole texture into linear data stored in a buffer for further checks.\n   *\n   * Used for `copyWholeTextureToBufferAndCheckContentsWithUpdatedData`.\n   */\n  copyWholeTextureToNewBuffer(\n    { texture, mipLevel }: { texture: GPUTexture; mipLevel: number | undefined },\n    resultDataLayout: TextureCopyLayout\n  ): GPUBuffer {\n    const { mipSize, byteLength, bytesPerRow, rowsPerImage } = resultDataLayout;\n    const buffer = this.device.createBuffer({\n      size: align(byteLength, 4), // this is necessary because we need to copy and map data from this buffer\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const encoder = this.device.createCommandEncoder();\n    encoder.copyTextureToBuffer(\n      { texture, mipLevel },\n      { buffer, bytesPerRow, rowsPerImage },\n      mipSize\n    );\n    this.device.queue.submit([encoder.finish()]);\n\n    return buffer;\n  }\n\n  copyFromArrayToArray(\n    src: Uint8Array,\n    srcOffset: number,\n    dst: Uint8Array,\n    dstOffset: number,\n    size: number\n  ): void {\n    dst.set(src.subarray(srcOffset, srcOffset + size), dstOffset);\n  }\n\n  /**\n   * Takes the data returned by `copyWholeTextureToNewBuffer` and updates it after a copy operation\n   * on the texture by emulating the copy behaviour here directly.\n   */\n  updateLinearTextureDataSubBox(\n    destinationDataLayout: Required<GPUImageDataLayout>,\n    sourceDataLayout: Required<GPUImageDataLayout>,\n    copySize: Required<GPUExtent3DDict>,\n    destinationOrigin: Required<GPUOrigin3DDict>,\n    sourceOrigin: Required<GPUOrigin3DDict>,\n    format: SizedTextureFormat,\n    destination: Uint8Array,\n    source: Uint8Array\n  ): void {\n    for (const texel of this.iterateBlockRows(copySize, sourceOrigin, format)) {\n      const sourceOffset = this.getTexelOffsetInBytes(\n        sourceDataLayout,\n        format,\n        texel,\n        sourceOrigin\n      );\n      const destinationOffset = this.getTexelOffsetInBytes(\n        destinationDataLayout,\n        format,\n        texel,\n        destinationOrigin\n      );\n      const rowLength = bytesInACompleteRow(copySize.width, format);\n      this.copyFromArrayToArray(source, sourceOffset, destination, destinationOffset, rowLength);\n    }\n  }\n\n  /**\n   * Used for checking whether the whole texture was updated correctly by\n   * `uploadLinearTextureDataToTextureSubpart`. Takes fullData returned by\n   * `copyWholeTextureToNewBuffer` before the copy operation which is the original texture data,\n   * then updates it with `updateLinearTextureDataSubpart` and checks the texture against the\n   * updated data after the copy operation.\n   */\n  copyWholeTextureToBufferAndCheckContentsWithUpdatedData(\n    { texture, mipLevel, origin }: TextureCopyViewWithRequiredOrigin,\n    fullTextureCopyLayout: TextureCopyLayout,\n    texturePartialDataLayout: Required<GPUImageDataLayout>,\n    copySize: Required<GPUExtent3DDict>,\n    format: SizedTextureFormat,\n    fullData: GPUBuffer,\n    partialData: Uint8Array\n  ): void {\n    const { mipSize, bytesPerRow, rowsPerImage, byteLength } = fullTextureCopyLayout;\n    const readbackPromise = this.readGPUBufferRangeTyped(fullData, {\n      type: Uint8Array,\n      typedLength: byteLength,\n    });\n\n    const destinationOrigin = { x: 0, y: 0, z: 0 };\n\n    // We add an eventual async expectation which will update the full data and then add\n    // other eventual async expectations to ensure it will be correct.\n    this.eventualAsyncExpectation(async () => {\n      const readback = await readbackPromise;\n      this.updateLinearTextureDataSubBox(\n        { offset: 0, ...fullTextureCopyLayout },\n        texturePartialDataLayout,\n        copySize,\n        destinationOrigin,\n        origin,\n        format,\n        readback.data,\n        partialData\n      );\n      this.copyPartialTextureToBufferAndCheckContents(\n        { texture, mipLevel, origin: destinationOrigin },\n        { width: mipSize[0], height: mipSize[1], depthOrArrayLayers: mipSize[2] },\n        format,\n        readback.data,\n        { bytesPerRow, rowsPerImage, offset: 0 }\n      );\n      readback.cleanup();\n    });\n  }\n\n  /**\n   * Tests copy between linear data and texture by creating a texture, putting some data into it\n   * with WriteTexture/CopyB2T, then getting data for the whole texture/for a part of it back and\n   * comparing it with the expectation.\n   */\n  uploadTextureAndVerifyCopy({\n    textureDataLayout,\n    copySize,\n    dataSize,\n    mipLevel = 0,\n    origin = { x: 0, y: 0, z: 0 },\n    textureSize,\n    format,\n    dimension = '2d',\n    initMethod,\n    checkMethod,\n    changeBeforePass = 'none',\n  }: {\n    textureDataLayout: Required<GPUImageDataLayout>;\n    copySize: Required<GPUExtent3DDict>;\n    dataSize: number;\n    mipLevel?: number;\n    origin?: Required<GPUOrigin3DDict>;\n    textureSize: readonly [number, number, number];\n    format: SizedTextureFormat;\n    dimension?: GPUTextureDimension;\n    initMethod: InitMethod;\n    checkMethod: CheckMethod;\n    changeBeforePass?: ChangeBeforePass;\n  }): void {\n    const texture = this.device.createTexture({\n      size: textureSize as [number, number, number],\n      format,\n      dimension,\n      mipLevelCount: mipLevel + 1,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const data = this.generateData(dataSize);\n\n    switch (checkMethod) {\n      case 'PartialCopyT2B': {\n        this.uploadLinearTextureDataToTextureSubBox(\n          { texture, mipLevel, origin },\n          textureDataLayout,\n          copySize,\n          data,\n          initMethod,\n          changeBeforePass\n        );\n\n        this.copyPartialTextureToBufferAndCheckContents(\n          { texture, mipLevel, origin },\n          copySize,\n          format,\n          data,\n          textureDataLayout,\n          changeBeforePass\n        );\n\n        break;\n      }\n      case 'FullCopyT2B': {\n        const fullTextureCopyLayout = getTextureCopyLayout(format, dimension, textureSize, {\n          mipLevel,\n        });\n\n        const fullData = this.copyWholeTextureToNewBuffer(\n          { texture, mipLevel },\n          fullTextureCopyLayout\n        );\n\n        this.uploadLinearTextureDataToTextureSubBox(\n          { texture, mipLevel, origin },\n          textureDataLayout,\n          copySize,\n          data,\n          initMethod,\n          changeBeforePass\n        );\n\n        this.copyWholeTextureToBufferAndCheckContentsWithUpdatedData(\n          { texture, mipLevel, origin },\n          fullTextureCopyLayout,\n          textureDataLayout,\n          copySize,\n          format,\n          fullData,\n          data\n        );\n\n        break;\n      }\n      default:\n        unreachable();\n    }\n  }\n}\n\n/**\n * This is a helper function used for filtering test parameters\n *\n * TODO: Modify this after introducing tests with rendering.\n */\nfunction formatCanBeTested({ format }: { format: SizedTextureFormat }): boolean {\n  return kTextureFormatInfo[format].copyDst && kTextureFormatInfo[format].copySrc;\n}\n\nexport const g = makeTestGroup(ImageCopyTest);\n\ng.test('rowsPerImage_and_bytesPerRow')\n  .desc(\n    `Test that copying data with various bytesPerRow and rowsPerImage values and minimum required\nbytes in copy works for every format.\n\n  Covers a special code path for Metal:\n    bufferSize - offset < bytesPerImage * copyExtent.depthOrArrayLayers\n  Covers a special code path for D3D12:\n    when bytesPerRow is not a multiple of 512 and copyExtent.depthOrArrayLayers > 1: copyExtent.depthOrArrayLayers % 2 == { 0, 1 }\n    bytesPerRow == bytesInACompleteCopyImage\n  `\n  )\n  .params(u =>\n    u\n      .combineWithParams(kMethodsToTest)\n      .combine('format', kWorkingTextureFormats)\n      .filter(formatCanBeTested)\n      .beginSubcases()\n      .combineWithParams([\n        { bytesPerRowPadding: 0, rowsPerImagePadding: 0 }, // no padding\n        { bytesPerRowPadding: 0, rowsPerImagePadding: 6 }, // rowsPerImage padding\n        { bytesPerRowPadding: 6, rowsPerImagePadding: 0 }, // bytesPerRow padding\n        { bytesPerRowPadding: 15, rowsPerImagePadding: 17 }, // both paddings\n      ])\n      .combineWithParams([\n        // In the two cases below, for (WriteTexture, PartialCopyB2T) and (CopyB2T, FullCopyT2B)\n        // sets of methods we will have bytesPerRow = 256 and copyDepth % 2 == { 0, 1 }\n        // respectively. This covers a special code path for D3D12.\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 5 }, // standard copy\n        { copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 2 }, // standard copy\n\n        { copyWidthInBlocks: 256, copyHeightInBlocks: 3, copyDepth: 2 }, // copyWidth is 256-aligned\n        { copyWidthInBlocks: 0, copyHeightInBlocks: 4, copyDepth: 5 }, // empty copy because of width\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 0, copyDepth: 5 }, // empty copy because of height\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 0 }, // empty copy because of depthOrArrayLayers\n        { copyWidthInBlocks: 1, copyHeightInBlocks: 3, copyDepth: 5 }, // copyWidth = 1\n\n        // The two cases below cover another special code path for D3D12.\n        //   - For (WriteTexture, FullCopyT2B) with r8unorm:\n        //         bytesPerRow = 15 = 3 * 5 = bytesInACompleteCopyImage.\n        { copyWidthInBlocks: 32, copyHeightInBlocks: 1, copyDepth: 8 }, // copyHeight = 1\n        //   - For (CopyB2T, FullCopyT2B) and (WriteTexture, PartialCopyT2B) with r8unorm:\n        //         bytesPerRow = 256 = 8 * 32 = bytesInACompleteCopyImage.\n        { copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 1 }, // copyDepth = 1\n\n        { copyWidthInBlocks: 7, copyHeightInBlocks: 1, copyDepth: 1 }, // copyHeight = 1 and copyDepth = 1\n      ])\n  )\n  .fn(async t => {\n    const {\n      bytesPerRowPadding,\n      rowsPerImagePadding,\n      copyWidthInBlocks,\n      copyHeightInBlocks,\n      copyDepth,\n      format,\n      initMethod,\n      checkMethod,\n    } = t.params;\n    const info = kTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.feature);\n\n    // For CopyB2T and CopyT2B we need to have bytesPerRow 256-aligned,\n    // to make this happen we align the bytesInACompleteRow value and multiply\n    // bytesPerRowPadding by 256.\n    const bytesPerRowAlignment =\n      initMethod === 'WriteTexture' && checkMethod === 'FullCopyT2B' ? 1 : 256;\n\n    const copyWidth = copyWidthInBlocks * info.blockWidth;\n    const copyHeight = copyHeightInBlocks * info.blockHeight;\n    const rowsPerImage = copyHeightInBlocks + rowsPerImagePadding;\n    const bytesPerRow =\n      align(bytesInACompleteRow(copyWidth, format), bytesPerRowAlignment) +\n      bytesPerRowPadding * bytesPerRowAlignment;\n    const copySize = { width: copyWidth, height: copyHeight, depthOrArrayLayers: copyDepth };\n\n    const dataSize = dataBytesForCopyOrFail({\n      layout: { offset: 0, bytesPerRow, rowsPerImage },\n      format,\n      copySize,\n      method: initMethod,\n    });\n\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: { offset: 0, bytesPerRow, rowsPerImage },\n      copySize,\n      dataSize,\n      textureSize: [\n        Math.max(copyWidth, info.blockWidth),\n        Math.max(copyHeight, info.blockHeight),\n        Math.max(copyDepth, 1),\n      ] /* making sure the texture is non-empty */,\n      format,\n      initMethod,\n      checkMethod,\n    });\n  });\n\ng.test('offsets_and_sizes')\n  .desc(\n    `Test that copying data with various offset values and additional data paddings\nworks for every format with 2d and 2d-array textures.\n\n  Covers two special code paths for D3D12:\n    offset + bytesInCopyExtentPerRow { ==, > } bytesPerRow\n    offset > bytesInACompleteCopyImage\n`\n  )\n  .params(\n    u =>\n      u\n        .combineWithParams(kMethodsToTest)\n        .combine('format', kWorkingTextureFormats)\n        .filter(formatCanBeTested)\n        .beginSubcases()\n        .combineWithParams([\n          { offsetInBlocks: 0, dataPaddingInBytes: 0 }, // no offset and no padding\n          { offsetInBlocks: 1, dataPaddingInBytes: 0 }, // offset = 1\n          { offsetInBlocks: 2, dataPaddingInBytes: 0 }, // offset = 2\n          { offsetInBlocks: 15, dataPaddingInBytes: 0 }, // offset = 15\n          { offsetInBlocks: 16, dataPaddingInBytes: 0 }, // offset = 16\n          { offsetInBlocks: 242, dataPaddingInBytes: 0 }, // for rgba8unorm format: offset + bytesInCopyExtentPerRow = 242 + 12 = 256 = bytesPerRow\n          { offsetInBlocks: 243, dataPaddingInBytes: 0 }, // for rgba8unorm format: offset + bytesInCopyExtentPerRow = 243 + 12 > 256 = bytesPerRow\n          { offsetInBlocks: 768, dataPaddingInBytes: 0 }, // for copyDepth = 1, blockWidth = 1 and bytesPerBlock = 1: offset = 768 = 3 * 256 = bytesInACompleteCopyImage\n          { offsetInBlocks: 769, dataPaddingInBytes: 0 }, // for copyDepth = 1, blockWidth = 1 and bytesPerBlock = 1: offset = 769 > 768 = bytesInACompleteCopyImage\n          { offsetInBlocks: 0, dataPaddingInBytes: 1 }, // dataPaddingInBytes > 0\n          { offsetInBlocks: 1, dataPaddingInBytes: 8 }, // offset > 0 and dataPaddingInBytes > 0\n        ])\n        .combine('copyDepth', [1, 2]) // 2d and 2d-array textures\n  )\n  .fn(async t => {\n    const {\n      offsetInBlocks,\n      dataPaddingInBytes,\n      copyDepth,\n      format,\n      initMethod,\n      checkMethod,\n    } = t.params;\n    const info = kTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.feature);\n\n    const offset = offsetInBlocks * info.bytesPerBlock;\n    const copySize = {\n      width: 3 * info.blockWidth,\n      height: 3 * info.blockHeight,\n      depthOrArrayLayers: copyDepth,\n    };\n    const rowsPerImage = 3;\n    const bytesPerRow = 256;\n\n    const minDataSize = dataBytesForCopyOrFail({\n      layout: { offset, bytesPerRow, rowsPerImage },\n      format,\n      copySize,\n      method: initMethod,\n    });\n    const dataSize = minDataSize + dataPaddingInBytes;\n\n    // We're copying a (3 x 3 x copyDepth) (in texel blocks) part of a (4 x 4 x copyDepth)\n    // (in texel blocks) texture with no origin.\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: { offset, bytesPerRow, rowsPerImage },\n      copySize,\n      dataSize,\n      textureSize: [4 * info.blockWidth, 4 * info.blockHeight, copyDepth],\n      format,\n      initMethod,\n      checkMethod,\n    });\n  });\n\ng.test('origins_and_extents')\n  .desc(\n    `Test that copying slices of a texture works with various origin and copyExtent values\nfor all formats. We pass origin and copyExtent as [number, number, number].`\n  )\n  .params(u =>\n    u\n      .combineWithParams(kMethodsToTest)\n      .combine('format', kWorkingTextureFormats)\n      .filter(formatCanBeTested)\n      .beginSubcases()\n      .combine('originValueInBlocks', [0, 7, 8])\n      .combine('copySizeValueInBlocks', [0, 7, 8])\n      .combine('textureSizePaddingValueInBlocks', [0, 7, 8])\n      .unless(\n        p =>\n          // we can't create an empty texture\n          p.copySizeValueInBlocks + p.originValueInBlocks + p.textureSizePaddingValueInBlocks === 0\n      )\n      .combine('coordinateToTest', [0, 1, 2] as const)\n  )\n  .fn(async t => {\n    const {\n      originValueInBlocks,\n      copySizeValueInBlocks,\n      textureSizePaddingValueInBlocks,\n      format,\n      initMethod,\n      checkMethod,\n    } = t.params;\n    const info = kTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.feature);\n\n    const originBlocks = [1, 1, 1];\n    const copySizeBlocks = [2, 2, 2];\n    const texSizeBlocks = [3, 3, 3];\n\n    {\n      const ctt = t.params.coordinateToTest;\n      originBlocks[ctt] = originValueInBlocks;\n      copySizeBlocks[ctt] = copySizeValueInBlocks;\n      texSizeBlocks[ctt] =\n        originBlocks[ctt] + copySizeBlocks[ctt] + textureSizePaddingValueInBlocks;\n    }\n\n    const origin: Required<GPUOrigin3DDict> = {\n      x: originBlocks[0] * info.blockWidth,\n      y: originBlocks[1] * info.blockHeight,\n      z: originBlocks[2],\n    };\n    const copySize = {\n      width: copySizeBlocks[0] * info.blockWidth,\n      height: copySizeBlocks[1] * info.blockHeight,\n      depthOrArrayLayers: copySizeBlocks[2],\n    };\n    const textureSize = [\n      texSizeBlocks[0] * info.blockWidth,\n      texSizeBlocks[1] * info.blockHeight,\n      texSizeBlocks[2],\n    ] as const;\n\n    const rowsPerImage = copySizeBlocks[1];\n    const bytesPerRow = align(copySizeBlocks[0] * info.bytesPerBlock, 256);\n\n    const dataSize = dataBytesForCopyOrFail({\n      layout: { offset: 0, bytesPerRow, rowsPerImage },\n      format,\n      copySize,\n      method: initMethod,\n    });\n\n    // For testing width: we copy a (_ x 2 x 2) (in texel blocks) part of a (_ x 3 x 3)\n    // (in texel blocks) texture with origin (_, 1, 1) (in texel blocks).\n    // Similarly for other coordinates.\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: { offset: 0, bytesPerRow, rowsPerImage },\n      copySize,\n      dataSize,\n      origin,\n      textureSize,\n      format,\n      initMethod,\n      checkMethod,\n      changeBeforePass: 'arrays',\n    });\n  });\n\n/**\n * Generates textureSizes which correspond to the same physicalSizeAtMipLevel including virtual\n * sizes at mip level different from the physical ones.\n */\nfunction* generateTestTextureSizes({\n  format,\n  mipLevel,\n  _mipSizeInBlocks,\n}: {\n  format: SizedTextureFormat;\n  mipLevel: number;\n  _mipSizeInBlocks: Required<GPUExtent3DDict>;\n}): Generator<[number, number, number]> {\n  const info = kTextureFormatInfo[format];\n\n  const widthAtThisLevel = _mipSizeInBlocks.width * info.blockWidth;\n  const heightAtThisLevel = _mipSizeInBlocks.height * info.blockHeight;\n  const textureSize: [number, number, number] = [\n    widthAtThisLevel << mipLevel,\n    heightAtThisLevel << mipLevel,\n    _mipSizeInBlocks.depthOrArrayLayers,\n  ];\n  yield textureSize;\n\n  // We choose width and height of the texture so that the values are divisible by blockWidth and\n  // blockHeight respectively and so that the virtual size at mip level corresponds to the same\n  // physical size.\n  // Virtual size at mip level with modified width has width = (physical size width) - (blockWidth / 2).\n  // Virtual size at mip level with modified height has height = (physical size height) - (blockHeight / 2).\n  const widthAtPrevLevel = widthAtThisLevel << 1;\n  const heightAtPrevLevel = heightAtThisLevel << 1;\n  assert(mipLevel > 0);\n  assert(widthAtPrevLevel >= info.blockWidth && heightAtPrevLevel >= info.blockHeight);\n  const modifiedWidth = (widthAtPrevLevel - info.blockWidth) << (mipLevel - 1);\n  const modifiedHeight = (heightAtPrevLevel - info.blockHeight) << (mipLevel - 1);\n\n  const modifyWidth = info.blockWidth > 1 && modifiedWidth !== textureSize[0];\n  const modifyHeight = info.blockHeight > 1 && modifiedHeight !== textureSize[1];\n\n  if (modifyWidth) {\n    yield [modifiedWidth, textureSize[1], textureSize[2]];\n  }\n  if (modifyHeight) {\n    yield [textureSize[0], modifiedHeight, textureSize[2]];\n  }\n  if (modifyWidth && modifyHeight) {\n    yield [modifiedWidth, modifiedHeight, textureSize[2]];\n  }\n}\n\ng.test('mip_levels')\n  .desc(\n    `Test that copying various mip levels works. Covers two special code paths:\n  - The physical size of the subresource is not equal to the logical size.\n  - bufferSize - offset < bytesPerImage * copyExtent.depthOrArrayLayers, and copyExtent needs to be clamped for all block formats.\n  `\n  )\n  .params(u =>\n    u\n      .combineWithParams(kMethodsToTest)\n      .combine('format', kWorkingTextureFormats)\n      .filter(formatCanBeTested)\n      .beginSubcases()\n      .combineWithParams([\n        // origin + copySize = texturePhysicalSizeAtMipLevel for all coordinates, 2d texture */\n        {\n          copySizeInBlocks: { width: 5, height: 4, depthOrArrayLayers: 1 },\n          originInBlocks: { x: 3, y: 2, z: 0 },\n          _mipSizeInBlocks: { width: 8, height: 6, depthOrArrayLayers: 1 },\n          mipLevel: 1,\n        },\n        // origin + copySize = texturePhysicalSizeAtMipLevel for all coordinates, 2d-array texture\n        {\n          copySizeInBlocks: { width: 5, height: 4, depthOrArrayLayers: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _mipSizeInBlocks: { width: 8, height: 6, depthOrArrayLayers: 3 },\n          mipLevel: 2,\n        },\n        // origin.x + copySize.width = texturePhysicalSizeAtMipLevel.width\n        {\n          copySizeInBlocks: { width: 5, height: 4, depthOrArrayLayers: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _mipSizeInBlocks: { width: 8, height: 7, depthOrArrayLayers: 4 },\n          mipLevel: 3,\n        },\n        // origin.y + copySize.height = texturePhysicalSizeAtMipLevel.height\n        {\n          copySizeInBlocks: { width: 5, height: 4, depthOrArrayLayers: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _mipSizeInBlocks: { width: 9, height: 6, depthOrArrayLayers: 4 },\n          mipLevel: 4,\n        },\n        // origin.z + copySize.depthOrArrayLayers = texturePhysicalSizeAtMipLevel.depthOrArrayLayers\n        {\n          copySizeInBlocks: { width: 5, height: 4, depthOrArrayLayers: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _mipSizeInBlocks: { width: 9, height: 7, depthOrArrayLayers: 3 },\n          mipLevel: 5,\n        },\n        // origin + copySize < texturePhysicalSizeAtMipLevel for all coordinates\n        {\n          copySizeInBlocks: { width: 5, height: 4, depthOrArrayLayers: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _mipSizeInBlocks: { width: 9, height: 7, depthOrArrayLayers: 4 },\n          mipLevel: 6,\n        },\n      ])\n      .expand('textureSize', generateTestTextureSizes)\n  )\n  .fn(async t => {\n    const {\n      copySizeInBlocks,\n      originInBlocks,\n      textureSize,\n      mipLevel,\n      format,\n      initMethod,\n      checkMethod,\n    } = t.params;\n    const info = kTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.feature);\n\n    const origin = {\n      x: originInBlocks.x * info.blockWidth,\n      y: originInBlocks.y * info.blockHeight,\n      z: originInBlocks.z,\n    };\n    const copySize = {\n      width: copySizeInBlocks.width * info.blockWidth,\n      height: copySizeInBlocks.height * info.blockHeight,\n      depthOrArrayLayers: copySizeInBlocks.depthOrArrayLayers,\n    };\n\n    const rowsPerImage = copySizeInBlocks.height + 1;\n    const bytesPerRow = align(copySize.width, 256);\n\n    const dataSize = dataBytesForCopyOrFail({\n      layout: { offset: 0, bytesPerRow, rowsPerImage },\n      format,\n      copySize,\n      method: initMethod,\n    });\n\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: { offset: 0, bytesPerRow, rowsPerImage },\n      copySize,\n      dataSize,\n      origin,\n      mipLevel,\n      textureSize,\n      format,\n      initMethod,\n      checkMethod,\n    });\n  });\n\nconst UND = undefined;\ng.test('undefined_params')\n  .desc(\n    `Tests undefined values of bytesPerRow, rowsPerImage, and origin.x/y/z.\n  Ensures bytesPerRow/rowsPerImage=undefined are valid and behave as expected.\n  Ensures origin.x/y/z undefined default to 0.`\n  )\n  .params(u =>\n    u\n      .combineWithParams(kMethodsToTest)\n      .beginSubcases()\n      .combineWithParams([\n        // copying one row: bytesPerRow and rowsPerImage can be undefined\n        { copySize: [3, 1, 1], origin: [UND, UND, UND], bytesPerRow: UND, rowsPerImage: UND },\n        // copying one slice: rowsPerImage can be undefined\n        { copySize: [3, 3, 1], origin: [UND, UND, UND], bytesPerRow: 256, rowsPerImage: UND },\n        // copying two slices\n        { copySize: [3, 3, 2], origin: [UND, UND, UND], bytesPerRow: 256, rowsPerImage: 3 },\n        // origin.x = undefined\n        { copySize: [1, 1, 1], origin: [UND, 1, 1], bytesPerRow: UND, rowsPerImage: UND },\n        // origin.y = undefined\n        { copySize: [1, 1, 1], origin: [1, UND, 1], bytesPerRow: UND, rowsPerImage: UND },\n        // origin.z = undefined\n        { copySize: [1, 1, 1], origin: [1, 1, UND], bytesPerRow: UND, rowsPerImage: UND },\n      ])\n  )\n  .fn(async t => {\n    const { bytesPerRow, rowsPerImage, copySize, origin, initMethod, checkMethod } = t.params;\n\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: {\n        offset: 0,\n        // Zero will get turned back into undefined later.\n        bytesPerRow: bytesPerRow ?? 0,\n        // Zero will get turned back into undefined later.\n        rowsPerImage: rowsPerImage ?? 0,\n      },\n      copySize: { width: copySize[0], height: copySize[1], depthOrArrayLayers: copySize[2] },\n      dataSize: 2000,\n      textureSize: [100, 3, 2],\n      // Zeros will get turned back into undefined later.\n      origin: { x: origin[0] ?? 0, y: origin[1] ?? 0, z: origin[2] ?? 0 },\n      format: 'rgba8unorm',\n      initMethod,\n      checkMethod,\n      changeBeforePass: 'undefined',\n    });\n  });\n\ng.test('copy_from_stencil_aspect')\n  .desc(\n    `\n  Validate the correctness of copyTextureToBuffer() with stencil aspect.\n\n  For all the texture formats with stencil aspect:\n  - Initialize the source texture with the stencil comparison function \"always\" and the stencil\n    operation \"replace\" in a render pass encoder\n  - Copy the stencil aspect of the source texture into the destination buffer\n  - Check if the data in the destination buffer is expected\n  - Test the copies from / into zero / non-zero array layer / mipmap levels\n  - Test copying multiple array layers\n  `\n  )\n  .unimplemented();\n\ng.test('copy_into_stencil_aspect')\n  .desc(\n    `\n  Validate the correctness of copyBufferToTexture() with stencil aspect.\n\n  For all the texture formats with stencil aspect:\n  - Initialize the source buffer with the expected data\n  - Copy the data in the source buffer into the stencil aspect of the destination texture\n  - Check if the data in the stencil aspect of the destination texture is expected with the stencil\n    comparison function \"equal\" and the stencil operation \"keep\" in a render pass encoder\n  - Test the copies from / into zero / non-zero array layer / mipmap levels\n  - Test copying multiple array layers\n  `\n  )\n  .unimplemented();\n"],"file":"image_copy.spec.js"}