{"version":3,"sources":["../../../../../../src/webgpu/api/operation/command_buffer/programmable/programmable_state_test.ts"],"names":["unreachable","GPUTest","ProgrammableStateTest","encoder","bindGroupLayout","commonBindGroupLayout","device","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","FRAGMENT","buffer","type","createBindGroup","layout","resource","createBindingStatePipeline","encoderType","groups","algorithm","wgsl","a","b","out","createComputePipeline","createPipelineLayout","bindGroupLayouts","compute","module","createShaderModule","code","entryPoint","wgslShaders","vertex","fragment","createRenderPipeline","targets","format","primitive","topology","setPipeline","pass","pipeline","GPUComputePassEncoder","GPURenderPassEncoder","GPURenderBundleEncoder","dispatchOrDraw","dispatch","draw"],"mappings":"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","sourcesContent":["import { unreachable } from '../../../../../common/util/util.js';\nimport { GPUTest } from '../../../../gpu_test.js';\nimport { EncoderType } from '../../../../util/command_buffer_maker.js';\n\ninterface BindGroupIndices {\n  a: number;\n  b: number;\n  out: number;\n}\n\nexport class ProgrammableStateTest extends GPUTest {\n  private commonBindGroupLayout: GPUBindGroupLayout | undefined;\n  private encoder: GPUCommandEncoder | null = null;\n\n  get bindGroupLayout(): GPUBindGroupLayout {\n    if (!this.commonBindGroupLayout) {\n      this.commonBindGroupLayout = this.device.createBindGroupLayout({\n        entries: [\n          {\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,\n            buffer: { type: 'storage' },\n          },\n        ],\n      });\n    }\n    return this.commonBindGroupLayout;\n  }\n\n  createBindGroup(buffer: GPUBuffer): GPUBindGroup {\n    return this.device.createBindGroup({\n      layout: this.bindGroupLayout,\n      entries: [{ binding: 0, resource: { buffer } }],\n    });\n  }\n\n  // Create a compute pipeline that performs an operation on data from two bind groups,\n  // then writes the result to a third bind group.\n  createBindingStatePipeline<T extends EncoderType>(\n    encoderType: T,\n    groups: BindGroupIndices,\n    algorithm: string = 'a.value - b.value'\n  ): GPUComputePipeline | GPURenderPipeline {\n    switch (encoderType) {\n      case 'compute pass': {\n        const wgsl = `struct Data {\n            value : i32;\n          };\n\n          @group(${groups.a}) @binding(0) var<storage> a : Data;\n          @group(${groups.b}) @binding(0) var<storage> b : Data;\n          @group(${groups.out}) @binding(0) var<storage, read_write> out : Data;\n\n          @stage(compute) @workgroup_size(1) fn main() {\n            out.value = ${algorithm};\n            return;\n          }\n        `;\n\n        return this.device.createComputePipeline({\n          layout: this.device.createPipelineLayout({\n            bindGroupLayouts: [this.bindGroupLayout, this.bindGroupLayout, this.bindGroupLayout],\n          }),\n          compute: {\n            module: this.device.createShaderModule({\n              code: wgsl,\n            }),\n            entryPoint: 'main',\n          },\n        });\n      }\n      case 'render pass':\n      case 'render bundle': {\n        const wgslShaders = {\n          vertex: `\n            @stage(vertex) fn vert_main() -> @builtin(position) vec4<f32> {\n              return vec4<f32>(0.5, 0.5, 0.0, 1.0);\n            }\n          `,\n\n          fragment: `\n            struct Data {\n              value : i32;\n            };\n\n            @group(${groups.a}) @binding(0) var<storage> a : Data;\n            @group(${groups.b}) @binding(0) var<storage> b : Data;\n            @group(${groups.out}) @binding(0) var<storage, read_write> out : Data;\n\n            @stage(fragment) fn frag_main() -> @location(0) vec4<f32> {\n              out.value = ${algorithm};\n              return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n            }\n          `,\n        };\n\n        return this.device.createRenderPipeline({\n          layout: this.device.createPipelineLayout({\n            bindGroupLayouts: [this.bindGroupLayout, this.bindGroupLayout, this.bindGroupLayout],\n          }),\n          vertex: {\n            module: this.device.createShaderModule({\n              code: wgslShaders.vertex,\n            }),\n            entryPoint: 'vert_main',\n          },\n          fragment: {\n            module: this.device.createShaderModule({\n              code: wgslShaders.fragment,\n            }),\n            entryPoint: 'frag_main',\n            targets: [{ format: 'rgba8unorm' }],\n          },\n          primitive: { topology: 'point-list' },\n        });\n      }\n      default:\n        unreachable();\n    }\n  }\n\n  setPipeline(pass: GPUProgrammablePassEncoder, pipeline: GPUComputePipeline | GPURenderPipeline) {\n    if (pass instanceof GPUComputePassEncoder) {\n      pass.setPipeline(pipeline as GPUComputePipeline);\n    } else if (pass instanceof GPURenderPassEncoder || pass instanceof GPURenderBundleEncoder) {\n      pass.setPipeline(pipeline as GPURenderPipeline);\n    }\n  }\n\n  dispatchOrDraw(pass: GPUProgrammablePassEncoder) {\n    if (pass instanceof GPUComputePassEncoder) {\n      pass.dispatch(1);\n    } else if (pass instanceof GPURenderPassEncoder) {\n      pass.draw(1);\n    } else if (pass instanceof GPURenderBundleEncoder) {\n      pass.draw(1);\n    }\n  }\n}\n"],"file":"programmable_state_test.js"}