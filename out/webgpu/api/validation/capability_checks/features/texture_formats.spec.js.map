{"version":3,"sources":["../../../../../../src/webgpu/api/validation/capability_checks/features/texture_formats.spec.ts"],"names":["description","makeTestGroup","kAllTextureFormats","kTextureFormatInfo","ValidationTest","g","kOptionalTextureFormats","filter","t","feature","undefined","test","desc","params","u","combine","beforeAllSubcases","format","enable_required_feature","formatInfo","selectDeviceOrSkipTestCase","fn","expectValidationError","device","createTexture","size","blockWidth","blockHeight","usage","GPUTextureUsage","TEXTURE_BINDING","storage","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","storageTexture","renderable","color","createRenderPipeline","vertex","module","createShaderModule","code","entryPoint","fragment","targets","depth","stencil","depthStencil","createRenderBundleEncoder","colorFormats","depthStencilFormat"],"mappings":"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","sourcesContent":["export const description = `\nTests for capability checking for features enabling optional texture formats.\n\nTODO(#902): test GPUTextureViewDescriptor.format\nTODO(#902): test GPUCanvasConfiguration.format (it doesn't allow any optional formats today but the\n  error might still be different - exception instead of validation.\n\nTODO(#920): test GPUTextureDescriptor.viewFormats (if/when it takes formats)\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { kAllTextureFormats, kTextureFormatInfo } from '../../../../capability_info.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nexport const g = makeTestGroup(ValidationTest);\n\nconst kOptionalTextureFormats = kAllTextureFormats.filter(\n  t => kTextureFormatInfo[t].feature !== undefined\n);\n\ng.test('texture_descriptor')\n  .desc(\n    `\n  Test creating a texture with an optional texture format will fail if the required optional feature\n  is not enabled.\n\n  TODO(#919): Actually it should throw an exception, not fail with a validation error.\n  `\n  )\n  .params(u =>\n    u.combine('format', kOptionalTextureFormats).combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      await t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    t.expectValidationError(() => {\n      t.device.createTexture({\n        format,\n        size: [formatInfo.blockWidth, formatInfo.blockHeight, 1] as const,\n        usage: GPUTextureUsage.TEXTURE_BINDING,\n      });\n    }, !enable_required_feature);\n  });\n\ng.test('storage_texture_binding_layout')\n  .desc(\n    `\n  Test creating a GPUStorageTextureBindingLayout with an optional texture format will fail if the\n  required optional feature are not enabled.\n\n  Note: This test has no cases if there are no optional texture formats supporting storage.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(t => kTextureFormatInfo[t.format].storage)\n      .combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      await t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    t.expectValidationError(() => {\n      t.device.createBindGroupLayout({\n        entries: [\n          {\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            storageTexture: {\n              format,\n            },\n          },\n        ],\n      });\n    }, !enable_required_feature);\n  });\n\ng.test('color_target_state')\n  .desc(\n    `\n  Test creating a render pipeline with an optional texture format set in GPUColorTargetState will\n  fail if the required optional feature is not enabled.\n\n  Note: This test has no cases if there are no optional texture formats supporting color rendering.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(t => kTextureFormatInfo[t.format].renderable && kTextureFormatInfo[t.format].color)\n      .combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      await t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    t.expectValidationError(() => {\n      t.device.createRenderPipeline({\n        vertex: {\n          module: t.device.createShaderModule({\n            code: `\n              @stage(vertex)\n              fn main()-> @builtin(position) vec4<f32> {\n                return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n              }`,\n          }),\n          entryPoint: 'main',\n        },\n        fragment: {\n          module: t.device.createShaderModule({\n            code: `\n              @stage(fragment)\n              fn main() -> @location(0) vec4<f32> {\n                return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n              }`,\n          }),\n          entryPoint: 'main',\n          targets: [{ format }],\n        },\n      });\n    }, !enable_required_feature);\n  });\n\ng.test('depth_stencil_state')\n  .desc(\n    `\n  Test creating a render pipeline with an optional texture format set in GPUColorTargetState will\n  fail if the required optional feature is not enabled.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(\n        t =>\n          kTextureFormatInfo[t.format].renderable &&\n          (kTextureFormatInfo[t.format].depth || kTextureFormatInfo[t.format].stencil)\n      )\n      .combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      await t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    t.expectValidationError(() => {\n      t.device.createRenderPipeline({\n        vertex: {\n          module: t.device.createShaderModule({\n            code: `\n              @stage(vertex)\n              fn main()-> @builtin(position) vec4<f32> {\n                return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n              }`,\n          }),\n          entryPoint: 'main',\n        },\n        depthStencil: {\n          format,\n        },\n        fragment: {\n          module: t.device.createShaderModule({\n            code: `\n              @stage(fragment)\n              fn main() -> @location(0) vec4<f32> {\n                return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n              }`,\n          }),\n          entryPoint: 'main',\n          targets: [{ format: 'rgba8unorm' }],\n        },\n      });\n    }, !enable_required_feature);\n  });\n\ng.test('render_bundle_encoder_descriptor_color_format')\n  .desc(\n    `\n  Test creating a render bundle encoder with an optional texture format set as one of the color\n  format will fail if the required optional feature is not enabled.\n\n  Note: This test has no cases if there are no optional texture formats supporting color rendering.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(t => kTextureFormatInfo[t.format].renderable && kTextureFormatInfo[t.format].color)\n      .combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      await t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    t.expectValidationError(() => {\n      t.device.createRenderBundleEncoder({\n        colorFormats: [format],\n      });\n    }, !enable_required_feature);\n  });\n\ng.test('render_bundle_encoder_descriptor_depth_stencil_format')\n  .desc(\n    `\n  Test creating a render bundle encoder with an optional texture format set as the depth stencil\n  format will fail if the required optional feature is not enabled.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(\n        t =>\n          kTextureFormatInfo[t.format].renderable &&\n          (kTextureFormatInfo[t.format].depth || kTextureFormatInfo[t.format].stencil)\n      )\n      .combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      await t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    t.expectValidationError(() => {\n      t.device.createRenderBundleEncoder({\n        colorFormats: ['rgba8unorm'],\n        depthStencilFormat: format,\n      });\n    }, !enable_required_feature);\n  });\n"],"file":"texture_formats.spec.js"}