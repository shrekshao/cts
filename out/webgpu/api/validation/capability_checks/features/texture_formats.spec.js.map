{"version":3,"sources":["../../../../../../src/webgpu/api/validation/capability_checks/features/texture_formats.spec.ts"],"names":["description","makeTestGroup","assert","kAllTextureFormats","kTextureFormatInfo","kAllCanvasTypes","createCanvas","ValidationTest","g","kOptionalTextureFormats","filter","t","feature","undefined","test","desc","params","u","combine","beforeAllSubcases","format","enable_required_feature","formatInfo","selectDeviceOrSkipTestCase","fn","shouldThrow","device","createTexture","size","blockWidth","blockHeight","usage","GPUTextureUsage","TEXTURE_BINDING","viewFormats","textureFormat","testTexture","testViewDesc","dimension","aspect","arrayLayerCount","baseMipLevel","mipLevelCount","baseArrayLayer","createView","canvasType","canvas","ctx","getContext","GPUCanvasContext","canvasConf","COPY_SRC","COPY_DST","expectValidationError","configure","map","selectDeviceForTextureFormatOrSkipTestCase","storage","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","storageTexture","renderable","color","createRenderPipeline","layout","vertex","module","createShaderModule","code","entryPoint","fragment","targets","depth","stencil","depthStencil","createRenderBundleEncoder","colorFormats","depthStencilFormat"],"mappings":"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","sourcesContent":["export const description = `\nTests for capability checking for features enabling optional texture formats.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { assert } from '../../../../../common/util/util.js';\nimport { kAllTextureFormats, kTextureFormatInfo } from '../../../../capability_info.js';\nimport { kAllCanvasTypes, createCanvas } from '../../../../util/create_elements.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nexport const g = makeTestGroup(ValidationTest);\n\nconst kOptionalTextureFormats = kAllTextureFormats.filter(\n  t => kTextureFormatInfo[t].feature !== undefined\n);\n\ng.test('texture_descriptor')\n  .desc(\n    `\n  Test creating a texture with an optional texture format will fail if the required optional feature\n  is not enabled.\n  `\n  )\n  .params(u =>\n    u.combine('format', kOptionalTextureFormats).combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    t.shouldThrow(enable_required_feature ? false : 'TypeError', () => {\n      t.device.createTexture({\n        format,\n        size: [formatInfo.blockWidth, formatInfo.blockHeight, 1] as const,\n        usage: GPUTextureUsage.TEXTURE_BINDING,\n      });\n    });\n  });\n\ng.test('texture_descriptor_view_formats')\n  .desc(\n    `\n  Test creating a texture with view formats that have an optional texture format will fail if the\n  required optional feature is not enabled.\n  `\n  )\n  .params(u =>\n    u.combine('format', kOptionalTextureFormats).combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    t.shouldThrow(enable_required_feature ? false : 'TypeError', () => {\n      t.device.createTexture({\n        format,\n        size: [formatInfo.blockWidth, formatInfo.blockHeight, 1] as const,\n        usage: GPUTextureUsage.TEXTURE_BINDING,\n        viewFormats: [format],\n      });\n    });\n  });\n\ng.test('texture_view_descriptor')\n  .desc(\n    `\n  Test creating a texture view with all texture formats will fail if the required optional feature\n  is not enabled.\n  `\n  )\n  .params(u =>\n    u.combine('format', kOptionalTextureFormats).combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    // If the required feature isn't enabled then the texture will fail to create and we won't be\n    // able to test createView, so pick and alternate guaranteed format instead. This will almost\n    // certainly not be view-compatible with the format being tested, but that doesn't matter since\n    // createView should throw an exception due to the format feature not being enabled before it\n    // has a chance to validate that the view and texture formats aren't compatible.\n    const textureFormat = enable_required_feature ? format : 'rgba8unorm';\n\n    const formatInfo = kTextureFormatInfo[format];\n    const testTexture = t.device.createTexture({\n      format: textureFormat,\n      size: [formatInfo.blockWidth, formatInfo.blockHeight, 1] as const,\n      usage: GPUTextureUsage.TEXTURE_BINDING,\n    });\n    const testViewDesc: GPUTextureViewDescriptor = {\n      format,\n      dimension: '2d',\n      aspect: 'all',\n      arrayLayerCount: 1,\n      baseMipLevel: 0,\n      mipLevelCount: 1,\n      baseArrayLayer: 0,\n    };\n    t.shouldThrow(enable_required_feature ? false : 'TypeError', () => {\n      testTexture.createView(testViewDesc);\n    });\n  });\n\ng.test('canvas_configuration')\n  .desc(\n    `\n  Test configuring a canvas with optional texture formats will throw an exception if the required\n  optional feature is not enabled. Otherwise, a validation error should be generated instead of\n  throwing an exception.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .combine('canvasType', kAllCanvasTypes)\n      .combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, canvasType, enable_required_feature } = t.params;\n\n    const canvas = createCanvas(t, canvasType, 2, 2);\n    const ctx = canvas.getContext('webgpu');\n    assert(ctx instanceof GPUCanvasContext, 'Failed to get WebGPU context from canvas');\n\n    const canvasConf = {\n      device: t.device,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    };\n\n    if (enable_required_feature) {\n      t.expectValidationError(() => {\n        ctx.configure(canvasConf);\n      });\n    } else {\n      t.shouldThrow('TypeError', () => {\n        ctx.configure(canvasConf);\n      });\n    }\n  });\n\ng.test('canvas_configuration_view_formats')\n  .desc(\n    `\n  Test that configuring a canvas with view formats throws an exception if the required optional\n  feature is not enabled. Otherwise, a validation error should be generated instead of throwing an\n  exception.\n  `\n  )\n  .params(u =>\n    u\n      .combine('viewFormats', [\n        ...kOptionalTextureFormats.map(format => [format]),\n        ['bgra8unorm', 'bc1-rgba-unorm'],\n        ['bc1-rgba-unorm', 'bgra8unorm'],\n      ])\n      .combine('canvasType', kAllCanvasTypes)\n      .combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    const { viewFormats, enable_required_feature } = t.params;\n\n    if (enable_required_feature) {\n      t.selectDeviceForTextureFormatOrSkipTestCase(viewFormats as GPUTextureFormat[]);\n    }\n  })\n  .fn(async t => {\n    const { viewFormats, canvasType, enable_required_feature } = t.params;\n\n    const canvas = createCanvas(t, canvasType, 2, 2);\n    const ctx = canvas.getContext('webgpu');\n    assert(ctx instanceof GPUCanvasContext, 'Failed to get WebGPU context from canvas');\n\n    const canvasConf = {\n      device: t.device,\n      format: 'bgra8unorm' as const,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n      viewFormats: viewFormats as GPUTextureFormat[],\n    };\n\n    if (enable_required_feature) {\n      t.expectValidationError(() => {\n        ctx.configure(canvasConf);\n      });\n    } else {\n      t.shouldThrow('TypeError', () => {\n        ctx.configure(canvasConf);\n      });\n    }\n  });\n\ng.test('storage_texture_binding_layout')\n  .desc(\n    `\n  Test creating a GPUStorageTextureBindingLayout with an optional texture format will fail if the\n  required optional feature are not enabled.\n\n  Note: This test has no cases if there are no optional texture formats supporting storage.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(t => kTextureFormatInfo[t.format].storage)\n      .combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    t.shouldThrow(enable_required_feature ? false : 'TypeError', () => {\n      t.device.createBindGroupLayout({\n        entries: [\n          {\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            storageTexture: {\n              format,\n            },\n          },\n        ],\n      });\n    });\n  });\n\ng.test('color_target_state')\n  .desc(\n    `\n  Test creating a render pipeline with an optional texture format set in GPUColorTargetState will\n  fail if the required optional feature is not enabled.\n\n  Note: This test has no cases if there are no optional texture formats supporting color rendering.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(t => kTextureFormatInfo[t.format].renderable && kTextureFormatInfo[t.format].color)\n      .combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    t.shouldThrow(enable_required_feature ? false : 'TypeError', () => {\n      t.device.createRenderPipeline({\n        layout: 'auto',\n        vertex: {\n          module: t.device.createShaderModule({\n            code: `\n              @vertex\n              fn main()-> @builtin(position) vec4<f32> {\n                return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n              }`,\n          }),\n          entryPoint: 'main',\n        },\n        fragment: {\n          module: t.device.createShaderModule({\n            code: `\n              @fragment\n              fn main() -> @location(0) vec4<f32> {\n                return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n              }`,\n          }),\n          entryPoint: 'main',\n          targets: [{ format }],\n        },\n      });\n    });\n  });\n\ng.test('depth_stencil_state')\n  .desc(\n    `\n  Test creating a render pipeline with an optional texture format set in GPUColorTargetState will\n  fail if the required optional feature is not enabled.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(\n        t =>\n          kTextureFormatInfo[t.format].renderable &&\n          (kTextureFormatInfo[t.format].depth || kTextureFormatInfo[t.format].stencil)\n      )\n      .combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    t.shouldThrow(enable_required_feature ? false : 'TypeError', () => {\n      t.device.createRenderPipeline({\n        layout: 'auto',\n        vertex: {\n          module: t.device.createShaderModule({\n            code: `\n              @vertex\n              fn main()-> @builtin(position) vec4<f32> {\n                return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n              }`,\n          }),\n          entryPoint: 'main',\n        },\n        depthStencil: {\n          format,\n        },\n        fragment: {\n          module: t.device.createShaderModule({\n            code: `\n              @fragment\n              fn main() -> @location(0) vec4<f32> {\n                return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n              }`,\n          }),\n          entryPoint: 'main',\n          targets: [{ format: 'rgba8unorm' }],\n        },\n      });\n    });\n  });\n\ng.test('render_bundle_encoder_descriptor_color_format')\n  .desc(\n    `\n  Test creating a render bundle encoder with an optional texture format set as one of the color\n  format will fail if the required optional feature is not enabled.\n\n  Note: This test has no cases if there are no optional texture formats supporting color rendering.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(t => kTextureFormatInfo[t.format].renderable && kTextureFormatInfo[t.format].color)\n      .combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    t.shouldThrow(enable_required_feature ? false : 'TypeError', () => {\n      t.device.createRenderBundleEncoder({\n        colorFormats: [format],\n      });\n    });\n  });\n\ng.test('render_bundle_encoder_descriptor_depth_stencil_format')\n  .desc(\n    `\n  Test creating a render bundle encoder with an optional texture format set as the depth stencil\n  format will fail if the required optional feature is not enabled.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(\n        t =>\n          kTextureFormatInfo[t.format].renderable &&\n          (kTextureFormatInfo[t.format].depth || kTextureFormatInfo[t.format].stencil)\n      )\n      .combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    t.shouldThrow(enable_required_feature ? false : 'TypeError', () => {\n      t.device.createRenderBundleEncoder({\n        colorFormats: ['rgba8unorm'],\n        depthStencilFormat: format,\n      });\n    });\n  });\n"],"file":"texture_formats.spec.js"}