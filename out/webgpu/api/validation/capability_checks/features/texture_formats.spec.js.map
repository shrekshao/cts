{"version":3,"sources":["../../../../../../src/webgpu/api/validation/capability_checks/features/texture_formats.spec.ts"],"names":["description","makeTestGroup","kAllTextureFormats","kTextureFormatInfo","ValidationTest","g","kOptionalTextureFormats","filter","t","feature","undefined","test","desc","params","u","combine","beforeAllSubcases","format","enable_required_feature","formatInfo","selectDeviceOrSkipTestCase","fn","shouldThrow","device","createTexture","size","blockWidth","blockHeight","usage","GPUTextureUsage","TEXTURE_BINDING","storage","expectValidationError","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","storageTexture","renderable","color","createRenderPipeline","layout","vertex","module","createShaderModule","code","entryPoint","fragment","targets","depth","stencil","depthStencil","createRenderBundleEncoder","colorFormats","depthStencilFormat"],"mappings":"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","sourcesContent":["export const description = `\nTests for capability checking for features enabling optional texture formats.\n\nTODO(#902): test GPUTextureViewDescriptor.format\nTODO(#902): test GPUCanvasConfiguration.format (it doesn't allow any optional formats today but the\n  error might still be different - exception instead of validation.\n\nTODO(#920): test GPUTextureDescriptor.viewFormats (if/when it takes formats)\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { kAllTextureFormats, kTextureFormatInfo } from '../../../../capability_info.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nexport const g = makeTestGroup(ValidationTest);\n\nconst kOptionalTextureFormats = kAllTextureFormats.filter(\n  t => kTextureFormatInfo[t].feature !== undefined\n);\n\ng.test('texture_descriptor')\n  .desc(\n    `\n  Test creating a texture with an optional texture format will fail if the required optional feature\n  is not enabled.\n  `\n  )\n  .params(u =>\n    u.combine('format', kOptionalTextureFormats).combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    t.shouldThrow(enable_required_feature ? false : 'TypeError', () => {\n      t.device.createTexture({\n        format,\n        size: [formatInfo.blockWidth, formatInfo.blockHeight, 1] as const,\n        usage: GPUTextureUsage.TEXTURE_BINDING,\n      });\n    });\n  });\n\ng.test('storage_texture_binding_layout')\n  .desc(\n    `\n  Test creating a GPUStorageTextureBindingLayout with an optional texture format will fail if the\n  required optional feature are not enabled.\n\n  Note: This test has no cases if there are no optional texture formats supporting storage.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(t => kTextureFormatInfo[t.format].storage)\n      .combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    t.expectValidationError(() => {\n      t.device.createBindGroupLayout({\n        entries: [\n          {\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            storageTexture: {\n              format,\n            },\n          },\n        ],\n      });\n    }, !enable_required_feature);\n  });\n\ng.test('color_target_state')\n  .desc(\n    `\n  Test creating a render pipeline with an optional texture format set in GPUColorTargetState will\n  fail if the required optional feature is not enabled.\n\n  Note: This test has no cases if there are no optional texture formats supporting color rendering.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(t => kTextureFormatInfo[t.format].renderable && kTextureFormatInfo[t.format].color)\n      .combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    t.expectValidationError(() => {\n      t.device.createRenderPipeline({\n        layout: 'auto',\n        vertex: {\n          module: t.device.createShaderModule({\n            code: `\n              @stage(vertex)\n              fn main()-> @builtin(position) vec4<f32> {\n                return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n              }`,\n          }),\n          entryPoint: 'main',\n        },\n        fragment: {\n          module: t.device.createShaderModule({\n            code: `\n              @stage(fragment)\n              fn main() -> @location(0) vec4<f32> {\n                return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n              }`,\n          }),\n          entryPoint: 'main',\n          targets: [{ format }],\n        },\n      });\n    }, !enable_required_feature);\n  });\n\ng.test('depth_stencil_state')\n  .desc(\n    `\n  Test creating a render pipeline with an optional texture format set in GPUColorTargetState will\n  fail if the required optional feature is not enabled.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(\n        t =>\n          kTextureFormatInfo[t.format].renderable &&\n          (kTextureFormatInfo[t.format].depth || kTextureFormatInfo[t.format].stencil)\n      )\n      .combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    t.expectValidationError(() => {\n      t.device.createRenderPipeline({\n        layout: 'auto',\n        vertex: {\n          module: t.device.createShaderModule({\n            code: `\n              @stage(vertex)\n              fn main()-> @builtin(position) vec4<f32> {\n                return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n              }`,\n          }),\n          entryPoint: 'main',\n        },\n        depthStencil: {\n          format,\n        },\n        fragment: {\n          module: t.device.createShaderModule({\n            code: `\n              @stage(fragment)\n              fn main() -> @location(0) vec4<f32> {\n                return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n              }`,\n          }),\n          entryPoint: 'main',\n          targets: [{ format: 'rgba8unorm' }],\n        },\n      });\n    }, !enable_required_feature);\n  });\n\ng.test('render_bundle_encoder_descriptor_color_format')\n  .desc(\n    `\n  Test creating a render bundle encoder with an optional texture format set as one of the color\n  format will fail if the required optional feature is not enabled.\n\n  Note: This test has no cases if there are no optional texture formats supporting color rendering.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(t => kTextureFormatInfo[t.format].renderable && kTextureFormatInfo[t.format].color)\n      .combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    t.expectValidationError(() => {\n      t.device.createRenderBundleEncoder({\n        colorFormats: [format],\n      });\n    }, !enable_required_feature);\n  });\n\ng.test('render_bundle_encoder_descriptor_depth_stencil_format')\n  .desc(\n    `\n  Test creating a render bundle encoder with an optional texture format set as the depth stencil\n  format will fail if the required optional feature is not enabled.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(\n        t =>\n          kTextureFormatInfo[t.format].renderable &&\n          (kTextureFormatInfo[t.format].depth || kTextureFormatInfo[t.format].stencil)\n      )\n      .combine('enable_required_feature', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n  })\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    t.expectValidationError(() => {\n      t.device.createRenderBundleEncoder({\n        colorFormats: ['rgba8unorm'],\n        depthStencilFormat: format,\n      });\n    }, !enable_required_feature);\n  });\n"],"file":"texture_formats.spec.js"}