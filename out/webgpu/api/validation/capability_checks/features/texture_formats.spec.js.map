{"version":3,"sources":["../../../../../../src/webgpu/api/validation/capability_checks/features/texture_formats.spec.ts"],"names":["description","makeTestGroup","kAllTextureFormats","kTextureFormatInfo","ValidationTest","g","kOptionalTextureFormats","filter","t","feature","undefined","test","desc","params","u","combine","beginSubcases","fn","format","enable_required_feature","formatInfo","selectDeviceOrSkipTestCase","expectValidationError","device","createTexture","size","blockWidth","blockHeight","usage","GPUTextureUsage","TEXTURE_BINDING","storage","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","storageTexture","renderable","color","createRenderPipeline","vertex","module","createShaderModule","code","entryPoint","fragment","targets","depth","stencil","depthStencil","createRenderBundleEncoder","colorFormats","depthStencilFormat"],"mappings":";AAAA;AACA,GADA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CARO,CAUP,SAASC,aAAT,QAA8B,+CAA9B;AACA,SAASC,kBAAT,EAA6BC,kBAA7B,QAAuD,gCAAvD;AACA,SAASC,cAAT,QAA+B,0BAA/B;;AAEA,OAAO,MAAMC,CAAC,GAAGJ,aAAa,CAACG,cAAD,CAAvB;;AAEP,MAAME,uBAAuB,GAAGJ,kBAAkB,CAACK,MAAnB;AAC9BC,CAAC,IAAIL,kBAAkB,CAACK,CAAD,CAAlB,CAAsBC,OAAtB,KAAkCC,SADT,CAAhC;;;AAIAL,CAAC,CAACM,IAAF,CAAO,oBAAP;AACGC,IADH;AAEK;AACL;AACA;AACA;AACA;AACA,GAPA;;AASGC,MATH,CASU,CAAAC,CAAC;AACPA,CAAC;AACEC,OADH,CACW,QADX,EACqBT,uBADrB;AAEGU,aAFH;AAGGD,OAHH,CAGW,yBAHX,EAGsC,CAAC,IAAD,EAAO,KAAP,CAHtC,CAVJ;;AAeGE,EAfH,CAeM,MAAMT,CAAN,IAAW;AACb,QAAM,EAAEU,MAAF,EAAUC,uBAAV,KAAsCX,CAAC,CAACK,MAA9C;;AAEA,QAAMO,UAAU,GAAGjB,kBAAkB,CAACe,MAAD,CAArC;AACA,MAAIC,uBAAJ,EAA6B;AAC3B,UAAMX,CAAC,CAACa,0BAAF,CAA6BD,UAAU,CAACX,OAAxC,CAAN;AACD;;AAEDD,EAAAA,CAAC,CAACc,qBAAF,CAAwB,MAAM;AAC5Bd,IAAAA,CAAC,CAACe,MAAF,CAASC,aAAT,CAAuB;AACrBN,MAAAA,MADqB;AAErBO,MAAAA,IAAI,EAAE,CAACL,UAAU,CAACM,UAAZ,EAAwBN,UAAU,CAACO,WAAnC,EAAgD,CAAhD,CAFe;AAGrBC,MAAAA,KAAK,EAAEC,eAAe,CAACC,eAHF,EAAvB;;AAKD,GAND,EAMG,CAACX,uBANJ;AAOD,CA9BH;;AAgCAd,CAAC,CAACM,IAAF,CAAO,gCAAP;AACGC,IADH;AAEK;AACL;AACA;AACA;AACA;AACA,GAPA;;AASGC,MATH,CASU,CAAAC,CAAC;AACPA,CAAC;AACEC,OADH,CACW,QADX,EACqBT,uBADrB;AAEGC,MAFH,CAEUC,CAAC,IAAIL,kBAAkB,CAACK,CAAC,CAACU,MAAH,CAAlB,CAA6Ba,OAF5C;AAGGf,aAHH;AAIGD,OAJH,CAIW,yBAJX,EAIsC,CAAC,IAAD,EAAO,KAAP,CAJtC,CAVJ;;AAgBGE,EAhBH,CAgBM,MAAMT,CAAN,IAAW;AACb,QAAM,EAAEU,MAAF,EAAUC,uBAAV,KAAsCX,CAAC,CAACK,MAA9C;;AAEA,QAAMO,UAAU,GAAGjB,kBAAkB,CAACe,MAAD,CAArC;AACA,MAAIC,uBAAJ,EAA6B;AAC3B,UAAMX,CAAC,CAACa,0BAAF,CAA6BD,UAAU,CAACX,OAAxC,CAAN;AACD;;AAEDD,EAAAA,CAAC,CAACc,qBAAF,CAAwB,MAAM;AAC5Bd,IAAAA,CAAC,CAACe,MAAF,CAASS,qBAAT,CAA+B;AAC7BC,MAAAA,OAAO,EAAE;AACP;AACEC,QAAAA,OAAO,EAAE,CADX;AAEEC,QAAAA,UAAU,EAAEC,cAAc,CAACC,OAF7B;AAGEC,QAAAA,cAAc,EAAE;AACdpB,UAAAA,MADc,EAHlB,EADO,CADoB,EAA/B;;;;;AAWD,GAZD,EAYG,CAACC,uBAZJ;AAaD,CArCH;;AAuCAd,CAAC,CAACM,IAAF,CAAO,oBAAP;AACGC,IADH;AAEK;AACL;AACA;AACA;AACA;AACA,GAPA;;AASGC,MATH,CASU,CAAAC,CAAC;AACPA,CAAC;AACEC,OADH,CACW,QADX,EACqBT,uBADrB;AAEGC,MAFH,CAEUC,CAAC,IAAIL,kBAAkB,CAACK,CAAC,CAACU,MAAH,CAAlB,CAA6BqB,UAA7B,IAA2CpC,kBAAkB,CAACK,CAAC,CAACU,MAAH,CAAlB,CAA6BsB,KAFvF;AAGGxB,aAHH;AAIGD,OAJH,CAIW,yBAJX,EAIsC,CAAC,IAAD,EAAO,KAAP,CAJtC,CAVJ;;AAgBGE,EAhBH,CAgBM,MAAMT,CAAN,IAAW;AACb,QAAM,EAAEU,MAAF,EAAUC,uBAAV,KAAsCX,CAAC,CAACK,MAA9C;;AAEA,QAAMO,UAAU,GAAGjB,kBAAkB,CAACe,MAAD,CAArC;AACA,MAAIC,uBAAJ,EAA6B;AAC3B,UAAMX,CAAC,CAACa,0BAAF,CAA6BD,UAAU,CAACX,OAAxC,CAAN;AACD;;AAEDD,EAAAA,CAAC,CAACc,qBAAF,CAAwB,MAAM;AAC5Bd,IAAAA,CAAC,CAACe,MAAF,CAASkB,oBAAT,CAA8B;AAC5BC,MAAAA,MAAM,EAAE;AACNC,QAAAA,MAAM,EAAEnC,CAAC,CAACe,MAAF,CAASqB,kBAAT,CAA4B;AAClCC,UAAAA,IAAI,EAAG;AACnB;AACA;AACA;AACA,gBAL8C,EAA5B,CADF;;AAQNC,QAAAA,UAAU,EAAE,MARN,EADoB;;AAW5BC,MAAAA,QAAQ,EAAE;AACRJ,QAAAA,MAAM,EAAEnC,CAAC,CAACe,MAAF,CAASqB,kBAAT,CAA4B;AAClCC,UAAAA,IAAI,EAAG;AACnB;AACA;AACA;AACA,gBAL8C,EAA5B,CADA;;AAQRC,QAAAA,UAAU,EAAE,MARJ;AASRE,QAAAA,OAAO,EAAE,CAAC,EAAE9B,MAAF,EAAD,CATD,EAXkB,EAA9B;;;AAuBD,GAxBD,EAwBG,CAACC,uBAxBJ;AAyBD,CAjDH;;AAmDAd,CAAC,CAACM,IAAF,CAAO,qBAAP;AACGC,IADH;AAEK;AACL;AACA;AACA,GALA;;AAOGC,MAPH,CAOU,CAAAC,CAAC;AACPA,CAAC;AACEC,OADH,CACW,QADX,EACqBT,uBADrB;AAEGC,MAFH;AAGI,CAAAC,CAAC;AACCL,kBAAkB,CAACK,CAAC,CAACU,MAAH,CAAlB,CAA6BqB,UAA7B;AACCpC,kBAAkB,CAACK,CAAC,CAACU,MAAH,CAAlB,CAA6B+B,KAA7B,IAAsC9C,kBAAkB,CAACK,CAAC,CAACU,MAAH,CAAlB,CAA6BgC,OADpE,CAJN;;AAOGlC,aAPH;AAQGD,OARH,CAQW,yBARX,EAQsC,CAAC,IAAD,EAAO,KAAP,CARtC,CARJ;;AAkBGE,EAlBH,CAkBM,MAAMT,CAAN,IAAW;AACb,QAAM,EAAEU,MAAF,EAAUC,uBAAV,KAAsCX,CAAC,CAACK,MAA9C;;AAEA,QAAMO,UAAU,GAAGjB,kBAAkB,CAACe,MAAD,CAArC;AACA,MAAIC,uBAAJ,EAA6B;AAC3B,UAAMX,CAAC,CAACa,0BAAF,CAA6BD,UAAU,CAACX,OAAxC,CAAN;AACD;;AAEDD,EAAAA,CAAC,CAACc,qBAAF,CAAwB,MAAM;AAC5Bd,IAAAA,CAAC,CAACe,MAAF,CAASkB,oBAAT,CAA8B;AAC5BC,MAAAA,MAAM,EAAE;AACNC,QAAAA,MAAM,EAAEnC,CAAC,CAACe,MAAF,CAASqB,kBAAT,CAA4B;AAClCC,UAAAA,IAAI,EAAG;AACnB;AACA;AACA;AACA,gBAL8C,EAA5B,CADF;;AAQNC,QAAAA,UAAU,EAAE,MARN,EADoB;;AAW5BK,MAAAA,YAAY,EAAE;AACZjC,QAAAA,MADY,EAXc;;AAc5B6B,MAAAA,QAAQ,EAAE;AACRJ,QAAAA,MAAM,EAAEnC,CAAC,CAACe,MAAF,CAASqB,kBAAT,CAA4B;AAClCC,UAAAA,IAAI,EAAG;AACnB;AACA;AACA;AACA,gBAL8C,EAA5B,CADA;;AAQRC,QAAAA,UAAU,EAAE,MARJ;AASRE,QAAAA,OAAO,EAAE,CAAC,EAAE9B,MAAM,EAAE,YAAV,EAAD,CATD,EAdkB,EAA9B;;;AA0BD,GA3BD,EA2BG,CAACC,uBA3BJ;AA4BD,CAtDH;;AAwDAd,CAAC,CAACM,IAAF,CAAO,+CAAP;AACGC,IADH;AAEK;AACL;AACA;AACA;AACA;AACA,GAPA;;AASGC,MATH,CASU,CAAAC,CAAC;AACPA,CAAC;AACEC,OADH,CACW,QADX,EACqBT,uBADrB;AAEGC,MAFH,CAEUC,CAAC,IAAIL,kBAAkB,CAACK,CAAC,CAACU,MAAH,CAAlB,CAA6BqB,UAA7B,IAA2CpC,kBAAkB,CAACK,CAAC,CAACU,MAAH,CAAlB,CAA6BsB,KAFvF;AAGGxB,aAHH;AAIGD,OAJH,CAIW,yBAJX,EAIsC,CAAC,IAAD,EAAO,KAAP,CAJtC,CAVJ;;AAgBGE,EAhBH,CAgBM,MAAMT,CAAN,IAAW;AACb,QAAM,EAAEU,MAAF,EAAUC,uBAAV,KAAsCX,CAAC,CAACK,MAA9C;;AAEA,QAAMO,UAAU,GAAGjB,kBAAkB,CAACe,MAAD,CAArC;AACA,MAAIC,uBAAJ,EAA6B;AAC3B,UAAMX,CAAC,CAACa,0BAAF,CAA6BD,UAAU,CAACX,OAAxC,CAAN;AACD;;AAEDD,EAAAA,CAAC,CAACc,qBAAF,CAAwB,MAAM;AAC5Bd,IAAAA,CAAC,CAACe,MAAF,CAAS6B,yBAAT,CAAmC;AACjCC,MAAAA,YAAY,EAAE,CAACnC,MAAD,CADmB,EAAnC;;AAGD,GAJD,EAIG,CAACC,uBAJJ;AAKD,CA7BH;;AA+BAd,CAAC,CAACM,IAAF,CAAO,uDAAP;AACGC,IADH;AAEK;AACL;AACA;AACA,GALA;;AAOGC,MAPH,CAOU,CAAAC,CAAC;AACPA,CAAC;AACEC,OADH,CACW,QADX,EACqBT,uBADrB;AAEGC,MAFH;AAGI,CAAAC,CAAC;AACCL,kBAAkB,CAACK,CAAC,CAACU,MAAH,CAAlB,CAA6BqB,UAA7B;AACCpC,kBAAkB,CAACK,CAAC,CAACU,MAAH,CAAlB,CAA6B+B,KAA7B,IAAsC9C,kBAAkB,CAACK,CAAC,CAACU,MAAH,CAAlB,CAA6BgC,OADpE,CAJN;;AAOGlC,aAPH;AAQGD,OARH,CAQW,yBARX,EAQsC,CAAC,IAAD,EAAO,KAAP,CARtC,CARJ;;AAkBGE,EAlBH,CAkBM,MAAMT,CAAN,IAAW;AACb,QAAM,EAAEU,MAAF,EAAUC,uBAAV,KAAsCX,CAAC,CAACK,MAA9C;;AAEA,QAAMO,UAAU,GAAGjB,kBAAkB,CAACe,MAAD,CAArC;AACA,MAAIC,uBAAJ,EAA6B;AAC3B,UAAMX,CAAC,CAACa,0BAAF,CAA6BD,UAAU,CAACX,OAAxC,CAAN;AACD;;AAEDD,EAAAA,CAAC,CAACc,qBAAF,CAAwB,MAAM;AAC5Bd,IAAAA,CAAC,CAACe,MAAF,CAAS6B,yBAAT,CAAmC;AACjCC,MAAAA,YAAY,EAAE,CAAC,YAAD,CADmB;AAEjCC,MAAAA,kBAAkB,EAAEpC,MAFa,EAAnC;;AAID,GALD,EAKG,CAACC,uBALJ;AAMD,CAhCH","sourcesContent":["export const description = `\nTests for capability checking for features enabling optional texture formats.\n\nTODO(#902): test GPUTextureViewDescriptor.format\nTODO(#902): test GPUCanvasConfiguration.format (it doesn't allow any optional formats today but the\n  error might still be different - exception instead of validation.\n\nTODO(#920): test GPUTextureDescriptor.viewFormats (if/when it takes formats)\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { kAllTextureFormats, kTextureFormatInfo } from '../../../../capability_info.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nexport const g = makeTestGroup(ValidationTest);\n\nconst kOptionalTextureFormats = kAllTextureFormats.filter(\n  t => kTextureFormatInfo[t].feature !== undefined\n);\n\ng.test('texture_descriptor')\n  .desc(\n    `\n  Test creating a texture with an optional texture format will fail if the required optional feature\n  is not enabled.\n\n  TODO(#919): Actually it should throw an exception, not fail with a validation error.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .beginSubcases()\n      .combine('enable_required_feature', [true, false])\n  )\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      await t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n\n    t.expectValidationError(() => {\n      t.device.createTexture({\n        format,\n        size: [formatInfo.blockWidth, formatInfo.blockHeight, 1] as const,\n        usage: GPUTextureUsage.TEXTURE_BINDING,\n      });\n    }, !enable_required_feature);\n  });\n\ng.test('storage_texture_binding_layout')\n  .desc(\n    `\n  Test creating a GPUStorageTextureBindingLayout with an optional texture format will fail if the\n  required optional feature are not enabled.\n\n  Note: This test has no cases if there are no optional texture formats supporting storage.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(t => kTextureFormatInfo[t.format].storage)\n      .beginSubcases()\n      .combine('enable_required_feature', [true, false])\n  )\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      await t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n\n    t.expectValidationError(() => {\n      t.device.createBindGroupLayout({\n        entries: [\n          {\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            storageTexture: {\n              format,\n            },\n          },\n        ],\n      });\n    }, !enable_required_feature);\n  });\n\ng.test('color_target_state')\n  .desc(\n    `\n  Test creating a render pipeline with an optional texture format set in GPUColorTargetState will\n  fail if the required optional feature is not enabled.\n\n  Note: This test has no cases if there are no optional texture formats supporting color rendering.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(t => kTextureFormatInfo[t.format].renderable && kTextureFormatInfo[t.format].color)\n      .beginSubcases()\n      .combine('enable_required_feature', [true, false])\n  )\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      await t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n\n    t.expectValidationError(() => {\n      t.device.createRenderPipeline({\n        vertex: {\n          module: t.device.createShaderModule({\n            code: `\n              @stage(vertex)\n              fn main()-> @builtin(position) vec4<f32> {\n                return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n              }`,\n          }),\n          entryPoint: 'main',\n        },\n        fragment: {\n          module: t.device.createShaderModule({\n            code: `\n              @stage(fragment)\n              fn main() -> @location(0) vec4<f32> {\n                return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n              }`,\n          }),\n          entryPoint: 'main',\n          targets: [{ format }],\n        },\n      });\n    }, !enable_required_feature);\n  });\n\ng.test('depth_stencil_state')\n  .desc(\n    `\n  Test creating a render pipeline with an optional texture format set in GPUColorTargetState will\n  fail if the required optional feature is not enabled.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(\n        t =>\n          kTextureFormatInfo[t.format].renderable &&\n          (kTextureFormatInfo[t.format].depth || kTextureFormatInfo[t.format].stencil)\n      )\n      .beginSubcases()\n      .combine('enable_required_feature', [true, false])\n  )\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      await t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n\n    t.expectValidationError(() => {\n      t.device.createRenderPipeline({\n        vertex: {\n          module: t.device.createShaderModule({\n            code: `\n              @stage(vertex)\n              fn main()-> @builtin(position) vec4<f32> {\n                return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n              }`,\n          }),\n          entryPoint: 'main',\n        },\n        depthStencil: {\n          format,\n        },\n        fragment: {\n          module: t.device.createShaderModule({\n            code: `\n              @stage(fragment)\n              fn main() -> @location(0) vec4<f32> {\n                return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n              }`,\n          }),\n          entryPoint: 'main',\n          targets: [{ format: 'rgba8unorm' }],\n        },\n      });\n    }, !enable_required_feature);\n  });\n\ng.test('render_bundle_encoder_descriptor_color_format')\n  .desc(\n    `\n  Test creating a render bundle encoder with an optional texture format set as one of the color\n  format will fail if the required optional feature is not enabled.\n\n  Note: This test has no cases if there are no optional texture formats supporting color rendering.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(t => kTextureFormatInfo[t.format].renderable && kTextureFormatInfo[t.format].color)\n      .beginSubcases()\n      .combine('enable_required_feature', [true, false])\n  )\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      await t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n\n    t.expectValidationError(() => {\n      t.device.createRenderBundleEncoder({\n        colorFormats: [format],\n      });\n    }, !enable_required_feature);\n  });\n\ng.test('render_bundle_encoder_descriptor_depth_stencil_format')\n  .desc(\n    `\n  Test creating a render bundle encoder with an optional texture format set as the depth stencil\n  format will fail if the required optional feature is not enabled.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kOptionalTextureFormats)\n      .filter(\n        t =>\n          kTextureFormatInfo[t.format].renderable &&\n          (kTextureFormatInfo[t.format].depth || kTextureFormatInfo[t.format].stencil)\n      )\n      .beginSubcases()\n      .combine('enable_required_feature', [true, false])\n  )\n  .fn(async t => {\n    const { format, enable_required_feature } = t.params;\n\n    const formatInfo = kTextureFormatInfo[format];\n    if (enable_required_feature) {\n      await t.selectDeviceOrSkipTestCase(formatInfo.feature);\n    }\n\n    t.expectValidationError(() => {\n      t.device.createRenderBundleEncoder({\n        colorFormats: ['rgba8unorm'],\n        depthStencilFormat: format,\n      });\n    }, !enable_required_feature);\n  });\n"],"file":"texture_formats.spec.js"}