{"version":3,"file":"maxUniformBufferBindingSize.spec.js","names":["keysOf","kLimitBaseParams","kLimitValueTestKeys","makeLimitTestGroup","BufferParts","wholeBuffer","biggerBufferWithOffset","kBufferPartsKeys","getSizeAndOffsetForBufferPart","device","bufferPart","size","align","limits","minUniformBufferOffsetAlignment","offset","limit","g","description","test","desc","params","combine","fn","t","limitTest","testValueName","testDeviceWithRequestedLimits","testValue","shouldError","bindGroupLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","VERTEX","buffer","pushErrorScope","uniformBuffer","trackForCleanup","createBuffer","usage","GPUBufferUsage","UNIFORM","outOfMemoryError","popErrorScope","expectValidationError","createBindGroup","layout","resource","u","actualLimit","expect","maxBufferSize"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/maxUniformBufferBindingSize.spec.ts"],"sourcesContent":["import { keysOf } from '../../../../../common/util/data_tables.js';\n\nimport { kLimitBaseParams, kLimitValueTestKeys, makeLimitTestGroup } from './limit_utils.js';\n\nconst BufferParts = {\n  wholeBuffer: true,\n  biggerBufferWithOffset: true,\n};\ntype BufferPart = keyof typeof BufferParts;\nconst kBufferPartsKeys = keysOf(BufferParts);\n\nfunction getSizeAndOffsetForBufferPart(device: GPUDevice, bufferPart: BufferPart, size: number) {\n  const align = device.limits.minUniformBufferOffsetAlignment;\n  switch (bufferPart) {\n    case 'wholeBuffer':\n      return { offset: 0, size };\n    case 'biggerBufferWithOffset':\n      return { size: size + align, offset: align };\n  }\n}\n\nconst limit = 'maxUniformBufferBindingSize';\nexport const { g, description } = makeLimitTestGroup(limit);\n\ng.test('createBindGroup,at_over')\n  .desc(`Test using at and over ${limit} limit`)\n  .params(kLimitBaseParams.combine('bufferPart', kBufferPartsKeys))\n  .fn(async t => {\n    const { limitTest, testValueName, bufferPart } = t.params;\n    await t.testDeviceWithRequestedLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError }) => {\n        const bindGroupLayout = device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.VERTEX,\n              buffer: {},\n            },\n          ],\n        });\n\n        const { size, offset } = getSizeAndOffsetForBufferPart(device, bufferPart, testValue);\n        device.pushErrorScope('out-of-memory');\n        const uniformBuffer = t.trackForCleanup(\n          device.createBuffer({\n            usage: GPUBufferUsage.UNIFORM,\n            size,\n          })\n        );\n        const outOfMemoryError = await device.popErrorScope();\n\n        if (!outOfMemoryError) {\n          await t.expectValidationError(() => {\n            device.createBindGroup({\n              layout: bindGroupLayout,\n              entries: [\n                {\n                  binding: 0,\n                  resource: {\n                    buffer: uniformBuffer,\n                    offset,\n                    size: testValue,\n                  },\n                },\n              ],\n            });\n          }, shouldError);\n        }\n      }\n    );\n  });\n\ng.test('validate,maxBufferSize')\n  .desc(`Test that ${limit} <= maxBufferSize`)\n  .params(u => u.combine('limitTest', kLimitValueTestKeys))\n  .fn(async t => {\n    const { limitTest } = t.params;\n    await t.testDeviceWithRequestedLimits(limitTest, 'atLimit', ({ device, actualLimit }) => {\n      t.expect(actualLimit <= device.limits.maxBufferSize);\n    });\n  });\n"],"mappings":"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"}