{"version":3,"file":"maxColorAttachmentBytesPerSample.spec.js","names":["assert","kTextureSampleCounts","kTextureFormatInfo","align","kMaximumLimitBaseParams","makeLimitTestGroup","kFormatsToUseBySize","kInterleaveFormats","getAttachments","interleaveFormat","testValue","bytesPerSample","targets","addTexture","format","renderTargetPixelByteCost","renderTargetComponentAlignment","newBytesPerSample","push","writeMask","getDescription","actualLimit","sampleCount","offset","map","s","padEnd","toString","padStart","join","getPipelineDescriptor","device","code","module","createShaderModule","pipelineDescriptor","layout","vertex","entryPoint","fragment","depthStencil","depthWriteEnabled","depthCompare","multisample","count","createTextures","t","trackForCleanup","createTexture","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","kExtraLimits","maxColorAttachments","maxFragmentCombinedOutputResources","limit","g","description","test","desc","params","combine","fn","limitTest","testValueName","async","testDeviceWithRequestedMaximumLimits","shouldError","result","numTargets","length","limits","testCreateRenderPipeline","encoder","createCommandEncoder","textures","pass","beginRenderPass","colorAttachments","texture","view","createView","loadOp","storeOp","end","expectValidationError","finish","createRenderBundleEncoder","colorFormats"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/maxColorAttachmentBytesPerSample.spec.ts"],"sourcesContent":["import { assert } from '../../../../../common/util/util.js';\nimport { kTextureSampleCounts, kTextureFormatInfo } from '../../../../capability_info.js';\nimport { align } from '../../../../util/math.js';\n\nimport {\n  kMaximumLimitBaseParams,\n  LimitsRequest,\n  LimitTestsImpl,\n  makeLimitTestGroup,\n} from './limit_utils.js';\n\nconst kFormatsToUseBySize: GPUTextureFormat[] = [\n  'rgba32float',\n  'rgba16float',\n  'rgba8unorm',\n  'rg8unorm',\n  'r8unorm',\n];\n\nconst kInterleaveFormats: GPUTextureFormat[] = [\n  'rgba16float',\n  'rg16float',\n  'rgba8unorm',\n  'rg8unorm',\n  'r8unorm',\n];\n\nfunction getAttachments(interleaveFormat: GPUTextureFormat, testValue: number) {\n  let bytesPerSample = 0;\n  const targets: GPUColorTargetState[] = [];\n\n  const addTexture = (format: GPUTextureFormat) => {\n    const { renderTargetPixelByteCost, renderTargetComponentAlignment } = kTextureFormatInfo[\n      format\n    ];\n    const newBytesPerSample =\n      align(bytesPerSample, renderTargetComponentAlignment!) + renderTargetPixelByteCost!;\n    if (newBytesPerSample > testValue) {\n      return false;\n    }\n    targets.push({ format, writeMask: 0 });\n    bytesPerSample = newBytesPerSample;\n    return true;\n  };\n\n  while (bytesPerSample < testValue) {\n    addTexture(interleaveFormat);\n    for (const format of kFormatsToUseBySize) {\n      if (addTexture(format)) {\n        break;\n      }\n    }\n  }\n\n  assert(bytesPerSample === testValue);\n  return targets;\n}\n\nfunction getDescription(\n  testValue: number,\n  actualLimit: number,\n  sampleCount: number,\n  targets: GPUColorTargetState[]\n) {\n  return `\n    // testValue  : ${testValue}\n    // actualLimit: ${actualLimit}\n    // sampleCount: ${sampleCount}\n    // targets:\n    ${(() => {\n      let offset = 0;\n      return targets\n        .map(({ format }) => {\n          const { renderTargetPixelByteCost, renderTargetComponentAlignment } = kTextureFormatInfo[\n            format\n          ];\n          offset = align(offset, renderTargetComponentAlignment!);\n          const s = `//   ${format.padEnd(11)} (offset: ${offset\n            .toString()\n            .padStart(\n              2\n            )}, align: ${renderTargetComponentAlignment}, size: ${renderTargetPixelByteCost})`;\n          offset += renderTargetPixelByteCost!;\n          return s;\n        })\n        .join('\\n    ');\n    })()}\n  `;\n}\n\nfunction getPipelineDescriptor(\n  device: GPUDevice,\n  actualLimit: number,\n  interleaveFormat: GPUTextureFormat,\n  sampleCount: number,\n  testValue: number\n): { pipelineDescriptor: GPURenderPipelineDescriptor; code: string } | undefined {\n  const targets = getAttachments(interleaveFormat, testValue);\n  if (!targets) {\n    return;\n  }\n\n  const code = `\n    ${getDescription(testValue, actualLimit, sampleCount, targets)}\n    @vertex fn vs() -> @builtin(position) vec4f {\n      return vec4f(0);\n    }\n\n    @fragment fn fs() -> @location(0) vec4f {\n      return vec4f(0);\n    }\n  `;\n  const module = device.createShaderModule({ code });\n  const pipelineDescriptor: GPURenderPipelineDescriptor = {\n    layout: 'auto',\n    vertex: {\n      module,\n      entryPoint: 'vs',\n    },\n    fragment: {\n      module,\n      entryPoint: 'fs',\n      targets,\n    },\n    // depth should not affect the test so added to make sure the implementation does not consider it\n    depthStencil: {\n      depthWriteEnabled: true,\n      depthCompare: 'less',\n      format: 'depth24plus',\n    },\n    multisample: {\n      count: sampleCount,\n    },\n  };\n  return { pipelineDescriptor, code };\n}\n\nfunction createTextures(t: LimitTestsImpl, targets: GPUColorTargetState[]) {\n  return targets.map(({ format }) =>\n    t.trackForCleanup(\n      t.device.createTexture({\n        size: [1, 1],\n        format,\n        usage: GPUTextureUsage.RENDER_ATTACHMENT,\n      })\n    )\n  );\n}\n\nconst kExtraLimits: LimitsRequest = {\n  maxColorAttachments: 'adapterLimit',\n  maxFragmentCombinedOutputResources: 'adapterLimit',\n};\n\nconst limit = 'maxColorAttachmentBytesPerSample';\nexport const { g, description } = makeLimitTestGroup(limit);\n\ng.test('createRenderPipeline,at_over')\n  .desc(`Test using at and over ${limit} limit in createRenderPipeline(Async)`)\n  .params(\n    kMaximumLimitBaseParams\n      .combine('async', [false, true] as const)\n      .combine('sampleCount', kTextureSampleCounts)\n      .combine('interleaveFormat', kInterleaveFormats)\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, async, sampleCount, interleaveFormat } = t.params;\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, actualLimit, shouldError }) => {\n        const result = getPipelineDescriptor(\n          device,\n          actualLimit,\n          interleaveFormat,\n          sampleCount,\n          testValue\n        );\n        if (!result) {\n          return;\n        }\n        const { pipelineDescriptor, code } = result;\n        const numTargets = (pipelineDescriptor.fragment!.targets as GPUColorTargetState[]).length;\n        if (\n          numTargets > device.limits.maxColorAttachments ||\n          numTargets > device.limits.maxFragmentCombinedOutputResources\n        ) {\n          return;\n        }\n\n        await t.testCreateRenderPipeline(pipelineDescriptor, async, shouldError, code);\n      },\n      kExtraLimits\n    );\n  });\n\ng.test('beginRenderPass,at_over')\n  .desc(`Test using at and over ${limit} limit in beginRenderPass`)\n  .params(\n    kMaximumLimitBaseParams\n      .combine('sampleCount', kTextureSampleCounts)\n      .combine('interleaveFormat', kInterleaveFormats)\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, sampleCount, interleaveFormat } = t.params;\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, actualLimit, shouldError }) => {\n        const targets = getAttachments(interleaveFormat, testValue);\n        if (\n          targets.length > device.limits.maxColorAttachments ||\n          targets.length > device.limits.maxFragmentCombinedOutputResources\n        ) {\n          return;\n        }\n\n        const encoder = device.createCommandEncoder();\n        const textures = createTextures(t, targets);\n\n        const pass = encoder.beginRenderPass({\n          colorAttachments: textures.map(texture => ({\n            view: texture.createView(),\n            loadOp: 'clear',\n            storeOp: 'store',\n          })),\n        });\n        pass.end();\n\n        await t.expectValidationError(\n          () => {\n            encoder.finish();\n          },\n          shouldError,\n          getDescription(testValue, actualLimit, sampleCount, targets)\n        );\n      },\n      kExtraLimits\n    );\n  });\n\ng.test('createRenderBundle,at_over')\n  .desc(`Test using at and over ${limit} limit in createRenderBundle`)\n  .params(\n    kMaximumLimitBaseParams\n      .combine('sampleCount', kTextureSampleCounts)\n      .combine('interleaveFormat', kInterleaveFormats)\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, sampleCount, interleaveFormat } = t.params;\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, actualLimit, shouldError }) => {\n        const targets = getAttachments(interleaveFormat, testValue);\n        if (\n          targets.length > device.limits.maxColorAttachments ||\n          targets.length > device.limits.maxFragmentCombinedOutputResources\n        ) {\n          return;\n        }\n\n        await t.expectValidationError(\n          () => {\n            device.createRenderBundleEncoder({\n              colorFormats: targets.map(({ format }) => format),\n            });\n          },\n          shouldError,\n          getDescription(testValue, actualLimit, sampleCount, targets)\n        );\n      },\n      kExtraLimits\n    );\n  });\n"],"mappings":"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"}