{"version":3,"file":"maxColorAttachmentBytesPerSample.spec.js","names":["assert","range","kTextureSampleCounts","kTextureFormatInfo","align","kMaximumLimitBaseParams","kLimitModes","makeLimitTestGroup","kFormatsToUseBySize","kInterleaveFormats","getAttachments","interleaveFormat","testValue","bytesPerSample","targets","addTexture","format","renderTargetPixelByteCost","renderTargetComponentAlignment","alignedBytesPerSample","bytesRemaining","push","writeMask","getDescription","actualLimit","sampleCount","offset","map","s","padEnd","toString","padStart","join","getPipelineDescriptor","device","code","module","createShaderModule","pipelineDescriptor","layout","vertex","entryPoint","fragment","multisample","count","createTextures","t","trackForCleanup","createTexture","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","limit","g","description","test","desc","params","combine","fn","limitTest","testValueName","maxColorAttachmentsLimitMode","testDeviceWithRequestedMaximumLimits","shouldError","result","expectValidationError","createRenderPipeline","maxColorAttachments","shouldRejectConditionally","createRenderPipelineAsync","limits","length","encoder","createCommandEncoder","textures","pass","beginRenderPass","colorAttachments","i","view","createView","loadOp","storeOp","end","finish","createRenderBundleEncoder","colorFormats"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/maxColorAttachmentBytesPerSample.spec.ts"],"sourcesContent":["import { assert, range } from '../../../../../common/util/util.js';\nimport { kTextureSampleCounts, kTextureFormatInfo } from '../../../../capability_info.js';\nimport { align } from '../../../../util/math.js';\n\nimport {\n  kMaximumLimitBaseParams,\n  kLimitModes,\n  LimitTestsImpl,\n  makeLimitTestGroup,\n} from './limit_utils.js';\n\nconst kFormatsToUseBySize: GPUTextureFormat[] = [\n  'rgba32float',\n  'rgba16float',\n  'rgba8unorm',\n  'rg8unorm',\n  'r8unorm',\n];\n\nconst kInterleaveFormats: GPUTextureFormat[] = [\n  'rgba16float',\n  'rg16float',\n  'rgba8unorm',\n  'rg8unorm',\n  'r8unorm',\n];\n\nfunction getAttachments(interleaveFormat: GPUTextureFormat, testValue: number) {\n  let bytesPerSample = 0;\n  const targets: GPUColorTargetState[] = [];\n\n  const addTexture = (format: GPUTextureFormat) => {\n    const { renderTargetPixelByteCost, renderTargetComponentAlignment } = kTextureFormatInfo[\n      format\n    ];\n    const alignedBytesPerSample = align(bytesPerSample, renderTargetComponentAlignment!);\n    const bytesRemaining = testValue - alignedBytesPerSample;\n    if (renderTargetPixelByteCost! > bytesRemaining) {\n      return false;\n    }\n    targets.push({ format, writeMask: 0 });\n    bytesPerSample = alignedBytesPerSample + renderTargetPixelByteCost!;\n    return true;\n  };\n\n  while (bytesPerSample < testValue) {\n    addTexture(interleaveFormat);\n    for (const format of kFormatsToUseBySize) {\n      if (addTexture(format)) {\n        break;\n      }\n    }\n  }\n\n  assert(bytesPerSample === testValue);\n  return targets;\n}\n\nfunction getDescription(\n  testValue: number,\n  actualLimit: number,\n  sampleCount: number,\n  targets: GPUColorTargetState[]\n) {\n  return `\n    // testValue  : ${testValue}\n    // actualLimit: ${actualLimit}\n    // sampleCount: ${sampleCount}\n    // targets:\n    ${(() => {\n      let offset = 0;\n      return targets\n        .map(({ format }) => {\n          const { renderTargetPixelByteCost, renderTargetComponentAlignment } = kTextureFormatInfo[\n            format\n          ];\n          offset = align(offset, renderTargetComponentAlignment!);\n          const s = `//   ${format.padEnd(11)} (offset: ${offset\n            .toString()\n            .padStart(\n              2\n            )}, align: ${renderTargetComponentAlignment}, size: ${renderTargetPixelByteCost})`;\n          offset += renderTargetPixelByteCost!;\n          return s;\n        })\n        .join('\\n    ');\n    })()}\n  `;\n}\n\nfunction getPipelineDescriptor(\n  device: GPUDevice,\n  actualLimit: number,\n  interleaveFormat: GPUTextureFormat,\n  sampleCount: number,\n  testValue: number\n): { pipelineDescriptor: GPURenderPipelineDescriptor; code: string } | undefined {\n  const targets = getAttachments(interleaveFormat, testValue);\n  if (!targets) {\n    return;\n  }\n\n  const code = `\n    ${getDescription(testValue, actualLimit, sampleCount, targets)}\n    @vertex fn vs() -> @builtin(position) vec4f {\n      return vec4f(0);\n    }\n\n    @fragment fn fs() -> @location(0) vec4f {\n      return vec4f(0);\n    }\n  `;\n  const module = device.createShaderModule({ code });\n  const pipelineDescriptor: GPURenderPipelineDescriptor = {\n    layout: 'auto',\n    vertex: {\n      module,\n      entryPoint: 'vs',\n    },\n    fragment: {\n      module,\n      entryPoint: 'fs',\n      targets,\n    },\n    multisample: {\n      count: sampleCount,\n    },\n  };\n  return { pipelineDescriptor, code };\n}\n\nfunction createTextures(t: LimitTestsImpl, targets: GPUColorTargetState[]) {\n  return targets.map(({ format }) =>\n    t.trackForCleanup(\n      t.device.createTexture({\n        size: [1, 1],\n        format,\n        usage: GPUTextureUsage.RENDER_ATTACHMENT,\n      })\n    )\n  );\n}\n\nconst limit = 'maxColorAttachmentBytesPerSample';\nexport const { g, description } = makeLimitTestGroup(limit);\n\ng.test('createRenderPipeline,at_over')\n  .desc(`Test using at and over ${limit} limit in createRenderPipeline`)\n  .params(\n    kMaximumLimitBaseParams\n      .combine('maxColorAttachmentsLimitMode', kLimitModes)\n      .combine('sampleCount', kTextureSampleCounts)\n      .combine('interleaveFormat', kInterleaveFormats)\n  )\n  .fn(async t => {\n    const {\n      limitTest,\n      testValueName,\n      maxColorAttachmentsLimitMode,\n      sampleCount,\n      interleaveFormat,\n    } = t.params;\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, actualLimit, shouldError }) => {\n        const result = getPipelineDescriptor(\n          device,\n          actualLimit,\n          interleaveFormat,\n          sampleCount,\n          testValue\n        );\n        if (!result) {\n          return;\n        }\n        const { pipelineDescriptor, code } = result;\n\n        await t.expectValidationError(\n          () => {\n            device.createRenderPipeline(pipelineDescriptor);\n          },\n          shouldError,\n          code\n        );\n      },\n      { maxColorAttachments: maxColorAttachmentsLimitMode }\n    );\n  });\n\ng.test('createRenderPipelineAsync,at_over')\n  .desc(`Test using at and over ${limit} limit in createRenderPipelineAsync`)\n  .params(\n    kMaximumLimitBaseParams\n      .combine('maxColorAttachmentsLimitMode', kLimitModes)\n      .combine('sampleCount', kTextureSampleCounts)\n      .combine('interleaveFormat', kInterleaveFormats)\n  )\n  .fn(async t => {\n    const {\n      limitTest,\n      testValueName,\n      maxColorAttachmentsLimitMode,\n      sampleCount,\n      interleaveFormat,\n    } = t.params;\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, actualLimit, shouldError }) => {\n        const result = getPipelineDescriptor(\n          device,\n          actualLimit,\n          interleaveFormat,\n          sampleCount,\n          testValue\n        );\n        if (!result) {\n          return;\n        }\n        const { pipelineDescriptor, code } = result;\n\n        await t.shouldRejectConditionally(\n          'GPUPipelineError',\n          device.createRenderPipelineAsync(pipelineDescriptor),\n          shouldError,\n          code\n        );\n      },\n      { maxColorAttachments: maxColorAttachmentsLimitMode }\n    );\n  });\n\ng.test('beginRenderPass,at_over')\n  .desc(`Test using at and over ${limit} limit in beginRenderPass`)\n  .params(\n    kMaximumLimitBaseParams\n      .combine('maxColorAttachmentsLimitMode', kLimitModes)\n      .combine('sampleCount', kTextureSampleCounts)\n      .combine('interleaveFormat', kInterleaveFormats)\n  )\n  .fn(async t => {\n    const {\n      limitTest,\n      testValueName,\n      maxColorAttachmentsLimitMode,\n      sampleCount,\n      interleaveFormat,\n    } = t.params;\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, actualLimit, shouldError }) => {\n        const targets = getAttachments(interleaveFormat, testValue);\n        const maxColorAttachments = device.limits.maxColorAttachments;\n        if (targets.length > maxColorAttachments) {\n          return;\n        }\n\n        const encoder = device.createCommandEncoder();\n        const textures = createTextures(t, targets);\n\n        const pass = encoder.beginRenderPass({\n          colorAttachments: range(testValue, i => ({\n            view: textures[i].createView(),\n            loadOp: 'clear',\n            storeOp: 'store',\n          })),\n        });\n        pass.end();\n\n        await t.expectValidationError(\n          () => {\n            encoder.finish();\n          },\n          shouldError,\n          getDescription(testValue, actualLimit, sampleCount, targets)\n        );\n      },\n      { maxColorAttachments: maxColorAttachmentsLimitMode }\n    );\n  });\n\ng.test('createRenderBundle,at_over')\n  .desc(`Test using at and over ${limit} limit in createRenderBundle`)\n  .params(\n    kMaximumLimitBaseParams\n      .combine('maxColorAttachmentsLimitMode', kLimitModes)\n      .combine('sampleCount', kTextureSampleCounts)\n      .combine('interleaveFormat', kInterleaveFormats)\n  )\n  .fn(async t => {\n    const {\n      limitTest,\n      testValueName,\n      maxColorAttachmentsLimitMode,\n      sampleCount,\n      interleaveFormat,\n    } = t.params;\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, actualLimit, shouldError }) => {\n        const targets = getAttachments(interleaveFormat, testValue);\n        const maxColorAttachments = device.limits.maxColorAttachments;\n        if (targets.length > maxColorAttachments) {\n          return;\n        }\n\n        await t.expectValidationError(\n          () => {\n            device.createRenderBundleEncoder({\n              colorFormats: targets.map(({ format }) => format),\n            });\n          },\n          shouldError,\n          getDescription(testValue, actualLimit, sampleCount, targets)\n        );\n      },\n      { maxColorAttachments: maxColorAttachmentsLimitMode }\n    );\n  });\n"],"mappings":"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"}