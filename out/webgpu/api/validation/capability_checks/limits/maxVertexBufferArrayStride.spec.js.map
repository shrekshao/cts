{"version":3,"file":"maxVertexBufferArrayStride.spec.js","names":["roundDown","kMaximumLimitBaseParams","makeLimitTestGroup","getPipelineDescriptor","device","testValue","code","module","createShaderModule","layout","vertex","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","format","kMinAttributeStride","getDeviceLimitToRequest","limitValueTest","defaultLimit","maximumLimit","Math","min","getTestValue","testValueName","requestedLimit","getDeviceLimitToRequestAndValueToTest","limit","g","description","test","desc","params","fn","t","limitTest","adapterLimit","testDeviceWithSpecificLimits","shouldError","pipelineDescriptor","expectValidationError","createRenderPipeline","shouldRejectConditionally","createRenderPipelineAsync"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/maxVertexBufferArrayStride.spec.ts"],"sourcesContent":["import { roundDown } from '../../../../util/math.js';\n\nimport {\n  kMaximumLimitBaseParams,\n  makeLimitTestGroup,\n  MaximumLimitValueTest,\n  MaximumTestValue,\n} from './limit_utils.js';\n\nfunction getPipelineDescriptor(device: GPUDevice, testValue: number): GPURenderPipelineDescriptor {\n  const code = `\n  @vertex fn vs(@location(0) v: f32) -> @builtin(position) vec4f {\n    return vec4f(v);\n  }\n  `;\n  const module = device.createShaderModule({ code });\n  return {\n    layout: 'auto',\n    vertex: {\n      module,\n      entryPoint: 'vs',\n      buffers: [\n        {\n          arrayStride: testValue,\n          attributes: [\n            {\n              shaderLocation: 0,\n              offset: 0,\n              format: 'float32',\n            },\n          ],\n        },\n      ],\n    },\n  };\n}\n\nconst kMinAttributeStride = 4;\n\nfunction getDeviceLimitToRequest(\n  limitValueTest: MaximumLimitValueTest,\n  defaultLimit: number,\n  maximumLimit: number\n) {\n  switch (limitValueTest) {\n    case 'atDefault':\n      return defaultLimit;\n    case 'underDefault':\n      return defaultLimit - kMinAttributeStride;\n    case 'betweenDefaultAndMaximum':\n      return Math.min(\n        defaultLimit,\n        roundDown(((defaultLimit + maximumLimit) / 2) | 0, kMinAttributeStride)\n      );\n    case 'atMaximum':\n      return maximumLimit;\n    case 'overMaximum':\n      return maximumLimit + kMinAttributeStride;\n  }\n}\n\nfunction getTestValue(testValueName: MaximumTestValue, requestedLimit: number) {\n  switch (testValueName) {\n    case 'atLimit':\n      return requestedLimit;\n    case 'overLimit':\n      return requestedLimit + kMinAttributeStride;\n  }\n}\n\nfunction getDeviceLimitToRequestAndValueToTest(\n  limitValueTest: MaximumLimitValueTest,\n  testValueName: MaximumTestValue,\n  defaultLimit: number,\n  maximumLimit: number\n) {\n  const requestedLimit = getDeviceLimitToRequest(limitValueTest, defaultLimit, maximumLimit);\n  return {\n    requestedLimit,\n    testValue: getTestValue(testValueName, requestedLimit),\n  };\n}\n\n/*\nNote: We need to request +4 (vs the default +1) because otherwise we may trigger the wrong validation\nof the arrayStride not being a multiple of 4\n*/\nconst limit = 'maxVertexBufferArrayStride';\nexport const { g, description } = makeLimitTestGroup(limit);\n\ng.test('createRenderPipeline,at_over')\n  .desc(`Test using createRenderPipeline at and over ${limit} limit`)\n  .params(kMaximumLimitBaseParams)\n  .fn(async t => {\n    const { limitTest, testValueName } = t.params;\n    const { defaultLimit, adapterLimit: maximumLimit } = t;\n    const { requestedLimit, testValue } = getDeviceLimitToRequestAndValueToTest(\n      limitTest,\n      testValueName,\n      defaultLimit,\n      maximumLimit\n    );\n\n    await t.testDeviceWithSpecificLimits(\n      requestedLimit,\n      testValue,\n      async ({ device, testValue, shouldError }) => {\n        const pipelineDescriptor = getPipelineDescriptor(device, testValue);\n\n        await t.expectValidationError(() => {\n          device.createRenderPipeline(pipelineDescriptor);\n        }, shouldError);\n      }\n    );\n  });\n\ng.test('createRenderPipelineAsync,at_over')\n  .desc(`Test using createRenderPipelineAsync at and over ${limit} limit`)\n  .params(kMaximumLimitBaseParams)\n  .fn(async t => {\n    const { limitTest, testValueName } = t.params;\n    const { defaultLimit, adapterLimit: maximumLimit } = t;\n    const { requestedLimit, testValue } = getDeviceLimitToRequestAndValueToTest(\n      limitTest,\n      testValueName,\n      defaultLimit,\n      maximumLimit\n    );\n    await t.testDeviceWithSpecificLimits(\n      requestedLimit,\n      testValue,\n      async ({ device, testValue, shouldError }) => {\n        const pipelineDescriptor = getPipelineDescriptor(device, testValue);\n        await t.shouldRejectConditionally(\n          'GPUPipelineError',\n          device.createRenderPipelineAsync(pipelineDescriptor),\n          shouldError\n        );\n      }\n    );\n  });\n"],"mappings":"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"}