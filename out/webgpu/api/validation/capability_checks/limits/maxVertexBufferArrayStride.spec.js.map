{"version":3,"file":"maxVertexBufferArrayStride.spec.js","names":["roundDown","kLimitBaseParams","makeLimitTestGroup","getPipelineDescriptor","device","testValue","code","module","createShaderModule","layout","vertex","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","format","kMinAttributeStride","getDeviceLimitToRequest","limitValueTest","defaultLimit","maximumLimit","Math","min","getTestValue","testValueName","requestedLimit","getDeviceLimitToRequestAndValueToTest","limit","g","description","test","desc","params","fn","t","limitTest","adapter","getAdapterAndLimits","testDeviceWithSpecificLimits","shouldError","pipelineDescriptor","expectValidationError","createRenderPipeline","shouldRejectConditionally","createRenderPipelineAsync"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/maxVertexBufferArrayStride.spec.ts"],"sourcesContent":["import { roundDown } from '../../../../util/math.js';\n\nimport { kLimitBaseParams, makeLimitTestGroup, LimitValueTest, TestValue } from './limit_utils.js';\n\nfunction getPipelineDescriptor(device: GPUDevice, testValue: number): GPURenderPipelineDescriptor {\n  const code = `\n  @vertex fn vs(@location(0) v: f32) -> @builtin(position) vec4f {\n    return vec4f(v);\n  }\n  `;\n  const module = device.createShaderModule({ code });\n  return {\n    layout: 'auto',\n    vertex: {\n      module,\n      entryPoint: 'vs',\n      buffers: [\n        {\n          arrayStride: testValue,\n          attributes: [\n            {\n              shaderLocation: 0,\n              offset: 0,\n              format: 'float32',\n            },\n          ],\n        },\n      ],\n    },\n  };\n}\n\nconst kMinAttributeStride = 4;\n\nfunction getDeviceLimitToRequest(\n  limitValueTest: LimitValueTest,\n  defaultLimit: number,\n  maximumLimit: number\n) {\n  switch (limitValueTest) {\n    case 'atDefault':\n      return defaultLimit;\n    case 'underDefault':\n      return defaultLimit - kMinAttributeStride;\n    case 'betweenDefaultAndMaximum':\n      return Math.min(\n        defaultLimit,\n        roundDown(((defaultLimit + maximumLimit) / 2) | 0, kMinAttributeStride)\n      );\n    case 'atMaximum':\n      return maximumLimit;\n    case 'overMaximum':\n      return maximumLimit + kMinAttributeStride;\n  }\n}\n\nfunction getTestValue(testValueName: TestValue, requestedLimit: number) {\n  switch (testValueName) {\n    case 'atLimit':\n      return requestedLimit;\n    case 'overLimit':\n      return requestedLimit + kMinAttributeStride;\n  }\n}\n\nfunction getDeviceLimitToRequestAndValueToTest(\n  limitValueTest: LimitValueTest,\n  testValueName: TestValue,\n  defaultLimit: number,\n  maximumLimit: number\n) {\n  const requestedLimit = getDeviceLimitToRequest(limitValueTest, defaultLimit, maximumLimit);\n  return {\n    requestedLimit,\n    testValue: getTestValue(testValueName, requestedLimit),\n  };\n}\n\n/*\nNote: We need to request +4 (vs the default +1) because otherwise we may trigger the wrong validation\nof the arrayStride not being a multiple of 4\n*/\nconst limit = 'maxVertexBufferArrayStride';\nexport const { g, description } = makeLimitTestGroup(limit);\n\ng.test('createRenderPipeline,at_over')\n  .desc(`Test using createRenderPipeline at and over ${limit} limit`)\n  .params(kLimitBaseParams)\n  .fn(async t => {\n    const { limitTest, testValueName } = t.params;\n    const { adapter, defaultLimit, maximumLimit } = await t.getAdapterAndLimits();\n    const { requestedLimit, testValue } = getDeviceLimitToRequestAndValueToTest(\n      limitTest,\n      testValueName,\n      defaultLimit,\n      maximumLimit\n    );\n\n    await t.testDeviceWithSpecificLimits(\n      adapter,\n      requestedLimit,\n      testValue,\n      async ({ device, testValue, shouldError }) => {\n        const pipelineDescriptor = getPipelineDescriptor(device, testValue);\n\n        await t.expectValidationError(() => {\n          device.createRenderPipeline(pipelineDescriptor);\n        }, shouldError);\n      }\n    );\n  });\n\ng.test('createRenderPipelineAsync,at_over')\n  .desc(`Test using createRenderPipelineAsync at and over ${limit} limit`)\n  .params(kLimitBaseParams)\n  .fn(async t => {\n    const { limitTest, testValueName } = t.params;\n    const { adapter, defaultLimit, maximumLimit } = await t.getAdapterAndLimits();\n    const { requestedLimit, testValue } = getDeviceLimitToRequestAndValueToTest(\n      limitTest,\n      testValueName,\n      defaultLimit,\n      maximumLimit\n    );\n    await t.testDeviceWithSpecificLimits(\n      adapter,\n      requestedLimit,\n      testValue,\n      async ({ device, testValue, shouldError }) => {\n        const pipelineDescriptor = getPipelineDescriptor(device, testValue);\n        await t.shouldRejectConditionally(\n          'GPUPipelineError',\n          device.createRenderPipelineAsync(pipelineDescriptor),\n          shouldError\n        );\n      }\n    );\n  });\n"],"mappings":"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"}