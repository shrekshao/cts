{"version":3,"file":"maxVertexBuffers.spec.js","names":["keysOf","range","kRenderEncoderTypes","kLimitBaseParams","makeLimitTestGroup","PipelineTypes","withoutLocations","withLocations","kPipelineTypes","getPipelineDescriptor","device","pipelineType","testValue","code","i","join","module","createShaderModule","layout","vertex","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","format","limit","g","description","test","desc","params","combine","fn","t","limitTest","testValueName","testDeviceWithRequestedLimits","shouldError","pipelineDescriptor","expectValidationError","createRenderPipeline","shouldRejectConditionally","createRenderPipelineAsync","encoderType","actualLimit","lastIndex","buffer","createBuffer","size","usage","GPUBufferUsage","VERTEX","testGPURenderCommandsMixin","mixin","setVertexBuffer","destroy"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/maxVertexBuffers.spec.ts"],"sourcesContent":["import { keysOf } from '../../../../../common/util/data_tables.js';\nimport { range } from '../../../../../common/util/util.js';\n\nimport { kRenderEncoderTypes, kLimitBaseParams, makeLimitTestGroup } from './limit_utils.js';\n\nconst PipelineTypes = {\n  withoutLocations: true,\n  withLocations: true,\n};\ntype PipelineType = keyof typeof PipelineTypes;\nconst kPipelineTypes = keysOf(PipelineTypes);\n\nfunction getPipelineDescriptor(\n  device: GPUDevice,\n  pipelineType: PipelineType,\n  testValue: number\n): GPURenderPipelineDescriptor {\n  const code =\n    pipelineType === 'withLocations'\n      ? `\n        struct VSInput {\n          ${range(testValue, i => `@location(${i}) p${i}: f32,`).join('\\n')}\n        }\n        @vertex fn vs(v: VSInput) -> @builtin(position) vec4f {\n          let x = ${range(testValue, i => `v.p${i}`).join(' + ')};\n          return vec4f(x, 0, 0, 1);\n        }\n        `\n      : `\n        @vertex fn vs() -> @builtin(position) vec4f {\n          return vec4f(0);\n        }\n        `;\n  const module = device.createShaderModule({ code });\n  return {\n    layout: 'auto',\n    vertex: {\n      module,\n      entryPoint: 'vs',\n      buffers: range(testValue, i => ({\n        arrayStride: 32,\n        attributes: [{ shaderLocation: i, offset: 0, format: 'float32' }],\n      })),\n    },\n  };\n}\n\nconst limit = 'maxVertexBuffers';\nexport const { g, description } = makeLimitTestGroup(limit);\n\ng.test('createRenderPipeline,at_over')\n  .desc(`Test using at and over ${limit} limit in createRenderPipeline`)\n  .params(kLimitBaseParams.combine('pipelineType', kPipelineTypes))\n  .fn(async t => {\n    const { limitTest, testValueName, pipelineType } = t.params;\n    await t.testDeviceWithRequestedLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError }) => {\n        const pipelineDescriptor = getPipelineDescriptor(device, pipelineType, testValue);\n\n        await t.expectValidationError(() => {\n          device.createRenderPipeline(pipelineDescriptor);\n        }, shouldError);\n      }\n    );\n  });\n\ng.test('createRenderPipelineAsync,at_over')\n  .desc(`Test using at and over ${limit} limit in createRenderPipelineAsync`)\n  .params(kLimitBaseParams.combine('pipelineType', kPipelineTypes))\n  .fn(async t => {\n    const { limitTest, testValueName, pipelineType } = t.params;\n    await t.testDeviceWithRequestedLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError }) => {\n        const pipelineDescriptor = getPipelineDescriptor(device, pipelineType, testValue);\n        await t.shouldRejectConditionally(\n          'GPUPipelineError',\n          device.createRenderPipelineAsync(pipelineDescriptor),\n          shouldError\n        );\n      }\n    );\n  });\n\ng.test('setVertexBuffer,at_over')\n  .desc(`Test using at and over ${limit} limit in setVertexBuffer`)\n  .params(kLimitBaseParams.combine('encoderType', kRenderEncoderTypes))\n  .fn(async t => {\n    const { limitTest, testValueName, encoderType } = t.params;\n    await t.testDeviceWithRequestedLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError, actualLimit }) => {\n        const lastIndex = testValue - 1;\n\n        const buffer = device.createBuffer({\n          size: 16,\n          usage: GPUBufferUsage.VERTEX,\n        });\n\n        await t.testGPURenderCommandsMixin(\n          encoderType,\n          ({ mixin }) => {\n            mixin.setVertexBuffer(lastIndex, buffer);\n          },\n          shouldError,\n          `lastIndex: ${lastIndex}, actualLimit: ${actualLimit}, shouldError: ${shouldError}`\n        );\n\n        buffer.destroy();\n      }\n    );\n  });\n"],"mappings":"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"}