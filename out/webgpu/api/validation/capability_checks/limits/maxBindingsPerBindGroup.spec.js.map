{"version":3,"file":"maxBindingsPerBindGroup.spec.js","names":["kCreatePipelineTypes","kCreatePipelineAsyncTypes","kMaximumLimitBaseParams","makeLimitTestGroup","limit","g","description","test","desc","params","fn","t","limitTest","testValueName","testDeviceWithRequestedMaximumLimits","device","testValue","shouldError","expectValidationError","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","VERTEX","buffer","combine","createPipelineType","lastIndex","code","getBindingIndexWGSLForPipelineType","module","createShaderModule","createPipeline","createPipelineAsyncType","promise","createPipelineAsync","shouldRejectConditionally","adapter","adapterLimit","maxBindingsPerShaderStage","limits","maxSampledTexturesPerShaderStage","maxSamplersPerShaderStage","maxStorageBuffersPerShaderStage","maxStorageTexturesPerShaderStage","maxUniformBuffersPerShaderStage","maxShaderStagesPerPipeline","minMaxBindingsPerBindGroup","expect"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/maxBindingsPerBindGroup.spec.ts"],"sourcesContent":["import {\n  kCreatePipelineTypes,\n  kCreatePipelineAsyncTypes,\n  kMaximumLimitBaseParams,\n  makeLimitTestGroup,\n} from './limit_utils.js';\n\nconst limit = 'maxBindingsPerBindGroup';\nexport const { g, description } = makeLimitTestGroup(limit);\n\ng.test('createBindGroupLayout,at_over')\n  .desc(`Test using createBindGroupLayout at and over ${limit} limit`)\n  .params(kMaximumLimitBaseParams)\n  .fn(async t => {\n    const { limitTest, testValueName } = t.params;\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError }) => {\n        await t.expectValidationError(() => {\n          device.createBindGroupLayout({\n            entries: [\n              {\n                binding: testValue - 1,\n                visibility: GPUShaderStage.VERTEX,\n                buffer: {},\n              },\n            ],\n          });\n        }, shouldError);\n      }\n    );\n  });\n\ng.test('createPipeline,at_over')\n  .desc(`Test using createRenderPipeline and createComputePipeline at and over ${limit} limit`)\n  .params(kMaximumLimitBaseParams.combine('createPipelineType', kCreatePipelineTypes))\n  .fn(async t => {\n    const { limitTest, testValueName, createPipelineType } = t.params;\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError }) => {\n        const lastIndex = testValue - 1;\n\n        const code = t.getBindingIndexWGSLForPipelineType(createPipelineType, lastIndex);\n        const module = device.createShaderModule({ code });\n\n        await t.expectValidationError(() => {\n          t.createPipeline(createPipelineType, module);\n        }, shouldError);\n      }\n    );\n  });\n\ng.test('createPipelineAsync,at_over')\n  .desc(\n    `Test using createRenderPipelineAsync and createComputePipelineAsync at and over ${limit} limit`\n  )\n  .params(kMaximumLimitBaseParams.combine('createPipelineAsyncType', kCreatePipelineAsyncTypes))\n  .fn(async t => {\n    const { limitTest, testValueName, createPipelineAsyncType } = t.params;\n\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError }) => {\n        const lastIndex = testValue - 1;\n\n        const code = t.getBindingIndexWGSLForPipelineType(createPipelineAsyncType, lastIndex);\n        const module = device.createShaderModule({ code });\n\n        const promise = t.createPipelineAsync(createPipelineAsyncType, module);\n        await t.shouldRejectConditionally('GPUPipelineError', promise, shouldError);\n      }\n    );\n  });\n\ng.test('validate')\n  .desc(`Test ${limit} matches the spec limits`)\n  .fn(t => {\n    const { adapter, adapterLimit } = t;\n    const maxBindingsPerShaderStage =\n      adapter.limits.maxSampledTexturesPerShaderStage +\n      adapter.limits.maxSamplersPerShaderStage +\n      adapter.limits.maxStorageBuffersPerShaderStage +\n      adapter.limits.maxStorageTexturesPerShaderStage +\n      adapter.limits.maxUniformBuffersPerShaderStage;\n    const maxShaderStagesPerPipeline = 2;\n    const minMaxBindingsPerBindGroup = maxBindingsPerShaderStage * maxShaderStagesPerPipeline;\n    t.expect(\n      adapterLimit >= minMaxBindingsPerBindGroup,\n      `maxBindingsPerBindGroup(${adapterLimit}) >= maxBindingsPerShaderStage(${maxBindingsPerShaderStage}) * maxShaderStagesPerPipeline(${maxShaderStagesPerPipeline} = (${minMaxBindingsPerBindGroup}))`\n    );\n  });\n"],"mappings":"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"}