{"version":3,"sources":["../../../../../src/webgpu/api/validation/render_pipeline/inter_stage.spec.ts"],"names":["description","makeTestGroup","assert","range","CreateRenderPipelineValidationTest","getVarName","i","InterStageMatchingValidationTest","getVertexStateWithOutputs","outputs","module","device","createShaderModule","code","map","v","replace","join","entryPoint","getFragmentStateWithInputs","inputs","hasBuiltinPosition","targets","format","getDescriptorWithStates","vertex","fragment","layout","g","test","desc","params","u","combine","combineWithParams","_success","fn","t","isAsync","descriptor","doCreateRenderPipelineTest","unimplemented","output","input","locationDelta","maxInterStageShaderVariables","limits","location","numScalarDelta","topology","numScalarComponents","maxInterStageShaderComponents","numVec4","Math","floor","numTrailingScalars","numUserDefinedInterStageVariables","typeString","push","primitive","useExtraBuiltinInputs"],"mappings":"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","sourcesContent":["export const description = `\nInterface matching between vertex and fragment shader validation for createRenderPipeline.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, range } from '../../../../common/util/util.js';\n\nimport { CreateRenderPipelineValidationTest } from './common.js';\n\nfunction getVarName(i: number) {\n  return `v${i}`;\n}\n\nclass InterStageMatchingValidationTest extends CreateRenderPipelineValidationTest {\n  getVertexStateWithOutputs(outputs: string[]): GPUVertexState {\n    return {\n      module: this.device.createShaderModule({\n        code: `\n        struct A {\n            ${outputs.map((v, i) => v.replace('__', getVarName(i))).join(',\\n')},\n            @builtin(position) pos: vec4<f32>,\n        }\n        @vertex fn main() -> A {\n            var vertexOut: A;\n            vertexOut.pos = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n            return vertexOut;\n        }\n        `,\n      }),\n      entryPoint: 'main',\n    };\n  }\n\n  getFragmentStateWithInputs(\n    inputs: string[],\n    hasBuiltinPosition: boolean = false\n  ): GPUFragmentState {\n    return {\n      targets: [{ format: 'rgba8unorm' }],\n      module: this.device.createShaderModule({\n        code: `\n        struct B {\n            ${inputs.map((v, i) => v.replace('__', getVarName(i))).join(',\\n')},\n            ${hasBuiltinPosition ? '@builtin(position) pos: vec4<f32>' : ''}\n        }\n        @fragment fn main(fragmentIn: B) -> @location(0) vec4<f32> {\n            return vec4<f32>(1.0, 1.0, 1.0, 1.0);\n        }\n        `,\n      }),\n      entryPoint: 'main',\n    };\n  }\n\n  getDescriptorWithStates(\n    vertex: GPUVertexState,\n    fragment: GPUFragmentState\n  ): GPURenderPipelineDescriptor {\n    return {\n      layout: 'auto',\n      vertex,\n      fragment,\n    };\n  }\n}\n\nexport const g = makeTestGroup(InterStageMatchingValidationTest);\n\ng.test('location,mismatch')\n  .desc(`Tests that missing declaration at the same location should fail validation.`)\n  .params(u =>\n    u.combine('isAsync', [false, true]).combineWithParams([\n      { outputs: ['@location(0) __: f32'], inputs: ['@location(0) __: f32'], _success: true },\n      { outputs: ['@location(0) __: f32'], inputs: ['@location(1) __: f32'], _success: false },\n      { outputs: ['@location(1) __: f32'], inputs: ['@location(0) __: f32'], _success: false },\n      {\n        outputs: ['@location(0) __: f32', '@location(1) __: f32'],\n        inputs: ['@location(1) __: f32', '@location(0) __: f32'],\n        _success: true,\n      },\n      {\n        outputs: ['@location(1) __: f32', '@location(0) __: f32'],\n        inputs: ['@location(0) __: f32', '@location(1) __: f32'],\n        _success: true,\n      },\n    ])\n  )\n  .fn(async t => {\n    const { isAsync, outputs, inputs, _success } = t.params;\n\n    const descriptor = t.getDescriptorWithStates(\n      t.getVertexStateWithOutputs(outputs),\n      t.getFragmentStateWithInputs(inputs)\n    );\n\n    t.doCreateRenderPipelineTest(isAsync, _success, descriptor);\n  });\n\ng.test('location,superset')\n  .desc(`TODO: implement after spec is settled: https://github.com/gpuweb/gpuweb/issues/2038`)\n  .unimplemented();\n\ng.test('location,subset')\n  .desc(`Tests that validation should fail when vertex output is a subset of fragment input.`)\n  .params(u => u.combine('isAsync', [false, true]))\n  .fn(async t => {\n    const { isAsync } = t.params;\n\n    const descriptor = t.getDescriptorWithStates(\n      t.getVertexStateWithOutputs(['@location(0) vout0: f32']),\n      t.getFragmentStateWithInputs(['@location(0) fin0: f32', '@location(1) fin1: f32'])\n    );\n\n    t.doCreateRenderPipelineTest(isAsync, false, descriptor);\n  });\n\ng.test('type')\n  .desc(\n    `Tests that validation should fail when type of vertex output and fragment input at the same location doesn't match.`\n  )\n  .params(u =>\n    u.combine('isAsync', [false, true]).combineWithParams([\n      { output: 'f32', input: 'f32' },\n      { output: 'i32', input: 'f32' },\n      { output: 'u32', input: 'f32' },\n      { output: 'u32', input: 'i32' },\n      { output: 'i32', input: 'u32' },\n      { output: 'vec2<f32>', input: 'vec2<f32>' },\n      { output: 'vec3<f32>', input: 'vec2<f32>' },\n      { output: 'vec2<f32>', input: 'vec3<f32>' },\n      { output: 'vec2<f32>', input: 'f32' },\n      { output: 'f32', input: 'vec2<f32>' },\n    ])\n  )\n  .fn(async t => {\n    const { isAsync, output, input } = t.params;\n\n    const descriptor = t.getDescriptorWithStates(\n      t.getVertexStateWithOutputs([`@location(0) @interpolate(flat) vout0: ${output}`]),\n      t.getFragmentStateWithInputs([`@location(0) @interpolate(flat) fin0: ${input}`])\n    );\n\n    t.doCreateRenderPipelineTest(isAsync, output === input, descriptor);\n  });\n\ng.test('interpolation_type')\n  .desc(\n    `Tests that validation should fail when interpolation type of vertex output and fragment input at the same location doesn't match.`\n  )\n  .params(u =>\n    u.combine('isAsync', [false, true]).combineWithParams([\n      // default is @interpolate(perspective, center)\n      { output: '', input: '' },\n      { output: '', input: '@interpolate(perspective)', _success: true },\n      { output: '', input: '@interpolate(perspective, center)', _success: true },\n      { output: '@interpolate(perspective)', input: '', _success: true },\n      { output: '', input: '@interpolate(linear)' },\n      { output: '@interpolate(perspective)', input: '@interpolate(perspective)' },\n      { output: '@interpolate(linear)', input: '@interpolate(perspective)' },\n      { output: '@interpolate(flat)', input: '@interpolate(perspective)' },\n      { output: '@interpolate(linear)', input: '@interpolate(flat)' },\n      { output: '@interpolate(linear, center)', input: '@interpolate(linear, center)' },\n    ])\n  )\n  .fn(async t => {\n    const { isAsync, output, input, _success } = t.params;\n\n    const descriptor = t.getDescriptorWithStates(\n      t.getVertexStateWithOutputs([`@location(0) ${output} vout0: f32`]),\n      t.getFragmentStateWithInputs([`@location(0) ${input} fin0: f32`])\n    );\n\n    t.doCreateRenderPipelineTest(isAsync, _success ?? output === input, descriptor);\n  });\n\ng.test('interpolation_sampling')\n  .desc(\n    `Tests that validation should fail when interpolation sampling of vertex output and fragment input at the same location doesn't match.`\n  )\n  .params(u =>\n    u.combine('isAsync', [false, true]).combineWithParams([\n      // default is @interpolate(perspective, center)\n      { output: '@interpolate(perspective)', input: '@interpolate(perspective)' },\n      {\n        output: '@interpolate(perspective)',\n        input: '@interpolate(perspective, center)',\n        _success: true,\n      },\n      { output: '@interpolate(linear, center)', input: '@interpolate(linear)', _success: true },\n      { output: '@interpolate(flat)', input: '@interpolate(flat)' },\n      { output: '@interpolate(perspective)', input: '@interpolate(perspective, sample)' },\n      { output: '@interpolate(perspective, center)', input: '@interpolate(perspective, sample)' },\n      {\n        output: '@interpolate(perspective, center)',\n        input: '@interpolate(perspective, centroid)',\n      },\n      { output: '@interpolate(perspective, centroid)', input: '@interpolate(perspective)' },\n    ])\n  )\n  .fn(async t => {\n    const { isAsync, output, input, _success } = t.params;\n\n    const descriptor = t.getDescriptorWithStates(\n      t.getVertexStateWithOutputs([`@location(0) ${output} vout0: f32`]),\n      t.getFragmentStateWithInputs([`@location(0) ${input} fin0: f32`])\n    );\n\n    t.doCreateRenderPipelineTest(isAsync, _success ?? output === input, descriptor);\n  });\n\ng.test('max_shader_variable_location')\n  .desc(\n    `Tests that validation should fail when there is location of user-defined output/input variable >= device.limits.maxInterStageShaderVariables`\n  )\n  .params(u =>\n    u\n      .combine('isAsync', [false, true])\n      // User defined variable location = maxInterStageShaderVariables + locationDelta\n      .combine('locationDelta', [0, -1, -2])\n  )\n  .fn(async t => {\n    const { isAsync, locationDelta } = t.params;\n    const maxInterStageShaderVariables = t.device.limits.maxInterStageShaderVariables;\n    const location = maxInterStageShaderVariables + locationDelta;\n\n    const descriptor = t.getDescriptorWithStates(\n      t.getVertexStateWithOutputs([`@location(${location}) vout0: f32`]),\n      t.getFragmentStateWithInputs([`@location(${location}) fin0: f32`])\n    );\n\n    t.doCreateRenderPipelineTest(isAsync, location < maxInterStageShaderVariables, descriptor);\n  });\n\ng.test('max_components_count,output')\n  .desc(\n    `Tests that validation should fail when scalar components of all user-defined outputs > max vertex shader output components.`\n  )\n  .params(u =>\n    u.combine('isAsync', [false, true]).combineWithParams([\n      // Number of user-defined output scalar components in test shader = device.limits.maxInterStageShaderComponents + numScalarDelta.\n      { numScalarDelta: 0, topology: 'triangle-list', _success: true },\n      { numScalarDelta: 1, topology: 'triangle-list', _success: false },\n      { numScalarDelta: 0, topology: 'point-list', _success: false },\n      { numScalarDelta: -1, topology: 'point-list', _success: true },\n    ] as const)\n  )\n  .fn(async t => {\n    const { isAsync, numScalarDelta, topology, _success } = t.params;\n\n    const numScalarComponents = t.device.limits.maxInterStageShaderComponents + numScalarDelta;\n\n    const numVec4 = Math.floor(numScalarComponents / 4);\n    const numTrailingScalars = numScalarComponents % 4;\n    const numUserDefinedInterStageVariables = numTrailingScalars > 0 ? numVec4 + 1 : numVec4;\n\n    assert(numUserDefinedInterStageVariables <= t.device.limits.maxInterStageShaderVariables);\n\n    const outputs = range(numVec4, i => `@location(${i}) vout${i}: vec4<f32>`);\n    const inputs = range(numVec4, i => `@location(${i}) fin${i}: vec4<f32>`);\n\n    if (numTrailingScalars > 0) {\n      const typeString = numTrailingScalars === 1 ? 'f32' : `vec${numTrailingScalars}<f32>`;\n      outputs.push(`@location(${numVec4}) vout${numVec4}: ${typeString}`);\n      inputs.push(`@location(${numVec4}) fin${numVec4}: ${typeString}`);\n    }\n\n    const descriptor = t.getDescriptorWithStates(\n      t.getVertexStateWithOutputs(outputs),\n      t.getFragmentStateWithInputs(inputs)\n    );\n    descriptor.primitive = { topology };\n\n    t.doCreateRenderPipelineTest(isAsync, _success, descriptor);\n  });\n\ng.test('max_components_count,input')\n  .desc(\n    `Tests that validation should fail when scalar components of all user-defined inputs > max vertex shader output components.`\n  )\n  .params(u =>\n    u.combine('isAsync', [false, true]).combineWithParams([\n      // Number of user-defined input scalar components in test shader = device.limits.maxInterStageShaderComponents + numScalarDelta.\n      { numScalarDelta: 0, useExtraBuiltinInputs: false, _success: true },\n      { numScalarDelta: 1, useExtraBuiltinInputs: false, _success: false },\n      { numScalarDelta: 0, useExtraBuiltinInputs: true, _success: false },\n      { numScalarDelta: -3, useExtraBuiltinInputs: true, _success: true },\n      { numScalarDelta: -2, useExtraBuiltinInputs: true, _success: false },\n    ] as const)\n  )\n  .fn(async t => {\n    const { isAsync, numScalarDelta, useExtraBuiltinInputs, _success } = t.params;\n\n    const numScalarComponents = t.device.limits.maxInterStageShaderComponents + numScalarDelta;\n\n    const numVec4 = Math.floor(numScalarComponents / 4);\n    const numTrailingScalars = numScalarComponents % 4;\n    const numUserDefinedInterStageVariables = numTrailingScalars > 0 ? numVec4 + 1 : numVec4;\n\n    assert(numUserDefinedInterStageVariables <= t.device.limits.maxInterStageShaderVariables);\n\n    const outputs = range(numVec4, i => `@location(${i}) vout${i}: vec4<f32>`);\n    const inputs = range(numVec4, i => `@location(${i}) fin${i}: vec4<f32>`);\n\n    if (numTrailingScalars > 0) {\n      const typeString = numTrailingScalars === 1 ? 'f32' : `vec${numTrailingScalars}<f32>`;\n      outputs.push(`@location(${numVec4}) vout${numVec4}: ${typeString}`);\n      inputs.push(`@location(${numVec4}) fin${numVec4}: ${typeString}`);\n    }\n\n    if (useExtraBuiltinInputs) {\n      inputs.push(\n        '@builtin(front_facing) front_facing_in: bool',\n        '@builtin(sample_index) sample_index_in: u32',\n        '@builtin(sample_mask) sample_mask_in: u32'\n      );\n    }\n\n    const descriptor = t.getDescriptorWithStates(\n      t.getVertexStateWithOutputs(outputs),\n      t.getFragmentStateWithInputs(inputs, true)\n    );\n\n    t.doCreateRenderPipelineTest(isAsync, _success, descriptor);\n  });\n"],"file":"inter_stage.spec.js"}