{"version":3,"sources":["../../../../../src/webgpu/api/validation/render_pipeline/multisample_state.spec.ts"],"names":["description","makeTestGroup","kDefaultFragmentShaderCode","CreateRenderPipelineValidationTest","g","test","desc","params","u","combine","beginSubcases","fn","t","isAsync","count","descriptor","getDescriptor","multisample","alphaToCoverageEnabled","_success","doCreateRenderPipelineTest","hasSampleMaskOutput","fragmentShaderCode"],"mappings":"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","sourcesContent":["export const description = `\nThis test dedicatedly tests validation of GPUMultisampleState of createRenderPipeline.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { kDefaultFragmentShaderCode } from '../../../util/shader.js';\n\nimport { CreateRenderPipelineValidationTest } from './common.js';\n\nexport const g = makeTestGroup(CreateRenderPipelineValidationTest);\n\ng.test('count')\n  .desc(`If multisample.count must either be 1 or 4.`)\n  .params(u =>\n    u\n      .combine('isAsync', [false, true])\n      .beginSubcases()\n      .combine('count', [0, 1, 2, 3, 4, 8, 16, 1024])\n  )\n  .fn(async t => {\n    const { isAsync, count } = t.params;\n\n    const descriptor = t.getDescriptor({ multisample: { count, alphaToCoverageEnabled: false } });\n\n    const _success = count === 1 || count === 4;\n    t.doCreateRenderPipelineTest(isAsync, _success, descriptor);\n  });\n\ng.test('alpha_to_coverage,count')\n  .desc(\n    `If multisample.alphaToCoverageEnabled is true, multisample.count must be greater than 1, e.g. it can only be 4.`\n  )\n  .params(u =>\n    u\n      .combine('isAsync', [false, true])\n      .combine('alphaToCoverageEnabled', [false, true])\n      .beginSubcases()\n      .combine('count', [1, 4])\n  )\n  .fn(async t => {\n    const { isAsync, alphaToCoverageEnabled, count } = t.params;\n\n    const descriptor = t.getDescriptor({ multisample: { count, alphaToCoverageEnabled } });\n\n    const _success = alphaToCoverageEnabled ? count === 4 : count === 1 || count === 4;\n    t.doCreateRenderPipelineTest(isAsync, _success, descriptor);\n  });\n\ng.test('alpha_to_coverage,sample_mask')\n  .desc(\n    `If sample_mask builtin is a pipeline output of fragment, multisample.alphaToCoverageEnabled should be false.`\n  )\n  .params(u =>\n    u\n      .combine('isAsync', [false, true])\n      .combine('alphaToCoverageEnabled', [false, true])\n      .beginSubcases()\n      .combine('hasSampleMaskOutput', [false, true])\n  )\n  .fn(async t => {\n    const { isAsync, alphaToCoverageEnabled, hasSampleMaskOutput } = t.params;\n\n    const descriptor = t.getDescriptor({\n      multisample: { alphaToCoverageEnabled, count: 4 },\n      fragmentShaderCode: hasSampleMaskOutput\n        ? `\n      struct Output {\n        @builtin(sample_mask) mask_out: u32,\n        @location(0) color : vec4<f32>,\n      }\n      @fragment fn main() -> Output {\n        var o: Output;\n        // We need to make sure this sample_mask isn't optimized out even its value equals \"no op\".\n        o.mask_out = 0xFFFFFFFFu;\n        o.color = vec4<f32>(1.0, 1.0, 1.0, 1.0);\n        return o;\n      }`\n        : kDefaultFragmentShaderCode,\n    });\n\n    const _success = !hasSampleMaskOutput || !alphaToCoverageEnabled;\n    t.doCreateRenderPipelineTest(isAsync, _success, descriptor);\n  });\n"],"file":"multisample_state.spec.js"}