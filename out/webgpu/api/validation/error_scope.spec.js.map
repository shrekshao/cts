{"version":3,"sources":["../../../../src/webgpu/api/validation/error_scope.spec.ts"],"names":["description","Fixture","makeTestGroup","getGPU","assert","raceWithRejectOnTimeout","kErrorScopeFilters","kMaxUnsignedLongLongValue","ErrorScopeTests","_device","undefined","device","init","gpu","adapter","requestAdapter","requestDevice","generateError","filter","createBuffer","size","usage","GPUBufferUsage","COPY_SRC","COPY_DST","queue","submit","isInstanceOfError","error","GPUOutOfMemoryError","GPUValidationError","expectUncapturedError","fn","immediateAsyncExpectation","TIMEOUT_IN_MS","promise","Promise","resolve","eventListener","event","debug","addEventListener","once","g","test","desc","params","u","combine","t","errorType","errorFilter","pushErrorScope","uncapturedErrorEvent","expect","popErrorScope","shouldReject","stackDepth","unmatchedFilters","i","length","promises","push","errors","all","every","e","numErrors"],"mappings":"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","sourcesContent":["export const description = `\nError scope validation tests.\n\nNote these must create their own device, not use GPUTest (that one already has error scopes on it).\n\nTODO: (POSTV1) Test error scopes of different threads and make sure they go to the right place.\nTODO: (POSTV1) Test that unhandled errors go the right device, and nowhere if the device was dropped.\n`;\n\nimport { Fixture } from '../../../common/framework/fixture.js';\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { getGPU } from '../../../common/util/navigator_gpu.js';\nimport { assert, raceWithRejectOnTimeout } from '../../../common/util/util.js';\nimport { kErrorScopeFilters } from '../../capability_info.js';\nimport { kMaxUnsignedLongLongValue } from '../../constants.js';\n\nclass ErrorScopeTests extends Fixture {\n  _device: GPUDevice | undefined = undefined;\n\n  get device(): GPUDevice {\n    assert(this._device !== undefined);\n    return this._device;\n  }\n\n  async init(): Promise<void> {\n    await super.init();\n    const gpu = getGPU();\n    const adapter = await gpu.requestAdapter();\n    assert(adapter !== null);\n    const device = await adapter.requestDevice();\n    assert(device !== null);\n    this._device = device;\n  }\n\n  // Generates an error of the given filter type. For now, the errors are generated by calling a\n  // known code-path to cause the error. This can be updated in the future should there be a more\n  // direct way to inject errors.\n  generateError(filter: GPUErrorFilter): void {\n    switch (filter) {\n      case 'out-of-memory':\n        // Generating an out-of-memory error by allocating a massive buffer.\n        this.device.createBuffer({\n          size: kMaxUnsignedLongLongValue, // Unrealistically massive buffer size\n          usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        });\n        break;\n      case 'validation':\n        // Generating a validation error by passing in an invalid usage when creating a buffer.\n        this.device.createBuffer({\n          size: 1024,\n          usage: 0xffff, // Invalid GPUBufferUsage\n        });\n        break;\n    }\n    // MAINTENANCE_TODO: This is a workaround for Chromium not flushing. Remove when not needed.\n    this.device.queue.submit([]);\n  }\n\n  // Checks whether the error is of the type expected given the filter.\n  isInstanceOfError(filter: GPUErrorFilter, error: GPUError | null): boolean {\n    switch (filter) {\n      case 'out-of-memory':\n        return error instanceof GPUOutOfMemoryError;\n      case 'validation':\n        return error instanceof GPUValidationError;\n    }\n  }\n\n  // Expect an uncapturederror event to occur. Note: this MUST be awaited, because\n  // otherwise it could erroneously pass by capturing an error from later in the test.\n  async expectUncapturedError(fn: Function): Promise<GPUUncapturedErrorEvent> {\n    return this.immediateAsyncExpectation(() => {\n      // MAINTENANCE_TODO: Make arbitrary timeout value a test runner variable\n      const TIMEOUT_IN_MS = 1000;\n\n      const promise: Promise<GPUUncapturedErrorEvent> = new Promise(resolve => {\n        const eventListener = ((event: GPUUncapturedErrorEvent) => {\n          this.debug(`Got uncaptured error event with ${event.error}`);\n          resolve(event);\n        }) as EventListener;\n\n        this.device.addEventListener('uncapturederror', eventListener, { once: true });\n      });\n\n      fn();\n\n      return raceWithRejectOnTimeout(\n        promise,\n        TIMEOUT_IN_MS,\n        'Timeout occurred waiting for uncaptured error'\n      );\n    });\n  }\n}\n\nexport const g = makeTestGroup(ErrorScopeTests);\n\ng.test('simple')\n  .desc(\n    `\nTests that error scopes catches their expected errors, firing an uncaptured error event otherwise.\n\n- Same error and error filter (popErrorScope should return the error)\n- Different error from filter (uncaptured error should result)\n    `\n  )\n  .params(u =>\n    u.combine('errorType', kErrorScopeFilters).combine('errorFilter', kErrorScopeFilters)\n  )\n  .fn(async t => {\n    const { errorType, errorFilter } = t.params;\n    t.device.pushErrorScope(errorFilter);\n\n    if (errorType !== errorFilter) {\n      // Different error case\n      const uncapturedErrorEvent = await t.expectUncapturedError(() => {\n        t.generateError(errorType);\n      });\n      t.expect(t.isInstanceOfError(errorType, uncapturedErrorEvent.error));\n\n      const error = await t.device.popErrorScope();\n      t.expect(error === null);\n    } else {\n      // Same error as filter\n      t.generateError(errorType);\n      const error = await t.device.popErrorScope();\n      t.expect(t.isInstanceOfError(errorType, error));\n    }\n  });\n\ng.test('empty')\n  .desc(\n    `\nTests that popping an empty error scope stack should reject.\n    `\n  )\n  .fn(async t => {\n    const promise = t.device.popErrorScope();\n    t.shouldReject('OperationError', promise);\n  });\n\ng.test('parent_scope')\n  .desc(\n    `\nTests that an error bubbles to the correct parent scope.\n\n- Different error types as the parent scope\n- Different depths of non-capturing filters for the generated error\n    `\n  )\n  .params(u =>\n    u.combine('errorFilter', kErrorScopeFilters).combine('stackDepth', [1, 10, 100, 1000])\n  )\n  .fn(async t => {\n    const { errorFilter, stackDepth } = t.params;\n    t.device.pushErrorScope(errorFilter);\n\n    // Push a bunch of error filters onto the stack (none that match errorFilter)\n    const unmatchedFilters = kErrorScopeFilters.filter(filter => {\n      return filter !== errorFilter;\n    });\n    for (let i = 0; i < stackDepth; i++) {\n      t.device.pushErrorScope(unmatchedFilters[i % unmatchedFilters.length]);\n    }\n\n    // Cause the error and then pop all the unrelated filters.\n    t.generateError(errorFilter);\n    const promises = [];\n    for (let i = 0; i < stackDepth; i++) {\n      promises.push(t.device.popErrorScope());\n    }\n    const errors = await Promise.all(promises);\n    t.expect(errors.every(e => e === null));\n\n    // Finally the actual error should have been caught by the parent scope.\n    const error = await t.device.popErrorScope();\n    t.expect(t.isInstanceOfError(errorFilter, error));\n  });\n\ng.test('current_scope')\n  .desc(\n    `\nTests that an error does not bubbles to parent scopes when local scope matches.\n\n- Different error types as the current scope\n- Different depths of non-capturing filters for the generated error\n    `\n  )\n  .params(u =>\n    u.combine('errorFilter', kErrorScopeFilters).combine('stackDepth', [1, 10, 100, 1000, 100000])\n  )\n  .fn(async t => {\n    const { errorFilter, stackDepth } = t.params;\n\n    // Push a bunch of error filters onto the stack\n    for (let i = 0; i < stackDepth; i++) {\n      t.device.pushErrorScope(kErrorScopeFilters[i % kErrorScopeFilters.length]);\n    }\n\n    // Current scope should catch the error immediately.\n    t.device.pushErrorScope(errorFilter);\n    t.generateError(errorFilter);\n    const error = await t.device.popErrorScope();\n    t.expect(t.isInstanceOfError(errorFilter, error));\n\n    // Remaining scopes shouldn't catch anything.\n    const promises = [];\n    for (let i = 0; i < stackDepth; i++) {\n      promises.push(t.device.popErrorScope());\n    }\n    const errors = await Promise.all(promises);\n    t.expect(errors.every(e => e === null));\n  });\n\ng.test('balanced_siblings')\n  .desc(\n    `\nTests that sibling error scopes need to be balanced.\n\n- Different error types as the current scope\n- Different number of sibling errors\n    `\n  )\n  .params(u =>\n    u.combine('errorFilter', kErrorScopeFilters).combine('numErrors', [1, 10, 100, 1000])\n  )\n  .fn(async t => {\n    const { errorFilter, numErrors } = t.params;\n\n    const promises = [];\n    for (let i = 0; i < numErrors; i++) {\n      t.device.pushErrorScope(errorFilter);\n      promises.push(t.device.popErrorScope());\n    }\n\n    {\n      // Trying to pop an additional non-exisiting scope should reject.\n      const promise = t.device.popErrorScope();\n      t.shouldReject('OperationError', promise);\n    }\n\n    const errors = await Promise.all(promises);\n    t.expect(errors.every(e => e === null));\n  });\n\ng.test('balanced_nesting')\n  .desc(\n    `\nTests that nested error scopes need to be balanced.\n\n- Different error types as the current scope\n- Different number of nested errors\n    `\n  )\n  .params(u =>\n    u.combine('errorFilter', kErrorScopeFilters).combine('numErrors', [1, 10, 100, 1000])\n  )\n  .fn(async t => {\n    const { errorFilter, numErrors } = t.params;\n\n    for (let i = 0; i < numErrors; i++) {\n      t.device.pushErrorScope(errorFilter);\n    }\n\n    const promises = [];\n    for (let i = 0; i < numErrors; i++) {\n      promises.push(t.device.popErrorScope());\n    }\n    const errors = await Promise.all(promises);\n    t.expect(errors.every(e => e === null));\n\n    {\n      // Trying to pop an additional non-exisiting scope should reject.\n      const promise = t.device.popErrorScope();\n      t.shouldReject('OperationError', promise);\n    }\n  });\n"],"file":"error_scope.spec.js"}