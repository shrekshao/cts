{"version":3,"sources":["../../../../src/webgpu/api/validation/vertex_state.spec.ts"],"names":["description","makeTestGroup","kMaxVertexAttributes","kMaxVertexBufferArrayStride","kMaxVertexBuffers","kVertexFormats","kVertexFormatInfo","ValidationTest","VERTEX_SHADER_CODE_WITH_NO_INPUT","addTestAttributes","attributes","testAttribute","testAttributeAtStart","extraAttributeCount","extraAttributeSkippedLocations","currentLocation","extraAttribsAdded","includes","push","format","shaderLocation","offset","unshift","F","getDescriptor","buffers","vertexShaderCode","descriptor","vertex","module","device","createShaderModule","code","entryPoint","fragment","targets","primitive","topology","testVertexState","success","vertexShader","vsModule","fsModule","expectValidationError","createRenderPipeline","generateTestVertexShader","inputs","interfaces","body","count","input","location","type","g","test","desc","paramsSubcasesOnly","u","combine","fn","t","lastEmpty","params","vertexBuffers","i","arrayStride","attribCount","attribsPerBuffer","attribsAdded","targetCount","Math","min","length","vertexBufferIndex","testShaderLocation","vertexBufferIndexA","vertexBufferIndexB","testAttributeAtStartA","testAttributeAtStartB","shaderLocationA","shaderLocationB","vertexBufferAttributes","attributesA","attributesB","testLocation","shader","beginSubcases","expand","p","shaderBaseType","shaderType","requiredBaseType","sint","uint","snorm","unorm","float","bytesPerComponent","componentCount","formatSize","halfAlignment","floor","Set","formatInfo","limit","formats"],"mappings":"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","sourcesContent":["export const description = `vertexState validation tests.`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport {\n  kMaxVertexAttributes,\n  kMaxVertexBufferArrayStride,\n  kMaxVertexBuffers,\n  kVertexFormats,\n  kVertexFormatInfo,\n} from '../../capability_info.js';\n\nimport { ValidationTest } from './validation_test.js';\n\nconst VERTEX_SHADER_CODE_WITH_NO_INPUT = `\n  [[stage(vertex)]] fn main() -> [[builtin(position)]] vec4<f32> {\n    return vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  }\n`;\n\nfunction addTestAttributes(\n  attributes: GPUVertexAttribute[],\n  {\n    testAttribute,\n    testAttributeAtStart = true,\n    extraAttributeCount = 0,\n    extraAttributeSkippedLocations = [],\n  }: {\n    testAttribute?: GPUVertexAttribute;\n    testAttributeAtStart?: boolean;\n    extraAttributeCount?: Number;\n    extraAttributeSkippedLocations?: Number[];\n  }\n) {\n  // Add a bunch of dummy attributes each with a different location such that none of the locations\n  // are in extraAttributeSkippedLocations\n  let currentLocation = 0;\n  let extraAttribsAdded = 0;\n  while (extraAttribsAdded !== extraAttributeCount) {\n    if (extraAttributeSkippedLocations.includes(currentLocation)) {\n      currentLocation++;\n      continue;\n    }\n\n    attributes.push({ format: 'float32', shaderLocation: currentLocation, offset: 0 });\n    currentLocation++;\n    extraAttribsAdded++;\n  }\n\n  // Add the test attribute at the start or the end of the attributes.\n  if (testAttribute) {\n    if (testAttributeAtStart) {\n      attributes.unshift(testAttribute);\n    } else {\n      attributes.push(testAttribute);\n    }\n  }\n}\n\nclass F extends ValidationTest {\n  getDescriptor(\n    buffers: Iterable<GPUVertexBufferLayout>,\n    vertexShaderCode: string\n  ): GPURenderPipelineDescriptor {\n    const descriptor: GPURenderPipelineDescriptor = {\n      vertex: {\n        module: this.device.createShaderModule({ code: vertexShaderCode }),\n        entryPoint: 'main',\n        buffers,\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n            [[stage(fragment)]] fn main() -> [[location(0)]] vec4<f32> {\n              return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'triangle-list' },\n    };\n    return descriptor;\n  }\n\n  testVertexState(\n    success: boolean,\n    buffers: Iterable<GPUVertexBufferLayout>,\n    vertexShader: string = VERTEX_SHADER_CODE_WITH_NO_INPUT\n  ) {\n    const vsModule = this.device.createShaderModule({ code: vertexShader });\n    const fsModule = this.device.createShaderModule({\n      code: `\n        [[stage(fragment)]] fn main() -> [[location(0)]] vec4<f32> {\n          return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n        }`,\n    });\n\n    this.expectValidationError(() => {\n      this.device.createRenderPipeline({\n        vertex: {\n          module: vsModule,\n          entryPoint: 'main',\n          buffers,\n        },\n        fragment: {\n          module: fsModule,\n          entryPoint: 'main',\n          targets: [{ format: 'rgba8unorm' }],\n        },\n        primitive: { topology: 'triangle-list' },\n      });\n    }, !success);\n  }\n\n  generateTestVertexShader(inputs: { type: string; location: number }[]): string {\n    let interfaces = '';\n    let body = '';\n\n    let count = 0;\n    for (const input of inputs) {\n      interfaces += `[[location(${input.location})]] input${count} : ${input.type};\\n`;\n      body += `var i${count} : ${input.type} = input.input${count};\\n`;\n      count++;\n    }\n\n    return `\n      struct Inputs {\n        ${interfaces}\n      };\n      [[stage(vertex)]] fn main(input : Inputs) -> [[builtin(position)]] vec4<f32> {\n        ${body}\n        return vec4<f32>(0.0, 0.0, 0.0, 0.0);\n      }\n    `;\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('max_vertex_buffer_limit')\n  .desc(\n    `Test that only up to <maxVertexBuffers> vertex buffers are allowed.\n   - Tests with 0, 1, limits, limits + 1 vertex buffers.\n   - Tests with the last buffer having an attribute or not.\n  This also happens to test that vertex buffers with no attributes are allowed and that a vertex state with no buffers is allowed.`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('count', [0, 1, kMaxVertexBuffers, kMaxVertexBuffers + 1])\n      .combine('lastEmpty', [false, true])\n  )\n  .fn(t => {\n    const { count, lastEmpty } = t.params;\n\n    const vertexBuffers = [];\n    for (let i = 0; i < count; i++) {\n      if (lastEmpty || i !== count - 1) {\n        vertexBuffers.push({ attributes: [], arrayStride: 0 });\n      } else {\n        vertexBuffers.push({\n          attributes: [{ format: 'float32', offset: 0, shaderLocation: 0 }],\n          arrayStride: 0,\n        } as const);\n      }\n    }\n\n    const success = count <= kMaxVertexBuffers;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('max_vertex_attribute_limit')\n  .desc(\n    `Test that only up to <maxVertexAttributes> vertex attributes are allowed.\n   - Tests with 0, 1, limit, limits + 1 vertex attribute.\n   - Tests with 0, 1, 4 attributes per buffer (with remaining attributes in the last buffer).`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('attribCount', [0, 1, kMaxVertexAttributes, kMaxVertexAttributes + 1])\n      .combine('attribsPerBuffer', [0, 1, 4])\n  )\n  .fn(t => {\n    const { attribCount, attribsPerBuffer } = t.params;\n\n    const vertexBuffers = [];\n\n    let attribsAdded = 0;\n    while (attribsAdded !== attribCount) {\n      // Choose how many attributes to add for this buffer. The last buffer gets all remaining attributes.\n      let targetCount = Math.min(attribCount, attribsAdded + attribsPerBuffer);\n      if (vertexBuffers.length === kMaxVertexBuffers - 1) {\n        targetCount = attribCount;\n      }\n\n      const attributes = [];\n      while (attribsAdded !== targetCount) {\n        attributes.push({ format: 'float32', offset: 0, shaderLocation: attribsAdded } as const);\n        attribsAdded++;\n      }\n\n      vertexBuffers.push({ arrayStride: 0, attributes });\n    }\n\n    const success = attribCount <= kMaxVertexAttributes;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('max_vertex_buffer_array_stride_limit')\n  .desc(\n    `Test that the vertex buffer arrayStride must be at most <maxVertexBufferArrayStride>.\n   - Test for various vertex buffer indices\n   - Test for array strides 0, 4, 256, limit - 4, limit, limit + 4`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1])\n      .combine('arrayStride', [\n        0,\n        4,\n        256,\n        kMaxVertexBufferArrayStride - 4,\n        kMaxVertexBufferArrayStride,\n        kMaxVertexBufferArrayStride + 4,\n      ])\n  )\n  .fn(t => {\n    const { vertexBufferIndex, arrayStride } = t.params;\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes: [] };\n\n    const success = arrayStride <= kMaxVertexBufferArrayStride;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_buffer_array_stride_limit_alignment')\n  .desc(\n    `Test that the vertex buffer arrayStride must be a multiple of 4 (including 0).\n   - Test for various vertex buffer indices\n   - Test for array strides 0, 1, 2, 4, limit - 4, limit - 2, limit`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1])\n      .combine('arrayStride', [\n        0,\n        1,\n        2,\n        4,\n        kMaxVertexBufferArrayStride - 4,\n        kMaxVertexBufferArrayStride - 2,\n        kMaxVertexBufferArrayStride,\n      ])\n  )\n  .fn(t => {\n    const { vertexBufferIndex, arrayStride } = t.params;\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes: [] };\n\n    const success = arrayStride % 4 === 0;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_attribute_shaderLocation_limit')\n  .desc(\n    `Test shaderLocation must be less than maxVertexAttributes.\n   - Test for various vertex buffer indices\n   - Test for various amounts of attributes in that vertex buffer\n   - Test for shaderLocation 0, 1, limit - 1, limit`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1])\n      .combine('extraAttributeCount', [0, 1, kMaxVertexAttributes - 1])\n      .combine('testAttributeAtStart', [false, true])\n      .combine('testShaderLocation', [0, 1, kMaxVertexAttributes - 1, kMaxVertexAttributes])\n  )\n  .fn(t => {\n    const {\n      vertexBufferIndex,\n      extraAttributeCount,\n      testShaderLocation,\n      testAttributeAtStart,\n    } = t.params;\n\n    const attributes: GPUVertexAttribute[] = [];\n    addTestAttributes(attributes, {\n      testAttribute: { format: 'float32', offset: 0, shaderLocation: testShaderLocation },\n      testAttributeAtStart,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [testShaderLocation],\n    });\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride: 256, attributes };\n\n    const success = testShaderLocation < kMaxVertexAttributes;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_attribute_shaderLocation_unique')\n  .desc(\n    `Test that shaderLocation must be unique in the vertex state.\n   - Test for various pairs of buffers that contain the potentially conflicting attributes\n   - Test for the potentially conflicting attributes in various places in the buffers (with dummy attributes)\n   - Test for various shaderLocations that conflict or not`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('vertexBufferIndexA', [0, 1, kMaxVertexBuffers - 1])\n      .combine('vertexBufferIndexB', [0, 1, kMaxVertexBuffers - 1])\n      .combine('testAttributeAtStartA', [false, true])\n      .combine('testAttributeAtStartB', [false, true])\n      .combine('shaderLocationA', [0, 1, 7, kMaxVertexAttributes - 1])\n      .combine('shaderLocationB', [0, 1, 7, kMaxVertexAttributes - 1])\n      .combine('extraAttributeCount', [0, 4])\n  )\n  .fn(t => {\n    const {\n      vertexBufferIndexA,\n      vertexBufferIndexB,\n      testAttributeAtStartA,\n      testAttributeAtStartB,\n      shaderLocationA,\n      shaderLocationB,\n      extraAttributeCount,\n    } = t.params;\n\n    // Depending on the params, the vertexBuffer for A and B can be the same or different. To support\n    // both cases without code changes we treat `vertexBufferAttributes` as a map from indices to\n    // vertex buffer descriptors, with A and B potentially reusing the same JS object if they have the\n    // same index.\n    const vertexBufferAttributes = [];\n    vertexBufferAttributes[vertexBufferIndexA] = [];\n    vertexBufferAttributes[vertexBufferIndexB] = [];\n\n    // Add the dummy attributes for attribute A\n    const attributesA = vertexBufferAttributes[vertexBufferIndexA];\n    addTestAttributes(attributesA, {\n      testAttribute: { format: 'float32', offset: 0, shaderLocation: shaderLocationA },\n      testAttributeAtStart: testAttributeAtStartA,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [shaderLocationA, shaderLocationB],\n    });\n\n    // Add attribute B. Not that attributesB can be the same object as attributesA so they end\n    // up in the same vertex buffer.\n    const attributesB = vertexBufferAttributes[vertexBufferIndexB];\n    addTestAttributes(attributesB, {\n      testAttribute: { format: 'float32', offset: 0, shaderLocation: shaderLocationB },\n      testAttributeAtStart: testAttributeAtStartB,\n    });\n\n    // Use the attributes to make the list of vertex buffers. Note that we might be setting the same vertex\n    // buffer twice, but that only happens when it is the only vertex buffer.\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndexA] = { arrayStride: 256, attributes: attributesA };\n    vertexBuffers[vertexBufferIndexB] = { arrayStride: 256, attributes: attributesB };\n\n    // Note that an empty vertex shader will be used so errors only happens because of the conflict\n    // in the vertex state.\n    const success = shaderLocationA !== shaderLocationB;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_shader_input_location_limit')\n  .desc(\n    `Test that vertex shader's input's location decoration must be less than maxVertexAttributes.\n   - Test for shaderLocation 0, 1, limit - 1, limit`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('testLocation', [0, 1, kMaxVertexAttributes - 1, kMaxVertexAttributes, -1, 2 ** 32])\n  )\n  .fn(t => {\n    const { testLocation } = t.params;\n\n    const shader = t.generateTestVertexShader([\n      {\n        type: 'vec4<f32>',\n        location: testLocation,\n      },\n    ]);\n\n    const vertexBuffers = [\n      {\n        arrayStride: 512,\n        attributes: [\n          {\n            format: 'float32',\n            offset: 0,\n            shaderLocation: testLocation,\n          } as const,\n        ],\n      },\n    ];\n\n    const success = testLocation < kMaxVertexAttributes;\n    t.testVertexState(success, vertexBuffers, shader);\n  });\n\ng.test('vertex_shader_input_location_in_vertex_state')\n  .desc(\n    `Test that a vertex shader defined in the shader must have a corresponding attribute in the vertex state.\n       - Test for various input locations.\n       - Test for the attribute in various places in the list of vertex buffer and various places inside the vertex buffer descriptor`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1])\n      .combine('extraAttributeCount', [0, 1, kMaxVertexAttributes - 1])\n      .combine('testAttributeAtStart', [false, true])\n      .combine('testShaderLocation', [0, 1, 4, 7, kMaxVertexAttributes - 1])\n  )\n  .fn(t => {\n    const {\n      vertexBufferIndex,\n      extraAttributeCount,\n      testAttributeAtStart,\n      testShaderLocation,\n    } = t.params;\n    // We have a shader using `testShaderLocation`.\n    const shader = t.generateTestVertexShader([\n      {\n        type: 'vec4<f32>',\n        location: testShaderLocation,\n      },\n    ]);\n\n    const attributes: GPUVertexAttribute[] = [];\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride: 256, attributes };\n\n    // Fill attributes with a bunch of attributes for other locations.\n    // Using that vertex state is invalid because the vertex state doesn't contain the test location\n    addTestAttributes(attributes, {\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [testShaderLocation],\n    });\n    t.testVertexState(false, vertexBuffers, shader);\n\n    // Add an attribute for the test location and try again.\n    addTestAttributes(attributes, {\n      testAttribute: { format: 'float32', shaderLocation: testShaderLocation, offset: 0 },\n      testAttributeAtStart,\n    });\n    t.testVertexState(true, vertexBuffers, shader);\n  });\n\ng.test('vertex_shader_type_matches_attribute_format')\n  .desc(\n    `\n    Test that the vertex shader declaration must have a type compatible with the vertex format.\n     - Test for all formats.\n     - Test for all combinations of u/i/f32 with and without vectors.`\n  )\n  .params(u =>\n    u\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .combine('shaderBaseType', ['u32', 'i32', 'f32'])\n      .expand('shaderType', p => [\n        p.shaderBaseType,\n        `vec2<${p.shaderBaseType}>`,\n        `vec3<${p.shaderBaseType}>`,\n        `vec4<${p.shaderBaseType}>`,\n      ])\n  )\n  .fn(t => {\n    const { format, shaderBaseType, shaderType } = t.params;\n    const shader = t.generateTestVertexShader([\n      {\n        type: shaderType,\n        location: 0,\n      },\n    ]);\n\n    const requiredBaseType = {\n      sint: 'i32',\n      uint: 'u32',\n      snorm: 'f32',\n      unorm: 'f32',\n      float: 'f32',\n    }[kVertexFormatInfo[format].type];\n\n    const success = requiredBaseType === shaderBaseType;\n    t.testVertexState(\n      success,\n      [\n        {\n          arrayStride: 0,\n          attributes: [{ offset: 0, shaderLocation: 0, format }],\n        },\n      ],\n      shader\n    );\n  });\n\ng.test('vertex_attribute_offset_alignment')\n  .desc(\n    `\n    Test that vertex attribute offsets must be aligned to the format's component byte size.\n    - Test for all formats.\n    - Test for various arrayStrides and offsets within that stride\n    - Test for various vertex buffer indices\n    - Test for various amounts of attributes in that vertex buffer`\n  )\n  .params(u =>\n    u\n      .combine('format', kVertexFormats)\n      .combine('arrayStride', [256, kMaxVertexBufferArrayStride])\n      .expand('offset', p => {\n        const { bytesPerComponent, componentCount } = kVertexFormatInfo[p.format];\n        const formatSize = bytesPerComponent * componentCount;\n        const halfAlignment = Math.floor(bytesPerComponent / 2);\n\n        return new Set([\n          0,\n          halfAlignment,\n          bytesPerComponent,\n          p.arrayStride - formatSize,\n          p.arrayStride - formatSize - halfAlignment,\n        ]);\n      })\n      .beginSubcases()\n      .combine('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1])\n      .combine('extraAttributeCount', [0, 1, kMaxVertexAttributes - 1])\n      .combine('testAttributeAtStart', [false, true])\n  )\n  .fn(t => {\n    const {\n      format,\n      arrayStride,\n      offset,\n      vertexBufferIndex,\n      extraAttributeCount,\n      testAttributeAtStart,\n    } = t.params;\n\n    const attributes: GPUVertexAttribute[] = [];\n    addTestAttributes(attributes, {\n      testAttribute: { format, offset, shaderLocation: 0 },\n      testAttributeAtStart,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [0],\n    });\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes };\n\n    const success = offset % kVertexFormatInfo[format].bytesPerComponent === 0;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_attribute_contained_in_stride')\n  .desc(\n    `\n    Test that vertex attribute [offset, offset + formatSize) must be contained in the arrayStride if arrayStride is not 0:\n    - Test for all formats.\n    - Test for various arrayStrides and offsets within that stride\n    - Test for various vertex buffer indices\n    - Test for various amounts of attributes in that vertex buffer`\n  )\n  .params(u =>\n    u\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .combine('arrayStride', [\n        0,\n        256,\n        kMaxVertexBufferArrayStride - 4,\n        kMaxVertexBufferArrayStride,\n      ])\n      .expand('offset', function* (p) {\n        // Compute a bunch of test offsets to test.\n        const { bytesPerComponent, componentCount } = kVertexFormatInfo[p.format];\n        const formatSize = bytesPerComponent * componentCount;\n        yield 0;\n        yield bytesPerComponent;\n\n        // arrayStride = 0 is a special case because for the offset validation it acts the same\n        // as arrayStride = kMaxVertexBufferArrayStride. We branch so as to avoid adding negative\n        // offsets that would cause an IDL exception to be thrown instead of a validation error.\n        if (p.arrayStride === 0) {\n          yield kMaxVertexBufferArrayStride - formatSize;\n          yield kMaxVertexBufferArrayStride - formatSize + bytesPerComponent;\n        } else {\n          yield p.arrayStride - formatSize;\n          yield p.arrayStride - formatSize + bytesPerComponent;\n        }\n      })\n      .combine('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1])\n      .combine('extraAttributeCount', [0, 1, kMaxVertexAttributes - 1])\n      .combine('testAttributeAtStart', [false, true])\n  )\n  .fn(t => {\n    const {\n      format,\n      arrayStride,\n      offset,\n      vertexBufferIndex,\n      extraAttributeCount,\n      testAttributeAtStart,\n    } = t.params;\n\n    const attributes: GPUVertexAttribute[] = [];\n    addTestAttributes(attributes, {\n      testAttribute: { format, offset, shaderLocation: 0 },\n      testAttributeAtStart,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [0],\n    });\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes };\n\n    const formatInfo = kVertexFormatInfo[format];\n    const formatSize = formatInfo.bytesPerComponent * formatInfo.componentCount;\n    const limit = arrayStride === 0 ? kMaxVertexBufferArrayStride : arrayStride;\n\n    const success = offset + formatSize <= limit;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('many_attributes_overlapping')\n  .desc(`Test that it is valid to have many vertex attributes overlap`)\n  .fn(async t => {\n    // Create many attributes, each of them intersects with at least 3 others.\n    const attributes = [];\n    const formats = ['float32x4', 'uint32x4', 'sint32x4'] as const;\n    for (let i = 0; i < kMaxVertexAttributes; i++) {\n      attributes.push({ format: formats[i % 3], offset: i * 4, shaderLocation: i } as const);\n    }\n\n    t.testVertexState(true, [{ arrayStride: 0, attributes }]);\n  });\n"],"file":"vertex_state.spec.js"}