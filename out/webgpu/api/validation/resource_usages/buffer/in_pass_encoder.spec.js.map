{"version":3,"sources":["../../../../../../src/webgpu/api/validation/resource_usages/buffer/in_pass_encoder.spec.ts"],"names":["description","makeTestGroup","assert","unreachable","ValidationTest","kBoundBufferSize","F","createBindGroupLayoutForTest","type","resourceVisibility","bindGroupLayoutEntry","binding","visibility","GPUShaderStage","COMPUTE","FRAGMENT","buffer","device","createBindGroupLayout","entries","createBindGroupForTest","offset","createBindGroup","layout","resource","size","beginSimpleRenderPass","encoder","colorTexture","createTexture","format","usage","GPUTextureUsage","RENDER_ATTACHMENT","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","IsBufferUsageInBindGroup","bufferUsage","g","test","desc","params","u","combine","beginSubcases","unless","t","visibility0","usage0","visibility1","usage1","fn","inSamePass","hasOverlap","UseBufferOnRenderPassEncoder","index","bindGroupVisibility","renderPassEncoder","bindGroup","setBindGroup","setVertexBuffer","setIndexBuffer","renderPipeline","createNoOpRenderPipeline","setPipeline","drawIndirect","indexBuffer","createBuffer","GPUBufferUsage","INDEX","drawIndexedIndirect","UNIFORM","STORAGE","VERTEX","INDIRECT","createCommandEncoder","offset0","index0","offset1","index1","end","anotherRenderPassEncoder","fail","expectValidationError","finish","computePassEncoder","beginComputePass","bindGroup0","bindGroup1","filter","usage0AccessibleInDispatch","dispatchBeforeUsage1","usage1AccessibleInDispatch","pipelineLayout","undefined","bindGroupLayout0","createPipelineLayout","bindGroupLayouts","computePipeline","createNoOpComputePipeline","dispatchWorkgroups","dispatchWorkgroupsIndirect","bindGroupIndex","push","bindGroupLayout1","usageHasConflict","UseBufferOnComputePassEncoder","bindGroupLayout","anotherComputePassEncoder"],"mappings":"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","sourcesContent":["export const description = `\nBuffer Usages Validation Tests in Render Pass and Compute Pass.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { assert, unreachable } from '../../../../../common/util/util.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nconst kBoundBufferSize = 256;\n\nclass F extends ValidationTest {\n  createBindGroupLayoutForTest(\n    type: 'uniform' | 'storage' | 'read-only-storage',\n    resourceVisibility: 'compute' | 'fragment'\n  ): GPUBindGroupLayout {\n    const bindGroupLayoutEntry: GPUBindGroupLayoutEntry = {\n      binding: 0,\n      visibility:\n        resourceVisibility === 'compute' ? GPUShaderStage.COMPUTE : GPUShaderStage.FRAGMENT,\n      buffer: {\n        type,\n      },\n    };\n    return this.device.createBindGroupLayout({\n      entries: [bindGroupLayoutEntry],\n    });\n  }\n\n  createBindGroupForTest(\n    buffer: GPUBuffer,\n    offset: number,\n    type: 'uniform' | 'storage' | 'read-only-storage',\n    resourceVisibility: 'compute' | 'fragment'\n  ): GPUBindGroup {\n    return this.device.createBindGroup({\n      layout: this.createBindGroupLayoutForTest(type, resourceVisibility),\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer, offset, size: kBoundBufferSize },\n        },\n      ],\n    });\n  }\n\n  beginSimpleRenderPass(encoder: GPUCommandEncoder) {\n    const colorTexture = this.device.createTexture({\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n      size: [16, 16, 1],\n    });\n    return encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: colorTexture.createView(),\n          loadOp: 'load',\n          storeOp: 'store',\n        },\n      ],\n    });\n  }\n}\n\nfunction IsBufferUsageInBindGroup(\n  bufferUsage:\n    | 'uniform'\n    | 'storage'\n    | 'read-only-storage'\n    | 'vertex'\n    | 'index'\n    | 'indirect'\n    | 'indexedIndirect'\n): boolean {\n  switch (bufferUsage) {\n    case 'uniform':\n    case 'storage':\n    case 'read-only-storage':\n      return true;\n    case 'vertex':\n    case 'index':\n    case 'indirect':\n    case 'indexedIndirect':\n      return false;\n    default:\n      unreachable();\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('subresources,buffer_usage_in_render_pass')\n  .desc(\n    `\nTest that when one buffer is used in one render pass encoder, its list of internal usages within one\nusage scope (all the commands in the whole render pass) can only be a compatible usage list; while\nthere is no such restriction when it is used in different render pass encoders. The usage scope\nrules are not related to the buffer offset or the bind group layout visibilities.`\n  )\n  .params(u =>\n    u\n      .combine('inSamePass', [true, false])\n      .combine('hasOverlap', [true, false])\n      .beginSubcases()\n      .combine('usage0', [\n        'uniform',\n        'storage',\n        'read-only-storage',\n        'vertex',\n        'index',\n        'indirect',\n        'indexedIndirect',\n      ] as const)\n      .combine('visibility0', ['compute', 'fragment'] as const)\n      .unless(t => t.visibility0 === 'compute' && !IsBufferUsageInBindGroup(t.usage0))\n      .combine('usage1', [\n        'uniform',\n        'storage',\n        'read-only-storage',\n        'vertex',\n        'index',\n        'indirect',\n        'indexedIndirect',\n      ] as const)\n      .combine('visibility1', ['compute', 'fragment'] as const)\n      // The situation that the index buffer is reset by another setIndexBuffer call will be tested\n      // in another test case.\n      .unless(\n        t =>\n          (t.visibility1 === 'compute' && !IsBufferUsageInBindGroup(t.usage1)) ||\n          (t.usage0 === 'index' && t.usage1 === 'index')\n      )\n  )\n  .fn(async t => {\n    const { inSamePass, hasOverlap, usage0, visibility0, usage1, visibility1 } = t.params;\n\n    const UseBufferOnRenderPassEncoder = (\n      buffer: GPUBuffer,\n      index: number,\n      offset: number,\n      type:\n        | 'uniform'\n        | 'storage'\n        | 'read-only-storage'\n        | 'vertex'\n        | 'index'\n        | 'indirect'\n        | 'indexedIndirect',\n      bindGroupVisibility: 'compute' | 'fragment',\n      renderPassEncoder: GPURenderPassEncoder\n    ) => {\n      switch (type) {\n        case 'uniform':\n        case 'storage':\n        case 'read-only-storage': {\n          const bindGroup = t.createBindGroupForTest(buffer, offset, type, bindGroupVisibility);\n          renderPassEncoder.setBindGroup(index, bindGroup);\n          break;\n        }\n        case 'vertex': {\n          renderPassEncoder.setVertexBuffer(index, buffer, offset, kBoundBufferSize);\n          break;\n        }\n        case 'index': {\n          renderPassEncoder.setIndexBuffer(buffer, 'uint16', offset, kBoundBufferSize);\n          break;\n        }\n        case 'indirect': {\n          const renderPipeline = t.createNoOpRenderPipeline();\n          renderPassEncoder.setPipeline(renderPipeline);\n          renderPassEncoder.drawIndirect(buffer, offset);\n          break;\n        }\n        case 'indexedIndirect': {\n          const renderPipeline = t.createNoOpRenderPipeline();\n          renderPassEncoder.setPipeline(renderPipeline);\n          const indexBuffer = t.device.createBuffer({\n            size: 4,\n            usage: GPUBufferUsage.INDEX,\n          });\n          renderPassEncoder.setIndexBuffer(indexBuffer, 'uint16');\n          renderPassEncoder.drawIndexedIndirect(buffer, offset);\n          break;\n        }\n      }\n    };\n\n    const buffer = t.device.createBuffer({\n      size: kBoundBufferSize * 2,\n      usage:\n        GPUBufferUsage.UNIFORM |\n        GPUBufferUsage.STORAGE |\n        GPUBufferUsage.VERTEX |\n        GPUBufferUsage.INDEX |\n        GPUBufferUsage.INDIRECT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPassEncoder = t.beginSimpleRenderPass(encoder);\n    const offset0 = 0;\n    const index0 = 0;\n    UseBufferOnRenderPassEncoder(buffer, index0, offset0, usage0, visibility0, renderPassEncoder);\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    const index1 = 1;\n    if (inSamePass) {\n      UseBufferOnRenderPassEncoder(buffer, index1, offset1, usage1, visibility1, renderPassEncoder);\n      renderPassEncoder.end();\n    } else {\n      renderPassEncoder.end();\n      const anotherRenderPassEncoder = t.beginSimpleRenderPass(encoder);\n      UseBufferOnRenderPassEncoder(\n        buffer,\n        index1,\n        offset1,\n        usage1,\n        visibility1,\n        anotherRenderPassEncoder\n      );\n      anotherRenderPassEncoder.end();\n    }\n\n    const fail =\n      inSamePass &&\n      ((usage0 === 'storage' && usage1 !== 'storage') ||\n        (usage0 !== 'storage' && usage1 === 'storage'));\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, fail);\n  });\n\ng.test('subresources,buffer_usage_in_one_compute_pass_with_no_dispatch')\n  .desc(\n    `\nTest that it is always allowed to set multiple bind groups with same buffer in a compute pass\nencoder without any dispatch calls as state-setting compute pass commands, like setBindGroup(index,\nbindGroup, dynamicOffsets), do not contribute directly to a usage scope.`\n  )\n  .params(u =>\n    u\n      .combine('usage0', ['uniform', 'storage', 'read-only-storage'] as const)\n      .combine('usage1', ['uniform', 'storage', 'read-only-storage'] as const)\n      .beginSubcases()\n      .combine('visibility0', ['compute', 'fragment'] as const)\n      .combine('visibility1', ['compute', 'fragment'] as const)\n      .combine('hasOverlap', [true, false])\n  )\n  .fn(async t => {\n    const { usage0, usage1, visibility0, visibility1, hasOverlap } = t.params;\n\n    const buffer = t.device.createBuffer({\n      size: kBoundBufferSize * 2,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.STORAGE,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const computePassEncoder = encoder.beginComputePass();\n\n    const offset0 = 0;\n    const bindGroup0 = t.createBindGroupForTest(buffer, offset0, usage0, visibility0);\n    computePassEncoder.setBindGroup(0, bindGroup0);\n\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    const bindGroup1 = t.createBindGroupForTest(buffer, offset1, usage1, visibility1);\n    computePassEncoder.setBindGroup(1, bindGroup1);\n\n    computePassEncoder.end();\n\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, false);\n  });\n\ng.test('subresources,buffer_usage_in_one_compute_pass_with_one_dispatch')\n  .desc(\n    `\nTest that when one buffer is used in one compute pass encoder, its list of internal usages within\none usage scope can only be a compatible usage list. According to WebGPU SPEC, within one dispatch,\nfor each bind group slot that is used by the current GPUComputePipeline's layout, every subresource\nreferenced by that bind group is \"used\" in the usage scope. `\n  )\n  .params(u =>\n    u\n      .combine('usage0AccessibleInDispatch', [true, false])\n      .combine('usage1AccessibleInDispatch', [true, false])\n      .combine('dispatchBeforeUsage1', [true, false])\n      .beginSubcases()\n      .combine('usage0', ['uniform', 'storage', 'read-only-storage', 'indirect'] as const)\n      .combine('visibility0', ['compute', 'fragment'] as const)\n      .filter(t => {\n        // The buffer with `indirect` usage is always accessible in the dispatch call.\n        if (\n          t.usage0 === 'indirect' &&\n          (!t.usage0AccessibleInDispatch || t.visibility0 !== 'compute' || !t.dispatchBeforeUsage1)\n        ) {\n          return false;\n        }\n        if (t.usage0AccessibleInDispatch && t.visibility0 !== 'compute') {\n          return false;\n        }\n        if (t.dispatchBeforeUsage1 && t.usage1AccessibleInDispatch) {\n          return false;\n        }\n        return true;\n      })\n      .combine('usage1', ['uniform', 'storage', 'read-only-storage', 'indirect'] as const)\n      .combine('visibility1', ['compute', 'fragment'] as const)\n      .filter(t => {\n        if (\n          t.usage1 === 'indirect' &&\n          (!t.usage1AccessibleInDispatch || t.visibility1 !== 'compute' || t.dispatchBeforeUsage1)\n        ) {\n          return false;\n        }\n        // When the first buffer usage is `indirect`, there has already been one dispatch call, so\n        // in this test we always make the second usage inaccessible in the dispatch call.\n        if (\n          t.usage1AccessibleInDispatch &&\n          (t.visibility1 !== 'compute' || t.usage0 === 'indirect')\n        ) {\n          return false;\n        }\n        return true;\n      })\n      .combine('hasOverlap', [true, false])\n  )\n  .fn(async t => {\n    const {\n      usage0AccessibleInDispatch,\n      usage1AccessibleInDispatch,\n      dispatchBeforeUsage1,\n      usage0,\n      visibility0,\n      usage1,\n      visibility1,\n      hasOverlap,\n    } = t.params;\n\n    const buffer = t.device.createBuffer({\n      size: kBoundBufferSize * 2,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const computePassEncoder = encoder.beginComputePass();\n\n    const offset0 = 0;\n    switch (usage0) {\n      case 'uniform':\n      case 'storage':\n      case 'read-only-storage': {\n        const bindGroup0 = t.createBindGroupForTest(buffer, offset0, usage0, visibility0);\n        computePassEncoder.setBindGroup(0, bindGroup0);\n\n        /*\n         * setBindGroup(bindGroup0);\n         * dispatchWorkgroups();\n         * setBindGroup(bindGroup1);\n         */\n        if (dispatchBeforeUsage1) {\n          let pipelineLayout: GPUPipelineLayout | undefined = undefined;\n          if (usage0AccessibleInDispatch) {\n            const bindGroupLayout0 = t.createBindGroupLayoutForTest(usage0, visibility0);\n            pipelineLayout = t.device.createPipelineLayout({\n              bindGroupLayouts: [bindGroupLayout0],\n            });\n          }\n          const computePipeline = t.createNoOpComputePipeline(pipelineLayout);\n          computePassEncoder.setPipeline(computePipeline);\n          computePassEncoder.dispatchWorkgroups(1);\n        }\n        break;\n      }\n      case 'indirect': {\n        /*\n         * dispatchWorkgroupsIndirect(buffer);\n         * setBindGroup(bindGroup1);\n         */\n        assert(dispatchBeforeUsage1);\n        const computePipeline = t.createNoOpComputePipeline();\n        computePassEncoder.setPipeline(computePipeline);\n        computePassEncoder.dispatchWorkgroupsIndirect(buffer, offset0);\n        break;\n      }\n    }\n\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    switch (usage1) {\n      case 'uniform':\n      case 'storage':\n      case 'read-only-storage': {\n        const bindGroup1 = t.createBindGroupForTest(buffer, offset1, usage1, visibility1);\n        const bindGroupIndex = usage0AccessibleInDispatch ? 1 : 0;\n        computePassEncoder.setBindGroup(bindGroupIndex, bindGroup1);\n\n        /*\n         * setBindGroup(bindGroup0);\n         * setBindGroup(bindGroup1);\n         * dispatchWorkgroups();\n         */\n        if (!dispatchBeforeUsage1) {\n          const bindGroupLayouts: GPUBindGroupLayout[] = [];\n          if (usage0AccessibleInDispatch && usage0 !== 'indirect') {\n            const bindGroupLayout0 = t.createBindGroupLayoutForTest(usage0, visibility0);\n            bindGroupLayouts.push(bindGroupLayout0);\n          }\n          if (usage1AccessibleInDispatch) {\n            const bindGroupLayout1 = t.createBindGroupLayoutForTest(usage1, visibility1);\n            bindGroupLayouts.push(bindGroupLayout1);\n          }\n          const pipelineLayout: GPUPipelineLayout | undefined = bindGroupLayouts\n            ? t.device.createPipelineLayout({\n                bindGroupLayouts,\n              })\n            : undefined;\n          const computePipeline = t.createNoOpComputePipeline(pipelineLayout);\n          computePassEncoder.setPipeline(computePipeline);\n          computePassEncoder.dispatchWorkgroups(1);\n        }\n        break;\n      }\n      case 'indirect': {\n        /*\n         * setBindGroup(bindGroup0);\n         * dispatchWorkgroupsIndirect(buffer);\n         */\n        assert(!dispatchBeforeUsage1);\n        let pipelineLayout: GPUPipelineLayout | undefined = undefined;\n        if (usage0AccessibleInDispatch) {\n          assert(usage0 !== 'indirect');\n          pipelineLayout = t.device.createPipelineLayout({\n            bindGroupLayouts: [t.createBindGroupLayoutForTest(usage0, visibility0)],\n          });\n        }\n        const computePipeline = t.createNoOpComputePipeline(pipelineLayout);\n        computePassEncoder.setPipeline(computePipeline);\n        computePassEncoder.dispatchWorkgroupsIndirect(buffer, offset1);\n        break;\n      }\n    }\n    computePassEncoder.end();\n\n    const usageHasConflict =\n      (usage0 === 'storage' && usage1 !== 'storage') ||\n      (usage0 !== 'storage' && usage1 === 'storage');\n    const fail =\n      usageHasConflict &&\n      visibility0 === 'compute' &&\n      visibility1 === 'compute' &&\n      usage0AccessibleInDispatch &&\n      usage1AccessibleInDispatch;\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, fail);\n  });\n\ng.test('subresources,buffer_usage_in_compute_pass_with_two_dispatches')\n  .desc(\n    `\nTest that it is always allowed to use one buffer in different dispatch calls as in WebGPU SPEC,\nwithin one dispatch, for each bind group slot that is used by the current GPUComputePipeline's\nlayout, every subresource referenced by that bind group is \"used\" in the usage scope, and different\ndispatch calls refer to different usage scopes.`\n  )\n  .params(u =>\n    u\n      .combine('usage0', ['uniform', 'storage', 'read-only-storage', 'indirect'] as const)\n      .combine('usage1', ['uniform', 'storage', 'read-only-storage', 'indirect'] as const)\n      .beginSubcases()\n      .combine('inSamePass', [true, false])\n      .combine('hasOverlap', [true, false])\n  )\n  .fn(async t => {\n    const { usage0, usage1, inSamePass, hasOverlap } = t.params;\n\n    const UseBufferOnComputePassEncoder = (\n      computePassEncoder: GPUComputePassEncoder,\n      buffer: GPUBuffer,\n      usage: 'uniform' | 'storage' | 'read-only-storage' | 'indirect',\n      offset: number\n    ) => {\n      switch (usage) {\n        case 'uniform':\n        case 'storage':\n        case 'read-only-storage': {\n          const bindGroup = t.createBindGroupForTest(buffer, offset, usage, 'compute');\n          computePassEncoder.setBindGroup(0, bindGroup);\n\n          const bindGroupLayout = t.createBindGroupLayoutForTest(usage, 'compute');\n          const pipelineLayout = t.device.createPipelineLayout({\n            bindGroupLayouts: [bindGroupLayout],\n          });\n          const computePipeline = t.createNoOpComputePipeline(pipelineLayout);\n          computePassEncoder.setPipeline(computePipeline);\n          computePassEncoder.dispatchWorkgroups(1);\n          break;\n        }\n        case 'indirect': {\n          const computePipeline = t.createNoOpComputePipeline();\n          computePassEncoder.setPipeline(computePipeline);\n          computePassEncoder.dispatchWorkgroupsIndirect(buffer, offset);\n          break;\n        }\n        default:\n          unreachable();\n          break;\n      }\n    };\n\n    const buffer = t.device.createBuffer({\n      size: kBoundBufferSize * 2,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const computePassEncoder = encoder.beginComputePass();\n\n    const offset0 = 0;\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    UseBufferOnComputePassEncoder(computePassEncoder, buffer, usage0, offset0);\n\n    if (inSamePass) {\n      UseBufferOnComputePassEncoder(computePassEncoder, buffer, usage1, offset1);\n      computePassEncoder.end();\n    } else {\n      computePassEncoder.end();\n      const anotherComputePassEncoder = encoder.beginComputePass();\n      UseBufferOnComputePassEncoder(anotherComputePassEncoder, buffer, usage1, offset1);\n      anotherComputePassEncoder.end();\n    }\n\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, false);\n  });\n"],"file":"in_pass_encoder.spec.js"}