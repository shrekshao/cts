{"version":3,"sources":["../../../../../../src/webgpu/api/validation/resource_usages/buffer/in_pass_encoder.spec.ts"],"names":["description","makeTestGroup","assert","unreachable","ValidationTest","kBoundBufferSize","kAllBufferUsages","BufferResourceUsageTest","createBindGroupLayoutForTest","type","resourceVisibility","bindGroupLayoutEntry","binding","visibility","GPUShaderStage","COMPUTE","FRAGMENT","buffer","device","createBindGroupLayout","entries","createBindGroupForTest","offset","createBindGroup","layout","resource","size","beginSimpleRenderPass","encoder","colorTexture","createTexture","format","usage","GPUTextureUsage","RENDER_ATTACHMENT","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","createRenderPipelineForTest","pipelineLayout","vertexBufferCount","vertexBuffers","i","push","arrayStride","attributes","shaderLocation","createRenderPipeline","vertex","module","createShaderModule","code","getNoOpShaderCode","entryPoint","buffers","fragment","targets","primitive","topology","IsBufferUsageInBindGroup","bufferUsage","g","test","desc","params","u","combine","beginSubcases","fn","t","usage0","usage1","visibility0","visibility1","hasOverlap","createBufferWithState","GPUBufferUsage","UNIFORM","STORAGE","createCommandEncoder","computePassEncoder","beginComputePass","offset0","bindGroup0","setBindGroup","offset1","bindGroup1","end","expectValidationError","finish","filter","usage0AccessibleInDispatch","dispatchBeforeUsage1","usage1AccessibleInDispatch","INDIRECT","undefined","bindGroupLayout0","createPipelineLayout","bindGroupLayouts","computePipeline","createNoOpComputePipeline","setPipeline","dispatchWorkgroups","dispatchWorkgroupsIndirect","bindGroupIndex","bindGroupLayout1","usageHasConflict","fail","inSamePass","UseBufferOnComputePassEncoder","bindGroup","bindGroupLayout","anotherComputePassEncoder","unless","UseBufferOnRenderPassEncoder","bindGroupVisibility","renderPassEncoder","setVertexBuffer","setIndexBuffer","VERTEX","INDEX","usage0AccessibleInDraw","drawBeforeUsage1","usage1AccessibleInDraw","bufferAccessibleInDraw","bufferIndex","usedBindGroupLayouts","MakeDrawCallWithOneUsage","draw","drawIndexed","drawIndirect","indexBuffer","createBuffer","drawIndexedIndirect","bufferIndex0","pipeline","bufferIndex1","UseBufferOnRenderPassEncoderInDrawCall","kVertexBufferCount","anotherRenderPassEncoder"],"mappings":"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","sourcesContent":["export const description = `\nBuffer Usages Validation Tests in Render Pass and Compute Pass.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { assert, unreachable } from '../../../../../common/util/util.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nconst kBoundBufferSize = 256;\n\nexport type BufferUsage =\n  | 'uniform'\n  | 'storage'\n  | 'read-only-storage'\n  | 'vertex'\n  | 'index'\n  | 'indirect'\n  | 'indexedIndirect';\n\nexport const kAllBufferUsages: BufferUsage[] = [\n  'uniform',\n  'storage',\n  'read-only-storage',\n  'vertex',\n  'index',\n  'indirect',\n  'indexedIndirect',\n];\n\nexport class BufferResourceUsageTest extends ValidationTest {\n  createBindGroupLayoutForTest(\n    type: 'uniform' | 'storage' | 'read-only-storage',\n    resourceVisibility: 'compute' | 'fragment'\n  ): GPUBindGroupLayout {\n    const bindGroupLayoutEntry: GPUBindGroupLayoutEntry = {\n      binding: 0,\n      visibility:\n        resourceVisibility === 'compute' ? GPUShaderStage.COMPUTE : GPUShaderStage.FRAGMENT,\n      buffer: {\n        type,\n      },\n    };\n    return this.device.createBindGroupLayout({\n      entries: [bindGroupLayoutEntry],\n    });\n  }\n\n  createBindGroupForTest(\n    buffer: GPUBuffer,\n    offset: number,\n    type: 'uniform' | 'storage' | 'read-only-storage',\n    resourceVisibility: 'compute' | 'fragment'\n  ): GPUBindGroup {\n    return this.device.createBindGroup({\n      layout: this.createBindGroupLayoutForTest(type, resourceVisibility),\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer, offset, size: kBoundBufferSize },\n        },\n      ],\n    });\n  }\n\n  beginSimpleRenderPass(encoder: GPUCommandEncoder) {\n    const colorTexture = this.device.createTexture({\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n      size: [16, 16, 1],\n    });\n    return encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: colorTexture.createView(),\n          loadOp: 'load',\n          storeOp: 'store',\n        },\n      ],\n    });\n  }\n\n  createRenderPipelineForTest(\n    pipelineLayout: GPUPipelineLayout | GPUAutoLayoutMode,\n    vertexBufferCount: number\n  ): GPURenderPipeline {\n    const vertexBuffers: GPUVertexBufferLayout[] = [];\n    for (let i = 0; i < vertexBufferCount; ++i) {\n      vertexBuffers.push({\n        arrayStride: 4,\n        attributes: [\n          {\n            format: 'float32',\n            shaderLocation: i,\n            offset: 0,\n          },\n        ],\n      });\n    }\n\n    return this.device.createRenderPipeline({\n      layout: pipelineLayout,\n      vertex: {\n        module: this.device.createShaderModule({\n          code: this.getNoOpShaderCode('VERTEX'),\n        }),\n        entryPoint: 'main',\n        buffers: vertexBuffers,\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n              @fragment fn main()\n                -> @location(0) vec4<f32> {\n                  return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n              }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'point-list' },\n    });\n  }\n}\n\nfunction IsBufferUsageInBindGroup(bufferUsage: BufferUsage): boolean {\n  switch (bufferUsage) {\n    case 'uniform':\n    case 'storage':\n    case 'read-only-storage':\n      return true;\n    case 'vertex':\n    case 'index':\n    case 'indirect':\n    case 'indexedIndirect':\n      return false;\n    default:\n      unreachable();\n  }\n}\n\nexport const g = makeTestGroup(BufferResourceUsageTest);\n\ng.test('subresources,buffer_usage_in_one_compute_pass_with_no_dispatch')\n  .desc(\n    `\nTest that it is always allowed to set multiple bind groups with same buffer in a compute pass\nencoder without any dispatch calls as state-setting compute pass commands, like setBindGroup(index,\nbindGroup, dynamicOffsets), do not contribute directly to a usage scope.`\n  )\n  .params(u =>\n    u\n      .combine('usage0', ['uniform', 'storage', 'read-only-storage'] as const)\n      .combine('usage1', ['uniform', 'storage', 'read-only-storage'] as const)\n      .beginSubcases()\n      .combine('visibility0', ['compute', 'fragment'] as const)\n      .combine('visibility1', ['compute', 'fragment'] as const)\n      .combine('hasOverlap', [true, false])\n  )\n  .fn(async t => {\n    const { usage0, usage1, visibility0, visibility1, hasOverlap } = t.params;\n\n    const buffer = t.createBufferWithState('valid', {\n      size: kBoundBufferSize * 2,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.STORAGE,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const computePassEncoder = encoder.beginComputePass();\n\n    const offset0 = 0;\n    const bindGroup0 = t.createBindGroupForTest(buffer, offset0, usage0, visibility0);\n    computePassEncoder.setBindGroup(0, bindGroup0);\n\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    const bindGroup1 = t.createBindGroupForTest(buffer, offset1, usage1, visibility1);\n    computePassEncoder.setBindGroup(1, bindGroup1);\n\n    computePassEncoder.end();\n\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, false);\n  });\n\ng.test('subresources,buffer_usage_in_one_compute_pass_with_one_dispatch')\n  .desc(\n    `\nTest that when one buffer is used in one compute pass encoder, its list of internal usages within\none usage scope can only be a compatible usage list. According to WebGPU SPEC, within one dispatch,\nfor each bind group slot that is used by the current GPUComputePipeline's layout, every subresource\nreferenced by that bind group is \"used\" in the usage scope. `\n  )\n  .params(u =>\n    u\n      .combine('usage0AccessibleInDispatch', [true, false])\n      .combine('usage1AccessibleInDispatch', [true, false])\n      .combine('dispatchBeforeUsage1', [true, false])\n      .beginSubcases()\n      .combine('usage0', ['uniform', 'storage', 'read-only-storage', 'indirect'] as const)\n      .combine('visibility0', ['compute', 'fragment'] as const)\n      .filter(t => {\n        // The buffer with `indirect` usage is always accessible in the dispatch call.\n        if (\n          t.usage0 === 'indirect' &&\n          (!t.usage0AccessibleInDispatch || t.visibility0 !== 'compute' || !t.dispatchBeforeUsage1)\n        ) {\n          return false;\n        }\n        if (t.usage0AccessibleInDispatch && t.visibility0 !== 'compute') {\n          return false;\n        }\n        if (t.dispatchBeforeUsage1 && t.usage1AccessibleInDispatch) {\n          return false;\n        }\n        return true;\n      })\n      .combine('usage1', ['uniform', 'storage', 'read-only-storage', 'indirect'] as const)\n      .combine('visibility1', ['compute', 'fragment'] as const)\n      .filter(t => {\n        if (\n          t.usage1 === 'indirect' &&\n          (!t.usage1AccessibleInDispatch || t.visibility1 !== 'compute' || t.dispatchBeforeUsage1)\n        ) {\n          return false;\n        }\n        // When the first buffer usage is `indirect`, there has already been one dispatch call, so\n        // in this test we always make the second usage inaccessible in the dispatch call.\n        if (\n          t.usage1AccessibleInDispatch &&\n          (t.visibility1 !== 'compute' || t.usage0 === 'indirect')\n        ) {\n          return false;\n        }\n        return true;\n      })\n      .combine('hasOverlap', [true, false])\n  )\n  .fn(async t => {\n    const {\n      usage0AccessibleInDispatch,\n      usage1AccessibleInDispatch,\n      dispatchBeforeUsage1,\n      usage0,\n      visibility0,\n      usage1,\n      visibility1,\n      hasOverlap,\n    } = t.params;\n\n    const buffer = t.createBufferWithState('valid', {\n      size: kBoundBufferSize * 2,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const computePassEncoder = encoder.beginComputePass();\n\n    const offset0 = 0;\n    switch (usage0) {\n      case 'uniform':\n      case 'storage':\n      case 'read-only-storage': {\n        const bindGroup0 = t.createBindGroupForTest(buffer, offset0, usage0, visibility0);\n        computePassEncoder.setBindGroup(0, bindGroup0);\n\n        /*\n         * setBindGroup(bindGroup0);\n         * dispatchWorkgroups();\n         * setBindGroup(bindGroup1);\n         */\n        if (dispatchBeforeUsage1) {\n          let pipelineLayout: GPUPipelineLayout | undefined = undefined;\n          if (usage0AccessibleInDispatch) {\n            const bindGroupLayout0 = t.createBindGroupLayoutForTest(usage0, visibility0);\n            pipelineLayout = t.device.createPipelineLayout({\n              bindGroupLayouts: [bindGroupLayout0],\n            });\n          }\n          const computePipeline = t.createNoOpComputePipeline(pipelineLayout);\n          computePassEncoder.setPipeline(computePipeline);\n          computePassEncoder.dispatchWorkgroups(1);\n        }\n        break;\n      }\n      case 'indirect': {\n        /*\n         * dispatchWorkgroupsIndirect(buffer);\n         * setBindGroup(bindGroup1);\n         */\n        assert(dispatchBeforeUsage1);\n        const computePipeline = t.createNoOpComputePipeline();\n        computePassEncoder.setPipeline(computePipeline);\n        computePassEncoder.dispatchWorkgroupsIndirect(buffer, offset0);\n        break;\n      }\n    }\n\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    switch (usage1) {\n      case 'uniform':\n      case 'storage':\n      case 'read-only-storage': {\n        const bindGroup1 = t.createBindGroupForTest(buffer, offset1, usage1, visibility1);\n        const bindGroupIndex = usage0AccessibleInDispatch ? 1 : 0;\n        computePassEncoder.setBindGroup(bindGroupIndex, bindGroup1);\n\n        /*\n         * setBindGroup(bindGroup0);\n         * setBindGroup(bindGroup1);\n         * dispatchWorkgroups();\n         */\n        if (!dispatchBeforeUsage1) {\n          const bindGroupLayouts: GPUBindGroupLayout[] = [];\n          if (usage0AccessibleInDispatch && usage0 !== 'indirect') {\n            const bindGroupLayout0 = t.createBindGroupLayoutForTest(usage0, visibility0);\n            bindGroupLayouts.push(bindGroupLayout0);\n          }\n          if (usage1AccessibleInDispatch) {\n            const bindGroupLayout1 = t.createBindGroupLayoutForTest(usage1, visibility1);\n            bindGroupLayouts.push(bindGroupLayout1);\n          }\n          const pipelineLayout: GPUPipelineLayout | undefined = bindGroupLayouts\n            ? t.device.createPipelineLayout({\n                bindGroupLayouts,\n              })\n            : undefined;\n          const computePipeline = t.createNoOpComputePipeline(pipelineLayout);\n          computePassEncoder.setPipeline(computePipeline);\n          computePassEncoder.dispatchWorkgroups(1);\n        }\n        break;\n      }\n      case 'indirect': {\n        /*\n         * setBindGroup(bindGroup0);\n         * dispatchWorkgroupsIndirect(buffer);\n         */\n        assert(!dispatchBeforeUsage1);\n        let pipelineLayout: GPUPipelineLayout | undefined = undefined;\n        if (usage0AccessibleInDispatch) {\n          assert(usage0 !== 'indirect');\n          pipelineLayout = t.device.createPipelineLayout({\n            bindGroupLayouts: [t.createBindGroupLayoutForTest(usage0, visibility0)],\n          });\n        }\n        const computePipeline = t.createNoOpComputePipeline(pipelineLayout);\n        computePassEncoder.setPipeline(computePipeline);\n        computePassEncoder.dispatchWorkgroupsIndirect(buffer, offset1);\n        break;\n      }\n    }\n    computePassEncoder.end();\n\n    const usageHasConflict =\n      (usage0 === 'storage' && usage1 !== 'storage') ||\n      (usage0 !== 'storage' && usage1 === 'storage');\n    const fail =\n      usageHasConflict &&\n      visibility0 === 'compute' &&\n      visibility1 === 'compute' &&\n      usage0AccessibleInDispatch &&\n      usage1AccessibleInDispatch;\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, fail);\n  });\n\ng.test('subresources,buffer_usage_in_compute_pass_with_two_dispatches')\n  .desc(\n    `\nTest that it is always allowed to use one buffer in different dispatch calls as in WebGPU SPEC,\nwithin one dispatch, for each bind group slot that is used by the current GPUComputePipeline's\nlayout, every subresource referenced by that bind group is \"used\" in the usage scope, and different\ndispatch calls refer to different usage scopes.`\n  )\n  .params(u =>\n    u\n      .combine('usage0', ['uniform', 'storage', 'read-only-storage', 'indirect'] as const)\n      .combine('usage1', ['uniform', 'storage', 'read-only-storage', 'indirect'] as const)\n      .beginSubcases()\n      .combine('inSamePass', [true, false])\n      .combine('hasOverlap', [true, false])\n  )\n  .fn(async t => {\n    const { usage0, usage1, inSamePass, hasOverlap } = t.params;\n\n    const UseBufferOnComputePassEncoder = (\n      computePassEncoder: GPUComputePassEncoder,\n      buffer: GPUBuffer,\n      usage: 'uniform' | 'storage' | 'read-only-storage' | 'indirect',\n      offset: number\n    ) => {\n      switch (usage) {\n        case 'uniform':\n        case 'storage':\n        case 'read-only-storage': {\n          const bindGroup = t.createBindGroupForTest(buffer, offset, usage, 'compute');\n          computePassEncoder.setBindGroup(0, bindGroup);\n\n          const bindGroupLayout = t.createBindGroupLayoutForTest(usage, 'compute');\n          const pipelineLayout = t.device.createPipelineLayout({\n            bindGroupLayouts: [bindGroupLayout],\n          });\n          const computePipeline = t.createNoOpComputePipeline(pipelineLayout);\n          computePassEncoder.setPipeline(computePipeline);\n          computePassEncoder.dispatchWorkgroups(1);\n          break;\n        }\n        case 'indirect': {\n          const computePipeline = t.createNoOpComputePipeline();\n          computePassEncoder.setPipeline(computePipeline);\n          computePassEncoder.dispatchWorkgroupsIndirect(buffer, offset);\n          break;\n        }\n        default:\n          unreachable();\n          break;\n      }\n    };\n\n    const buffer = t.createBufferWithState('valid', {\n      size: kBoundBufferSize * 2,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const computePassEncoder = encoder.beginComputePass();\n\n    const offset0 = 0;\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    UseBufferOnComputePassEncoder(computePassEncoder, buffer, usage0, offset0);\n\n    if (inSamePass) {\n      UseBufferOnComputePassEncoder(computePassEncoder, buffer, usage1, offset1);\n      computePassEncoder.end();\n    } else {\n      computePassEncoder.end();\n      const anotherComputePassEncoder = encoder.beginComputePass();\n      UseBufferOnComputePassEncoder(anotherComputePassEncoder, buffer, usage1, offset1);\n      anotherComputePassEncoder.end();\n    }\n\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, false);\n  });\n\ng.test('subresources,buffer_usage_in_one_render_pass_with_no_draw')\n  .desc(\n    `\nTest that when one buffer is used in one render pass encoder, its list of internal usages within one\nusage scope (all the commands in the whole render pass) can only be a compatible usage list even if\nthere is no draw call in the render pass.\n    `\n  )\n  .params(u =>\n    u\n      .combine('usage0', ['uniform', 'storage', 'read-only-storage', 'vertex', 'index'] as const)\n      .combine('usage1', ['uniform', 'storage', 'read-only-storage', 'vertex', 'index'] as const)\n      .beginSubcases()\n      .combine('hasOverlap', [true, false])\n      .combine('visibility0', ['compute', 'fragment'] as const)\n      .unless(t => t.visibility0 === 'compute' && !IsBufferUsageInBindGroup(t.usage0))\n      .combine('visibility1', ['compute', 'fragment'] as const)\n      .unless(t => t.visibility1 === 'compute' && !IsBufferUsageInBindGroup(t.usage1))\n  )\n  .fn(async t => {\n    const { usage0, usage1, hasOverlap, visibility0, visibility1 } = t.params;\n\n    const UseBufferOnRenderPassEncoder = (\n      buffer: GPUBuffer,\n      offset: number,\n      type: BufferUsage,\n      bindGroupVisibility: 'compute' | 'fragment',\n      renderPassEncoder: GPURenderPassEncoder\n    ) => {\n      switch (type) {\n        case 'uniform':\n        case 'storage':\n        case 'read-only-storage': {\n          const bindGroup = t.createBindGroupForTest(buffer, offset, type, bindGroupVisibility);\n          renderPassEncoder.setBindGroup(0, bindGroup);\n          break;\n        }\n        case 'vertex': {\n          renderPassEncoder.setVertexBuffer(0, buffer, offset, kBoundBufferSize);\n          break;\n        }\n        case 'index': {\n          renderPassEncoder.setIndexBuffer(buffer, 'uint16', offset, kBoundBufferSize);\n          break;\n        }\n        case 'indirect':\n        case 'indexedIndirect':\n          unreachable();\n          break;\n      }\n    };\n\n    const buffer = t.createBufferWithState('valid', {\n      size: kBoundBufferSize * 2,\n      usage:\n        GPUBufferUsage.UNIFORM |\n        GPUBufferUsage.STORAGE |\n        GPUBufferUsage.VERTEX |\n        GPUBufferUsage.INDEX,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPassEncoder = t.beginSimpleRenderPass(encoder);\n    const offset0 = 0;\n    UseBufferOnRenderPassEncoder(buffer, offset0, usage0, visibility0, renderPassEncoder);\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    UseBufferOnRenderPassEncoder(buffer, offset1, usage1, visibility1, renderPassEncoder);\n    renderPassEncoder.end();\n\n    const fail = (usage0 === 'storage') !== (usage1 === 'storage');\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, fail);\n  });\n\ng.test('subresources,buffer_usage_in_one_render_pass_with_one_draw')\n  .desc(\n    `\nTest that when one buffer is used in one render pass encoder where there is one draw call, its list\nof internal usages within one usage scope (all the commands in the whole render pass) can only be a\ncompatible usage list. The usage scope rules are not related to the buffer offset or the bind group\nlayout visibilities.`\n  )\n  .params(u =>\n    u\n      .combine('usage0', kAllBufferUsages)\n      .combine('usage1', kAllBufferUsages)\n      .beginSubcases()\n      .combine('usage0AccessibleInDraw', [true, false])\n      .combine('usage1AccessibleInDraw', [true, false])\n      .combine('drawBeforeUsage1', [true, false])\n      .combine('visibility0', ['compute', 'fragment'] as const)\n      .filter(t => {\n        // The buffer with `indirect` or `indexedIndirect` usage is always accessible in the draw\n        // call.\n        if (\n          (t.usage0 === 'indirect' || t.usage0 === 'indexedIndirect') &&\n          (!t.usage0AccessibleInDraw || t.visibility0 !== 'fragment' || !t.drawBeforeUsage1)\n        ) {\n          return false;\n        }\n        // The buffer usages `vertex` and `index` do nothing with shader visibilities.\n        if ((t.usage0 === 'vertex' || t.usage0 === 'index') && t.visibility0 !== 'fragment') {\n          return false;\n        }\n\n        // As usage0 is accessible in the draw call, visibility0 can only be 'fragment'.\n        if (t.usage0AccessibleInDraw && t.visibility0 !== 'fragment') {\n          return false;\n        }\n        // As usage1 is accessible in the draw call, the draw call cannot be before usage1.\n        if (t.drawBeforeUsage1 && t.usage1AccessibleInDraw) {\n          return false;\n        }\n        return true;\n      })\n      .combine('visibility1', ['compute', 'fragment'] as const)\n      .filter(t => {\n        if (\n          (t.usage1 === 'indirect' || t.usage1 === 'indexedIndirect') &&\n          (!t.usage1AccessibleInDraw || t.visibility1 !== 'fragment' || t.drawBeforeUsage1)\n        ) {\n          return false;\n        }\n        if ((t.usage1 === 'vertex' || t.usage1 === 'index') && t.visibility1 !== 'fragment') {\n          return false;\n        }\n        // When the first buffer usage is `indirect` or `indexedIndirect`, there has already been\n        // one draw call, so in this test we always make the second usage inaccessible in the draw\n        // call.\n        if (\n          t.usage1AccessibleInDraw &&\n          (t.visibility1 !== 'fragment' ||\n            t.usage0 === 'indirect' ||\n            t.usage0 === 'indexedIndirect')\n        ) {\n          return false;\n        }\n        // When the first buffer usage is `index` and is accessible in the draw call, the second\n        // usage cannot be `indirect` (it should be `indexedIndirect` for the tests on indirect draw\n        // calls)\n        if (t.usage0 === 'index' && t.usage0AccessibleInDraw && t.usage1 === 'indirect') {\n          return false;\n        }\n        return true;\n      })\n      .combine('hasOverlap', [true, false])\n  )\n  .fn(async t => {\n    const {\n      // Buffer with usage0 will be \"used\" in the draw call if this value is true.\n      usage0AccessibleInDraw,\n      // Buffer with usage1 will be \"used\" in the draw call if this value is true.\n      usage1AccessibleInDraw,\n      // Whether we will have the draw call before setting the buffer usage as \"usage1\" or not.\n      // If it is true: set-usage0 -> draw -> set-usage1 or indirect-draw -> set-usage1\n      // Otherwise: set-usage0 -> set-usage1 -> draw or set-usage0 -> indirect-draw\n      drawBeforeUsage1,\n      usage0,\n      visibility0,\n      usage1,\n      visibility1,\n      hasOverlap,\n    } = t.params;\n    const buffer = t.createBufferWithState('valid', {\n      size: kBoundBufferSize * 2,\n      usage:\n        GPUBufferUsage.UNIFORM |\n        GPUBufferUsage.STORAGE |\n        GPUBufferUsage.VERTEX |\n        GPUBufferUsage.INDEX |\n        GPUBufferUsage.INDIRECT,\n    });\n\n    const UseBufferOnRenderPassEncoder = (\n      bufferAccessibleInDraw: boolean,\n      bufferIndex: number,\n      offset: number,\n      usage: BufferUsage,\n      bindGroupVisibility: 'compute' | 'fragment',\n      renderPassEncoder: GPURenderPassEncoder,\n      usedBindGroupLayouts: GPUBindGroupLayout[]\n    ) => {\n      switch (usage) {\n        case 'uniform':\n        case 'storage':\n        case 'read-only-storage': {\n          const bindGroup = t.createBindGroupForTest(buffer, offset, usage, bindGroupVisibility);\n          renderPassEncoder.setBindGroup(bufferIndex, bindGroup);\n          // To \"use\" the bind group we will set the corresponding bind group layout in the\n          // pipeline layout when creating the render pipeline.\n          if (bufferAccessibleInDraw && bindGroupVisibility === 'fragment') {\n            usedBindGroupLayouts.push(t.createBindGroupLayoutForTest(usage, bindGroupVisibility));\n          }\n          break;\n        }\n        case 'vertex': {\n          renderPassEncoder.setVertexBuffer(bufferIndex, buffer, offset);\n          break;\n        }\n        case 'index': {\n          renderPassEncoder.setIndexBuffer(buffer, 'uint16', offset);\n          break;\n        }\n        case 'indirect':\n        case 'indexedIndirect': {\n          // We will handle the indirect draw calls later.\n          break;\n        }\n      }\n    };\n\n    const MakeDrawCallWithOneUsage = (\n      usage: BufferUsage,\n      offset: number,\n      renderPassEncoder: GPURenderPassEncoder\n    ) => {\n      switch (usage) {\n        case 'uniform':\n        case 'read-only-storage':\n        case 'storage':\n        case 'vertex':\n          renderPassEncoder.draw(1);\n          break;\n        case 'index':\n          renderPassEncoder.drawIndexed(1);\n          break;\n        case 'indirect':\n          renderPassEncoder.drawIndirect(buffer, offset);\n          break;\n        case 'indexedIndirect': {\n          const indexBuffer = t.device.createBuffer({\n            size: 4,\n            usage: GPUBufferUsage.INDEX,\n          });\n          renderPassEncoder.setIndexBuffer(indexBuffer, 'uint16');\n          renderPassEncoder.drawIndexedIndirect(buffer, offset);\n          break;\n        }\n      }\n    };\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPassEncoder = t.beginSimpleRenderPass(encoder);\n\n    // Set buffer with usage0\n    const offset0 = 0;\n    // Invisible bind groups or vertex buffers are all bound to the slot 1.\n    const bufferIndex0 = visibility0 === 'fragment' ? 0 : 1;\n    const usedBindGroupLayouts: GPUBindGroupLayout[] = [];\n\n    UseBufferOnRenderPassEncoder(\n      usage0AccessibleInDraw,\n      bufferIndex0,\n      offset0,\n      usage0,\n      visibility0,\n      renderPassEncoder,\n      usedBindGroupLayouts\n    );\n\n    let vertexBufferCount = 0;\n\n    // Set pipeline and do draw call if drawBeforeUsage1 === true\n    if (drawBeforeUsage1) {\n      const pipelineLayout = t.device.createPipelineLayout({\n        bindGroupLayouts: usedBindGroupLayouts,\n      });\n      // To \"use\" the vertex buffer we need to set the corresponding vertex buffer layout when\n      // creating the render pipeline.\n      if (usage0 === 'vertex' && usage0AccessibleInDraw) {\n        ++vertexBufferCount;\n      }\n      const pipeline = t.createRenderPipelineForTest(pipelineLayout, vertexBufferCount);\n      renderPassEncoder.setPipeline(pipeline);\n      if (!usage0AccessibleInDraw) {\n        renderPassEncoder.draw(1);\n      } else {\n        MakeDrawCallWithOneUsage(usage0, offset0, renderPassEncoder);\n      }\n    }\n\n    // Set buffer with usage1.\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    let bufferIndex1 = 0;\n    if (visibility1 !== 'fragment') {\n      // Invisible bind groups or vertex buffers are all bound to the slot 1.\n      bufferIndex1 = 1;\n    } else if (visibility0 === 'fragment' && usage0AccessibleInDraw) {\n      // When buffer is bound to different bind groups or bound as vertex buffers in one render pass\n      // encoder, the second buffer binding should consume the slot 1.\n      if (IsBufferUsageInBindGroup(usage0) && IsBufferUsageInBindGroup(usage1)) {\n        bufferIndex1 = 1;\n      } else if (usage0 === 'vertex' && usage1 === 'vertex') {\n        bufferIndex1 = 1;\n      }\n    }\n\n    UseBufferOnRenderPassEncoder(\n      usage1AccessibleInDraw,\n      bufferIndex1,\n      offset1,\n      usage1,\n      visibility1,\n      renderPassEncoder,\n      usedBindGroupLayouts\n    );\n\n    // Set pipeline and do draw call if drawBeforeUsage1 === false\n    if (!drawBeforeUsage1) {\n      const pipelineLayout = t.device.createPipelineLayout({\n        bindGroupLayouts: usedBindGroupLayouts,\n      });\n      if (usage1 === 'vertex' && usage1AccessibleInDraw) {\n        // To \"use\" the vertex buffer we need to set the corresponding vertex buffer layout when\n        // creating the render pipeline.\n        ++vertexBufferCount;\n      }\n      const pipeline = t.createRenderPipelineForTest(pipelineLayout, vertexBufferCount);\n      renderPassEncoder.setPipeline(pipeline);\n\n      assert(usage0 !== 'indirect');\n      if (!usage0AccessibleInDraw && !usage1AccessibleInDraw) {\n        renderPassEncoder.draw(1);\n      } else if (usage0AccessibleInDraw && !usage1AccessibleInDraw) {\n        MakeDrawCallWithOneUsage(usage0, offset0, renderPassEncoder);\n      } else if (!usage0AccessibleInDraw && usage1AccessibleInDraw) {\n        MakeDrawCallWithOneUsage(usage1, offset1, renderPassEncoder);\n      } else {\n        if (usage1 === 'indexedIndirect') {\n          // If the index buffer has already been set (as usage0), we won't need to set another\n          // index buffer.\n          if (usage0 !== 'index') {\n            const indexBuffer = t.createBufferWithState('valid', {\n              size: 4,\n              usage: GPUBufferUsage.INDEX,\n            });\n            renderPassEncoder.setIndexBuffer(indexBuffer, 'uint16');\n          }\n          renderPassEncoder.drawIndexedIndirect(buffer, offset1);\n        } else if (usage1 === 'indirect') {\n          assert(usage0 !== 'index');\n          renderPassEncoder.drawIndirect(buffer, offset1);\n        } else if (usage0 === 'index' || usage1 === 'index') {\n          // We need to call drawIndexed to \"use\" the index buffer (as usage0 or usage1).\n          renderPassEncoder.drawIndexed(1);\n        } else {\n          renderPassEncoder.draw(1);\n        }\n      }\n    }\n    renderPassEncoder.end();\n\n    const fail = (usage0 === 'storage') !== (usage1 === 'storage');\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, fail);\n  });\n\ng.test('subresources,buffer_usage_in_one_render_pass_with_two_draws')\n  .desc(\n    `\nTest that when one buffer is used in different draw calls in one render pass, its list of internal\nusages within one usage scope (all the commands in the whole render pass) can only be a compatible\nusage list, and the usage scope rules are not related to the buffer offset, while the draw calls in\ndifferent render pass encoders belong to different usage scopes.`\n  )\n  .params(u =>\n    u\n      .combine('usage0', kAllBufferUsages)\n      .combine('usage1', kAllBufferUsages)\n      .beginSubcases()\n      .combine('inSamePass', [true, false])\n      .combine('hasOverlap', [true, false])\n  )\n  .fn(async t => {\n    const { usage0, usage1, inSamePass, hasOverlap } = t.params;\n    const buffer = t.createBufferWithState('valid', {\n      size: kBoundBufferSize * 2,\n      usage:\n        GPUBufferUsage.UNIFORM |\n        GPUBufferUsage.STORAGE |\n        GPUBufferUsage.VERTEX |\n        GPUBufferUsage.INDEX |\n        GPUBufferUsage.INDIRECT,\n    });\n    const UseBufferOnRenderPassEncoderInDrawCall = (\n      offset: number,\n      usage: BufferUsage,\n      renderPassEncoder: GPURenderPassEncoder\n    ) => {\n      switch (usage) {\n        case 'uniform':\n        case 'storage':\n        case 'read-only-storage': {\n          const bindGroupLayout = t.createBindGroupLayoutForTest(usage, 'fragment');\n          const pipelineLayout = t.device.createPipelineLayout({\n            bindGroupLayouts: [bindGroupLayout],\n          });\n          const pipeline = t.createRenderPipelineForTest(pipelineLayout, 0);\n          renderPassEncoder.setPipeline(pipeline);\n          const bindGroup = t.createBindGroupForTest(buffer, offset, usage, 'fragment');\n          renderPassEncoder.setBindGroup(0, bindGroup);\n          renderPassEncoder.draw(1);\n          break;\n        }\n        case 'vertex': {\n          const kVertexBufferCount = 1;\n          const pipeline = t.createRenderPipelineForTest('auto', kVertexBufferCount);\n          renderPassEncoder.setPipeline(pipeline);\n          renderPassEncoder.setVertexBuffer(0, buffer, offset);\n          renderPassEncoder.draw(1);\n          break;\n        }\n        case 'index': {\n          const pipeline = t.createRenderPipelineForTest('auto', 0);\n          renderPassEncoder.setPipeline(pipeline);\n          renderPassEncoder.setIndexBuffer(buffer, 'uint16', offset);\n          renderPassEncoder.drawIndexed(1);\n          break;\n        }\n        case 'indirect': {\n          const pipeline = t.createRenderPipelineForTest('auto', 0);\n          renderPassEncoder.setPipeline(pipeline);\n          renderPassEncoder.drawIndirect(buffer, offset);\n          break;\n        }\n        case 'indexedIndirect': {\n          const pipeline = t.createRenderPipelineForTest('auto', 0);\n          renderPassEncoder.setPipeline(pipeline);\n          const indexBuffer = t.createBufferWithState('valid', {\n            size: 4,\n            usage: GPUBufferUsage.INDEX,\n          });\n          renderPassEncoder.setIndexBuffer(indexBuffer, 'uint16');\n          renderPassEncoder.drawIndexedIndirect(buffer, offset);\n          break;\n        }\n      }\n    };\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPassEncoder = t.beginSimpleRenderPass(encoder);\n\n    const offset0 = 0;\n    UseBufferOnRenderPassEncoderInDrawCall(offset0, usage0, renderPassEncoder);\n\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    if (inSamePass) {\n      UseBufferOnRenderPassEncoderInDrawCall(offset1, usage1, renderPassEncoder);\n      renderPassEncoder.end();\n    } else {\n      renderPassEncoder.end();\n      const anotherRenderPassEncoder = t.beginSimpleRenderPass(encoder);\n      UseBufferOnRenderPassEncoderInDrawCall(offset1, usage1, anotherRenderPassEncoder);\n      anotherRenderPassEncoder.end();\n    }\n\n    const fail = inSamePass && (usage0 === 'storage') !== (usage1 === 'storage');\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, fail);\n  });\n"],"file":"in_pass_encoder.spec.js"}