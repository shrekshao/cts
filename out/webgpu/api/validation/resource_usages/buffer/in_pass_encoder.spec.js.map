{"version":3,"sources":["../../../../../../src/webgpu/api/validation/resource_usages/buffer/in_pass_encoder.spec.ts"],"names":["description","makeTestGroup","unreachable","ValidationTest","kBoundBufferSize","F","createBindGroupForTest","buffer","offset","type","resourceVisibility","bindGroupLayoutEntry","binding","visibility","GPUShaderStage","COMPUTE","FRAGMENT","bindGroupLayout","device","createBindGroupLayout","entries","createBindGroup","layout","resource","size","beginSimpleRenderPass","encoder","colorTexture","createTexture","format","usage","GPUTextureUsage","RENDER_ATTACHMENT","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","IsBufferUsageInBindGroup","bufferUsage","g","test","desc","params","u","combine","beginSubcases","unless","t","visibility0","usage0","visibility1","usage1","fn","inSamePass","hasOverlap","UseBufferOnRenderPassEncoder","index","bindGroupVisibility","renderPassEncoder","bindGroup","setBindGroup","setVertexBuffer","setIndexBuffer","renderPipeline","createNoOpRenderPipeline","setPipeline","drawIndirect","indexBuffer","createBuffer","GPUBufferUsage","INDEX","drawIndexedIndirect","UNIFORM","STORAGE","VERTEX","INDIRECT","createCommandEncoder","offset0","index0","offset1","index1","end","anotherRenderPassEncoder","fail","expectValidationError","finish"],"mappings":"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","sourcesContent":["export const description = `\nBuffer Usages Validation Tests in Render Pass and Compute Pass.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { unreachable } from '../../../../../common/util/util.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nconst kBoundBufferSize = 256;\n\nclass F extends ValidationTest {\n  createBindGroupForTest(\n    buffer: GPUBuffer,\n    offset: number,\n    type: 'uniform' | 'storage' | 'read-only-storage',\n    resourceVisibility: 'compute' | 'fragment'\n  ) {\n    const bindGroupLayoutEntry: GPUBindGroupLayoutEntry = {\n      binding: 0,\n      visibility:\n        resourceVisibility === 'compute' ? GPUShaderStage.COMPUTE : GPUShaderStage.FRAGMENT,\n      buffer: {\n        type,\n      },\n    };\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      entries: [bindGroupLayoutEntry],\n    });\n\n    return this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer, offset, size: kBoundBufferSize },\n        },\n      ],\n    });\n  }\n\n  beginSimpleRenderPass(encoder: GPUCommandEncoder) {\n    const colorTexture = this.device.createTexture({\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n      size: [16, 16, 1],\n    });\n    return encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: colorTexture.createView(),\n          loadOp: 'load',\n          storeOp: 'store',\n        },\n      ],\n    });\n  }\n}\n\nfunction IsBufferUsageInBindGroup(\n  bufferUsage:\n    | 'uniform'\n    | 'storage'\n    | 'read-only-storage'\n    | 'vertex'\n    | 'index'\n    | 'indirect'\n    | 'indexedIndirect'\n): boolean {\n  switch (bufferUsage) {\n    case 'uniform':\n    case 'storage':\n    case 'read-only-storage':\n      return true;\n    case 'vertex':\n    case 'index':\n    case 'indirect':\n    case 'indexedIndirect':\n      return false;\n    default:\n      unreachable();\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('subresources,buffer_usage_in_render_pass')\n  .desc(\n    `\nTest that when one buffer is used in one render pass encoder, its list of internal usages within one\nusage scope can only be a compatible usage list; while there is no such restriction when it is used\nin different render pass encoders. The usage scope rules are not related to the buffer offset or the\nbind group layout visibility.`\n  )\n  .params(u =>\n    u\n      .combine('inSamePass', [true, false])\n      .combine('hasOverlap', [true, false])\n      .beginSubcases()\n      .combine('usage0', [\n        'uniform',\n        'storage',\n        'read-only-storage',\n        'vertex',\n        'index',\n        'indirect',\n        'indexedIndirect',\n      ] as const)\n      .combine('visibility0', ['compute', 'fragment'] as const)\n      .unless(t => t.visibility0 === 'compute' && !IsBufferUsageInBindGroup(t.usage0))\n      .combine('usage1', [\n        'uniform',\n        'storage',\n        'read-only-storage',\n        'vertex',\n        'index',\n        'indirect',\n        'indexedIndirect',\n      ] as const)\n      .combine('visibility1', ['compute', 'fragment'] as const)\n      // The situation that the index buffer is reset by another setIndexBuffer call will be tested\n      // in another test case.\n      .unless(\n        t =>\n          (t.visibility1 === 'compute' && !IsBufferUsageInBindGroup(t.usage1)) ||\n          (t.usage0 === 'index' && t.usage1 === 'index')\n      )\n  )\n  .fn(async t => {\n    const { usage0, visibility0, usage1, visibility1, inSamePass, hasOverlap } = t.params;\n\n    const UseBufferOnRenderPassEncoder = (\n      buffer: GPUBuffer,\n      index: number,\n      offset: number,\n      type:\n        | 'uniform'\n        | 'storage'\n        | 'read-only-storage'\n        | 'vertex'\n        | 'index'\n        | 'indirect'\n        | 'indexedIndirect',\n      bindGroupVisibility: 'compute' | 'fragment',\n      renderPassEncoder: GPURenderPassEncoder\n    ) => {\n      switch (type) {\n        case 'uniform':\n        case 'storage':\n        case 'read-only-storage': {\n          const bindGroup = t.createBindGroupForTest(buffer, offset, type, bindGroupVisibility);\n          renderPassEncoder.setBindGroup(index, bindGroup);\n          break;\n        }\n        case 'vertex': {\n          renderPassEncoder.setVertexBuffer(index, buffer, offset, kBoundBufferSize);\n          break;\n        }\n        case 'index': {\n          renderPassEncoder.setIndexBuffer(buffer, 'uint16', offset, kBoundBufferSize);\n          break;\n        }\n        case 'indirect': {\n          const renderPipeline = t.createNoOpRenderPipeline();\n          renderPassEncoder.setPipeline(renderPipeline);\n          renderPassEncoder.drawIndirect(buffer, offset);\n          break;\n        }\n        case 'indexedIndirect': {\n          const renderPipeline = t.createNoOpRenderPipeline();\n          renderPassEncoder.setPipeline(renderPipeline);\n          const indexBuffer = t.device.createBuffer({\n            size: 4,\n            usage: GPUBufferUsage.INDEX,\n          });\n          renderPassEncoder.setIndexBuffer(indexBuffer, 'uint16');\n          renderPassEncoder.drawIndexedIndirect(buffer, offset);\n          break;\n        }\n      }\n    };\n\n    const buffer = t.device.createBuffer({\n      size: kBoundBufferSize * 2,\n      usage:\n        GPUBufferUsage.UNIFORM |\n        GPUBufferUsage.STORAGE |\n        GPUBufferUsage.VERTEX |\n        GPUBufferUsage.INDEX |\n        GPUBufferUsage.INDIRECT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPassEncoder = t.beginSimpleRenderPass(encoder);\n    const offset0 = 0;\n    const index0 = 0;\n    UseBufferOnRenderPassEncoder(buffer, index0, offset0, usage0, visibility0, renderPassEncoder);\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    const index1 = 1;\n    if (inSamePass) {\n      UseBufferOnRenderPassEncoder(buffer, index1, offset1, usage1, visibility1, renderPassEncoder);\n      renderPassEncoder.end();\n    } else {\n      renderPassEncoder.end();\n      const anotherRenderPassEncoder = t.beginSimpleRenderPass(encoder);\n      UseBufferOnRenderPassEncoder(\n        buffer,\n        index1,\n        offset1,\n        usage1,\n        visibility1,\n        anotherRenderPassEncoder\n      );\n      anotherRenderPassEncoder.end();\n    }\n\n    const fail =\n      inSamePass &&\n      ((usage0 === 'storage' && usage1 !== 'storage') ||\n        (usage0 !== 'storage' && usage1 === 'storage'));\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, fail);\n  });\n"],"file":"in_pass_encoder.spec.js"}