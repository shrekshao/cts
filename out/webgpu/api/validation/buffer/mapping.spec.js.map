{"version":3,"sources":["../../../../../src/webgpu/api/validation/buffer/mapping.spec.ts"],"names":["description","makeTestGroup","attemptGarbageCollection","assert","unreachable","kBufferUsages","GPUConst","ValidationTest","F","testMapAsyncCall","success","rejectName","buffer","mode","offset","size","p","mapAsync","expectValidationError","ex","Error","name","testGetMappedRangeCall","data","getMappedRange","expect","ArrayBuffer","undefined","byteLength","shouldThrow","createMappableBuffer","type","GPUMapMode","READ","device","createBuffer","usage","GPUBufferUsage","MAP_READ","WRITE","MAP_WRITE","g","kMapModeOptions","MapMode","kOffsetAlignment","kSizeAlignment","test","desc","paramsSubcasesOnly","u","combineWithParams","mapMode","validUsage","BufferUsage","combine","fn","t","params","getErrorBuffer","destroy","mappedAtCreation","unmap","shouldReject","bufferSize","mapping","bufferUsage","expectGPUError","subrangeSize","data0","data1","COPY_DST","mapping0","beginSubcases","mapOffset","actualOffset","actualSize","mapSize","actualMapOffset","actualMapSize","offset1","size1","offset2","size2","remapBetweenCalls","range1StartsAfter2","range2StartsAfter1","disjoint","kStride","kNumStrides","stride","contents","Uint32Array","i","length"],"mappings":"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","sourcesContent":["export const description = `\nValidation tests for GPUBuffer.mapAsync, GPUBuffer.unmap and GPUBuffer.getMappedRange.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { attemptGarbageCollection } from '../../../../common/util/collect_garbage.js';\nimport { assert, unreachable } from '../../../../common/util/util.js';\nimport { kBufferUsages } from '../../../capability_info.js';\nimport { GPUConst } from '../../../constants.js';\nimport { ValidationTest } from '../validation_test.js';\n\nclass F extends ValidationTest {\n  async testMapAsyncCall(\n    success: boolean,\n    rejectName: string | null,\n    buffer: GPUBuffer,\n    mode: GPUMapModeFlags,\n    offset?: number,\n    size?: number\n  ) {\n    if (success) {\n      const p = buffer.mapAsync(mode, offset, size);\n      await p;\n    } else {\n      let p: Promise<void>;\n      this.expectValidationError(() => {\n        p = buffer.mapAsync(mode, offset, size);\n      });\n      try {\n        await p!;\n        assert(rejectName === null, 'mapAsync unexpectedly passed');\n      } catch (ex) {\n        assert(ex instanceof Error, 'mapAsync rejected with non-error');\n        assert(rejectName === ex.name, `mapAsync rejected unexpectedly with: ${ex}`);\n      }\n    }\n  }\n\n  testGetMappedRangeCall(success: boolean, buffer: GPUBuffer, offset?: number, size?: number) {\n    if (success) {\n      const data = buffer.getMappedRange(offset, size);\n      this.expect(data instanceof ArrayBuffer);\n      if (size !== undefined) {\n        this.expect(data.byteLength === size);\n      }\n    } else {\n      this.shouldThrow('OperationError', () => {\n        buffer.getMappedRange(offset, size);\n      });\n    }\n  }\n\n  createMappableBuffer(type: GPUMapModeFlags, size: number): GPUBuffer {\n    switch (type) {\n      case GPUMapMode.READ:\n        return this.device.createBuffer({\n          size,\n          usage: GPUBufferUsage.MAP_READ,\n        });\n      case GPUMapMode.WRITE:\n        return this.device.createBuffer({\n          size,\n          usage: GPUBufferUsage.MAP_WRITE,\n        });\n      default:\n        unreachable();\n    }\n  }\n}\n\nexport const g = makeTestGroup(F);\n\nconst kMapModeOptions = [GPUConst.MapMode.READ, GPUConst.MapMode.WRITE];\nconst kOffsetAlignment = 8;\nconst kSizeAlignment = 4;\n\ng.test('mapAsync,usage')\n  .desc(\n    `Test the usage validation for mapAsync.\n\n  For each buffer usage:\n  For GPUMapMode.READ, GPUMapMode.WRITE, and 0:\n    Test that the mapAsync call is valid iff the mapping usage is not 0 and the buffer usage\n    the mapMode flag.`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combineWithParams([\n        { mapMode: GPUConst.MapMode.READ, validUsage: GPUConst.BufferUsage.MAP_READ },\n        { mapMode: GPUConst.MapMode.WRITE, validUsage: GPUConst.BufferUsage.MAP_WRITE },\n        // Using mapMode 0 is never valid, so there is no validUsage.\n        { mapMode: 0, validUsage: null },\n      ])\n      .combine('usage', kBufferUsages)\n  )\n  .fn(async t => {\n    const { mapMode, validUsage, usage } = t.params;\n\n    const buffer = t.device.createBuffer({\n      size: 16,\n      usage,\n    });\n\n    const success = usage === validUsage;\n    await t.testMapAsyncCall(success, 'OperationError', buffer, mapMode);\n  });\n\ng.test('mapAsync,invalidBuffer')\n  .desc('Test that mapAsync is an error when called on an invalid buffer.')\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const buffer = t.getErrorBuffer();\n    await t.testMapAsyncCall(false, 'OperationError', buffer, mapMode);\n  });\n\ng.test('mapAsync,state,destroyed')\n  .desc('Test that mapAsync is an error when called on a destroyed buffer.')\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n    buffer.destroy();\n    await t.testMapAsyncCall(false, 'OperationError', buffer, mapMode);\n  });\n\ng.test('mapAsync,state,mappedAtCreation')\n  .desc(\n    `Test that mapAsync is an error when called on a buffer mapped at creation,\n    but succeeds after unmapping it.`\n  )\n  .paramsSubcasesOnly([\n    { mapMode: GPUConst.MapMode.READ, validUsage: GPUConst.BufferUsage.MAP_READ },\n    { mapMode: GPUConst.MapMode.WRITE, validUsage: GPUConst.BufferUsage.MAP_WRITE },\n  ])\n  .fn(async t => {\n    const { mapMode, validUsage } = t.params;\n\n    const buffer = t.device.createBuffer({\n      size: 16,\n      usage: validUsage,\n      mappedAtCreation: true,\n    });\n    await t.testMapAsyncCall(false, 'OperationError', buffer, mapMode);\n\n    buffer.unmap();\n    await t.testMapAsyncCall(true, null, buffer, mapMode);\n  });\n\ng.test('mapAsync,state,mapped')\n  .desc(\n    `Test that mapAsync is an error when called on a mapped buffer, but succeeds\n    after unmapping it.`\n  )\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n\n    const buffer = t.createMappableBuffer(mapMode, 16);\n    await t.testMapAsyncCall(true, null, buffer, mapMode);\n    await t.testMapAsyncCall(false, 'OperationError', buffer, mapMode);\n\n    buffer.unmap();\n    await t.testMapAsyncCall(true, null, buffer, mapMode);\n  });\n\ng.test('mapAsync,state,mappingPending')\n  .desc(\n    `Test that mapAsync is an error when called on a buffer that is being mapped,\n    but succeeds after the previous mapping request is cancelled.`\n  )\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    // Start mapping the buffer, we are going to unmap it before it resolves so it will reject\n    // the mapping promise with an AbortError.\n    t.shouldReject('AbortError', buffer.mapAsync(mapMode));\n\n    // Do the test of mapAsync while [[state]] is mapping pending. It has to be synchronous so\n    // that we can unmap the previous mapping in the same stack frame and check this one doesn't\n    // get canceled, but instead is treated as a real error.\n    t.expectValidationError(() => {\n      t.shouldReject('OperationError', buffer.mapAsync(mapMode));\n    });\n\n    // Unmap the first mapping. It should now be possible to successfully call mapAsync\n    buffer.unmap();\n    await t.testMapAsyncCall(true, null, buffer, mapMode);\n  });\n\ng.test('mapAsync,sizeUnspecifiedOOB')\n  .desc(\n    `Test that mapAsync with size unspecified rejects if offset > buffer.[[size]],\n    with various cases at the limits of the buffer size or with a misaligned offset.\n    Also test for an empty buffer.`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('mapMode', kMapModeOptions)\n      .combineWithParams([\n        // 0 size buffer.\n        { bufferSize: 0, offset: 0 },\n        { bufferSize: 0, offset: 1 },\n        { bufferSize: 0, offset: kOffsetAlignment },\n\n        // Test with a buffer that's not empty.\n        { bufferSize: 16, offset: 0 },\n        { bufferSize: 16, offset: kOffsetAlignment },\n        { bufferSize: 16, offset: 16 },\n        { bufferSize: 16, offset: 17 },\n        { bufferSize: 16, offset: 16 + kOffsetAlignment },\n      ])\n  )\n  .fn(async t => {\n    const { mapMode, bufferSize, offset } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, bufferSize);\n\n    const success = offset <= bufferSize;\n    await t.testMapAsyncCall(success, 'OperationError', buffer, mapMode, offset);\n  });\n\ng.test('mapAsync,offsetAndSizeAlignment')\n  .desc(\"Test that mapAsync fails if the alignment of offset and size isn't correct.\")\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('mapMode', kMapModeOptions)\n      .combine('offset', [0, kOffsetAlignment, kOffsetAlignment / 2])\n      .combine('size', [0, kSizeAlignment, kSizeAlignment / 2])\n  )\n  .fn(async t => {\n    const { mapMode, offset, size } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    const success = offset % kOffsetAlignment === 0 && size % kSizeAlignment === 0;\n    await t.testMapAsyncCall(success, 'OperationError', buffer, mapMode, offset, size);\n  });\n\ng.test('mapAsync,offsetAndSizeOOB')\n  .desc('Test that mapAsync fails if offset + size is larger than the buffer size.')\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('mapMode', kMapModeOptions)\n      .combineWithParams([\n        // For a 0 size buffer\n        { bufferSize: 0, offset: 0, size: 0 },\n        { bufferSize: 0, offset: 0, size: 4 },\n        { bufferSize: 0, offset: 8, size: 0 },\n\n        // For a small buffer\n        { bufferSize: 16, offset: 0, size: 16 },\n        { bufferSize: 16, offset: kOffsetAlignment, size: 16 },\n\n        { bufferSize: 16, offset: 16, size: 0 },\n        { bufferSize: 16, offset: 16, size: kSizeAlignment },\n\n        { bufferSize: 16, offset: 8, size: 0 },\n        { bufferSize: 16, offset: 8, size: 8 },\n        { bufferSize: 16, offset: 8, size: 8 + kSizeAlignment },\n\n        // For a larger buffer\n        { bufferSize: 1024, offset: 0, size: 1024 },\n        { bufferSize: 1024, offset: kOffsetAlignment, size: 1024 },\n\n        { bufferSize: 1024, offset: 1024, size: 0 },\n        { bufferSize: 1024, offset: 1024, size: kSizeAlignment },\n\n        { bufferSize: 1024, offset: 512, size: 0 },\n        { bufferSize: 1024, offset: 512, size: 512 },\n        { bufferSize: 1024, offset: 512, size: 512 + kSizeAlignment },\n      ])\n  )\n  .fn(async t => {\n    const { mapMode, bufferSize, size, offset } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, bufferSize);\n\n    const success = offset + size <= bufferSize;\n    await t.testMapAsyncCall(success, 'OperationError', buffer, mapMode, offset, size);\n  });\n\ng.test('getMappedRange,state,mapped')\n  .desc('Test that it is valid to call getMappedRange in the mapped state')\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const bufferSize = 16;\n    const buffer = t.createMappableBuffer(mapMode, bufferSize);\n    await buffer.mapAsync(mapMode);\n\n    const data = buffer.getMappedRange();\n    t.expect(data instanceof ArrayBuffer);\n    t.expect(data.byteLength === bufferSize);\n\n    t.expectValidationError(() => {\n      // map on already mapped buffer should be rejected\n      const mapping = buffer.mapAsync(mapMode);\n      t.expect(data.byteLength === bufferSize);\n      t.shouldReject('OperationError', mapping);\n    });\n\n    t.expect(data.byteLength === bufferSize);\n\n    buffer.unmap();\n\n    t.expect(data.byteLength === 0);\n  });\n\ng.test('getMappedRange,state,mappedAtCreation')\n  .desc(\n    `Test that, in the mapped-at-creation state, it is valid to call getMappedRange, for all buffer usages,\n    and invalid to call mapAsync, for all map modes.`\n  )\n  .paramsSubcasesOnly(u =>\n    u.combine('bufferUsage', kBufferUsages).combine('mapMode', kMapModeOptions)\n  )\n  .fn(async t => {\n    const { bufferUsage, mapMode } = t.params;\n    const bufferSize = 16;\n    const buffer = t.device.createBuffer({\n      usage: bufferUsage,\n      size: bufferSize,\n      mappedAtCreation: true,\n    });\n\n    const data = buffer.getMappedRange();\n    t.expect(data instanceof ArrayBuffer);\n    t.expect(data.byteLength === bufferSize);\n\n    t.expectValidationError(() => {\n      // map on already mapped buffer should be rejected\n      const mapping = buffer.mapAsync(mapMode);\n      t.expect(data.byteLength === bufferSize);\n      t.shouldReject('OperationError', mapping);\n    });\n\n    t.expect(data.byteLength === bufferSize);\n\n    buffer.unmap();\n\n    t.expect(data.byteLength === 0);\n  });\n\ng.test('getMappedRange,state,invalid_mappedAtCreation')\n  .desc(\n    `mappedAtCreation should return a mapped buffer, even if the buffer is invalid.\nLike VRAM allocation (see map_oom), validation can be performed asynchronously (in the GPU process)\nso the Content process doesn't necessarily know the buffer is invalid.`\n  )\n  .fn(async t => {\n    const buffer = t.expectGPUError('validation', () =>\n      t.device.createBuffer({\n        mappedAtCreation: true,\n        size: 16,\n        usage: 0xffff_ffff, // Invalid usage\n      })\n    );\n\n    // Should still be valid.\n    buffer.getMappedRange();\n  });\n\ng.test('getMappedRange,state,mappedAgain')\n  .desc(\n    'Test that it is valid to call getMappedRange in the mapped state, even if there is a duplicate mapAsync before'\n  )\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n    await buffer.mapAsync(mapMode);\n\n    // call mapAsync again on already mapped buffer should fail\n    await t.testMapAsyncCall(false, 'OperationError', buffer, mapMode);\n\n    // getMapppedRange should still success\n    t.testGetMappedRangeCall(true, buffer);\n  });\n\ng.test('getMappedRange,state,unmapped')\n  .desc(\n    `Test that it is invalid to call getMappedRange in the unmapped state.\nTest for various cases of being unmapped: at creation, after a mapAsync call or after being created mapped.`\n  )\n  .fn(async t => {\n    // It is invalid to call getMappedRange when the buffer starts unmapped when created.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      t.testGetMappedRangeCall(false, buffer);\n    }\n\n    // It is invalid to call getMappedRange when the buffer is unmapped after mapAsync.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      await buffer.mapAsync(GPUMapMode.READ);\n      buffer.unmap();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n\n    // It is invalid to call getMappedRange when the buffer is unmapped after mappedAtCreation.\n    {\n      const buffer = t.device.createBuffer({\n        usage: GPUBufferUsage.MAP_READ,\n        size: 16,\n        mappedAtCreation: true,\n      });\n      buffer.unmap();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n  });\n\ng.test('getMappedRange,subrange,mapped')\n  .desc(\n    `Test that old getMappedRange returned arraybuffer does not exist after unmap, and newly returned\n    arraybuffer after new map has correct subrange`\n  )\n  .params(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const bufferSize = 16;\n    const offset = 8;\n    const subrangeSize = bufferSize - offset;\n    const buffer = t.createMappableBuffer(mapMode, bufferSize);\n    await buffer.mapAsync(mapMode);\n\n    const data0 = buffer.getMappedRange();\n    t.expect(data0 instanceof ArrayBuffer);\n    t.expect(data0.byteLength === bufferSize);\n\n    buffer.unmap();\n    t.expect(data0.byteLength === 0);\n\n    await buffer.mapAsync(mapMode, offset);\n    const data1 = buffer.getMappedRange(8);\n\n    t.expect(data0.byteLength === 0);\n    t.expect(data1.byteLength === subrangeSize);\n  });\n\ng.test('getMappedRange,subrange,mappedAtCreation')\n  .desc(\n    `Test that old getMappedRange returned arraybuffer does not exist after unmap and newly returned\n    arraybuffer after new map has correct subrange`\n  )\n  .fn(async t => {\n    const bufferSize = 16;\n    const offset = 8;\n    const subrangeSize = bufferSize - offset;\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n      mappedAtCreation: true,\n    });\n\n    const data0 = buffer.getMappedRange();\n    t.expect(data0 instanceof ArrayBuffer);\n    t.expect(data0.byteLength === bufferSize);\n\n    buffer.unmap();\n    t.expect(data0.byteLength === 0);\n\n    await buffer.mapAsync(GPUMapMode.READ, offset);\n    const data1 = buffer.getMappedRange(8);\n\n    t.expect(data0.byteLength === 0);\n    t.expect(data1.byteLength === subrangeSize);\n  });\n\ng.test('getMappedRange,state,destroyed')\n  .desc(\n    `Test that it is invalid to call getMappedRange in the destroyed state.\nTest for various cases of being destroyed: at creation, after a mapAsync call or after being created mapped.`\n  )\n  .fn(async t => {\n    // It is invalid to call getMappedRange when the buffer is destroyed when unmapped.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      buffer.destroy();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n\n    // It is invalid to call getMappedRange when the buffer is destroyed when mapped.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      await buffer.mapAsync(GPUMapMode.READ);\n      buffer.destroy();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n\n    // It is invalid to call getMappedRange when the buffer is destroyed when mapped at creation.\n    {\n      const buffer = t.device.createBuffer({\n        usage: GPUBufferUsage.MAP_READ,\n        size: 16,\n        mappedAtCreation: true,\n      });\n      buffer.destroy();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n  });\n\ng.test('getMappedRange,state,mappingPending')\n  .desc('Test that it is invalid to call getMappedRange in the mappingPending state.')\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    /* noawait */ const mapping0 = buffer.mapAsync(mapMode);\n    t.expectValidationError(() => {\n      // seconding mapping should be rejected\n      t.shouldReject('OperationError', buffer.mapAsync(mapMode));\n    });\n\n    // invalid in mappingPending state\n    t.testGetMappedRangeCall(false, buffer);\n\n    await mapping0;\n\n    // valid after buffer is mapped\n    t.testGetMappedRangeCall(true, buffer);\n  });\n\ng.test('getMappedRange,offsetAndSizeAlignment,mapped')\n  .desc(`Test that getMappedRange fails if the alignment of offset and size isn't correct.`)\n  .params(u =>\n    u\n      .combine('mapMode', kMapModeOptions)\n      .beginSubcases()\n      .combine('mapOffset', [0, kOffsetAlignment])\n      .combine('offset', [0, kOffsetAlignment, kOffsetAlignment / 2])\n      .combine('size', [0, kSizeAlignment, kSizeAlignment / 2])\n  )\n  .fn(async t => {\n    const { mapMode, mapOffset, offset, size } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 32);\n    await buffer.mapAsync(mapMode, mapOffset);\n\n    const success = offset % kOffsetAlignment === 0 && size % kSizeAlignment === 0;\n    t.testGetMappedRangeCall(success, buffer, offset + mapOffset, size);\n  });\n\ng.test('getMappedRange,offsetAndSizeAlignment,mappedAtCreation')\n  .desc(`Test that getMappedRange fails if the alignment of offset and size isn't correct.`)\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('offset', [0, kOffsetAlignment, kOffsetAlignment / 2])\n      .combine('size', [0, kSizeAlignment, kSizeAlignment / 2])\n  )\n  .fn(async t => {\n    const { offset, size } = t.params;\n    const buffer = t.device.createBuffer({\n      size: 16,\n      usage: GPUBufferUsage.COPY_DST,\n      mappedAtCreation: true,\n    });\n    const success = offset % kOffsetAlignment === 0 && size % kSizeAlignment === 0;\n    t.testGetMappedRangeCall(success, buffer, offset, size);\n  });\n\ng.test('getMappedRange,sizeAndOffsetOOB,mappedAtCreation')\n  .desc(\n    `Test that getMappedRange size + offset must be less than the buffer size for a\n    buffer mapped at creation. (and offset has not constraints on its own)`\n  )\n  .paramsSubcasesOnly([\n    // Tests for a zero-sized buffer, with and without a size defined.\n    { bufferSize: 0, offset: undefined, size: undefined },\n    { bufferSize: 0, offset: undefined, size: 0 },\n    { bufferSize: 0, offset: undefined, size: kSizeAlignment },\n    { bufferSize: 0, offset: 0, size: undefined },\n    { bufferSize: 0, offset: 0, size: 0 },\n    { bufferSize: 0, offset: kOffsetAlignment, size: undefined },\n    { bufferSize: 0, offset: kOffsetAlignment, size: 0 },\n\n    // Tests for a non-empty buffer, with an undefined offset.\n    { bufferSize: 80, offset: undefined, size: 80 },\n    { bufferSize: 80, offset: undefined, size: 80 + kSizeAlignment },\n\n    // Tests for a non-empty buffer, with an undefined size.\n    { bufferSize: 80, offset: undefined, size: undefined },\n    { bufferSize: 80, offset: 0, size: undefined },\n    { bufferSize: 80, offset: kOffsetAlignment, size: undefined },\n    { bufferSize: 80, offset: 80, size: undefined },\n    { bufferSize: 80, offset: 80 + kOffsetAlignment, size: undefined },\n\n    // Tests for a non-empty buffer with a size defined.\n    { bufferSize: 80, offset: 0, size: 80 },\n    { bufferSize: 80, offset: 0, size: 80 + kSizeAlignment },\n    { bufferSize: 80, offset: kOffsetAlignment, size: 80 },\n\n    { bufferSize: 80, offset: 40, size: 40 },\n    { bufferSize: 80, offset: 40 + kOffsetAlignment, size: 40 },\n    { bufferSize: 80, offset: 40, size: 40 + kSizeAlignment },\n  ])\n  .fn(t => {\n    const { bufferSize, offset, size } = t.params;\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_DST,\n      mappedAtCreation: true,\n    });\n\n    const actualOffset = offset ?? 0;\n    const actualSize = size ?? bufferSize - actualOffset;\n\n    const success = actualOffset <= bufferSize && actualOffset + actualSize <= bufferSize;\n    t.testGetMappedRangeCall(success, buffer, offset, size);\n  });\n\ng.test('getMappedRange,sizeAndOffsetOOB,mapped')\n  .desc('Test that getMappedRange size + offset must be less than the mapAsync range.')\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('mapMode', kMapModeOptions)\n      .combineWithParams([\n        // Tests for an empty buffer, and implicit mapAsync size.\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: undefined, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: undefined, size: 0 },\n        {\n          bufferSize: 0,\n          mapOffset: 0,\n          mapSize: undefined,\n          offset: undefined,\n          size: kSizeAlignment,\n        },\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: 0, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: 0, size: 0 },\n        {\n          bufferSize: 0,\n          mapOffset: 0,\n          mapSize: undefined,\n          offset: kOffsetAlignment,\n          size: undefined,\n        },\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: kOffsetAlignment, size: 0 },\n\n        // Tests for an empty buffer, and explicit mapAsync size.\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: undefined, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: 0, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: 0, size: 0 },\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: kOffsetAlignment, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: kOffsetAlignment, size: 0 },\n\n        // Test for a fully implicit mapAsync call\n        { bufferSize: 80, mapOffset: undefined, mapSize: undefined, offset: 0, size: 80 },\n        {\n          bufferSize: 80,\n          mapOffset: undefined,\n          mapSize: undefined,\n          offset: 0,\n          size: 80 + kSizeAlignment,\n        },\n        {\n          bufferSize: 80,\n          mapOffset: undefined,\n          mapSize: undefined,\n          offset: kOffsetAlignment,\n          size: 80,\n        },\n\n        // Test for a mapAsync call with an implicit size\n        { bufferSize: 80, mapOffset: 24, mapSize: undefined, offset: 24, size: 80 - 24 },\n        {\n          bufferSize: 80,\n          mapOffset: 24,\n          mapSize: undefined,\n          offset: 0,\n          size: 80 - 24 + kSizeAlignment,\n        },\n        {\n          bufferSize: 80,\n          mapOffset: 24,\n          mapSize: undefined,\n          offset: kOffsetAlignment,\n          size: 80 - 24,\n        },\n\n        // Test for a non-empty buffer fully mapped.\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 0, size: 80 },\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: kOffsetAlignment, size: 80 },\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 0, size: 80 + kSizeAlignment },\n\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 40, size: 40 },\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 40 + kOffsetAlignment, size: 40 },\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 40, size: 40 + kSizeAlignment },\n\n        // Test for a buffer partially mapped.\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24, size: 40 },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24 - kOffsetAlignment, size: 40 },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24 + kOffsetAlignment, size: 40 },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24, size: 40 + kSizeAlignment },\n\n        // Test for a partially mapped buffer with implicit size and offset for getMappedRange.\n        // - Buffer partially mapped in the middle\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: undefined, size: undefined },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 0, size: undefined },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24, size: undefined },\n        // - Buffer partially mapped to the end\n        { bufferSize: 80, mapOffset: 24, mapSize: undefined, offset: 24, size: undefined },\n        { bufferSize: 80, mapOffset: 24, mapSize: undefined, offset: 80, size: undefined },\n        // - Buffer partially mapped from the start\n        { bufferSize: 80, mapOffset: 0, mapSize: 64, offset: undefined, size: undefined },\n        { bufferSize: 80, mapOffset: 0, mapSize: 64, offset: undefined, size: 64 },\n      ])\n  )\n  .fn(async t => {\n    const { mapMode, bufferSize, mapOffset, mapSize, offset, size } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, bufferSize);\n    await buffer.mapAsync(mapMode, mapOffset, mapSize);\n\n    const actualMapOffset = mapOffset ?? 0;\n    const actualMapSize = mapSize ?? bufferSize - actualMapOffset;\n\n    const actualOffset = offset ?? 0;\n    const actualSize = size ?? bufferSize - actualOffset;\n\n    const success =\n      actualOffset >= actualMapOffset &&\n      actualOffset <= bufferSize &&\n      actualOffset + actualSize <= actualMapOffset + actualMapSize;\n    t.testGetMappedRangeCall(success, buffer, offset, size);\n  });\n\ng.test('getMappedRange,disjointRanges')\n  .desc('Test that the ranges asked through getMappedRange must be disjoint.')\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('remapBetweenCalls', [false, true])\n      .combineWithParams([\n        // Disjoint ranges with one that's empty.\n        { offset1: 8, size1: 0, offset2: 8, size2: 8 },\n        { offset1: 16, size1: 0, offset2: 8, size2: 8 },\n\n        { offset1: 8, size1: 8, offset2: 8, size2: 0 },\n        { offset1: 8, size1: 8, offset2: 16, size2: 0 },\n\n        // Disjoint ranges with both non-empty.\n        { offset1: 0, size1: 8, offset2: 8, size2: 8 },\n        { offset1: 16, size1: 8, offset2: 8, size2: 8 },\n\n        { offset1: 8, size1: 8, offset2: 0, size2: 8 },\n        { offset1: 8, size1: 8, offset2: 16, size2: 8 },\n\n        // Empty range contained inside another one.\n        { offset1: 16, size1: 20, offset2: 24, size2: 0 },\n        { offset1: 24, size1: 0, offset2: 16, size2: 20 },\n\n        // Ranges that overlap only partially.\n        { offset1: 16, size1: 20, offset2: 8, size2: 20 },\n        { offset1: 16, size1: 20, offset2: 32, size2: 20 },\n\n        // Ranges that include one another.\n        { offset1: 0, size1: 80, offset2: 16, size2: 20 },\n        { offset1: 16, size1: 20, offset2: 0, size2: 80 },\n      ])\n  )\n  .fn(async t => {\n    const { offset1, size1, offset2, size2, remapBetweenCalls } = t.params;\n    const buffer = t.device.createBuffer({ size: 80, usage: GPUBufferUsage.MAP_READ });\n    await buffer.mapAsync(GPUMapMode.READ);\n\n    t.testGetMappedRangeCall(true, buffer, offset1, size1);\n\n    if (remapBetweenCalls) {\n      buffer.unmap();\n      await buffer.mapAsync(GPUMapMode.READ);\n    }\n\n    const range1StartsAfter2 = offset1 >= offset2 + size2;\n    const range2StartsAfter1 = offset2 >= offset1 + size1;\n    const disjoint = range1StartsAfter2 || range2StartsAfter1;\n    const success = disjoint || remapBetweenCalls;\n\n    t.testGetMappedRangeCall(success, buffer, offset2, size2);\n  });\n\ng.test('getMappedRange,disjoinRanges_many')\n  .desc('Test getting a lot of small ranges, and that the disjoint check checks them all.')\n  .fn(async t => {\n    const kStride = 256;\n    const kNumStrides = 256;\n\n    const buffer = t.device.createBuffer({\n      size: kStride * kNumStrides,\n      usage: GPUBufferUsage.MAP_READ,\n    });\n    await buffer.mapAsync(GPUMapMode.READ);\n\n    // Get a lot of small mapped ranges.\n    for (let stride = 0; stride < kNumStrides; stride++) {\n      t.testGetMappedRangeCall(true, buffer, stride * kStride, 8);\n    }\n\n    // Check for each range it is invalid to get a range that overlaps it and check that it is valid\n    // to get ranges for the rest of the buffer.\n    for (let stride = 0; stride < kNumStrides; stride++) {\n      t.testGetMappedRangeCall(false, buffer, stride * kStride, kStride);\n      t.testGetMappedRangeCall(true, buffer, stride * kStride + 8, kStride - 8);\n    }\n  });\n\ng.test('unmap,state,unmapped')\n  .desc(\n    `Test it is invalid to call unmap on a buffer that is unmapped (at creation, or after\n    mappedAtCreation or mapAsync)`\n  )\n  .fn(async t => {\n    // It is invalid to call unmap after creation of an unmapped buffer.\n    {\n      const buffer = t.device.createBuffer({ size: 16, usage: GPUBufferUsage.MAP_READ });\n      t.expectValidationError(() => {\n        buffer.unmap();\n      });\n    }\n\n    // It is invalid to call unmap after unmapping a mapAsynced buffer.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      await buffer.mapAsync(GPUMapMode.READ);\n      buffer.unmap();\n      t.expectValidationError(() => {\n        buffer.unmap();\n      });\n    }\n\n    // It is invalid to call unmap after unmapping a mappedAtCreation buffer.\n    {\n      const buffer = t.device.createBuffer({\n        usage: GPUBufferUsage.MAP_READ,\n        size: 16,\n        mappedAtCreation: true,\n      });\n      buffer.unmap();\n      t.expectValidationError(() => {\n        buffer.unmap();\n      });\n    }\n  });\n\ng.test('unmap,state,destroyed')\n  .desc(\n    `Test it is invalid to call unmap on a buffer that is destroyed (at creation, or after\n    mappedAtCreation or mapAsync)`\n  )\n  .fn(async t => {\n    // It is invalid to call unmap after destruction of an unmapped buffer.\n    {\n      const buffer = t.device.createBuffer({ size: 16, usage: GPUBufferUsage.MAP_READ });\n      buffer.destroy();\n      t.expectValidationError(() => {\n        buffer.unmap();\n      });\n    }\n\n    // It is invalid to call unmap after destroying a mapAsynced buffer.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      await buffer.mapAsync(GPUMapMode.READ);\n      buffer.destroy();\n      t.expectValidationError(() => {\n        buffer.unmap();\n      });\n    }\n\n    // It is invalid to call unmap after destroying a mappedAtCreation buffer.\n    {\n      const buffer = t.device.createBuffer({\n        usage: GPUBufferUsage.MAP_READ,\n        size: 16,\n        mappedAtCreation: true,\n      });\n      buffer.destroy();\n      t.expectValidationError(() => {\n        buffer.unmap();\n      });\n    }\n  });\n\ng.test('unmap,state,mappedAtCreation')\n  .desc('Test it is valid to call unmap on a buffer mapped at creation, for various usages')\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('bufferUsage', kBufferUsages)\n  )\n  .fn(t => {\n    const { bufferUsage } = t.params;\n    const buffer = t.device.createBuffer({ size: 16, usage: bufferUsage, mappedAtCreation: true });\n\n    buffer.unmap();\n  });\n\ng.test('unmap,state,mapped')\n  .desc(\"Test it is valid to call unmap on a buffer that's mapped\")\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    await buffer.mapAsync(mapMode);\n    buffer.unmap();\n  });\n\ng.test('unmap,state,mappingPending')\n  .desc(\"Test it is valid to call unmap on a buffer that's being mapped\")\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    const mapping = buffer.mapAsync(mapMode);\n    t.shouldReject('AbortError', mapping);\n\n    buffer.unmap();\n  });\n\ng.test('gc_behavior,mappedAtCreation')\n  .desc(\n    \"Test that GCing the buffer while mappings are handed out doesn't invalidate them - mappedAtCreation case\"\n  )\n  .fn(async t => {\n    let buffer = null;\n    buffer = t.device.createBuffer({\n      size: 256,\n      usage: GPUBufferUsage.COPY_DST,\n      mappedAtCreation: true,\n    });\n\n    // Write some non-zero data to the buffer.\n    const contents = new Uint32Array(buffer.getMappedRange());\n    for (let i = 0; i < contents.length; i++) {\n      contents[i] = i;\n    }\n\n    // Trigger garbage collection that should collect the buffer (or as if it collected it)\n    // NOTE: This won't fail unless the browser immediately starts reusing the memory, or gives it\n    // back to the OS. One good option for browsers to check their logic is good is to zero-out the\n    // memory on GPUBuffer (or internal gpu::Buffer-like object) destruction.\n    buffer = null;\n    await attemptGarbageCollection();\n\n    // Use the mapping again both for read and write, it should work.\n    for (let i = 0; i < contents.length; i++) {\n      t.expect(contents[i] === i);\n      contents[i] = i + 1;\n    }\n  });\n\ng.test('gc_behavior,mapAsync')\n  .desc(\n    \"Test that GCing the buffer while mappings are handed out doesn't invalidate them - mapAsync case\"\n  )\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n\n    let buffer = null;\n    buffer = t.createMappableBuffer(mapMode, 256);\n    await buffer.mapAsync(mapMode);\n\n    // Write some non-zero data to the buffer.\n    const contents = new Uint32Array(buffer.getMappedRange());\n    for (let i = 0; i < contents.length; i++) {\n      contents[i] = i;\n    }\n\n    // Trigger garbage collection that should collect the buffer (or as if it collected it)\n    // NOTE: This won't fail unless the browser immediately starts reusing the memory, or gives it\n    // back to the OS. One good option for browsers to check their logic is good is to zero-out the\n    // memory on GPUBuffer (or internal gpu::Buffer-like object) destruction.\n    buffer = null;\n    await attemptGarbageCollection();\n\n    // Use the mapping again both for read and write, it should work.\n    for (let i = 0; i < contents.length; i++) {\n      t.expect(contents[i] === i);\n      contents[i] = i + 1;\n    }\n  });\n"],"file":"mapping.spec.js"}