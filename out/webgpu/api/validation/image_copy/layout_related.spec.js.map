{"version":3,"sources":["../../../../../src/webgpu/api/validation/image_copy/layout_related.spec.ts"],"names":["description","makeTestGroup","assert","kTextureFormatInfo","kSizedTextureFormats","align","bytesInACompleteRow","dataBytesForCopyOrOverestimate","dataBytesForCopyOrFail","kImageCopyTypes","ImageCopyTest","texelBlockAlignmentTestExpanderForOffset","texelBlockAlignmentTestExpanderForRowsPerImage","formatCopyableWithMethod","g","test","params","u","combine","beginSubcases","undefined","fn","t","rowsPerImage","copyHeightInBlocks","copyDepth","method","format","copyHeight","blockHeight","texture","device","createTexture","size","width","height","depthOrArrayLayers","usage","GPUTextureUsage","COPY_SRC","COPY_DST","layout","bytesPerRow","copySize","minDataSizeOrOverestimate","copyValid","testRun","dataSize","success","desc","combineWithParams","_success","filter","bytesPerRowPadding","rowsPerImagePaddingInBlocks","copyWidthInBlocks","offsetInBlocks","info","depth","stencil","selectDeviceOrSkipTestCase","feature","bytesPerRowAlignment","copyWidth","blockWidth","offset","bytesPerBlock","minDataSize","createAlignedTexture","expand","expandWithParams","p","widthInBlocks","dataSizeInBlocks"],"mappings":"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","sourcesContent":["export const description = '';\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert } from '../../../../common/util/util.js';\nimport { kTextureFormatInfo, kSizedTextureFormats } from '../../../capability_info.js';\nimport { align } from '../../../util/math.js';\nimport {\n  bytesInACompleteRow,\n  dataBytesForCopyOrOverestimate,\n  dataBytesForCopyOrFail,\n  kImageCopyTypes,\n} from '../../../util/texture/layout.js';\n\nimport {\n  ImageCopyTest,\n  texelBlockAlignmentTestExpanderForOffset,\n  texelBlockAlignmentTestExpanderForRowsPerImage,\n  formatCopyableWithMethod,\n} from './image_copy.js';\n\nexport const g = makeTestGroup(ImageCopyTest);\n\ng.test('bound_on_rows_per_image')\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .beginSubcases()\n      .combine('rowsPerImage', [undefined, 0, 1, 2, 1024])\n      .combine('copyHeightInBlocks', [0, 1, 2])\n      .combine('copyDepth', [1, 3])\n  )\n  .fn(async t => {\n    const { rowsPerImage, copyHeightInBlocks, copyDepth, method } = t.params;\n\n    const format = 'rgba8unorm';\n    const copyHeight = copyHeightInBlocks * kTextureFormatInfo[format].blockHeight;\n\n    const texture = t.device.createTexture({\n      size: { width: 4, height: 4, depthOrArrayLayers: 3 },\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const layout = { bytesPerRow: 1024, rowsPerImage };\n    const copySize = { width: 0, height: copyHeight, depthOrArrayLayers: copyDepth };\n    const { minDataSizeOrOverestimate, copyValid } = dataBytesForCopyOrOverestimate({\n      layout,\n      format,\n      copySize,\n      method,\n    });\n\n    t.testRun({ texture }, layout, copySize, {\n      dataSize: minDataSizeOrOverestimate,\n      method,\n      success: copyValid,\n    });\n  });\n\ng.test('copy_end_overflows_u64')\n  .desc(`Test what happens when offset+requiredBytesInCopy overflows GPUSize64.`)\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .beginSubcases()\n      .combineWithParams([\n        { bytesPerRow: 2 ** 31, rowsPerImage: 2 ** 31, depthOrArrayLayers: 1, _success: true }, // success case\n        { bytesPerRow: 2 ** 31, rowsPerImage: 2 ** 31, depthOrArrayLayers: 16, _success: false }, // bytesPerRow * rowsPerImage * (depthOrArrayLayers - 1) overflows.\n      ])\n  )\n  .fn(async t => {\n    const { method, bytesPerRow, rowsPerImage, depthOrArrayLayers, _success } = t.params;\n\n    const texture = t.device.createTexture({\n      size: [1, 1, depthOrArrayLayers],\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    t.testRun(\n      { texture },\n      { bytesPerRow, rowsPerImage },\n      { width: 1, height: 1, depthOrArrayLayers },\n      {\n        dataSize: 10000,\n        method,\n        success: _success,\n      }\n    );\n  });\n\ng.test('required_bytes_in_copy')\n  .desc(\n    `Test that the min data size condition (requiredBytesInCopy) is checked correctly.\n\n  - Exact requiredBytesInCopy should succeed.\n  - requiredBytesInCopy - 1 should fail.\n  `\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combine('format', kSizedTextureFormats)\n      .filter(formatCopyableWithMethod)\n      .beginSubcases()\n      .combineWithParams([\n        { bytesPerRowPadding: 0, rowsPerImagePaddingInBlocks: 0 }, // no padding\n        { bytesPerRowPadding: 0, rowsPerImagePaddingInBlocks: 6 }, // rowsPerImage padding\n        { bytesPerRowPadding: 6, rowsPerImagePaddingInBlocks: 0 }, // bytesPerRow padding\n        { bytesPerRowPadding: 15, rowsPerImagePaddingInBlocks: 17 }, // both paddings\n      ])\n      .combineWithParams([\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 5, offsetInBlocks: 0 }, // standard copy\n        { copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 3, offsetInBlocks: 11 }, // standard copy, offset > 0\n        { copyWidthInBlocks: 256, copyHeightInBlocks: 3, copyDepth: 2, offsetInBlocks: 0 }, // copyWidth is 256-aligned\n        { copyWidthInBlocks: 0, copyHeightInBlocks: 4, copyDepth: 5, offsetInBlocks: 0 }, // empty copy because of width\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 0, copyDepth: 5, offsetInBlocks: 0 }, // empty copy because of height\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 0, offsetInBlocks: 13 }, // empty copy because of depth, offset > 0\n        { copyWidthInBlocks: 1, copyHeightInBlocks: 4, copyDepth: 5, offsetInBlocks: 0 }, // copyWidth = 1\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 1, copyDepth: 5, offsetInBlocks: 15 }, // copyHeight = 1, offset > 0\n        { copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 1, offsetInBlocks: 0 }, // copyDepth = 1\n        { copyWidthInBlocks: 7, copyHeightInBlocks: 1, copyDepth: 1, offsetInBlocks: 0 }, // copyHeight = 1 and copyDepth = 1\n      ])\n      // The test texture size will be rounded up from the copy size to the next valid texture size.\n      // If the format is a depth/stencil format, its copy size must equal to subresource's size.\n      // So filter out depth/stencil cases where the rounded-up texture size would be different from the copy size.\n      .filter(({ format, copyWidthInBlocks, copyHeightInBlocks, copyDepth }) => {\n        const info = kTextureFormatInfo[format];\n        return (\n          (!info.depth && !info.stencil) ||\n          (copyWidthInBlocks > 0 && copyHeightInBlocks > 0 && copyDepth > 0)\n        );\n      })\n  )\n  .fn(async t => {\n    const {\n      offsetInBlocks,\n      bytesPerRowPadding,\n      rowsPerImagePaddingInBlocks,\n      copyWidthInBlocks,\n      copyHeightInBlocks,\n      copyDepth,\n      format,\n      method,\n    } = t.params;\n    const info = kTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.feature);\n\n    // In the CopyB2T and CopyT2B cases we need to have bytesPerRow 256-aligned,\n    // to make this happen we align the bytesInACompleteRow value and multiply\n    // bytesPerRowPadding by 256.\n    const bytesPerRowAlignment = method === 'WriteTexture' ? 1 : 256;\n    const copyWidth = copyWidthInBlocks * info.blockWidth;\n    const copyHeight = copyHeightInBlocks * info.blockHeight;\n    const offset = offsetInBlocks * info.bytesPerBlock;\n    const rowsPerImage = copyHeight + rowsPerImagePaddingInBlocks * info.blockHeight;\n    const bytesPerRow =\n      align(bytesInACompleteRow(copyWidth, format), bytesPerRowAlignment) +\n      bytesPerRowPadding * bytesPerRowAlignment;\n    const copySize = { width: copyWidth, height: copyHeight, depthOrArrayLayers: copyDepth };\n\n    const layout = { offset, bytesPerRow, rowsPerImage };\n    const minDataSize = dataBytesForCopyOrFail({ layout, format, copySize, method });\n\n    const texture = t.createAlignedTexture(format, copySize);\n\n    t.testRun({ texture }, { offset, bytesPerRow, rowsPerImage }, copySize, {\n      dataSize: minDataSize,\n      method,\n      success: true,\n    });\n\n    if (minDataSize > 0) {\n      t.testRun({ texture }, { offset, bytesPerRow, rowsPerImage }, copySize, {\n        dataSize: minDataSize - 1,\n        method,\n        success: false,\n      });\n    }\n  });\n\ng.test('rows_per_image_alignment')\n  .desc(`rowsPerImage is measured in multiples of block height, so has no alignment constraints.`)\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combine('format', kSizedTextureFormats)\n      .filter(formatCopyableWithMethod)\n      .beginSubcases()\n      .expand('rowsPerImage', texelBlockAlignmentTestExpanderForRowsPerImage)\n      // Copy height is info.blockHeight, so rowsPerImage must be equal or greater than it.\n      .filter(({ rowsPerImage, format }) => rowsPerImage >= kTextureFormatInfo[format].blockHeight)\n  )\n  .fn(async t => {\n    const { rowsPerImage, format, method } = t.params;\n    const info = kTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.feature);\n\n    const size = { width: info.blockWidth, height: info.blockHeight, depthOrArrayLayers: 1 };\n    const texture = t.device.createTexture({\n      size,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    t.testRun({ texture }, { bytesPerRow: 256, rowsPerImage }, size, {\n      dataSize: info.bytesPerBlock,\n      method,\n      success: true,\n    });\n  });\n\ng.test('offset_alignment')\n  .desc(\n    `If texture format is not depth/stencil format, offset should be aligned with texture block. If texture format is depth/stencil format, offset should be a multiple of 4.`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combine('format', kSizedTextureFormats)\n      .filter(formatCopyableWithMethod)\n      .beginSubcases()\n      .expand('offset', texelBlockAlignmentTestExpanderForOffset)\n  )\n  .fn(async t => {\n    const { format, offset, method } = t.params;\n    const info = kTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.feature);\n\n    const size = { width: info.blockWidth, height: info.blockHeight, depthOrArrayLayers: 1 };\n    const texture = t.device.createTexture({\n      size,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    let success = false;\n    if (method === 'WriteTexture') success = true;\n    if (info.depth || info.stencil) {\n      if (offset % 4 === 0) success = true;\n    } else {\n      if (offset % info.bytesPerBlock === 0) success = true;\n    }\n\n    t.testRun({ texture }, { offset, bytesPerRow: 256 }, size, {\n      dataSize: offset + info.bytesPerBlock,\n      method,\n      success,\n    });\n  });\n\ng.test('bound_on_bytes_per_row')\n  .desc(`For all formats, verify image copy validations w.r.t bytesPerRow.`)\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combine('format', kSizedTextureFormats)\n      .filter(formatCopyableWithMethod)\n      .beginSubcases()\n      .combine('copyHeightInBlocks', [1, 2])\n      .combine('copyDepth', [1, 2])\n      .expandWithParams(p => {\n        const info = kTextureFormatInfo[p.format];\n        // We currently have a built-in assumption that for all formats, 128 % bytesPerBlock === 0.\n        // This assumption ensures that all division below results in integers.\n        assert(128 % info.bytesPerBlock === 0);\n        return [\n          // Copying exact fit with aligned bytesPerRow should work.\n          {\n            bytesPerRow: 256,\n            widthInBlocks: 256 / info.bytesPerBlock,\n            copyWidthInBlocks: 256 / info.bytesPerBlock,\n            _success: true,\n          },\n          // Copying into smaller texture when padding in bytesPerRow is enough should work unless\n          // it is a depth/stencil typed format.\n          {\n            bytesPerRow: 256,\n            widthInBlocks: 256 / info.bytesPerBlock,\n            copyWidthInBlocks: 256 / info.bytesPerBlock - 1,\n            _success: !(info.stencil || info.depth),\n          },\n          // Unaligned bytesPerRow should not work unless the method is 'WriteTexture'.\n          {\n            bytesPerRow: 128,\n            widthInBlocks: 128 / info.bytesPerBlock,\n            copyWidthInBlocks: 128 / info.bytesPerBlock,\n            _success: p.method === 'WriteTexture',\n          },\n          {\n            bytesPerRow: 384,\n            widthInBlocks: 384 / info.bytesPerBlock,\n            copyWidthInBlocks: 384 / info.bytesPerBlock,\n            _success: p.method === 'WriteTexture',\n          },\n          // When bytesPerRow is smaller than bytesInLastRow copying should fail.\n          {\n            bytesPerRow: 256,\n            widthInBlocks: (2 * 256) / info.bytesPerBlock,\n            copyWidthInBlocks: (2 * 256) / info.bytesPerBlock,\n            _success: false,\n          },\n          // When copyHeightInBlocks > 1, bytesPerRow must be specified.\n          {\n            bytesPerRow: undefined,\n            widthInBlocks: 256 / info.bytesPerBlock,\n            copyWidthInBlocks: 256 / info.bytesPerBlock,\n            _success: !(p.copyHeightInBlocks > 1 || p.copyDepth > 1),\n          },\n        ];\n      })\n  )\n  .fn(async t => {\n    const {\n      method,\n      format,\n      bytesPerRow,\n      widthInBlocks,\n      copyWidthInBlocks,\n      copyHeightInBlocks,\n      copyDepth,\n      _success,\n    } = t.params;\n    const info = kTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.feature);\n\n    // We create an aligned texture using the widthInBlocks which may be different from the\n    // copyWidthInBlocks. This allows us to test scenarios where the two may be different.\n    const texture = t.createAlignedTexture(format, {\n      width: widthInBlocks * info.blockWidth,\n      height: copyHeightInBlocks * info.blockHeight,\n      depthOrArrayLayers: copyDepth,\n    });\n\n    const layout = { bytesPerRow, rowsPerImage: copyHeightInBlocks };\n    const copySize = {\n      width: copyWidthInBlocks * info.blockWidth,\n      height: copyHeightInBlocks * info.blockHeight,\n      depthOrArrayLayers: copyDepth,\n    };\n    const { minDataSizeOrOverestimate } = dataBytesForCopyOrOverestimate({\n      layout,\n      format,\n      copySize,\n      method,\n    });\n\n    t.testRun({ texture }, layout, copySize, {\n      dataSize: minDataSizeOrOverestimate,\n      method,\n      success: _success,\n    });\n  });\n\ng.test('bound_on_offset')\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .beginSubcases()\n      .combine('offsetInBlocks', [0, 1, 2])\n      .combine('dataSizeInBlocks', [0, 1, 2])\n  )\n  .fn(async t => {\n    const { offsetInBlocks, dataSizeInBlocks, method } = t.params;\n\n    const format = 'rgba8unorm';\n    const info = kTextureFormatInfo[format];\n    const offset = offsetInBlocks * info.bytesPerBlock;\n    const dataSize = dataSizeInBlocks * info.bytesPerBlock;\n\n    const texture = t.device.createTexture({\n      size: { width: 4, height: 4, depthOrArrayLayers: 1 },\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const success = offset <= dataSize;\n\n    t.testRun(\n      { texture },\n      { offset, bytesPerRow: 0 },\n      { width: 0, height: 0, depthOrArrayLayers: 0 },\n      { dataSize, method, success }\n    );\n  });\n"],"file":"layout_related.spec.js"}