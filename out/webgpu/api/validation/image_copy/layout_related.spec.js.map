{"version":3,"sources":["../../../../../src/webgpu/api/validation/image_copy/layout_related.spec.ts"],"names":["description","makeTestGroup","assert","kTextureFormatInfo","kSizedTextureFormats","textureDimensionAndFormatCompatible","kTextureDimensions","align","bytesInACompleteRow","dataBytesForCopyOrOverestimate","dataBytesForCopyOrFail","kImageCopyTypes","ImageCopyTest","texelBlockAlignmentTestExpanderForOffset","texelBlockAlignmentTestExpanderForRowsPerImage","formatCopyableWithMethod","g","test","desc","params","u","combine","combineWithParams","dimension","size","beginSubcases","undefined","unless","p","copyHeightInBlocks","copyDepth","fn","t","rowsPerImage","method","format","copyHeight","blockHeight","texture","device","createTexture","usage","GPUTextureUsage","COPY_SRC","COPY_DST","layout","bytesPerRow","copySize","width","height","depthOrArrayLayers","minDataSizeOrOverestimate","copyValid","testRun","dataSize","success","_success","filter","bytesPerRowPadding","rowsPerImagePaddingInBlocks","copyWidthInBlocks","_offsetMultiplier","info","depth","stencil","expand","bytesPerBlock","beforeAllSubcases","selectDeviceOrSkipTestCase","feature","bufferOffset","bytesPerRowAlignment","copyWidth","blockWidth","minDataSize","createAlignedTexture","offset","expandWithParams","widthInBlocks","offsetInBlocks","dataSizeInBlocks"],"mappings":"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","sourcesContent":["export const description = `Validation tests for the linear data layout of linear data <-> texture copies\n\nTODO check if the tests need to be updated to support aspects of depth-stencil textures`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert } from '../../../../common/util/util.js';\nimport {\n  kTextureFormatInfo,\n  kSizedTextureFormats,\n  textureDimensionAndFormatCompatible,\n  kTextureDimensions,\n} from '../../../capability_info.js';\nimport { align } from '../../../util/math.js';\nimport {\n  bytesInACompleteRow,\n  dataBytesForCopyOrOverestimate,\n  dataBytesForCopyOrFail,\n  kImageCopyTypes,\n} from '../../../util/texture/layout.js';\n\nimport {\n  ImageCopyTest,\n  texelBlockAlignmentTestExpanderForOffset,\n  texelBlockAlignmentTestExpanderForRowsPerImage,\n  formatCopyableWithMethod,\n} from './image_copy.js';\n\nexport const g = makeTestGroup(ImageCopyTest);\n\ng.test('bound_on_rows_per_image')\n  .desc(\n    `\nTest that rowsPerImage must be at least the copy height (if defined).\n- for various copy methods\n- for all texture dimensions\n- for various values of rowsPerImage including undefined\n- for various copy heights\n- for various copy depths\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combineWithParams([\n        { dimension: '1d', size: [4, 1, 1] },\n        { dimension: '2d', size: [4, 4, 1] },\n        { dimension: '2d', size: [4, 4, 3] },\n        { dimension: '3d', size: [4, 4, 3] },\n      ] as const)\n      .beginSubcases()\n      .combine('rowsPerImage', [undefined, 0, 1, 2, 1024])\n      .combine('copyHeightInBlocks', [0, 1, 2])\n      .combine('copyDepth', [1, 3])\n      .unless(p => p.dimension === '1d' && p.copyHeightInBlocks !== 1)\n      .unless(p => p.copyDepth > p.size[2])\n  )\n  .fn(async t => {\n    const { rowsPerImage, copyHeightInBlocks, copyDepth, dimension, size, method } = t.params;\n\n    const format = 'rgba8unorm';\n    const copyHeight = copyHeightInBlocks * kTextureFormatInfo[format].blockHeight;\n\n    const texture = t.device.createTexture({\n      size,\n      dimension,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const layout = { bytesPerRow: 1024, rowsPerImage };\n    const copySize = { width: 0, height: copyHeight, depthOrArrayLayers: copyDepth };\n    const { minDataSizeOrOverestimate, copyValid } = dataBytesForCopyOrOverestimate({\n      layout,\n      format,\n      copySize,\n      method,\n    });\n\n    t.testRun({ texture }, layout, copySize, {\n      dataSize: minDataSizeOrOverestimate,\n      method,\n      success: copyValid,\n    });\n  });\n\ng.test('copy_end_overflows_u64')\n  .desc(\n    `\nTest an error is produced when offset+requiredBytesInCopy overflows GPUSize64.\n- for various copy methods\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .beginSubcases()\n      .combineWithParams([\n        { bytesPerRow: 2 ** 31, rowsPerImage: 2 ** 31, depthOrArrayLayers: 1, _success: true }, // success case\n        { bytesPerRow: 2 ** 31, rowsPerImage: 2 ** 31, depthOrArrayLayers: 16, _success: false }, // bytesPerRow * rowsPerImage * (depthOrArrayLayers - 1) overflows.\n      ])\n  )\n  .fn(async t => {\n    const { method, bytesPerRow, rowsPerImage, depthOrArrayLayers, _success } = t.params;\n\n    const texture = t.device.createTexture({\n      size: [1, 1, depthOrArrayLayers],\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    t.testRun(\n      { texture },\n      { bytesPerRow, rowsPerImage },\n      { width: 1, height: 1, depthOrArrayLayers },\n      {\n        dataSize: 10000,\n        method,\n        success: _success,\n      }\n    );\n  });\n\ng.test('required_bytes_in_copy')\n  .desc(\n    `\nTest the computation of requiredBytesInCopy by computing the minimum data size for the copy and checking success/error at the boundary.\n- for various copy methods\n- for all formats\n- for all dimensions\n- for various extra bytesPerRow/rowsPerImage\n- for various copy sizes\n- for various offsets in the linear data\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combine('format', kSizedTextureFormats)\n      .filter(formatCopyableWithMethod)\n      .combine('dimension', kTextureDimensions)\n      .filter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format))\n      .beginSubcases()\n      .combineWithParams([\n        { bytesPerRowPadding: 0, rowsPerImagePaddingInBlocks: 0 }, // no padding\n        { bytesPerRowPadding: 0, rowsPerImagePaddingInBlocks: 6 }, // rowsPerImage padding\n        { bytesPerRowPadding: 6, rowsPerImagePaddingInBlocks: 0 }, // bytesPerRow padding\n        { bytesPerRowPadding: 15, rowsPerImagePaddingInBlocks: 17 }, // both paddings\n      ])\n      .combineWithParams([\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 5, _offsetMultiplier: 0 }, // standard copy\n        { copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 3, _offsetMultiplier: 11 }, // standard copy, offset > 0\n        { copyWidthInBlocks: 256, copyHeightInBlocks: 3, copyDepth: 2, _offsetMultiplier: 0 }, // copyWidth is 256-aligned\n        { copyWidthInBlocks: 0, copyHeightInBlocks: 4, copyDepth: 5, _offsetMultiplier: 0 }, // empty copy because of width\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 0, copyDepth: 5, _offsetMultiplier: 0 }, // empty copy because of height\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 0, _offsetMultiplier: 13 }, // empty copy because of depth, offset > 0\n        { copyWidthInBlocks: 1, copyHeightInBlocks: 4, copyDepth: 5, _offsetMultiplier: 0 }, // copyWidth = 1\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 1, copyDepth: 5, _offsetMultiplier: 15 }, // copyHeight = 1, offset > 0\n        { copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 1, _offsetMultiplier: 0 }, // copyDepth = 1\n        { copyWidthInBlocks: 7, copyHeightInBlocks: 1, copyDepth: 1, _offsetMultiplier: 0 }, // copyHeight = 1 and copyDepth = 1\n      ])\n      // The test texture size will be rounded up from the copy size to the next valid texture size.\n      // If the format is a depth/stencil format, its copy size must equal to subresource's size.\n      // So filter out depth/stencil cases where the rounded-up texture size would be different from the copy size.\n      .filter(({ format, copyWidthInBlocks, copyHeightInBlocks, copyDepth }) => {\n        const info = kTextureFormatInfo[format];\n        return (\n          (!info.depth && !info.stencil) ||\n          (copyWidthInBlocks > 0 && copyHeightInBlocks > 0 && copyDepth > 0)\n        );\n      })\n      .unless(p => p.dimension === '1d' && (p.copyHeightInBlocks > 1 || p.copyDepth > 1))\n      .expand('bufferOffset', p => {\n        const info = kTextureFormatInfo[p.format];\n        if (info.depth || info.stencil) {\n          return [p._offsetMultiplier * 4];\n        }\n        return [p._offsetMultiplier * info.bytesPerBlock];\n      })\n  )\n  .beforeAllSubcases(t => {\n    const info = kTextureFormatInfo[t.params.format];\n    t.selectDeviceOrSkipTestCase(info.feature);\n  })\n  .fn(async t => {\n    const {\n      bufferOffset,\n      bytesPerRowPadding,\n      rowsPerImagePaddingInBlocks,\n      copyWidthInBlocks,\n      copyHeightInBlocks,\n      copyDepth,\n      format,\n      dimension,\n      method,\n    } = t.params;\n    const info = kTextureFormatInfo[format];\n\n    // In the CopyB2T and CopyT2B cases we need to have bytesPerRow 256-aligned,\n    // to make this happen we align the bytesInACompleteRow value and multiply\n    // bytesPerRowPadding by 256.\n    const bytesPerRowAlignment = method === 'WriteTexture' ? 1 : 256;\n    const copyWidth = copyWidthInBlocks * info.blockWidth;\n    const copyHeight = copyHeightInBlocks * info.blockHeight;\n    const rowsPerImage = copyHeight + rowsPerImagePaddingInBlocks * info.blockHeight;\n    const bytesPerRow =\n      align(bytesInACompleteRow(copyWidth, format), bytesPerRowAlignment) +\n      bytesPerRowPadding * bytesPerRowAlignment;\n    const copySize = { width: copyWidth, height: copyHeight, depthOrArrayLayers: copyDepth };\n\n    const layout = { bufferOffset, bytesPerRow, rowsPerImage };\n    const minDataSize = dataBytesForCopyOrFail({ layout, format, copySize, method });\n\n    const texture = t.createAlignedTexture(format, copySize, undefined, dimension);\n\n    t.testRun({ texture }, layout, copySize, {\n      dataSize: minDataSize,\n      method,\n      success: true,\n    });\n\n    if (minDataSize > 0) {\n      t.testRun({ texture }, layout, copySize, {\n        dataSize: minDataSize - 1,\n        method,\n        success: false,\n      });\n    }\n  });\n\ng.test('rows_per_image_alignment')\n  .desc(\n    `\nTest that rowsPerImage has no alignment constraints.\n- for various copy methods\n- for all sized format\n- for all dimensions\n- for various rowsPerImage\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combine('format', kSizedTextureFormats)\n      .filter(formatCopyableWithMethod)\n      .combine('dimension', kTextureDimensions)\n      .filter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format))\n      .beginSubcases()\n      .expand('rowsPerImage', texelBlockAlignmentTestExpanderForRowsPerImage)\n      // Copy height is info.blockHeight, so rowsPerImage must be equal or greater than it.\n      .filter(({ rowsPerImage, format }) => rowsPerImage >= kTextureFormatInfo[format].blockHeight)\n  )\n  .beforeAllSubcases(t => {\n    const info = kTextureFormatInfo[t.params.format];\n    t.selectDeviceOrSkipTestCase(info.feature);\n  })\n  .fn(async t => {\n    const { rowsPerImage, format, method } = t.params;\n    const info = kTextureFormatInfo[format];\n\n    const size = { width: info.blockWidth, height: info.blockHeight, depthOrArrayLayers: 1 };\n    const texture = t.device.createTexture({\n      size,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    t.testRun({ texture }, { bytesPerRow: 256, rowsPerImage }, size, {\n      dataSize: info.bytesPerBlock,\n      method,\n      success: true,\n    });\n  });\n\ng.test('offset_alignment')\n  .desc(\n    `\nTest the alignment requirement on the linear data offset (block size, or 4 for depth-stencil).\n- for various copy methods\n- for all sized formats\n- for all dimensions\n- for various linear data offsets\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combine('format', kSizedTextureFormats)\n      .filter(formatCopyableWithMethod)\n      .combine('dimension', kTextureDimensions)\n      .filter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format))\n      .beginSubcases()\n      .expand('offset', texelBlockAlignmentTestExpanderForOffset)\n  )\n  .beforeAllSubcases(t => {\n    const info = kTextureFormatInfo[t.params.format];\n    t.selectDeviceOrSkipTestCase(info.feature);\n  })\n  .fn(async t => {\n    const { format, offset, method } = t.params;\n    const info = kTextureFormatInfo[format];\n\n    const size = { width: info.blockWidth, height: info.blockHeight, depthOrArrayLayers: 1 };\n    const texture = t.device.createTexture({\n      size,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    let success = false;\n    if (method === 'WriteTexture') success = true;\n    if (info.depth || info.stencil) {\n      if (offset % 4 === 0) success = true;\n    } else {\n      if (offset % info.bytesPerBlock === 0) success = true;\n    }\n\n    t.testRun({ texture }, { offset, bytesPerRow: 256 }, size, {\n      dataSize: offset + info.bytesPerBlock,\n      method,\n      success,\n    });\n  });\n\ng.test('bound_on_bytes_per_row')\n  .desc(\n    `\nTest that bytesPerRow, if specified must be big enough for a full copy row.\n- for various copy methods\n- for all sized formats\n- for all dimension\n- for various copy heights\n- for various copy depths\n- for various combinations of bytesPerRow and copy width.\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combine('format', kSizedTextureFormats)\n      .filter(formatCopyableWithMethod)\n      .combine('dimension', kTextureDimensions)\n      .filter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format))\n      .beginSubcases()\n      .combine('copyHeightInBlocks', [1, 2])\n      .combine('copyDepth', [1, 2])\n      .unless(p => p.dimension === '1d' && (p.copyHeightInBlocks > 1 || p.copyDepth > 1))\n      .expandWithParams(p => {\n        const info = kTextureFormatInfo[p.format];\n        // We currently have a built-in assumption that for all formats, 128 % bytesPerBlock === 0.\n        // This assumption ensures that all division below results in integers.\n        assert(128 % info.bytesPerBlock === 0);\n        return [\n          // Copying exact fit with aligned bytesPerRow should work.\n          {\n            bytesPerRow: 256,\n            widthInBlocks: 256 / info.bytesPerBlock,\n            copyWidthInBlocks: 256 / info.bytesPerBlock,\n            _success: true,\n          },\n          // Copying into smaller texture when padding in bytesPerRow is enough should work unless\n          // it is a depth/stencil typed format.\n          {\n            bytesPerRow: 256,\n            widthInBlocks: 256 / info.bytesPerBlock,\n            copyWidthInBlocks: 256 / info.bytesPerBlock - 1,\n            _success: !(info.stencil || info.depth),\n          },\n          // Unaligned bytesPerRow should not work unless the method is 'WriteTexture'.\n          {\n            bytesPerRow: 128,\n            widthInBlocks: 128 / info.bytesPerBlock,\n            copyWidthInBlocks: 128 / info.bytesPerBlock,\n            _success: p.method === 'WriteTexture',\n          },\n          {\n            bytesPerRow: 384,\n            widthInBlocks: 384 / info.bytesPerBlock,\n            copyWidthInBlocks: 384 / info.bytesPerBlock,\n            _success: p.method === 'WriteTexture',\n          },\n          // When bytesPerRow is smaller than bytesInLastRow copying should fail.\n          {\n            bytesPerRow: 256,\n            widthInBlocks: (2 * 256) / info.bytesPerBlock,\n            copyWidthInBlocks: (2 * 256) / info.bytesPerBlock,\n            _success: false,\n          },\n          // When copyHeightInBlocks > 1, bytesPerRow must be specified.\n          {\n            bytesPerRow: undefined,\n            widthInBlocks: 256 / info.bytesPerBlock,\n            copyWidthInBlocks: 256 / info.bytesPerBlock,\n            _success: !(p.copyHeightInBlocks > 1 || p.copyDepth > 1),\n          },\n        ];\n      })\n  )\n  .beforeAllSubcases(t => {\n    const info = kTextureFormatInfo[t.params.format];\n    t.selectDeviceOrSkipTestCase(info.feature);\n  })\n  .fn(async t => {\n    const {\n      method,\n      format,\n      bytesPerRow,\n      widthInBlocks,\n      copyWidthInBlocks,\n      copyHeightInBlocks,\n      copyDepth,\n      _success,\n    } = t.params;\n    const info = kTextureFormatInfo[format];\n\n    // We create an aligned texture using the widthInBlocks which may be different from the\n    // copyWidthInBlocks. This allows us to test scenarios where the two may be different.\n    const texture = t.createAlignedTexture(format, {\n      width: widthInBlocks * info.blockWidth,\n      height: copyHeightInBlocks * info.blockHeight,\n      depthOrArrayLayers: copyDepth,\n    });\n\n    const layout = { bytesPerRow, rowsPerImage: copyHeightInBlocks };\n    const copySize = {\n      width: copyWidthInBlocks * info.blockWidth,\n      height: copyHeightInBlocks * info.blockHeight,\n      depthOrArrayLayers: copyDepth,\n    };\n    const { minDataSizeOrOverestimate } = dataBytesForCopyOrOverestimate({\n      layout,\n      format,\n      copySize,\n      method,\n    });\n\n    t.testRun({ texture }, layout, copySize, {\n      dataSize: minDataSizeOrOverestimate,\n      method,\n      success: _success,\n    });\n  });\n\ng.test('bound_on_offset')\n  .desc(\n    `\nTest that the offset cannot be larger than the linear data size (even for an empty copy).\n- for various offsets and data sizes\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .beginSubcases()\n      .combine('offsetInBlocks', [0, 1, 2])\n      .combine('dataSizeInBlocks', [0, 1, 2])\n  )\n  .fn(async t => {\n    const { offsetInBlocks, dataSizeInBlocks, method } = t.params;\n\n    const format = 'rgba8unorm';\n    const info = kTextureFormatInfo[format];\n    const offset = offsetInBlocks * info.bytesPerBlock;\n    const dataSize = dataSizeInBlocks * info.bytesPerBlock;\n\n    const texture = t.device.createTexture({\n      size: { width: 4, height: 4, depthOrArrayLayers: 1 },\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const success = offset <= dataSize;\n\n    t.testRun(\n      { texture },\n      { offset, bytesPerRow: 0 },\n      { width: 0, height: 0, depthOrArrayLayers: 0 },\n      { dataSize, method, success }\n    );\n  });\n"],"file":"layout_related.spec.js"}