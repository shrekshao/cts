{"version":3,"sources":["../../../../../src/webgpu/api/validation/image_copy/buffer_texture_copies.spec.ts"],"names":["description","makeTestGroup","assert","unreachable","kDepthStencilFormats","kBufferUsages","kTextureUsages","depthStencilBufferTextureCopySupported","depthStencilFormatAspectSize","GPUConst","align","kBufferCopyAlignment","kBytesPerRowAlignment","ValidationTest","ImageCopyTest","testCopyBufferToTexture","source","destination","copySize","isSuccess","encoder","validateFinishAndSubmit","createEncoder","copyBufferToTexture","testCopyTextureToBuffer","copyTextureToBuffer","testWriteTexture","uploadData","dataLayout","expectGPUError","queue","writeTexture","g","test","desc","params","u","combine","beginSubcases","beforeAllSubcases","t","format","selectDeviceForTextureFormatOrSkipTestCase","fn","aspect","textureSize","width","height","depthOrArrayLayers","texture","device","createTexture","size","usage","GPUTextureUsage","COPY_SRC","COPY_DST","uploadBufferSize","buffer","createBuffer","GPUBufferUsage","success","Uint8Array","filter","param","copyType","texelAspectSize","bytesPerRowAlignment","bytesPerRow","rowsPerImage","minimumBufferSize","bigEnoughBuffer","smallerBuffer","enoughUploadData","smallerUploadData","offset","sampleCount","RENDER_ATTACHMENT","kRequiredTextureUsage","CopyT2B","TextureUsage","CopyB2T","kRequiredBufferUsage","BufferUsage","expand","p","textureUsage","bufferUsage","_textureUsageValid","_bufferUsageValid","combineWithParams","bufMismatched","texMismatched","selectMismatchedDeviceOrSkipTestCase","undefined","mismatchedDevice","trackForCleanup","isValid"],"mappings":"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","sourcesContent":["export const description = `\ncopyTextureToBuffer and copyBufferToTexture validation tests not covered by\nthe general image_copy tests, or by destroyed,*.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, unreachable } from '../../../../common/util/util.js';\nimport {\n  kDepthStencilFormats,\n  kBufferUsages,\n  kTextureUsages,\n  depthStencilBufferTextureCopySupported,\n  depthStencilFormatAspectSize,\n} from '../../../capability_info.js';\nimport { GPUConst } from '../../../constants.js';\nimport { align } from '../../../util/math.js';\nimport { kBufferCopyAlignment, kBytesPerRowAlignment } from '../../../util/texture/layout.js';\nimport { ValidationTest } from '../validation_test.js';\n\nclass ImageCopyTest extends ValidationTest {\n  testCopyBufferToTexture(\n    source: GPUImageCopyBuffer,\n    destination: GPUImageCopyTexture,\n    copySize: GPUExtent3DStrict,\n    isSuccess: boolean\n  ): void {\n    const { encoder, validateFinishAndSubmit } = this.createEncoder('non-pass');\n    encoder.copyBufferToTexture(source, destination, copySize);\n    validateFinishAndSubmit(isSuccess, true);\n  }\n\n  testCopyTextureToBuffer(\n    source: GPUImageCopyTexture,\n    destination: GPUImageCopyBuffer,\n    copySize: GPUExtent3DStrict,\n    isSuccess: boolean\n  ): void {\n    const { encoder, validateFinishAndSubmit } = this.createEncoder('non-pass');\n    encoder.copyTextureToBuffer(source, destination, copySize);\n    validateFinishAndSubmit(isSuccess, true);\n  }\n\n  testWriteTexture(\n    destination: GPUImageCopyTexture,\n    uploadData: Uint8Array,\n    dataLayout: GPUImageDataLayout,\n    copySize: GPUExtent3DStrict,\n    isSuccess: boolean\n  ): void {\n    this.expectGPUError(\n      'validation',\n      () => this.queue.writeTexture(destination, uploadData, dataLayout, copySize),\n      !isSuccess\n    );\n  }\n}\n\nexport const g = makeTestGroup(ImageCopyTest);\n\ng.test('depth_stencil_format,copy_usage_and_aspect')\n  .desc(\n    `\n  Validate the combination of usage and aspect of each depth stencil format in copyBufferToTexture,\n  copyTextureToBuffer and writeTexture. See https://gpuweb.github.io/gpuweb/#depth-formats for more\n  details.\n  `\n  )\n  .params(u =>\n    u //\n      .combine('format', kDepthStencilFormats)\n      .beginSubcases()\n      .combine('aspect', ['all', 'depth-only', 'stencil-only'] as const)\n  )\n  .beforeAllSubcases(t => {\n    const { format } = t.params;\n    t.selectDeviceForTextureFormatOrSkipTestCase(format);\n  })\n  .fn(async t => {\n    const { format, aspect } = t.params;\n\n    const textureSize = { width: 1, height: 1, depthOrArrayLayers: 1 };\n    const texture = t.device.createTexture({\n      size: textureSize,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const uploadBufferSize = 32;\n    const buffer = t.device.createBuffer({\n      size: uploadBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    {\n      const success = depthStencilBufferTextureCopySupported('CopyB2T', format, aspect);\n      t.testCopyBufferToTexture({ buffer }, { texture, aspect }, textureSize, success);\n    }\n\n    {\n      const success = depthStencilBufferTextureCopySupported('CopyT2B', format, aspect);\n      t.testCopyTextureToBuffer({ texture, aspect }, { buffer }, textureSize, success);\n    }\n\n    {\n      const success = depthStencilBufferTextureCopySupported('WriteTexture', format, aspect);\n      const uploadData = new Uint8Array(uploadBufferSize);\n      t.testWriteTexture({ texture, aspect }, uploadData, {}, textureSize, success);\n    }\n  });\n\ng.test('depth_stencil_format,copy_buffer_size')\n  .desc(\n    `\n  Validate the minimum buffer size for each depth stencil format in copyBufferToTexture,\n  copyTextureToBuffer and writeTexture.\n\n  Given a depth stencil format, a copy aspect ('depth-only' or 'stencil-only'), the copy method\n  (buffer-to-texture or texture-to-buffer) and the copy size, validate\n  - if the copy can be successfully executed with the minimum required buffer size.\n  - if the copy fails with a validation error when the buffer size is less than the minimum\n  required buffer size.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kDepthStencilFormats)\n      .combine('aspect', ['depth-only', 'stencil-only'] as const)\n      .combine('copyType', ['CopyB2T', 'CopyT2B', 'WriteTexture'] as const)\n      .filter(param =>\n        depthStencilBufferTextureCopySupported(param.copyType, param.format, param.aspect)\n      )\n      .beginSubcases()\n      .combine('copySize', [\n        { width: 8, height: 1, depthOrArrayLayers: 1 },\n        { width: 4, height: 4, depthOrArrayLayers: 1 },\n        { width: 4, height: 4, depthOrArrayLayers: 3 },\n      ])\n  )\n  .beforeAllSubcases(t => {\n    const { format } = t.params;\n    t.selectDeviceForTextureFormatOrSkipTestCase(format);\n  })\n  .fn(async t => {\n    const { format, aspect, copyType, copySize } = t.params;\n\n    const texture = t.device.createTexture({\n      size: copySize,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const texelAspectSize = depthStencilFormatAspectSize(format, aspect);\n    assert(texelAspectSize > 0);\n\n    const bytesPerRowAlignment = copyType === 'WriteTexture' ? 1 : kBytesPerRowAlignment;\n    const bytesPerRow = align(texelAspectSize * copySize.width, bytesPerRowAlignment);\n    const rowsPerImage = copySize.height;\n    const minimumBufferSize =\n      bytesPerRow * (rowsPerImage * copySize.depthOrArrayLayers - 1) +\n      align(texelAspectSize * copySize.width, kBufferCopyAlignment);\n    assert(minimumBufferSize > kBufferCopyAlignment);\n\n    const bigEnoughBuffer = t.device.createBuffer({\n      size: minimumBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    const smallerBuffer = t.device.createBuffer({\n      size: minimumBufferSize - kBufferCopyAlignment,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    if (copyType === 'CopyB2T') {\n      t.testCopyBufferToTexture(\n        { buffer: bigEnoughBuffer, bytesPerRow, rowsPerImage },\n        { texture, aspect },\n        copySize,\n        true\n      );\n      t.testCopyBufferToTexture(\n        { buffer: smallerBuffer, bytesPerRow, rowsPerImage },\n        { texture, aspect },\n        copySize,\n        false\n      );\n    } else if (copyType === 'CopyT2B') {\n      t.testCopyTextureToBuffer(\n        { texture, aspect },\n        { buffer: bigEnoughBuffer, bytesPerRow, rowsPerImage },\n        copySize,\n        true\n      );\n      t.testCopyTextureToBuffer(\n        { texture, aspect },\n        { buffer: smallerBuffer, bytesPerRow, rowsPerImage },\n        copySize,\n        false\n      );\n    } else if (copyType === 'WriteTexture') {\n      const enoughUploadData = new Uint8Array(minimumBufferSize);\n      const smallerUploadData = new Uint8Array(minimumBufferSize - kBufferCopyAlignment);\n      t.testWriteTexture(\n        { texture, aspect },\n        enoughUploadData,\n        {\n          bytesPerRow,\n          rowsPerImage,\n        },\n        copySize,\n        true\n      );\n\n      t.testWriteTexture(\n        { texture, aspect },\n        smallerUploadData,\n        {\n          bytesPerRow,\n          rowsPerImage,\n        },\n        copySize,\n        false\n      );\n    } else {\n      unreachable();\n    }\n  });\n\ng.test('depth_stencil_format,copy_buffer_offset')\n  .desc(\n    `\n    Validate for every depth stencil formats the buffer offset must be a multiple of 4 in\n    copyBufferToTexture() and copyTextureToBuffer(), but the offset in writeTexture() doesn't always\n    need to be a multiple of 4.\n    `\n  )\n  .params(u =>\n    u\n      .combine('format', kDepthStencilFormats)\n      .combine('aspect', ['depth-only', 'stencil-only'] as const)\n      .combine('copyType', ['CopyB2T', 'CopyT2B', 'WriteTexture'] as const)\n      .filter(param =>\n        depthStencilBufferTextureCopySupported(param.copyType, param.format, param.aspect)\n      )\n      .beginSubcases()\n      .combine('offset', [1, 2, 4, 6, 8])\n  )\n  .beforeAllSubcases(t => {\n    const { format } = t.params;\n    t.selectDeviceForTextureFormatOrSkipTestCase(format);\n  })\n  .fn(async t => {\n    const { format, aspect, copyType, offset } = t.params;\n\n    const textureSize = { width: 4, height: 4, depthOrArrayLayers: 1 };\n\n    const texture = t.device.createTexture({\n      size: textureSize,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const texelAspectSize = depthStencilFormatAspectSize(format, aspect);\n    assert(texelAspectSize > 0);\n\n    const bytesPerRowAlignment = copyType === 'WriteTexture' ? 1 : kBytesPerRowAlignment;\n    const bytesPerRow = align(texelAspectSize * textureSize.width, bytesPerRowAlignment);\n    const rowsPerImage = textureSize.height;\n    const minimumBufferSize =\n      bytesPerRow * (rowsPerImage * textureSize.depthOrArrayLayers - 1) +\n      align(texelAspectSize * textureSize.width, kBufferCopyAlignment);\n    assert(minimumBufferSize > kBufferCopyAlignment);\n\n    const buffer = t.device.createBuffer({\n      size: align(minimumBufferSize + offset, kBufferCopyAlignment),\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const isSuccess = copyType === 'WriteTexture' ? true : offset % 4 === 0;\n\n    if (copyType === 'CopyB2T') {\n      t.testCopyBufferToTexture(\n        { buffer, offset, bytesPerRow, rowsPerImage },\n        { texture, aspect },\n        textureSize,\n        isSuccess\n      );\n    } else if (copyType === 'CopyT2B') {\n      t.testCopyTextureToBuffer(\n        { texture, aspect },\n        { buffer, offset, bytesPerRow, rowsPerImage },\n        textureSize,\n        isSuccess\n      );\n    } else if (copyType === 'WriteTexture') {\n      const uploadData = new Uint8Array(minimumBufferSize + offset);\n      t.testWriteTexture(\n        { texture, aspect },\n        uploadData,\n        {\n          offset,\n          bytesPerRow,\n          rowsPerImage,\n        },\n        textureSize,\n        isSuccess\n      );\n    } else {\n      unreachable();\n    }\n  });\n\ng.test('sample_count')\n  .desc(\n    `\n  Test that the texture sample count. Check that a validation error is generated if sample count is\n  not 1.\n  `\n  )\n  .params(u =>\n    u //\n      // writeTexture is handled by writeTexture.spec.ts.\n      .combine('copyType', ['CopyB2T', 'CopyT2B'] as const)\n      .beginSubcases()\n      .combine('sampleCount', [1, 4])\n  )\n  .fn(async t => {\n    const { sampleCount, copyType } = t.params;\n\n    let usage = GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST;\n    // WebGPU SPEC requires multisampled textures must have RENDER_ATTACHMENT usage.\n    if (sampleCount > 1) {\n      usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n    }\n    const texture = t.device.createTexture({\n      size: { width: 16, height: 16 },\n      sampleCount,\n      format: 'bgra8unorm',\n      usage,\n    });\n\n    const uploadBufferSize = 32;\n    const buffer = t.device.createBuffer({\n      size: uploadBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const textureSize = { width: 1, height: 1, depthOrArrayLayers: 1 };\n\n    const isSuccess = sampleCount === 1;\n\n    if (copyType === 'CopyB2T') {\n      t.testCopyBufferToTexture({ buffer }, { texture }, textureSize, isSuccess);\n    } else if (copyType === 'CopyT2B') {\n      t.testCopyTextureToBuffer({ texture }, { buffer }, textureSize, isSuccess);\n    }\n  });\n\nconst kRequiredTextureUsage = {\n  CopyT2B: GPUConst.TextureUsage.COPY_SRC,\n  CopyB2T: GPUConst.TextureUsage.COPY_DST,\n};\nconst kRequiredBufferUsage = {\n  CopyB2T: GPUConst.BufferUsage.COPY_SRC,\n  CopyT2B: GPUConst.BufferUsage.COPY_DST,\n};\n\ng.test('texture_buffer_usages')\n  .desc(\n    `\n  Tests calling copyTextureToBuffer or copyBufferToTexture with the texture and the buffer missed\n  COPY_SRC, COPY_DST usage respectively.\n    - texture and buffer {with, without} COPY_SRC and COPY_DST usage.\n  `\n  )\n  .params(u =>\n    u //\n      .combine('copyType', ['CopyB2T', 'CopyT2B'] as const)\n      .beginSubcases()\n      .combine('textureUsage', kTextureUsages)\n      .expand('_textureUsageValid', p => [p.textureUsage === kRequiredTextureUsage[p.copyType]])\n      .combine('bufferUsage', kBufferUsages)\n      .expand('_bufferUsageValid', p => [p.bufferUsage === kRequiredBufferUsage[p.copyType]])\n      .filter(p => p._textureUsageValid || p._bufferUsageValid)\n  )\n  .fn(async t => {\n    const { copyType, textureUsage, _textureUsageValid, bufferUsage, _bufferUsageValid } = t.params;\n\n    const texture = t.device.createTexture({\n      size: { width: 16, height: 16 },\n      format: 'rgba8unorm',\n      usage: textureUsage,\n    });\n\n    const uploadBufferSize = 32;\n    const buffer = t.device.createBuffer({\n      size: uploadBufferSize,\n      usage: bufferUsage,\n    });\n\n    const textureSize = { width: 1, height: 1, depthOrArrayLayers: 1 };\n\n    const isSuccess = _textureUsageValid && _bufferUsageValid;\n    if (copyType === 'CopyB2T') {\n      t.testCopyBufferToTexture({ buffer }, { texture }, textureSize, isSuccess);\n    } else if (copyType === 'CopyT2B') {\n      t.testCopyTextureToBuffer({ texture }, { buffer }, textureSize, isSuccess);\n    }\n  });\n\ng.test('device_mismatch')\n  .desc(\n    `\n    Tests copyBufferToTexture and copyTextureToBuffer cannot be called with a buffer or a texture\n    created from another device.\n  `\n  )\n  .params(u =>\n    u //\n      .combine('copyType', ['CopyB2T', 'CopyT2B'] as const)\n      .beginSubcases()\n      .combineWithParams([\n        { bufMismatched: false, texMismatched: false }, // control case\n        { bufMismatched: true, texMismatched: false },\n        { bufMismatched: false, texMismatched: true },\n      ] as const)\n  )\n  .beforeAllSubcases(t => {\n    t.selectMismatchedDeviceOrSkipTestCase(undefined);\n  })\n  .fn(async t => {\n    const { copyType, bufMismatched, texMismatched } = t.params;\n\n    const uploadBufferSize = 32;\n    const buffer = (bufMismatched ? t.mismatchedDevice : t.device).createBuffer({\n      size: uploadBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    t.trackForCleanup(buffer);\n\n    const textureSize = { width: 1, height: 1, depthOrArrayLayers: 1 };\n    const texture = (texMismatched ? t.mismatchedDevice : t.device).createTexture({\n      size: textureSize,\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n    t.trackForCleanup(texture);\n\n    const isValid = !bufMismatched && !texMismatched;\n\n    if (copyType === 'CopyB2T') {\n      t.testCopyBufferToTexture({ buffer }, { texture }, textureSize, isValid);\n    } else if (copyType === 'CopyT2B') {\n      t.testCopyTextureToBuffer({ texture }, { buffer }, textureSize, isValid);\n    }\n  });\n"],"file":"buffer_texture_copies.spec.js"}