{"version":3,"sources":["../../../../../src/webgpu/api/validation/image_copy/buffer_related.spec.ts"],"names":["description","makeTestGroup","kSizedTextureFormats","kTextureFormatInfo","textureDimensionAndFormatCompatible","GPUConst","kResourceStates","kImageCopyTypes","ImageCopyTest","formatCopyableWithMethod","g","test","desc","params","u","combine","fn","t","method","state","buffer","createBufferWithState","size","usage","GPUBufferUsage","COPY_SRC","COPY_DST","success","submit","texture","device","createTexture","width","height","depthOrArrayLayers","format","GPUTextureUsage","testBuffer","bytesPerRow","dataSize","beginSubcases","BufferUsage","UNIFORM","createBuffer","filter","dimension","undefined","expand","p","copyHeightInBlocks","unless","info","depth","stencil","_textureHeightInBlocks","bytesPerBlock","selectDeviceOrSkipTestCase","feature","blockWidth","blockHeight","copySize"],"mappings":"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","sourcesContent":["export const description = `Validation tests for buffer related parameters for copies`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport {\n  kSizedTextureFormats,\n  kTextureFormatInfo,\n  textureDimensionAndFormatCompatible,\n} from '../../../capability_info.js';\nimport { GPUConst } from '../../../constants.js';\nimport { kResourceStates } from '../../../gpu_test.js';\nimport { kImageCopyTypes } from '../../../util/texture/layout.js';\n\nimport { ImageCopyTest, formatCopyableWithMethod } from './image_copy.js';\n\nexport const g = makeTestGroup(ImageCopyTest);\n\ng.test('valid')\n  .desc(`The buffer must be valid and not destroyed.`)\n  .params(u =>\n    u //\n      // B2B copy validations are at api,validation,encoding,cmds,copyBufferToBuffer.spec.ts\n      .combine('method', ['CopyB2T', 'CopyT2B'] as const)\n      .combine('state', kResourceStates)\n  )\n  .fn(async t => {\n    const { method, state } = t.params;\n\n    // A valid buffer.\n    const buffer = t.createBufferWithState(state, {\n      size: 16,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const success = state !== 'invalid';\n    const submit = state !== 'destroyed';\n\n    const texture = t.device.createTexture({\n      size: { width: 2, height: 2, depthOrArrayLayers: 1 },\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    t.testBuffer(\n      buffer,\n      texture,\n      { bytesPerRow: 0 },\n      { width: 0, height: 0, depthOrArrayLayers: 0 },\n      { dataSize: 16, method, success, submit }\n    );\n  });\n\ng.test('usage')\n  .desc(`The buffer must have the appropriate COPY_SRC/COPY_DST usage.`)\n  .params(u =>\n    u\n      // B2B copy validations are at api,validation,encoding,cmds,copyBufferToBuffer.spec.ts\n      .combine('method', ['CopyB2T', 'CopyT2B'] as const)\n      .beginSubcases()\n      .combine('usage', [\n        GPUConst.BufferUsage.COPY_SRC | GPUConst.BufferUsage.UNIFORM,\n        GPUConst.BufferUsage.COPY_DST | GPUConst.BufferUsage.UNIFORM,\n        GPUConst.BufferUsage.COPY_SRC | GPUConst.BufferUsage.COPY_DST,\n      ])\n  )\n  .fn(async t => {\n    const { method, usage } = t.params;\n\n    const buffer = t.device.createBuffer({\n      size: 16,\n      usage,\n    });\n\n    const success =\n      method === 'CopyB2T'\n        ? (usage & GPUBufferUsage.COPY_SRC) !== 0\n        : (usage & GPUBufferUsage.COPY_DST) !== 0;\n\n    const texture = t.device.createTexture({\n      size: { width: 2, height: 2, depthOrArrayLayers: 1 },\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    t.testBuffer(\n      buffer,\n      texture,\n      { bytesPerRow: 0 },\n      { width: 0, height: 0, depthOrArrayLayers: 0 },\n      { dataSize: 16, method, success }\n    );\n  });\n\ng.test('bytes_per_row_alignment')\n  .desc(\n    `Test that bytesPerRow must be a multiple of 256 for CopyB2T and CopyT2B if it is required.`\n  )\n  .params(u =>\n    u //\n      .combine('method', kImageCopyTypes)\n      .combine('dimension', ['2d', '3d'] as const)\n      .combine('format', kSizedTextureFormats)\n      .filter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format))\n      .filter(formatCopyableWithMethod)\n      .beginSubcases()\n      .combine('bytesPerRow', [undefined, 0, 1, 255, 256, 257, 512])\n      .combine('copyHeightInBlocks', [0, 1, 2, 3])\n      .expand('_textureHeightInBlocks', p => [\n        p.copyHeightInBlocks === 0 ? 1 : p.copyHeightInBlocks,\n      ])\n      // Depth/stencil format copies must copy the whole subresource.\n      .unless(p => {\n        const info = kTextureFormatInfo[p.format];\n        return (info.depth || info.stencil) && p.copyHeightInBlocks !== p._textureHeightInBlocks;\n      })\n      // bytesPerRow must be specified and it must be equal or greater than the bytes size of each row if we are copying multiple rows.\n      // Note that we are copying one single block on each row in this test.\n      .filter(\n        ({ format, bytesPerRow, copyHeightInBlocks }) =>\n          (bytesPerRow === undefined && copyHeightInBlocks <= 1) ||\n          (bytesPerRow !== undefined && bytesPerRow >= kTextureFormatInfo[format].bytesPerBlock)\n      )\n  )\n  .fn(async t => {\n    const {\n      method,\n      dimension,\n      format,\n      bytesPerRow,\n      copyHeightInBlocks,\n      _textureHeightInBlocks,\n    } = t.params;\n\n    const info = kTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.feature);\n\n    const buffer = t.device.createBuffer({\n      size: 512 * 8 * 16,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    let success = false;\n    // writeTexture doesn't require bytesPerRow to be 256-byte aligned.\n    if (method === 'WriteTexture') success = true;\n    // If the copy height <= 1, bytesPerRow is not required.\n    if (copyHeightInBlocks <= 1 && bytesPerRow === undefined) success = true;\n    // If bytesPerRow > 0 and it is a multiple of 256, it will succeeed if other parameters are valid.\n    if (bytesPerRow !== undefined && bytesPerRow > 0 && bytesPerRow % 256 === 0) success = true;\n\n    const size = [info.blockWidth, _textureHeightInBlocks * info.blockHeight, 1];\n    const texture = t.device.createTexture({\n      size,\n      dimension,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const copySize = [info.blockWidth, copyHeightInBlocks * info.blockHeight, 1];\n\n    t.testBuffer(buffer, texture, { bytesPerRow }, copySize, {\n      dataSize: 512 * 8 * 16,\n      method,\n      success,\n    });\n  });\n"],"file":"buffer_related.spec.js"}