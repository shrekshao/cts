{"version":3,"sources":["../../../../../src/webgpu/api/validation/image_copy/buffer_related.spec.ts"],"names":["description","makeTestGroup","kSizedTextureFormats","kTextureDimensions","kTextureFormatInfo","textureDimensionAndFormatCompatible","GPUConst","kResourceStates","kImageCopyTypes","ImageCopyTest","formatCopyableWithMethod","g","test","desc","params","u","combine","fn","t","method","state","buffer","createBufferWithState","size","usage","GPUBufferUsage","COPY_SRC","COPY_DST","submit","success","texture","device","createTexture","width","height","depthOrArrayLayers","format","GPUTextureUsage","testBuffer","bytesPerRow","dataSize","paramsSubcasesOnly","beforeAllSubcases","selectMismatchedDeviceOrSkipTestCase","undefined","mismatched","mismatchedDevice","createBuffer","trackForCleanup","beginSubcases","BufferUsage","UNIFORM","filter","dimension","expand","p","copyHeightInBlocks","unless","info","depth","stencil","_textureHeightInBlocks","bytesPerBlock","selectDeviceOrSkipTestCase","feature","blockWidth","blockHeight","copySize"],"mappings":"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","sourcesContent":["export const description = `Validation tests for buffer related parameters for buffer <-> texture copies`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport {\n  kSizedTextureFormats,\n  kTextureDimensions,\n  kTextureFormatInfo,\n  textureDimensionAndFormatCompatible,\n} from '../../../capability_info.js';\nimport { GPUConst } from '../../../constants.js';\nimport { kResourceStates } from '../../../gpu_test.js';\nimport { kImageCopyTypes } from '../../../util/texture/layout.js';\n\nimport { ImageCopyTest, formatCopyableWithMethod } from './image_copy.js';\n\nexport const g = makeTestGroup(ImageCopyTest);\n\ng.test('buffer_state')\n  .desc(\n    `\nTest that the buffer must be valid and not destroyed.\n- for all buffer <-> texture copy methods\n- for various buffer states\n`\n  )\n  .params(u =>\n    u //\n      // B2B copy validations are at api,validation,encoding,cmds,copyBufferToBuffer.spec.ts\n      .combine('method', ['CopyB2T', 'CopyT2B'] as const)\n      .combine('state', kResourceStates)\n  )\n  .fn(async t => {\n    const { method, state } = t.params;\n\n    // A valid buffer.\n    const buffer = t.createBufferWithState(state, {\n      size: 16,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    // Invalid buffer will fail finish, and destroyed buffer will fail submit\n    const submit = state !== 'invalid';\n    const success = state === 'valid';\n\n    const texture = t.device.createTexture({\n      size: { width: 2, height: 2, depthOrArrayLayers: 1 },\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    t.testBuffer(\n      buffer,\n      texture,\n      { bytesPerRow: 0 },\n      { width: 0, height: 0, depthOrArrayLayers: 0 },\n      { dataSize: 16, method, success, submit }\n    );\n  });\n\ng.test('buffer,device_mismatch')\n  .desc('Tests the image copies cannot be called with a buffer created from another device')\n  .paramsSubcasesOnly(u =>\n    u.combine('method', ['CopyB2T', 'CopyT2B'] as const).combine('mismatched', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    t.selectMismatchedDeviceOrSkipTestCase(undefined);\n  })\n  .fn(async t => {\n    const { method, mismatched } = t.params;\n    const device = mismatched ? t.mismatchedDevice : t.device;\n\n    const buffer = device.createBuffer({\n      size: 16,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    t.trackForCleanup(buffer);\n\n    const texture = t.device.createTexture({\n      size: { width: 2, height: 2, depthOrArrayLayers: 1 },\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const success = !mismatched;\n\n    // Expect success in both finish and submit, or validation error in finish\n    t.testBuffer(\n      buffer,\n      texture,\n      { bytesPerRow: 0 },\n      { width: 0, height: 0, depthOrArrayLayers: 0 },\n      { dataSize: 16, method, success, submit: success }\n    );\n  });\n\ng.test('usage')\n  .desc(\n    `\nTest the buffer must have the appropriate COPY_SRC/COPY_DST usage.\nTODO update such that it tests\n- for all buffer source usages\n- for all buffer destination usages\n`\n  )\n  .params(u =>\n    u\n      // B2B copy validations are at api,validation,encoding,cmds,copyBufferToBuffer.spec.ts\n      .combine('method', ['CopyB2T', 'CopyT2B'] as const)\n      .beginSubcases()\n      .combine('usage', [\n        GPUConst.BufferUsage.COPY_SRC | GPUConst.BufferUsage.UNIFORM,\n        GPUConst.BufferUsage.COPY_DST | GPUConst.BufferUsage.UNIFORM,\n        GPUConst.BufferUsage.COPY_SRC | GPUConst.BufferUsage.COPY_DST,\n      ])\n  )\n  .fn(async t => {\n    const { method, usage } = t.params;\n\n    const buffer = t.device.createBuffer({\n      size: 16,\n      usage,\n    });\n\n    const success =\n      method === 'CopyB2T'\n        ? (usage & GPUBufferUsage.COPY_SRC) !== 0\n        : (usage & GPUBufferUsage.COPY_DST) !== 0;\n\n    const texture = t.device.createTexture({\n      size: { width: 2, height: 2, depthOrArrayLayers: 1 },\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    // Expect success in both finish and submit, or validation error in finish\n    t.testBuffer(\n      buffer,\n      texture,\n      { bytesPerRow: 0 },\n      { width: 0, height: 0, depthOrArrayLayers: 0 },\n      { dataSize: 16, method, success, submit: success }\n    );\n  });\n\ng.test('bytes_per_row_alignment')\n  .desc(\n    `\nTest that bytesPerRow must be a multiple of 256 for CopyB2T and CopyT2B if it is required.\n- for all copy methods between linear data and textures\n- for all texture dimensions\n- for all sized formats.\n- for various bytesPerRow aligned to 256 or not\n- for various number of blocks rows copied\n`\n  )\n  .params(u =>\n    u //\n      .combine('method', kImageCopyTypes)\n      .combine('format', kSizedTextureFormats)\n      .filter(formatCopyableWithMethod)\n      .combine('dimension', kTextureDimensions)\n      .filter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format))\n      .beginSubcases()\n      .combine('bytesPerRow', [undefined, 0, 1, 255, 256, 257, 512])\n      .combine('copyHeightInBlocks', [0, 1, 2, 3])\n      .expand('_textureHeightInBlocks', p => [\n        p.copyHeightInBlocks === 0 ? 1 : p.copyHeightInBlocks,\n      ])\n      .unless(p => p.dimension === '1d' && p.copyHeightInBlocks > 1)\n      // Depth/stencil format copies must copy the whole subresource.\n      .unless(p => {\n        const info = kTextureFormatInfo[p.format];\n        return (info.depth || info.stencil) && p.copyHeightInBlocks !== p._textureHeightInBlocks;\n      })\n      // bytesPerRow must be specified and it must be equal or greater than the bytes size of each row if we are copying multiple rows.\n      // Note that we are copying one single block on each row in this test.\n      .filter(\n        ({ format, bytesPerRow, copyHeightInBlocks }) =>\n          (bytesPerRow === undefined && copyHeightInBlocks <= 1) ||\n          (bytesPerRow !== undefined && bytesPerRow >= kTextureFormatInfo[format].bytesPerBlock)\n      )\n  )\n  .beforeAllSubcases(t => {\n    const info = kTextureFormatInfo[t.params.format];\n    t.selectDeviceOrSkipTestCase(info.feature);\n  })\n  .fn(async t => {\n    const {\n      method,\n      dimension,\n      format,\n      bytesPerRow,\n      copyHeightInBlocks,\n      _textureHeightInBlocks,\n    } = t.params;\n\n    const info = kTextureFormatInfo[format];\n\n    const buffer = t.device.createBuffer({\n      size: 512 * 8 * 16,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    let success = false;\n    // writeTexture doesn't require bytesPerRow to be 256-byte aligned.\n    if (method === 'WriteTexture') success = true;\n    // If the copy height <= 1, bytesPerRow is not required.\n    if (copyHeightInBlocks <= 1 && bytesPerRow === undefined) success = true;\n    // If bytesPerRow > 0 and it is a multiple of 256, it will succeed if other parameters are valid.\n    if (bytesPerRow !== undefined && bytesPerRow > 0 && bytesPerRow % 256 === 0) success = true;\n\n    const size = [info.blockWidth, _textureHeightInBlocks * info.blockHeight, 1];\n    const texture = t.device.createTexture({\n      size,\n      dimension,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const copySize = [info.blockWidth, copyHeightInBlocks * info.blockHeight, 1];\n\n    // Expect success in both finish and submit, or validation error in finish\n    t.testBuffer(buffer, texture, { bytesPerRow }, copySize, {\n      dataSize: 512 * 8 * 16,\n      method,\n      success,\n      submit: success,\n    });\n  });\n"],"file":"buffer_related.spec.js"}