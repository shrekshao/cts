{"version":3,"sources":["../../../../src/webgpu/api/validation/createRenderPipeline.spec.ts"],"names":["description","makeTestGroup","kTextureFormats","kTextureFormatInfo","ValidationTest","F","getDescriptor","options","defaultTargets","format","topology","targets","sampleCount","depthStencil","length","fragColorType","suffix","endsWith","vertex","module","device","createShaderModule","code","entryPoint","fragment","layout","getPipelineLayout","primitive","multisample","count","createPipelineLayout","bindGroupLayouts","createTexture","params","size","width","height","depthOrArrayLayers","usage","GPUTextureUsage","RENDER_ATTACHMENT","doCreateRenderPipelineTest","isAsync","_success","descriptor","shouldResolve","createRenderPipelineAsync","shouldReject","createRenderPipeline","expectValidationError","g","test","u","combine","fn","t","goodDescriptor","badDescriptor","info","selectDeviceOrSkipTestCase","feature","renderable","color","combineWithParams"],"mappings":"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","sourcesContent":["export const description = `\ncreateRenderPipeline and createRenderPipelineAsync validation tests.\n\nTODO: review existing tests, write descriptions, and make sure tests are complete.\n      Make sure the following is covered. Consider splitting the file if too large/disjointed.\n> - various attachment problems\n>\n> - interface matching between vertex and fragment shader\n>     - superset, subset, etc.\n>\n> - vertex stage {valid, invalid}\n> - fragment stage {valid, invalid}\n> - primitive topology all possible values\n> - rasterizationState various values\n> - multisample count {0, 1, 3, 4, 8, 16, 1024}\n> - multisample mask {0, 0xFFFFFFFF}\n> - alphaToCoverage:\n>     - alphaToCoverageEnabled is { true, false } and sampleCount { = 1, = 4 }.\n>       The only failing case is (true, 1).\n>     - output SV_Coverage semantics is statically used by fragmentStage and\n>       alphaToCoverageEnabled is { true (fails), false (passes) }.\n>     - sampleMask is being used and alphaToCoverageEnabled is { true (fails), false (passes) }.\n\n`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { kTextureFormats, kTextureFormatInfo } from '../../capability_info.js';\n\nimport { ValidationTest } from './validation_test.js';\n\nclass F extends ValidationTest {\n  getDescriptor(\n    options: {\n      topology?: GPUPrimitiveTopology;\n      targets?: GPUColorTargetState[];\n      sampleCount?: number;\n      depthStencil?: GPUDepthStencilState;\n    } = {}\n  ): GPURenderPipelineDescriptor {\n    const defaultTargets: GPUColorTargetState[] = [{ format: 'rgba8unorm' }];\n    const {\n      topology = 'triangle-list',\n      targets = defaultTargets,\n      sampleCount = 1,\n      depthStencil,\n    } = options;\n\n    const format = targets.length ? targets[0].format : 'rgba8unorm';\n\n    let fragColorType;\n    let suffix;\n    if (format.endsWith('sint')) {\n      fragColorType = 'i32';\n      suffix = '';\n    } else if (format.endsWith('uint')) {\n      fragColorType = 'u32';\n      suffix = 'u';\n    } else {\n      fragColorType = 'f32';\n      suffix = '.0';\n    }\n\n    return {\n      vertex: {\n        module: this.device.createShaderModule({\n          code: `\n            [[stage(vertex)]] fn main() -> [[builtin(position)]] vec4<f32> {\n              return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n            [[stage(fragment)]] fn main() -> [[location(0)]] vec4<${fragColorType}> {\n              return vec4<${fragColorType}>(0${suffix}, 1${suffix}, 0${suffix}, 1${suffix});\n            }`,\n        }),\n        entryPoint: 'main',\n        targets,\n      },\n      layout: this.getPipelineLayout(),\n      primitive: { topology },\n      multisample: { count: sampleCount },\n      depthStencil,\n    };\n  }\n\n  getPipelineLayout(): GPUPipelineLayout {\n    return this.device.createPipelineLayout({ bindGroupLayouts: [] });\n  }\n\n  createTexture(params: { format: GPUTextureFormat; sampleCount: number }): GPUTexture {\n    const { format, sampleCount } = params;\n\n    return this.device.createTexture({\n      size: { width: 4, height: 4, depthOrArrayLayers: 1 },\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n      format,\n      sampleCount,\n    });\n  }\n\n  doCreateRenderPipelineTest(\n    isAsync: boolean,\n    _success: boolean,\n    descriptor: GPURenderPipelineDescriptor\n  ) {\n    if (isAsync) {\n      if (_success) {\n        this.shouldResolve(this.device.createRenderPipelineAsync(descriptor));\n      } else {\n        this.shouldReject('OperationError', this.device.createRenderPipelineAsync(descriptor));\n      }\n    } else {\n      if (_success) {\n        this.device.createRenderPipeline(descriptor);\n      } else {\n        this.expectValidationError(() => {\n          this.device.createRenderPipeline(descriptor);\n        });\n      }\n    }\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('basic_use_of_createRenderPipeline')\n  .params(u => u.combine('isAsync', [false, true]))\n  .fn(async t => {\n    const { isAsync } = t.params;\n    const descriptor = t.getDescriptor();\n\n    t.doCreateRenderPipelineTest(isAsync, true, descriptor);\n  });\n\ng.test('at_least_one_color_state_is_required')\n  .params(u => u.combine('isAsync', [false, true]))\n  .fn(async t => {\n    const { isAsync } = t.params;\n\n    const goodDescriptor = t.getDescriptor({\n      targets: [{ format: 'rgba8unorm' }],\n    });\n\n    // Control case\n    t.doCreateRenderPipelineTest(isAsync, true, goodDescriptor);\n\n    // Fail because lack of color states\n    const badDescriptor = t.getDescriptor({\n      targets: [],\n    });\n\n    t.doCreateRenderPipelineTest(isAsync, false, badDescriptor);\n  });\n\ng.test('color_formats_must_be_renderable')\n  .params(u => u.combine('isAsync', [false, true]).combine('format', kTextureFormats))\n  .fn(async t => {\n    const { isAsync, format } = t.params;\n    const info = kTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.feature);\n\n    const descriptor = t.getDescriptor({ targets: [{ format }] });\n\n    t.doCreateRenderPipelineTest(isAsync, info.renderable && info.color, descriptor);\n  });\n\ng.test('sample_count_must_be_valid')\n  .params(u =>\n    u.combine('isAsync', [false, true]).combineWithParams([\n      { sampleCount: 0, _success: false },\n      { sampleCount: 1, _success: true },\n      { sampleCount: 2, _success: false },\n      { sampleCount: 3, _success: false },\n      { sampleCount: 4, _success: true },\n      { sampleCount: 8, _success: false },\n      { sampleCount: 16, _success: false },\n    ])\n  )\n  .fn(async t => {\n    const { isAsync, sampleCount, _success } = t.params;\n\n    const descriptor = t.getDescriptor({ sampleCount });\n\n    t.doCreateRenderPipelineTest(isAsync, _success, descriptor);\n  });\n"],"file":"createRenderPipeline.spec.js"}