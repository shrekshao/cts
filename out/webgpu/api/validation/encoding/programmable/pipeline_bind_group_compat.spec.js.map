{"version":3,"sources":["../../../../../../src/webgpu/api/validation/encoding/programmable/pipeline_bind_group_compat.spec.ts"],"names":["description","makeTestGroup","ValidationTest","F","getUniformBuffer","device","createBuffer","size","Float32Array","BYTES_PER_ELEMENT","usage","GPUBufferUsage","UNIFORM","createRenderPipeline","pipeline","vertex","module","createShaderModule","code","entryPoint","fragment","targets","format","primitive","topology","beginRenderPass","commandEncoder","attachmentTexture","createTexture","width","height","depthOrArrayLayers","GPUTextureUsage","RENDER_ATTACHMENT","colorAttachments","view","createView","loadValue","r","g","b","a","storeOp","test","paramsSubcasesOnly","setBindGroup1","setBindGroup2","_success","fn","t","params","uniformBuffer","bindGroup0","createBindGroup","entries","binding","resource","buffer","layout","getBindGroupLayout","bindGroup1","createCommandEncoder","renderPass","setPipeline","setBindGroup","draw","endPass","expectValidationError","finish"],"mappings":"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","sourcesContent":["export const description = `\nTODO:\n- test compatibility between bind groups and pipelines\n    - bind groups required by the pipeline layout are required.\n    - bind groups unused by the pipeline layout can be set or not.\n        (Even if e.g. bind groups 0 and 2 are used, but 1 is unused.)\n    - bindGroups[i].layout is \"group-equivalent\" (value-equal) to pipelineLayout.bgls[i].\n    - in the test fn, test once without the dispatch/draw (should always be valid) and once with\n      the dispatch/draw, to make sure the validation happens in dispatch/draw.\n    - x= {dispatch, all draws} (dispatch/draw should be size 0 to make sure validation still happens if no-op)\n    - x= all relevant stages\n\nTODO: subsume existing test, rewrite fixture as needed.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nclass F extends ValidationTest {\n  getUniformBuffer(): GPUBuffer {\n    return this.device.createBuffer({\n      size: 8 * Float32Array.BYTES_PER_ELEMENT,\n      usage: GPUBufferUsage.UNIFORM,\n    });\n  }\n\n  createRenderPipeline(): GPURenderPipeline {\n    const pipeline = this.device.createRenderPipeline({\n      vertex: {\n        module: this.device.createShaderModule({\n          code: `\n            [[block]] struct VertexUniforms {\n              transform : mat2x2<f32> ;\n            };\n            [[group(0), binding(0)]] var<uniform> uniforms : VertexUniforms;\n\n            [[stage(vertex)]] fn main(\n              [[builtin(vertex_index)]] VertexIndex : u32\n              ) -> [[builtin(position)]] vec4<f32> {\n              var pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                vec2<f32>(-1.0, -1.0),\n                vec2<f32>( 1.0, -1.0),\n                vec2<f32>(-1.0,  1.0)\n              );\n              return vec4<f32>(uniforms.transform * pos[VertexIndex], 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n            [[block]] struct FragmentUniforms {\n              color : vec4<f32>;\n            };\n            [[group(1), binding(0)]] var<uniform> uniforms : FragmentUniforms;\n\n            [[stage(fragment)]] fn main() -> [[location(0)]] vec4<f32> {\n              return uniforms.color;\n            }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'triangle-list' },\n    });\n    return pipeline;\n  }\n\n  beginRenderPass(commandEncoder: GPUCommandEncoder): GPURenderPassEncoder {\n    const attachmentTexture = this.device.createTexture({\n      format: 'rgba8unorm',\n      size: { width: 16, height: 16, depthOrArrayLayers: 1 },\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    return commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: attachmentTexture.createView(),\n          loadValue: { r: 1.0, g: 0.0, b: 0.0, a: 1.0 },\n          storeOp: 'store',\n        },\n      ],\n    });\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('it_is_invalid_to_draw_in_a_render_pass_with_missing_bind_groups')\n  .paramsSubcasesOnly([\n    { setBindGroup1: true, setBindGroup2: true, _success: true },\n    { setBindGroup1: true, setBindGroup2: false, _success: false },\n    { setBindGroup1: false, setBindGroup2: true, _success: false },\n    { setBindGroup1: false, setBindGroup2: false, _success: false },\n  ])\n  .fn(async t => {\n    const { setBindGroup1, setBindGroup2, _success } = t.params;\n\n    const pipeline = t.createRenderPipeline();\n\n    const uniformBuffer = t.getUniformBuffer();\n\n    const bindGroup0 = t.device.createBindGroup({\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: uniformBuffer,\n          },\n        },\n      ],\n      layout: pipeline.getBindGroupLayout(0),\n    });\n\n    const bindGroup1 = t.device.createBindGroup({\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: uniformBuffer,\n          },\n        },\n      ],\n      layout: pipeline.getBindGroupLayout(1),\n    });\n\n    const commandEncoder = t.device.createCommandEncoder();\n    const renderPass = t.beginRenderPass(commandEncoder);\n    renderPass.setPipeline(pipeline);\n    if (setBindGroup1) {\n      renderPass.setBindGroup(0, bindGroup0);\n    }\n    if (setBindGroup2) {\n      renderPass.setBindGroup(1, bindGroup1);\n    }\n    renderPass.draw(3);\n    renderPass.endPass();\n    t.expectValidationError(() => {\n      commandEncoder.finish();\n    }, !_success);\n  });\n"],"file":"pipeline_bind_group_compat.spec.js"}