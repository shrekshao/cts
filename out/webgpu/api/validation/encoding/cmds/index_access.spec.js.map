{"version":3,"sources":["../../../../../../src/webgpu/api/validation/encoding/cmds/index_access.spec.ts"],"names":["description","makeTestGroup","ValidationTest","F","createIndexBuffer","indexData","indexArray","Uint32Array","indexBuffer","device","createBuffer","mappedAtCreation","size","byteLength","usage","GPUBufferUsage","INDEX","getMappedRange","set","unmap","createRenderPipeline","vertex","module","createShaderModule","code","entryPoint","fragment","targets","format","primitive","topology","stripIndexFormat","beginRenderPass","encoder","colorAttachment","createTexture","width","height","depthOrArrayLayers","GPUTextureUsage","RENDER_ATTACHMENT","colorAttachments","view","createView","loadValue","r","g","b","a","storeOp","drawIndexed","indexCount","instanceCount","firstIndex","baseVertex","firstInstance","pipeline","createCommandEncoder","pass","setPipeline","setIndexBuffer","endPass","queue","submit","finish","drawIndexedIndirect","bufferArray","indirectOffset","indirectBuffer","INDIRECT","test","desc","params","u","combine","beginSubcases","combineWithParams","fn","t","indirect"],"mappings":"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","sourcesContent":["export const description = `\nindexed draws validation tests.\n\nTODO: review and make sure these notes are covered:\n> - indexed draws:\n>     - index access out of bounds (make sure this doesn't overlap with robust access)\n>         - bound index buffer **range** is {exact size, just under exact size} needed for draws with:\n>             - indexCount largeish\n>             - firstIndex {=, >} 0\n>     - x= {drawIndexed, drawIndexedIndirect}\n\nTODO: Since there are no errors here, these should be \"robustness\" operation tests (with multiple\nvalid results).\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nclass F extends ValidationTest {\n  createIndexBuffer(indexData: Iterable<number>): GPUBuffer {\n    const indexArray = new Uint32Array(indexData);\n\n    const indexBuffer = this.device.createBuffer({\n      mappedAtCreation: true,\n      size: indexArray.byteLength,\n      usage: GPUBufferUsage.INDEX,\n    });\n    new Uint32Array(indexBuffer.getMappedRange()).set(indexArray);\n    indexBuffer.unmap();\n\n    return indexBuffer;\n  }\n\n  createRenderPipeline(): GPURenderPipeline {\n    return this.device.createRenderPipeline({\n      vertex: {\n        module: this.device.createShaderModule({\n          code: `\n            [[stage(vertex)]] fn main() -> [[builtin(position)]] vec4<f32> {\n              return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n            [[stage(fragment)]] fn main() -> [[location(0)]] vec4<f32> {\n              return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: {\n        topology: 'triangle-strip',\n        stripIndexFormat: 'uint32',\n      },\n    });\n  }\n\n  beginRenderPass(encoder: GPUCommandEncoder) {\n    const colorAttachment = this.device.createTexture({\n      format: 'rgba8unorm',\n      size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    return encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: colorAttachment.createView(),\n          loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n          storeOp: 'store',\n        },\n      ],\n    });\n  }\n\n  drawIndexed(\n    indexBuffer: GPUBuffer,\n    indexCount: number,\n    instanceCount: number,\n    firstIndex: number,\n    baseVertex: number,\n    firstInstance: number\n  ) {\n    const pipeline = this.createRenderPipeline();\n\n    const encoder = this.device.createCommandEncoder();\n    const pass = this.beginRenderPass(encoder);\n    pass.setPipeline(pipeline);\n    pass.setIndexBuffer(indexBuffer, 'uint32');\n    pass.drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance);\n    pass.endPass();\n\n    this.device.queue.submit([encoder.finish()]);\n  }\n\n  drawIndexedIndirect(indexBuffer: GPUBuffer, bufferArray: Uint32Array, indirectOffset: number) {\n    const indirectBuffer = this.device.createBuffer({\n      mappedAtCreation: true,\n      size: bufferArray.byteLength,\n      usage: GPUBufferUsage.INDIRECT,\n    });\n    new Uint32Array(indirectBuffer.getMappedRange()).set(bufferArray);\n    indirectBuffer.unmap();\n\n    const pipeline = this.createRenderPipeline();\n\n    const encoder = this.device.createCommandEncoder();\n    const pass = this.beginRenderPass(encoder);\n    pass.setPipeline(pipeline);\n    pass.setIndexBuffer(indexBuffer, 'uint32');\n    pass.drawIndexedIndirect(indirectBuffer, indirectOffset);\n    pass.endPass();\n\n    this.device.queue.submit([encoder.finish()]);\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('out_of_bounds')\n  .desc(\n    `Test drawing with out of bound index access to make sure the implementation is robust\n    with the following indexCount and firstIndex conditions\n    - valid draw\n    - either is within bound but indexCount + firstIndex is out of bound\n    - only firstIndex is out of bound\n    - only indexCount is out of bound\n    - firstIndex much larger than indexCount\n    - indexCount much larger than firstIndex\n    - max uint32 value for both to make sure the sum doesn't overflow\n    - max uint32 indexCount and small firstIndex\n    - max uint32 firstIndex and small indexCount\n    Together with normal and large instanceCount`\n  )\n  .params(\n    u =>\n      u\n        .combine('indirect', [false, true])\n        .beginSubcases()\n        .combineWithParams([\n          { indexCount: 6, firstIndex: 1 }, // indexCount + firstIndex out of bound\n          { indexCount: 0, firstIndex: 6 }, // indexCount is 0 but firstIndex out of bound\n          { indexCount: 6, firstIndex: 6 }, // only firstIndex out of bound\n          { indexCount: 6, firstIndex: 10000 }, // firstIndex much larger than the bound\n          { indexCount: 7, firstIndex: 0 }, // only indexCount out of bound\n          { indexCount: 10000, firstIndex: 0 }, // indexCount much larger than the bound\n          { indexCount: 0xffffffff, firstIndex: 0xffffffff }, // max uint32 value\n          { indexCount: 0xffffffff, firstIndex: 2 }, // max uint32 indexCount and small firstIndex\n          { indexCount: 2, firstIndex: 0xffffffff }, // small indexCount and max uint32 firstIndex\n        ] as const)\n        .combine('instanceCount', [1, 10000]) // normal and large instanceCount\n  )\n  .fn(t => {\n    const { indirect, indexCount, firstIndex, instanceCount } = t.params;\n\n    const indexBuffer = t.createIndexBuffer([0, 1, 2, 3, 1, 2]);\n\n    if (indirect) {\n      t.drawIndexedIndirect(\n        indexBuffer,\n        new Uint32Array([indexCount, instanceCount, firstIndex, 0, 0]),\n        0\n      );\n    } else {\n      t.drawIndexed(indexBuffer, indexCount, instanceCount, firstIndex, 0, 0);\n    }\n  });\n\ng.test('out_of_bounds_zero_sized_index_buffer')\n  .desc(\n    `Test drawing with an empty index buffer to make sure the implementation is robust\n    with the following indexCount and firstIndex conditions\n    - indexCount + firstIndex is out of bound\n    - indexCount is 0 but firstIndex is out of bound\n    - only indexCount is out of bound\n    - both are 0s (not out of bound) but index buffer size is 0\n    Together with normal and large instanceCount`\n  )\n  .params(\n    u =>\n      u\n        .combine('indirect', [false, true])\n        .combineWithParams([\n          { indexCount: 3, firstIndex: 1 }, // indexCount + firstIndex out of bound\n          { indexCount: 0, firstIndex: 1 }, // indexCount is 0 but firstIndex out of bound\n          { indexCount: 3, firstIndex: 0 }, // only indexCount out of bound\n          { indexCount: 0, firstIndex: 0 }, // just zeros\n        ] as const)\n        .combine('instanceCount', [1, 10000]) // normal and large instanceCount\n  )\n  .fn(t => {\n    const { indirect, indexCount, firstIndex, instanceCount } = t.params;\n\n    const indexBuffer = t.createIndexBuffer([]);\n\n    if (indirect) {\n      t.drawIndexedIndirect(\n        indexBuffer,\n        new Uint32Array([indexCount, instanceCount, firstIndex, 0, 0]),\n        0\n      );\n    } else {\n      t.drawIndexed(indexBuffer, indexCount, instanceCount, firstIndex, 0, 0);\n    }\n  });\n"],"file":"index_access.spec.js"}