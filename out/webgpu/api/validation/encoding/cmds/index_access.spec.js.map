{"version":3,"sources":["../../../../../../src/webgpu/api/validation/encoding/cmds/index_access.spec.ts"],"names":["description","makeTestGroup","ValidationTest","F","createIndexBuffer","indexData","makeBufferWithContents","Uint32Array","GPUBufferUsage","INDEX","createRenderPipeline","device","layout","vertex","module","createShaderModule","code","entryPoint","fragment","targets","format","primitive","topology","stripIndexFormat","beginRenderPass","encoder","colorAttachment","createTexture","size","width","height","depthOrArrayLayers","usage","GPUTextureUsage","RENDER_ATTACHMENT","colorAttachments","view","createView","clearValue","r","g","b","a","loadOp","storeOp","drawIndexed","indexBuffer","indexCount","instanceCount","firstIndex","baseVertex","firstInstance","isSuccess","pipeline","createCommandEncoder","pass","setPipeline","setIndexBuffer","end","queue","submit","finish","expectValidationError","test","desc","params","u","combineWithParams","combine","fn","t"],"mappings":"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","sourcesContent":["export const description = `\nValidation tests for indexed draws accessing the index buffer.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nclass F extends ValidationTest {\n  createIndexBuffer(indexData: Iterable<number>): GPUBuffer {\n    return this.makeBufferWithContents(new Uint32Array(indexData), GPUBufferUsage.INDEX);\n  }\n\n  createRenderPipeline(): GPURenderPipeline {\n    return this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({\n          code: `\n            @vertex fn main() -> @builtin(position) vec4<f32> {\n              return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n            @fragment fn main() -> @location(0) vec4<f32> {\n              return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: {\n        topology: 'triangle-strip',\n        stripIndexFormat: 'uint32',\n      },\n    });\n  }\n\n  beginRenderPass(encoder: GPUCommandEncoder) {\n    const colorAttachment = this.device.createTexture({\n      format: 'rgba8unorm',\n      size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    return encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: colorAttachment.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n  }\n\n  drawIndexed(\n    indexBuffer: GPUBuffer,\n    indexCount: number,\n    instanceCount: number,\n    firstIndex: number,\n    baseVertex: number,\n    firstInstance: number,\n    isSuccess: boolean\n  ) {\n    const pipeline = this.createRenderPipeline();\n\n    const encoder = this.device.createCommandEncoder();\n    const pass = this.beginRenderPass(encoder);\n    pass.setPipeline(pipeline);\n    pass.setIndexBuffer(indexBuffer, 'uint32');\n    pass.drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance);\n    pass.end();\n\n    if (isSuccess) {\n      this.device.queue.submit([encoder.finish()]);\n    } else {\n      this.expectValidationError(() => {\n        encoder.finish();\n      });\n    }\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('out_of_bounds')\n  .desc(\n    `Test drawing with out of bound index access to make sure encoder validation catch the\n    following indexCount and firstIndex OOB conditions\n    - either is within bound but indexCount + firstIndex is out of bound\n    - only firstIndex is out of bound\n    - only indexCount is out of bound\n    - firstIndex much larger than indexCount\n    - indexCount much larger than firstIndex\n    - max uint32 value for both to make sure the sum doesn't overflow\n    - max uint32 indexCount and small firstIndex\n    - max uint32 firstIndex and small indexCount\n    Together with normal and large instanceCount`\n  )\n  .params(\n    u =>\n      u\n        .combineWithParams([\n          { indexCount: 6, firstIndex: 0 }, // draw all 6 out of 6 index\n          { indexCount: 5, firstIndex: 1 }, // draw the last 5 out of 6 index\n          { indexCount: 1, firstIndex: 5 }, // draw the last 1 out of 6 index\n          { indexCount: 0, firstIndex: 6 }, // firstIndex point to the one after last, but (indexCount + firstIndex) * stride <= bufferSize, valid\n          { indexCount: 0, firstIndex: 7 }, // (indexCount + firstIndex) * stride > bufferSize, invalid\n          { indexCount: 7, firstIndex: 0 }, // only indexCount out of bound\n          { indexCount: 6, firstIndex: 1 }, // indexCount + firstIndex out of bound\n          { indexCount: 1, firstIndex: 6 }, // indexCount valid, but (indexCount + firstIndex) out of bound\n          { indexCount: 6, firstIndex: 10000 }, // firstIndex much larger than the bound\n          { indexCount: 10000, firstIndex: 0 }, // indexCount much larger than the bound\n          { indexCount: 0xffffffff, firstIndex: 0xffffffff }, // max uint32 value\n          { indexCount: 0xffffffff, firstIndex: 2 }, // max uint32 indexCount and small firstIndex\n          { indexCount: 2, firstIndex: 0xffffffff }, // small indexCount and max uint32 firstIndex\n        ] as const)\n        .combine('instanceCount', [1, 10000]) // normal and large instanceCount\n  )\n  .fn(t => {\n    const { indexCount, firstIndex, instanceCount } = t.params;\n\n    const indexBuffer = t.createIndexBuffer([0, 1, 2, 3, 1, 2]);\n    const isSuccess: boolean = indexCount + firstIndex <= 6;\n\n    t.drawIndexed(indexBuffer, indexCount, instanceCount, firstIndex, 0, 0, isSuccess);\n  });\n\ng.test('out_of_bounds_zero_sized_index_buffer')\n  .desc(\n    `Test drawing with an empty index buffer to make sure the encoder validation catch the\n    following indexCount and firstIndex conditions\n    - indexCount + firstIndex is out of bound\n    - indexCount is 0 but firstIndex is out of bound\n    - only indexCount is out of bound\n    - both are 0s (not out of bound) but index buffer size is 0\n    Together with normal and large instanceCount`\n  )\n  .params(\n    u =>\n      u\n        .combineWithParams([\n          { indexCount: 3, firstIndex: 1 }, // indexCount + firstIndex out of bound\n          { indexCount: 0, firstIndex: 1 }, // indexCount is 0 but firstIndex out of bound\n          { indexCount: 3, firstIndex: 0 }, // only indexCount out of bound\n          { indexCount: 0, firstIndex: 0 }, // just zeros, valid\n        ] as const)\n        .combine('instanceCount', [1, 10000]) // normal and large instanceCount\n  )\n  .fn(t => {\n    const { indexCount, firstIndex, instanceCount } = t.params;\n\n    const indexBuffer = t.createIndexBuffer([]);\n    const isSuccess: boolean = indexCount + firstIndex <= 0;\n\n    t.drawIndexed(indexBuffer, indexCount, instanceCount, firstIndex, 0, 0, isSuccess);\n  });\n"],"file":"index_access.spec.js"}