{"version":3,"sources":["../../../../../../src/webgpu/api/validation/encoding/cmds/setBindGroup.spec.ts"],"names":["description","makeTestGroup","range","unreachable","kMinDynamicBufferOffsetAlignment","kResourceStates","kProgrammableEncoderTypes","ValidationTest","F","encoderTypeToStageFlag","encoderType","GPUShaderStage","COMPUTE","FRAGMENT","createBindingResourceWithState","resourceType","state","texture","createTextureWithState","view","createView","destroy","buffer","createBufferWithState","size","usage","GPUBufferUsage","STORAGE","createBindGroup","indices","device","pushErrorScope","Array","length","fill","layout","createBindGroupLayout","entries","map","binding","visibility","type","bindGroup","resource","popErrorScope","g","test","desc","params","u","combine","fn","t","maxBindGroups","limits","runTest","index","encoder","validateFinishAndSubmit","createEncoder","setBindGroup","debug","beginSubcases","unimplemented","dynamicOffsets","validateFinish","combineWithParams","_success","kBindingSize","bindGroupLayout","hasDynamicOffset","uniformBuffer","createBuffer","UNIFORM","storageBuffer","useU32array","Uint32Array","paramsSubcasesOnly","offsets","dynamicOffsetsDataStart","dynamicOffsetsDataLength","i","doSetBindGroup","shouldThrow"],"mappings":"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","sourcesContent":["export const description = `\nsetBindGroup validation tests.\n\nTODO: merge these notes and implement.\n> (Note: If there are errors with using certain binding types in certain passes, test those in the file for that pass type, not here.)\n>\n> - state tracking (probably separate file)\n>     - x= {compute pass, render pass}\n>     - {null, compatible, incompatible} current pipeline (should have no effect without draw/dispatch)\n>     - setBindGroup in different orders (e.g. 0,1,2 vs 2,0,1)\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { range, unreachable } from '../../../../../common/util/util.js';\nimport { kMinDynamicBufferOffsetAlignment } from '../../../../capability_info.js';\nimport { kResourceStates, ResourceState } from '../../../../gpu_test.js';\nimport {\n  kProgrammableEncoderTypes,\n  ProgrammableEncoderType,\n} from '../../../../util/command_buffer_maker.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nclass F extends ValidationTest {\n  encoderTypeToStageFlag(encoderType: ProgrammableEncoderType): GPUShaderStageFlags {\n    switch (encoderType) {\n      case 'compute pass':\n        return GPUShaderStage.COMPUTE;\n      case 'render pass':\n      case 'render bundle':\n        return GPUShaderStage.FRAGMENT;\n      default:\n        unreachable('Unknown encoder type');\n    }\n  }\n\n  createBindingResourceWithState(\n    resourceType: 'texture' | 'buffer',\n    state: 'valid' | 'destroyed'\n  ): GPUBindingResource {\n    switch (resourceType) {\n      case 'texture': {\n        const texture = this.createTextureWithState('valid');\n        const view = texture.createView();\n        if (state === 'destroyed') {\n          texture.destroy();\n        }\n        return view;\n      }\n      case 'buffer':\n        return {\n          buffer: this.createBufferWithState(state, {\n            size: 4,\n            usage: GPUBufferUsage.STORAGE,\n          }),\n        };\n      default:\n        unreachable('unknown resource type');\n    }\n  }\n\n  /**\n   * If state is 'invalid', creates an invalid bind group with valid resources.\n   * If state is 'destroyed', creates a valid bind group with destroyed resources.\n   */\n  createBindGroup(\n    state: ResourceState,\n    resourceType: 'buffer' | 'texture',\n    encoderType: ProgrammableEncoderType,\n    indices: number[]\n  ) {\n    if (state === 'invalid') {\n      this.device.pushErrorScope('validation');\n      indices = new Array<number>(indices.length + 1).fill(0);\n    }\n\n    const layout = this.device.createBindGroupLayout({\n      entries: indices.map(binding => ({\n        binding,\n        visibility: this.encoderTypeToStageFlag(encoderType),\n        ...(resourceType === 'buffer' ? { buffer: { type: 'storage' } } : { texture: {} }),\n      })),\n    });\n    const bindGroup = this.device.createBindGroup({\n      layout,\n      entries: indices.map(binding => ({\n        binding,\n        resource: this.createBindingResourceWithState(\n          resourceType,\n          state === 'destroyed' ? state : 'valid'\n        ),\n      })),\n    });\n\n    if (state === 'invalid') {\n      this.device.popErrorScope();\n    }\n    return bindGroup;\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('state_and_binding_index')\n  .desc('Tests that setBindGroup correctly handles {valid, invalid} bindGroups.')\n  .params(u =>\n    u\n      .combine('encoderType', kProgrammableEncoderTypes)\n      .combine('state', kResourceStates)\n      .combine('resourceType', ['buffer', 'texture'] as const)\n  )\n  .fn(async t => {\n    const { encoderType, state, resourceType } = t.params;\n    const maxBindGroups = t.device.limits?.maxBindGroups ?? 4;\n\n    async function runTest(index: number) {\n      const { encoder, validateFinishAndSubmit } = t.createEncoder(encoderType);\n      encoder.setBindGroup(index, t.createBindGroup(state, resourceType, encoderType, [index]));\n\n      validateFinishAndSubmit(state !== 'invalid' && index < maxBindGroups, state !== 'destroyed');\n    }\n\n    // MAINTENANCE_TODO: move to subcases() once we can query the device limits\n    for (const index of [1, maxBindGroups - 1, maxBindGroups]) {\n      t.debug(`test bind group index ${index}`);\n      await runTest(index);\n    }\n  });\n\ng.test('bind_group,device_mismatch')\n  .desc(\n    `\n    Tests setBindGroup cannot be called with a bind group created from another device\n    - x= setBindGroup {sequence overload, Uint32Array overload}\n    `\n  )\n  .params(u =>\n    u\n      .combine('encoderType', kProgrammableEncoderTypes)\n      .beginSubcases()\n      .combine('useU32Array', [true, false])\n      .combine('mismatched', [true, false])\n  )\n  .unimplemented();\n\ng.test('dynamic_offsets_passed_but_not_expected')\n  .desc('Tests that setBindGroup correctly errors on unexpected dynamicOffsets.')\n  .params(u => u.combine('encoderType', kProgrammableEncoderTypes))\n  .fn(async t => {\n    const { encoderType } = t.params;\n    const bindGroup = t.createBindGroup('valid', 'buffer', encoderType, []);\n    const dynamicOffsets = [0];\n\n    const { encoder, validateFinish } = t.createEncoder(encoderType);\n    encoder.setBindGroup(0, bindGroup, dynamicOffsets);\n    validateFinish(false);\n  });\n\ng.test('dynamic_offsets_match_expectations_in_pass_encoder')\n  .desc('Tests that given dynamicOffsets match the specified bindGroup.')\n  .params(u =>\n    u\n      .combine('encoderType', kProgrammableEncoderTypes)\n      .combineWithParams([\n        { dynamicOffsets: [256, 0], _success: true }, // Dynamic offsets aligned\n        { dynamicOffsets: [1, 2], _success: false }, // Dynamic offsets not aligned\n\n        // Wrong number of dynamic offsets\n        { dynamicOffsets: [256, 0, 0], _success: false },\n        { dynamicOffsets: [256], _success: false },\n        { dynamicOffsets: [], _success: false },\n\n        // Dynamic uniform buffer out of bounds because of binding size\n        { dynamicOffsets: [512, 0], _success: false },\n        { dynamicOffsets: [1024, 0], _success: false },\n        { dynamicOffsets: [0xffffffff, 0], _success: false },\n\n        // Dynamic storage buffer out of bounds because of binding size\n        { dynamicOffsets: [0, 512], _success: false },\n        { dynamicOffsets: [0, 1024], _success: false },\n        { dynamicOffsets: [0, 0xffffffff], _success: false },\n      ])\n      .combine('useU32array', [false, true])\n  )\n  .fn(async t => {\n    const kBindingSize = 9;\n\n    const bindGroupLayout = t.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,\n          buffer: {\n            type: 'uniform',\n            hasDynamicOffset: true,\n          },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,\n          buffer: {\n            type: 'storage',\n            hasDynamicOffset: true,\n          },\n        },\n      ],\n    });\n\n    const uniformBuffer = t.device.createBuffer({\n      size: 2 * kMinDynamicBufferOffsetAlignment + 8,\n      usage: GPUBufferUsage.UNIFORM,\n    });\n\n    const storageBuffer = t.device.createBuffer({\n      size: 2 * kMinDynamicBufferOffsetAlignment + 8,\n      usage: GPUBufferUsage.STORAGE,\n    });\n\n    const bindGroup = t.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: uniformBuffer,\n            size: kBindingSize,\n          },\n        },\n        {\n          binding: 1,\n          resource: {\n            buffer: storageBuffer,\n            size: kBindingSize,\n          },\n        },\n      ],\n    });\n\n    const { encoderType, dynamicOffsets, useU32array, _success } = t.params;\n\n    const { encoder, validateFinish } = t.createEncoder(encoderType);\n    if (useU32array) {\n      encoder.setBindGroup(0, bindGroup, new Uint32Array(dynamicOffsets), 0, dynamicOffsets.length);\n    } else {\n      encoder.setBindGroup(0, bindGroup, dynamicOffsets);\n    }\n    validateFinish(_success);\n  });\n\ng.test('u32array_start_and_length')\n  .desc('Tests that dynamicOffsetsData(Start|Length) apply to the given Uint32Array.')\n  .paramsSubcasesOnly([\n    // dynamicOffsetsDataLength > offsets.length\n    {\n      offsets: [0] as const,\n      dynamicOffsetsDataStart: 0,\n      dynamicOffsetsDataLength: 2,\n      _success: false,\n    },\n    // dynamicOffsetsDataStart + dynamicOffsetsDataLength > offsets.length\n    {\n      offsets: [0] as const,\n      dynamicOffsetsDataStart: 1,\n      dynamicOffsetsDataLength: 1,\n      _success: false,\n    },\n    {\n      offsets: [0, 0] as const,\n      dynamicOffsetsDataStart: 1,\n      dynamicOffsetsDataLength: 1,\n      _success: true,\n    },\n    {\n      offsets: [0, 0, 0] as const,\n      dynamicOffsetsDataStart: 1,\n      dynamicOffsetsDataLength: 1,\n      _success: true,\n    },\n    {\n      offsets: [0, 0] as const,\n      dynamicOffsetsDataStart: 0,\n      dynamicOffsetsDataLength: 2,\n      _success: true,\n    },\n  ])\n  .fn(t => {\n    const { offsets, dynamicOffsetsDataStart, dynamicOffsetsDataLength, _success } = t.params;\n    const kBindingSize = 8;\n\n    const bindGroupLayout = t.device.createBindGroupLayout({\n      entries: range(dynamicOffsetsDataLength, i => ({\n        binding: i,\n        visibility: GPUShaderStage.FRAGMENT,\n        buffer: {\n          type: 'storage',\n          hasDynamicOffset: true,\n        },\n      })),\n    });\n\n    const bindGroup = t.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: range(dynamicOffsetsDataLength, i => ({\n        binding: i,\n        resource: {\n          buffer: t.createBufferWithState('valid', {\n            size: kBindingSize,\n            usage: GPUBufferUsage.STORAGE,\n          }),\n          size: kBindingSize,\n        },\n      })),\n    });\n\n    const { encoder, validateFinish } = t.createEncoder('render pass');\n\n    const doSetBindGroup = () => {\n      encoder.setBindGroup(\n        0,\n        bindGroup,\n        new Uint32Array(offsets),\n        dynamicOffsetsDataStart,\n        dynamicOffsetsDataLength\n      );\n    };\n\n    if (_success) {\n      doSetBindGroup();\n    } else {\n      t.shouldThrow('RangeError', doSetBindGroup);\n    }\n\n    // RangeError in setBindGroup does not cause the encoder to become invalid.\n    validateFinish(true);\n  });\n"],"file":"setBindGroup.spec.js"}