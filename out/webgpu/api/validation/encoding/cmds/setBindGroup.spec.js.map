{"version":3,"sources":["../../../../../../src/webgpu/api/validation/encoding/cmds/setBindGroup.spec.ts"],"names":["description","makeTestGroup","range","unreachable","kMinDynamicBufferOffsetAlignment","kProgrammableEncoderTypes","ValidationTest","F","encoderTypeToStageFlag","encoderType","GPUShaderStage","COMPUTE","FRAGMENT","createBindingResourceWithState","resourceType","state","texture","createTextureWithState","view","createView","destroy","buffer","createBufferWithState","size","usage","GPUBufferUsage","STORAGE","createBindGroup","indices","device","pushErrorScope","Array","length","fill","layout","createBindGroupLayout","entries","map","binding","visibility","type","bindGroup","resource","popErrorScope","g","test","desc","params","u","combine","fn","t","maxBindGroups","limits","runTest","index","encoder","finish","createEncoder","setBindGroup","shouldError","commandBuffer","error","expect","expectValidationError","queue","submit","debug","dynamicOffsets","combineWithParams","_success","kBindingSize","bindGroupLayout","hasDynamicOffset","uniformBuffer","createBuffer","UNIFORM","storageBuffer","useU32array","Uint32Array","paramsSubcasesOnly","offsets","dynamicOffsetsDataStart","dynamicOffsetsDataLength","i"],"mappings":"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","sourcesContent":["export const description = `\nsetBindGroup validation tests.\n\nTODO: merge these notes and implement.\n> (Note: If there are errors with using certain binding types in certain passes, test those in the file for that pass type, not here.)\n>\n> - state tracking (probably separate file)\n>     - x= {compute pass, render pass}\n>     - {null, compatible, incompatible} current pipeline (should have no effect without draw/dispatch)\n>     - setBindGroup in different orders (e.g. 0,1,2 vs 2,0,1)\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { range, unreachable } from '../../../../../common/util/util.js';\nimport { kMinDynamicBufferOffsetAlignment } from '../../../../capability_info.js';\nimport {\n  kProgrammableEncoderTypes,\n  ProgrammableEncoderType,\n  ValidationTest,\n} from '../../validation_test.js';\n\nclass F extends ValidationTest {\n  encoderTypeToStageFlag(encoderType: ProgrammableEncoderType): GPUShaderStageFlags {\n    switch (encoderType) {\n      case 'compute pass':\n        return GPUShaderStage.COMPUTE;\n      case 'render pass':\n      case 'render bundle':\n        return GPUShaderStage.FRAGMENT;\n      default:\n        unreachable('Unknown encoder type');\n    }\n  }\n\n  createBindingResourceWithState(\n    resourceType: 'texture' | 'buffer',\n    state: 'valid' | 'destroyed'\n  ): GPUBindingResource {\n    switch (resourceType) {\n      case 'texture': {\n        const texture = this.createTextureWithState('valid');\n        const view = texture.createView();\n        if (state === 'destroyed') {\n          texture.destroy();\n        }\n        return view;\n      }\n      case 'buffer':\n        return {\n          buffer: this.createBufferWithState(state, {\n            size: 4,\n            usage: GPUBufferUsage.STORAGE,\n          }),\n        };\n      default:\n        unreachable('unknown resource type');\n    }\n  }\n\n  createBindGroup(\n    state: 'valid' | 'invalid' | 'destroyed',\n    resourceType: 'buffer' | 'texture',\n    encoderType: ProgrammableEncoderType,\n    indices: number[]\n  ) {\n    if (state === 'invalid') {\n      this.device.pushErrorScope('validation');\n      indices = new Array<number>(indices.length + 1).fill(0);\n    }\n\n    const layout = this.device.createBindGroupLayout({\n      entries: indices.map(binding => ({\n        binding,\n        visibility: this.encoderTypeToStageFlag(encoderType),\n        ...(resourceType === 'buffer' ? { buffer: { type: 'storage' } } : { texture: {} }),\n      })),\n    });\n    const bindGroup = this.device.createBindGroup({\n      layout,\n      entries: indices.map(binding => ({\n        binding,\n        resource: this.createBindingResourceWithState(\n          resourceType,\n          state === 'destroyed' ? state : 'valid'\n        ),\n      })),\n    });\n\n    if (state === 'invalid') {\n      this.device.popErrorScope();\n    }\n    return bindGroup;\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('state_and_binding_index')\n  .desc('Tests that setBindGroup correctly handles {valid, invalid} bindGroups.')\n  .params(u =>\n    u\n      .combine('encoderType', kProgrammableEncoderTypes)\n      .combine('state', ['valid', 'invalid', 'destroyed'] as const)\n      .combine('resourceType', ['buffer', 'texture'] as const)\n  )\n  .fn(async t => {\n    const { encoderType, state, resourceType } = t.params;\n    const maxBindGroups = t.device.limits?.maxBindGroups ?? 4;\n\n    async function runTest(index: number) {\n      const { encoder, finish } = t.createEncoder(encoderType);\n      encoder.setBindGroup(index, t.createBindGroup(state, resourceType, encoderType, [index]));\n\n      const shouldError = index >= maxBindGroups;\n\n      if (!shouldError && state === 'destroyed') {\n        t.device.pushErrorScope('validation');\n        const commandBuffer = finish();\n        const error = await t.device.popErrorScope();\n        t.expect(error === null, `finish() should not fail, but failed with ${error}`);\n        t.expectValidationError(() => {\n          t.queue.submit([commandBuffer]);\n        });\n      } else {\n        t.expectValidationError(() => {\n          t.debug('here');\n          finish();\n        }, shouldError || state !== 'valid');\n      }\n    }\n\n    // TODO: move to subcases() once we can query the device limits\n    for (const index of [1, maxBindGroups - 1, maxBindGroups]) {\n      t.debug(`test bind group index ${index}`);\n      await runTest(index);\n    }\n  });\n\ng.test('dynamic_offsets_passed_but_not_expected')\n  .desc('Tests that setBindGroup correctly errors on unexpected dynamicOffsets.')\n  .params(u => u.combine('encoderType', kProgrammableEncoderTypes))\n  .fn(async t => {\n    const { encoderType } = t.params;\n    const bindGroup = t.createBindGroup('valid', 'buffer', encoderType, []);\n    const dynamicOffsets = [0];\n\n    const { encoder, finish } = t.createEncoder(encoderType);\n    encoder.setBindGroup(0, bindGroup, dynamicOffsets);\n\n    t.expectValidationError(() => {\n      finish();\n    });\n  });\n\ng.test('dynamic_offsets_match_expectations_in_pass_encoder')\n  .desc('Tests that given dynamicOffsets match the specified bindGroup.')\n  .params(u =>\n    u\n      .combine('encoderType', kProgrammableEncoderTypes)\n      .combineWithParams([\n        { dynamicOffsets: [256, 0], _success: true }, // Dynamic offsets aligned\n        { dynamicOffsets: [1, 2], _success: false }, // Dynamic offsets not aligned\n\n        // Wrong number of dynamic offsets\n        { dynamicOffsets: [256, 0, 0], _success: false },\n        { dynamicOffsets: [256], _success: false },\n        { dynamicOffsets: [], _success: false },\n\n        // Dynamic uniform buffer out of bounds because of binding size\n        { dynamicOffsets: [512, 0], _success: false },\n        { dynamicOffsets: [1024, 0], _success: false },\n        { dynamicOffsets: [0xffffffff, 0], _success: false },\n\n        // Dynamic storage buffer out of bounds because of binding size\n        { dynamicOffsets: [0, 512], _success: false },\n        { dynamicOffsets: [0, 1024], _success: false },\n        { dynamicOffsets: [0, 0xffffffff], _success: false },\n      ])\n      .combine('useU32array', [false, true])\n  )\n  .fn(async t => {\n    const kBindingSize = 9;\n\n    const bindGroupLayout = t.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,\n          buffer: {\n            type: 'uniform',\n            hasDynamicOffset: true,\n          },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,\n          buffer: {\n            type: 'storage',\n            hasDynamicOffset: true,\n          },\n        },\n      ],\n    });\n\n    const uniformBuffer = t.device.createBuffer({\n      size: 2 * kMinDynamicBufferOffsetAlignment + 8,\n      usage: GPUBufferUsage.UNIFORM,\n    });\n\n    const storageBuffer = t.device.createBuffer({\n      size: 2 * kMinDynamicBufferOffsetAlignment + 8,\n      usage: GPUBufferUsage.STORAGE,\n    });\n\n    const bindGroup = t.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: uniformBuffer,\n            size: kBindingSize,\n          },\n        },\n        {\n          binding: 1,\n          resource: {\n            buffer: storageBuffer,\n            size: kBindingSize,\n          },\n        },\n      ],\n    });\n\n    const { encoderType, dynamicOffsets, useU32array, _success } = t.params;\n\n    const { encoder, finish } = t.createEncoder(encoderType);\n    if (useU32array) {\n      encoder.setBindGroup(0, bindGroup, new Uint32Array(dynamicOffsets), 0, dynamicOffsets.length);\n    } else {\n      encoder.setBindGroup(0, bindGroup, dynamicOffsets);\n    }\n\n    t.expectValidationError(() => {\n      finish();\n    }, !_success);\n  });\n\ng.test('u32array_start_and_length')\n  .desc('Tests that dynamicOffsetsData(Start|Length) apply to the given Uint32Array.')\n  .paramsSubcasesOnly([\n    // dynamicOffsetsDataLength > offsets.length\n    {\n      offsets: [0] as const,\n      dynamicOffsetsDataStart: 0,\n      dynamicOffsetsDataLength: 2,\n      _success: false,\n    },\n    // dynamicOffsetsDataStart + dynamicOffsetsDataLength > offsets.length\n    {\n      offsets: [0] as const,\n      dynamicOffsetsDataStart: 1,\n      dynamicOffsetsDataLength: 1,\n      _success: false,\n    },\n    {\n      offsets: [0, 0] as const,\n      dynamicOffsetsDataStart: 1,\n      dynamicOffsetsDataLength: 1,\n      _success: true,\n    },\n    {\n      offsets: [0, 0, 0] as const,\n      dynamicOffsetsDataStart: 1,\n      dynamicOffsetsDataLength: 1,\n      _success: true,\n    },\n    {\n      offsets: [0, 0] as const,\n      dynamicOffsetsDataStart: 0,\n      dynamicOffsetsDataLength: 2,\n      _success: true,\n    },\n  ])\n  .fn(t => {\n    const { offsets, dynamicOffsetsDataStart, dynamicOffsetsDataLength, _success } = t.params;\n    const kBindingSize = 8;\n\n    const bindGroupLayout = t.device.createBindGroupLayout({\n      entries: range(dynamicOffsetsDataLength, i => ({\n        binding: i,\n        visibility: GPUShaderStage.FRAGMENT,\n        buffer: {\n          type: 'storage',\n          hasDynamicOffset: true,\n        },\n      })),\n    });\n\n    const bindGroup = t.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: range(dynamicOffsetsDataLength, i => ({\n        binding: i,\n        resource: {\n          buffer: t.createBufferWithState('valid', {\n            size: kBindingSize,\n            usage: GPUBufferUsage.STORAGE,\n          }),\n          size: kBindingSize,\n        },\n      })),\n    });\n\n    const { encoder, finish } = t.createEncoder('render pass');\n    encoder.setBindGroup(\n      0,\n      bindGroup,\n      new Uint32Array(offsets),\n      dynamicOffsetsDataStart,\n      dynamicOffsetsDataLength\n    );\n\n    t.expectValidationError(() => {\n      finish();\n    }, !_success);\n  });\n"],"file":"setBindGroup.spec.js"}