{"version":3,"sources":["../../../../src/webgpu/web_platform/copyToTexture/canvas.spec.ts"],"names":["description","makeTestGroup","unreachable","assert","memcpy","kTextureFormatInfo","kValidTextureFormatsForCopyE2T","CopyToTextureUtils","isFp16Format","allCanvasTypes","createCanvas","kTexelRepresentationInfo","formatForExpectedPixels","format","F","init2DCanvasContent","canvasType","width","height","paintOpaqueRects","canvas","canvasContext","getContext","skip","rectWidth","Math","floor","rectHeight","alphaValue","ctx","fillStyle","fillRect","initGLCanvasContent","contextName","premultiplied","gl","premultipliedAlpha","trackForCleanup","colorValue","enable","SCISSOR_TEST","scissor","clearColor","clear","COLOR_BUFFER_BIT","getExpectedPixels","context","contextType","srcPremultiplied","dstPremultiplied","bytesPerPixel","bytesPerBlock","expectedPixels","Uint8ClampedArray","sourcePixels","getImageData","data","readPixels","RGBA","UNSIGNED_BYTE","rep","divide","rgba","i","j","pixelPos","R","G","B","A","dstPixelPos","src","pack","encode","dst","start","g","test","desc","params","u","combine","beginSubcases","fn","t","dstColorFormat","device","createTexture","size","depthOrArrayLayers","usage","GPUTextureUsage","COPY_DST","COPY_SRC","RENDER_ATTACHMENT","dstBytesPerPixel","doTestAndCheckResult","source","origin","x","y","texture","colorSpace"],"mappings":"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","sourcesContent":["export const description = `\ncopyToTexture with HTMLCanvasElement and OffscreenCanvas sources.\n\nTODO: consider whether external_texture and copyToTexture video tests should be in the same file\n`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { unreachable, assert, memcpy } from '../../../common/util/util.js';\nimport {\n  RegularTextureFormat,\n  kTextureFormatInfo,\n  kValidTextureFormatsForCopyE2T,\n} from '../../capability_info.js';\nimport { CopyToTextureUtils, isFp16Format } from '../../util/copy_to_texture.js';\nimport { canvasTypes, allCanvasTypes, createCanvas } from '../../util/create_elements.js';\nimport { kTexelRepresentationInfo } from '../../util/texture/texel_data.js';\n\n/**\n * If the destination format specifies a transfer function,\n * copyExternalImageToTexture (like B2T/T2T copies) should ignore it.\n */\nfunction formatForExpectedPixels(format: RegularTextureFormat): RegularTextureFormat {\n  return format === 'rgba8unorm-srgb'\n    ? 'rgba8unorm'\n    : format === 'bgra8unorm-srgb'\n    ? 'bgra8unorm'\n    : format;\n}\n\nclass F extends CopyToTextureUtils {\n  // TODO: Cache the generated canvas to avoid duplicated initialization.\n  init2DCanvasContent({\n    canvasType,\n    width,\n    height,\n    paintOpaqueRects,\n  }: {\n    canvasType: canvasTypes;\n    width: number;\n    height: number;\n    paintOpaqueRects: boolean;\n  }): {\n    canvas: HTMLCanvasElement | OffscreenCanvas;\n    canvasContext: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\n  } {\n    const canvas = createCanvas(this, canvasType, width, height);\n\n    let canvasContext = null;\n    canvasContext = canvas.getContext('2d') as\n      | CanvasRenderingContext2D\n      | OffscreenCanvasRenderingContext2D\n      | null;\n\n    if (canvasContext === null) {\n      this.skip(canvasType + ' canvas 2d context not available');\n    }\n\n    const rectWidth = Math.floor(width / 2);\n    const rectHeight = Math.floor(height / 2);\n\n    // The rgb10a2unorm dst texture will have tiny errors when we compare actual and expectation.\n    // This is due to the convert from 8-bit to 10-bit combined with alpha value ops. So for\n    // rgb10a2unorm dst textures, we'll set alphaValue to 1.0 to test.\n    const alphaValue = paintOpaqueRects ? 1.0 : 0.6;\n    const ctx = canvasContext as CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\n    // Red\n    ctx.fillStyle = `rgba(255, 0, 0, ${alphaValue})`;\n    ctx.fillRect(0, 0, rectWidth, rectHeight);\n    // Lime\n    ctx.fillStyle = `rgba(0, 255, 0, ${alphaValue})`;\n    ctx.fillRect(rectWidth, 0, width - rectWidth, rectHeight);\n    // Blue\n    ctx.fillStyle = `rgba(0, 0, 255, ${alphaValue})`;\n    ctx.fillRect(0, rectHeight, rectWidth, height - rectHeight);\n    // White\n    ctx.fillStyle = `rgba(255, 255, 255, ${alphaValue})`;\n    ctx.fillRect(rectWidth, rectHeight, width - rectWidth, height - rectHeight);\n\n    return { canvas, canvasContext };\n  }\n\n  // TODO: Cache the generated canvas to avoid duplicated initialization.\n  initGLCanvasContent({\n    canvasType,\n    contextName,\n    width,\n    height,\n    premultiplied,\n    paintOpaqueRects,\n  }: {\n    canvasType: canvasTypes;\n    contextName: 'webgl' | 'webgl2';\n    width: number;\n    height: number;\n    premultiplied: boolean;\n    paintOpaqueRects: boolean;\n  }): {\n    canvas: HTMLCanvasElement | OffscreenCanvas;\n    canvasContext: WebGLRenderingContext | WebGL2RenderingContext;\n  } {\n    const canvas = createCanvas(this, canvasType, width, height);\n\n    const gl = canvas.getContext(contextName, { premultipliedAlpha: premultiplied }) as\n      | WebGLRenderingContext\n      | WebGL2RenderingContext\n      | null;\n\n    if (gl === null) {\n      this.skip(canvasType + ' canvas ' + contextName + ' context not available');\n    }\n    this.trackForCleanup(gl);\n\n    const rectWidth = Math.floor(width / 2);\n    const rectHeight = Math.floor(height / 2);\n\n    const alphaValue = paintOpaqueRects ? 1.0 : 0.6;\n    const colorValue = premultiplied ? alphaValue : 1.0;\n\n    // For webgl/webgl2 context canvas, if the context created with premultipliedAlpha attributes,\n    // it means that the value in drawing buffer is premultiplied or not. So we should set\n    // premultipliedAlpha value for premultipliedAlpha true gl context and unpremultipliedAlpha value\n    // for the premulitpliedAlpha false gl context.\n    gl.enable(gl.SCISSOR_TEST);\n    gl.scissor(0, 0, rectWidth, rectHeight);\n    gl.clearColor(colorValue, 0.0, 0.0, alphaValue);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    gl.scissor(rectWidth, 0, width - rectWidth, rectHeight);\n    gl.clearColor(0.0, colorValue, 0.0, alphaValue);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    gl.scissor(0, rectHeight, rectWidth, height - rectHeight);\n    gl.clearColor(0.0, 0.0, colorValue, alphaValue);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    gl.scissor(rectWidth, rectHeight, width - rectWidth, height - rectHeight);\n    gl.clearColor(colorValue, colorValue, colorValue, alphaValue);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    return { canvas, canvasContext: gl };\n  }\n\n  getExpectedPixels({\n    context,\n    width,\n    height,\n    format,\n    contextType,\n    srcPremultiplied,\n    dstPremultiplied,\n  }: {\n    context:\n      | CanvasRenderingContext2D\n      | OffscreenCanvasRenderingContext2D\n      | WebGLRenderingContext\n      | WebGL2RenderingContext;\n    width: number;\n    height: number;\n    format: RegularTextureFormat;\n    contextType: '2d' | 'gl';\n    srcPremultiplied: boolean;\n    dstPremultiplied: boolean;\n  }): Uint8ClampedArray {\n    const bytesPerPixel = kTextureFormatInfo[format].bytesPerBlock;\n\n    const expectedPixels = new Uint8ClampedArray(bytesPerPixel * width * height);\n    let sourcePixels;\n    if (contextType === '2d') {\n      const ctx = context as CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\n      sourcePixels = ctx.getImageData(0, 0, width, height).data;\n    } else if (contextType === 'gl') {\n      sourcePixels = new Uint8ClampedArray(width * height * 4);\n      const gl = context as WebGLRenderingContext | WebGL2RenderingContext;\n      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, sourcePixels);\n    } else {\n      unreachable();\n    }\n\n    // Generate expectedPixels\n    // Use getImageData and readPixels to get canvas contents.\n    const rep = kTexelRepresentationInfo[format];\n    const divide = 255.0;\n    let rgba: { R: number; G: number; B: number; A: number };\n    for (let i = 0; i < height; ++i) {\n      for (let j = 0; j < width; ++j) {\n        const pixelPos = i * width + j;\n\n        rgba = {\n          R: sourcePixels[pixelPos * 4] / divide,\n          G: sourcePixels[pixelPos * 4 + 1] / divide,\n          B: sourcePixels[pixelPos * 4 + 2] / divide,\n          A: sourcePixels[pixelPos * 4 + 3] / divide,\n        };\n\n        if (!srcPremultiplied && dstPremultiplied) {\n          rgba.R *= rgba.A;\n          rgba.G *= rgba.A;\n          rgba.B *= rgba.A;\n        }\n\n        if (srcPremultiplied && !dstPremultiplied) {\n          assert(rgba.A !== 0.0);\n          rgba.R /= rgba.A;\n          rgba.G /= rgba.A;\n          rgba.B /= rgba.A;\n        }\n\n        // WebGL readPixel returns pixels from bottom-left origin. Using CopyExternalImageToTexture\n        // to copy from WebGL Canvas keeps top-left origin. So the expectation from webgl.readPixel should\n        // be flipped.\n        const dstPixelPos = contextType === 'gl' ? (height - i - 1) * width + j : pixelPos;\n\n        memcpy(\n          { src: rep.pack(rep.encode(rgba)) },\n          { dst: expectedPixels, start: dstPixelPos * bytesPerPixel }\n        );\n      }\n    }\n\n    return expectedPixels;\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('copy_contents_from_2d_context_canvas')\n  .desc(\n    `\n  Test HTMLCanvasElement and OffscreenCanvas with 2d context\n  can be copied to WebGPU texture correctly.\n\n  It creates HTMLCanvasElement/OffscreenCanvas with '2d'.\n  Use fillRect(2d context) to render red rect for top-left,\n  green rect for top-right, blue rect for bottom-left and white for bottom-right.\n\n  Then call copyExternalImageToTexture() to do a full copy to the 0 mipLevel\n  of dst texture, and read the contents out to compare with the canvas contents.\n\n  The tests covers:\n  - Valid canvas type\n  - Valid 2d context type\n  - TODO: color space tests need to be added\n  - TODO: Add error tolerance for rgb10a2unorm dst texture format\n\n  And the expected results are all passed.\n  `\n  )\n  .params(u =>\n    u\n      .combine('canvasType', allCanvasTypes)\n      .combine('dstColorFormat', kValidTextureFormatsForCopyE2T)\n      .combine('dstPremultiplied', [true, false])\n      .beginSubcases()\n      .combine('width', [1, 2, 4, 15, 255, 256])\n      .combine('height', [1, 2, 4, 15, 255, 256])\n  )\n  .fn(async t => {\n    const { width, height, canvasType, dstColorFormat, dstPremultiplied } = t.params;\n\n    // When dst texture format is rgb10a2unorm, the generated expected value of the result\n    // may have tiny errors compared to the actual result when the channel value is\n    // not 1.0 or 0.0.\n    // For example, we init the pixel with r channel to 0.6. And the denormalized value for\n    // 10-bit channel is 613.8, which needs to call \"round\" or other function to get an integer.\n    // It is possible that gpu adopt different \"round\" as our cpu implementation(we use Math.round())\n    // and it will generate tiny errors.\n    // So the cases with rgb10a2unorm dst texture format are handled specially by painting opaque rects\n    // to ensure they will have stable result after alphaOps(should keep the same value).\n    const { canvas, canvasContext } = t.init2DCanvasContent({\n      canvasType,\n      width,\n      height,\n      paintOpaqueRects: dstColorFormat === 'rgb10a2unorm',\n    });\n\n    const dst = t.device.createTexture({\n      size: {\n        width,\n        height,\n        depthOrArrayLayers: 1,\n      },\n      format: dstColorFormat,\n      usage:\n        GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    // Construct expected value for different dst color format\n    const dstBytesPerPixel = kTextureFormatInfo[dstColorFormat].bytesPerBlock;\n    const format: RegularTextureFormat = formatForExpectedPixels(dstColorFormat);\n\n    // For 2d canvas, get expected pixels with getImageData(), which returns unpremultiplied\n    // values.\n    const expectedPixels = t.getExpectedPixels({\n      context: canvasContext,\n      width,\n      height,\n      format,\n      contextType: '2d',\n      srcPremultiplied: false,\n      dstPremultiplied,\n    });\n\n    t.doTestAndCheckResult(\n      { source: canvas, origin: { x: 0, y: 0 } },\n      {\n        texture: dst,\n        origin: { x: 0, y: 0 },\n        colorSpace: 'srgb',\n        premultipliedAlpha: dstPremultiplied,\n      },\n      { width: canvas.width, height: canvas.height, depthOrArrayLayers: 1 },\n      dstBytesPerPixel,\n      expectedPixels,\n      isFp16Format(dstColorFormat)\n    );\n  });\n\ng.test('copy_contents_from_gl_context_canvas')\n  .desc(\n    `\n  Test HTMLCanvasElement and OffscreenCanvas with webgl/webgl2 context\n  can be copied to WebGPU texture correctly.\n\n  It creates HTMLCanvasElement/OffscreenCanvas with webgl'/'webgl2'.\n  Use stencil + clear to render red rect for top-left, green rect\n  for top-right, blue rect for bottom-left and white for bottom-right.\n  And do premultiply alpha in advance if the webgl/webgl2 context is created\n  with premultipliedAlpha : true.\n\n  Then call copyExternalImageToTexture() to do a full copy to the 0 mipLevel\n  of dst texture, and read the contents out to compare with the canvas contents.\n\n  The tests covers:\n  - Valid canvas type\n  - Valid webgl/webgl2 context type\n  - TODO: color space tests need to be added\n  - TODO: Add error tolerance for rgb10a2unorm dst texture format\n\n  And the expected results are all passed.\n  `\n  )\n  .params(u =>\n    u\n      .combine('canvasType', allCanvasTypes)\n      .combine('contextName', ['webgl', 'webgl2'] as const)\n      .combine('dstColorFormat', kValidTextureFormatsForCopyE2T)\n      .combine('srcPremultiplied', [true, false])\n      .combine('dstPremultiplied', [true, false])\n      .beginSubcases()\n      .combine('width', [1, 2, 4, 15, 255, 256])\n      .combine('height', [1, 2, 4, 15, 255, 256])\n  )\n  .fn(async t => {\n    const {\n      width,\n      height,\n      canvasType,\n      contextName,\n      dstColorFormat,\n      srcPremultiplied,\n      dstPremultiplied,\n    } = t.params;\n\n    // When dst texture format is rgb10a2unorm, the generated expected value of the result\n    // may have tiny errors compared to the actual result when the channel value is\n    // not 1.0 or 0.0.\n    // For example, we init the pixel with r channel to 0.6. And the denormalized value for\n    // 10-bit channel is 613.8, which needs to call \"round\" or other function to get an integer.\n    // It is possible that gpu adopt different \"round\" as our cpu implementation(we use Math.round())\n    // and it will generate tiny errors.\n    // So the cases with rgb10a2unorm dst texture format are handled specially by by painting opaque rects\n    // to ensure they will have stable result after alphaOps(should keep the same value).\n    const { canvas, canvasContext } = t.initGLCanvasContent({\n      canvasType,\n      contextName,\n      width,\n      height,\n      premultiplied: srcPremultiplied,\n      paintOpaqueRects: dstColorFormat === 'rgb10a2unorm',\n    });\n\n    const dst = t.device.createTexture({\n      size: {\n        width,\n        height,\n        depthOrArrayLayers: 1,\n      },\n      format: dstColorFormat,\n      usage:\n        GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    // Construct expected value for different dst color format\n    const dstBytesPerPixel = kTextureFormatInfo[dstColorFormat].bytesPerBlock;\n    const format: RegularTextureFormat = formatForExpectedPixels(dstColorFormat);\n    const expectedPixels = t.getExpectedPixels({\n      context: canvasContext,\n      width,\n      height,\n      format,\n      contextType: 'gl',\n      srcPremultiplied,\n      dstPremultiplied,\n    });\n\n    t.doTestAndCheckResult(\n      { source: canvas, origin: { x: 0, y: 0 } },\n      {\n        texture: dst,\n        origin: { x: 0, y: 0 },\n        colorSpace: 'srgb',\n        premultipliedAlpha: dstPremultiplied,\n      },\n      { width: canvas.width, height: canvas.height, depthOrArrayLayers: 1 },\n      dstBytesPerPixel,\n      expectedPixels,\n      isFp16Format(dstColorFormat)\n    );\n  });\n"],"file":"canvas.spec.js"}