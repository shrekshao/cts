{"version":3,"file":"util.js","names":["SkipTestCase","assert","ErrorWithExtra","raceWithRejectOnTimeout","unreachable","startPlayingAndWaitForVideo","video","callback","Promise","resolve","reject","callbackAndResolve","ex","error","message","addEventListener","event","requestVideoFrameCallback","timeWatcher","currentTime","requestAnimationFrame","loop","muted","preload","play","catch","waitForNextFrame","promise","videoCallbackHelper","getVideoColorSpaceInit","colorSpaceName","primaries","transfer","matrix","fullRange","getVideoFrameFromVideoElement","test","colorSpace","captureStream","undefined","skip","track","getVideoTracks","reader","MediaStreamTrackProcessor","readable","getReader","videoFrame","read","value","format","timestamp","bufferSize","allocationSize","buffer","ArrayBuffer","frameLayout","copyTo","frameInit","codedWidth","codedHeight","layout","VideoFrame","timeoutMessage","promiseWithoutTimeout"],"sources":["../../../src/webgpu/web_platform/util.ts"],"sourcesContent":["import { Fixture, SkipTestCase } from '../../common/framework/fixture.js';\nimport {\n  assert,\n  ErrorWithExtra,\n  raceWithRejectOnTimeout,\n  unreachable,\n} from '../../common/util/util.js';\n\ndeclare global {\n  interface HTMLMediaElement {\n    // Add captureStream() support for HTMLMediaElement from\n    // https://w3c.github.io/mediacapture-fromelement/#dom-htmlmediaelement-capturestream\n    captureStream(): MediaStream;\n  }\n}\n\n/**\n * Starts playing a video and waits for it to be consumable.\n * Returns a promise which resolves after `callback` (which may be async) completes.\n *\n * @param video An HTML5 Video element.\n * @param callback Function to call when video is ready.\n *\n * Adapted from https://github.com/KhronosGroup/WebGL/blob/main/sdk/tests/js/webgl-test-utils.js\n */\nexport function startPlayingAndWaitForVideo(\n  video: HTMLVideoElement,\n  callback: () => unknown | Promise<unknown>\n): Promise<void> {\n  return raceWithRejectOnTimeout(\n    new Promise((resolve, reject) => {\n      const callbackAndResolve = () =>\n        void (async () => {\n          try {\n            await callback();\n            resolve();\n          } catch (ex) {\n            reject();\n          }\n        })();\n      if (video.error) {\n        reject(\n          new ErrorWithExtra('Video.error: ' + video.error.message, () => ({ error: video.error }))\n        );\n        return;\n      }\n\n      video.addEventListener(\n        'error',\n        event => reject(new ErrorWithExtra('Video received \"error\" event', () => ({ event }))),\n        true\n      );\n\n      if ('requestVideoFrameCallback' in video) {\n        video.requestVideoFrameCallback(() => {\n          callbackAndResolve();\n        });\n      } else {\n        // If requestVideoFrameCallback isn't available, check each frame if the video has advanced.\n        const timeWatcher = () => {\n          if (video.currentTime > 0) {\n            callbackAndResolve();\n          } else {\n            requestAnimationFrame(timeWatcher);\n          }\n        };\n        timeWatcher();\n      }\n\n      video.loop = true;\n      video.muted = true;\n      video.preload = 'auto';\n      video.play().catch(reject);\n    }),\n    2000,\n    'Video never became ready'\n  );\n}\n\n/**\n * Fire a `callback` when the video reaches a new frame.\n * Returns a promise which resolves after `callback` (which may be async) completes.\n *\n * MAINTENANCE_TODO: Find a way to implement this for browsers without requestVideoFrameCallback as\n * well, similar to the timeWatcher path in startPlayingAndWaitForVideo. If that path is proven to\n * work well, we can consider getting rid of the requestVideoFrameCallback path.\n */\nexport function waitForNextFrame(\n  video: HTMLVideoElement,\n  callback: () => unknown | Promise<unknown>\n): Promise<void> {\n  const { promise, callbackAndResolve } = videoCallbackHelper(\n    callback,\n    'waitForNextFrame timed out'\n  );\n\n  if ('requestVideoFrameCallback' in video) {\n    video.requestVideoFrameCallback(() => {\n      callbackAndResolve();\n    });\n  } else {\n    throw new SkipTestCase('waitForNextFrame currently requires requestVideoFrameCallback');\n  }\n\n  return promise;\n}\n\ntype VideoColorSpaceName = 'REC601' | 'REC709' | 'REC2020';\n\nexport function getVideoColorSpaceInit(colorSpaceName: VideoColorSpaceName): VideoColorSpaceInit {\n  switch (colorSpaceName) {\n    case 'REC601':\n      return {\n        primaries: 'smpte170m',\n        transfer: 'smpte170m',\n        matrix: 'smpte170m',\n        fullRange: false,\n      };\n    case 'REC709':\n      return { primaries: 'bt709', transfer: 'bt709', matrix: 'bt709', fullRange: false };\n    case 'REC2020':\n      return { primaries: 'bt709', transfer: 'iec61966-2-1', matrix: 'rgb', fullRange: true };\n    default:\n      unreachable();\n  }\n}\n\nexport async function getVideoFrameFromVideoElement(\n  test: Fixture,\n  video: HTMLVideoElement,\n  colorSpace: VideoColorSpaceInit = getVideoColorSpaceInit('REC709')\n): Promise<VideoFrame> {\n  if (video.captureStream === undefined) {\n    test.skip('HTMLVideoElement.captureStream is not supported');\n  }\n\n  const track: MediaStreamVideoTrack = video.captureStream().getVideoTracks()[0];\n  const reader = new MediaStreamTrackProcessor({ track }).readable.getReader();\n  const videoFrame = (await reader.read()).value;\n  assert(videoFrame !== undefined, 'unable to get a VideoFrame from track 0');\n  assert(\n    videoFrame.format !== null && videoFrame.timestamp !== null,\n    'unable to get a valid VideoFrame from track 0'\n  );\n  // Apply color space info because the VideoFrame generated from captured stream\n  // doesn't have it.\n  const bufferSize = videoFrame.allocationSize();\n  const buffer = new ArrayBuffer(bufferSize);\n  const frameLayout = await videoFrame.copyTo(buffer);\n  const frameInit: VideoFrameBufferInit = {\n    format: videoFrame.format,\n    timestamp: videoFrame.timestamp,\n    codedWidth: videoFrame.codedWidth,\n    codedHeight: videoFrame.codedHeight,\n    colorSpace,\n    layout: frameLayout,\n  };\n  return new VideoFrame(buffer, frameInit);\n}\n\n/**\n * Helper for doing something inside of a (possibly async) callback (directly, not in a following\n * microtask), and returning a promise when the callback is done.\n * MAINTENANCE_TODO: Use this in startPlayingAndWaitForVideo (and make sure it works).\n */\nfunction videoCallbackHelper(\n  callback: () => unknown | Promise<unknown>,\n  timeoutMessage: string\n): { promise: Promise<void>; callbackAndResolve: () => void } {\n  let callbackAndResolve: () => void;\n\n  const promiseWithoutTimeout = new Promise<void>((resolve, reject) => {\n    callbackAndResolve = () =>\n      void (async () => {\n        try {\n          await callback(); // catches both exceptions and rejections\n          resolve();\n        } catch (ex) {\n          reject(ex);\n        }\n      })();\n  });\n  const promise = raceWithRejectOnTimeout(promiseWithoutTimeout, 2000, timeoutMessage);\n  return { promise, callbackAndResolve: callbackAndResolve! };\n}\n"],"mappings":"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"}