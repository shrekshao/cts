{"version":3,"sources":["../../../src/webgpu/web_platform/util.ts"],"names":["SkipTestCase","assert","ErrorWithExtra","raceWithRejectOnTimeout","unreachable","startPlayingAndWaitForVideo","video","callback","Promise","resolve","reject","callbackAndResolve","ex","error","message","addEventListener","event","requestVideoFrameCallback","timeWatcher","currentTime","requestAnimationFrame","loop","muted","preload","play","catch","waitForNextFrame","promise","videoCallbackHelper","getVideoColorSpaceInit","colorSpaceName","primaries","transfer","matrix","fullRange","getVideoFrameFromVideoElement","test","colorSpace","captureStream","undefined","skip","track","getVideoTracks","reader","MediaStreamTrackProcessor","readable","getReader","videoFrame","read","value","format","timestamp","bufferSize","allocationSize","buffer","ArrayBuffer","frameLayout","copyTo","frameInit","codedWidth","codedHeight","layout","VideoFrame","timeoutMessage","promiseWithoutTimeout"],"mappings":"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","sourcesContent":["import { Fixture, SkipTestCase } from '../../common/framework/fixture.js';\nimport {\n  assert,\n  ErrorWithExtra,\n  raceWithRejectOnTimeout,\n  unreachable,\n} from '../../common/util/util.js';\n\ndeclare global {\n  interface HTMLMediaElement {\n    // Add captureStream() support for HTMLMediaElement from\n    // https://w3c.github.io/mediacapture-fromelement/#dom-htmlmediaelement-capturestream\n    captureStream(): MediaStream;\n  }\n}\n\n/**\n * Starts playing a video and waits for it to be consumable.\n * Returns a promise which resolves after `callback` (which may be async) completes.\n *\n * @param video An HTML5 Video element.\n * @param callback Function to call when video is ready.\n *\n * Adapted from https://github.com/KhronosGroup/WebGL/blob/main/sdk/tests/js/webgl-test-utils.js\n */\nexport function startPlayingAndWaitForVideo(\n  video: HTMLVideoElement,\n  callback: () => unknown | Promise<unknown>\n): Promise<void> {\n  return raceWithRejectOnTimeout(\n    new Promise((resolve, reject) => {\n      const callbackAndResolve = () =>\n        void (async () => {\n          try {\n            await callback();\n            resolve();\n          } catch (ex) {\n            reject();\n          }\n        })();\n      if (video.error) {\n        reject(\n          new ErrorWithExtra('Video.error: ' + video.error.message, () => ({ error: video.error }))\n        );\n        return;\n      }\n\n      video.addEventListener(\n        'error',\n        event => reject(new ErrorWithExtra('Video received \"error\" event', () => ({ event }))),\n        true\n      );\n\n      if ('requestVideoFrameCallback' in video) {\n        video.requestVideoFrameCallback(() => {\n          callbackAndResolve();\n        });\n      } else {\n        // If requestVideoFrameCallback isn't available, check each frame if the video has advanced.\n        const timeWatcher = () => {\n          if (video.currentTime > 0) {\n            callbackAndResolve();\n          } else {\n            requestAnimationFrame(timeWatcher);\n          }\n        };\n        timeWatcher();\n      }\n\n      video.loop = true;\n      video.muted = true;\n      video.preload = 'auto';\n      video.play().catch(reject);\n    }),\n    2000,\n    'Video never became ready'\n  );\n}\n\n/**\n * Fire a `callback` when the video reaches a new frame.\n * Returns a promise which resolves after `callback` (which may be async) completes.\n *\n * MAINTENANCE_TODO: Find a way to implement this for browsers without requestVideoFrameCallback as\n * well, similar to the timeWatcher path in startPlayingAndWaitForVideo. If that path is proven to\n * work well, we can consider getting rid of the requestVideoFrameCallback path.\n */\nexport function waitForNextFrame(\n  video: HTMLVideoElement,\n  callback: () => unknown | Promise<unknown>\n): Promise<void> {\n  const { promise, callbackAndResolve } = videoCallbackHelper(\n    callback,\n    'waitForNextFrame timed out'\n  );\n\n  if ('requestVideoFrameCallback' in video) {\n    video.requestVideoFrameCallback(() => {\n      callbackAndResolve();\n    });\n  } else {\n    throw new SkipTestCase('waitForNextFrame currently requires requestVideoFrameCallback');\n  }\n\n  return promise;\n}\n\ntype VideoColorSpaceName = 'REC601' | 'REC709' | 'REC2020';\n\nexport function getVideoColorSpaceInit(colorSpaceName: VideoColorSpaceName): VideoColorSpaceInit {\n  switch (colorSpaceName) {\n    case 'REC601':\n      return {\n        primaries: 'smpte170m',\n        transfer: 'smpte170m',\n        matrix: 'smpte170m',\n        fullRange: false,\n      };\n    case 'REC709':\n      return { primaries: 'bt709', transfer: 'bt709', matrix: 'bt709', fullRange: false };\n    case 'REC2020':\n      return { primaries: 'bt709', transfer: 'iec61966-2-1', matrix: 'rgb', fullRange: true };\n    default:\n      unreachable();\n  }\n}\n\nexport async function getVideoFrameFromVideoElement(\n  test: Fixture,\n  video: HTMLVideoElement,\n  colorSpace: VideoColorSpaceInit = getVideoColorSpaceInit('REC709')\n): Promise<VideoFrame> {\n  if (video.captureStream === undefined) {\n    test.skip('HTMLVideoElement.captureStream is not supported');\n  }\n\n  const track: MediaStreamVideoTrack = video.captureStream().getVideoTracks()[0];\n  const reader = new MediaStreamTrackProcessor({ track }).readable.getReader();\n  const videoFrame = (await reader.read()).value;\n  assert(videoFrame !== undefined, 'unable to get a VideoFrame from track 0');\n  assert(\n    videoFrame.format !== null && videoFrame.timestamp !== null,\n    'unable to get a valid VideoFrame from track 0'\n  );\n  // Apply color space info because the VideoFrame generated from captured stream\n  // doesn't have it.\n  const bufferSize = videoFrame.allocationSize();\n  const buffer = new ArrayBuffer(bufferSize);\n  const frameLayout = await videoFrame.copyTo(buffer);\n  const frameInit: VideoFrameBufferInit = {\n    format: videoFrame.format,\n    timestamp: videoFrame.timestamp,\n    codedWidth: videoFrame.codedWidth,\n    codedHeight: videoFrame.codedHeight,\n    colorSpace,\n    layout: frameLayout,\n  };\n  return new VideoFrame(buffer, frameInit);\n}\n\n/**\n * Helper for doing something inside of a (possibly async) callback (directly, not in a following\n * microtask), and returning a promise when the callback is done.\n * MAINTENANCE_TODO: Use this in startPlayingAndWaitForVideo (and make sure it works).\n */\nfunction videoCallbackHelper(\n  callback: () => unknown | Promise<unknown>,\n  timeoutMessage: string\n): { promise: Promise<void>; callbackAndResolve: () => void } {\n  let callbackAndResolve: () => void;\n\n  const promiseWithoutTimeout = new Promise<void>((resolve, reject) => {\n    callbackAndResolve = () =>\n      void (async () => {\n        try {\n          await callback(); // catches both exceptions and rejections\n          resolve();\n        } catch (ex) {\n          reject(ex);\n        }\n      })();\n  });\n  const promise = raceWithRejectOnTimeout(promiseWithoutTimeout, 2000, timeoutMessage);\n  return { promise, callbackAndResolve: callbackAndResolve! };\n}\n"],"file":"util.js"}