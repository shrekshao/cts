{"version":3,"file":"util.js","names":["SkipTestCase","ErrorWithExtra","raceWithRejectOnTimeout","startPlayingAndWaitForVideo","video","callback","Promise","resolve","reject","callbackAndResolve","ex","error","message","addEventListener","event","requestVideoFrameCallback","timeWatcher","currentTime","requestAnimationFrame","loop","muted","preload","play","catch","waitForNextFrame","promise","videoCallbackHelper","getVideoFrameFromVideoElement","test","captureStream","undefined","skip","videoTrack","getVideoTracks","trackProcessor","MediaStreamTrackProcessor","track","transformer","TransformStream","transform","videoFrame","controller","stop","flush","terminate","trackGenerator","MediaStreamTrackGenerator","kind","readable","pipeThrough","pipeTo","writable","timeoutMessage","promiseWithoutTimeout"],"sources":["../../../src/webgpu/web_platform/util.ts"],"sourcesContent":["import { Fixture, SkipTestCase } from '../../common/framework/fixture.js';\nimport { ErrorWithExtra, raceWithRejectOnTimeout } from '../../common/util/util.js';\n\ndeclare global {\n  interface HTMLMediaElement {\n    // Add captureStream() support for HTMLMediaElement from\n    // https://w3c.github.io/mediacapture-fromelement/#dom-htmlmediaelement-capturestream\n    captureStream(): MediaStream;\n  }\n}\n\n/**\n * Starts playing a video and waits for it to be consumable.\n * Returns a promise which resolves after `callback` (which may be async) completes.\n *\n * @param video An HTML5 Video element.\n * @param callback Function to call when video is ready.\n *\n * Adapted from https://github.com/KhronosGroup/WebGL/blob/main/sdk/tests/js/webgl-test-utils.js\n */\nexport function startPlayingAndWaitForVideo(\n  video: HTMLVideoElement,\n  callback: () => unknown | Promise<unknown>\n): Promise<void> {\n  return raceWithRejectOnTimeout(\n    new Promise((resolve, reject) => {\n      const callbackAndResolve = () =>\n        void (async () => {\n          try {\n            await callback();\n            resolve();\n          } catch (ex) {\n            reject();\n          }\n        })();\n      if (video.error) {\n        reject(\n          new ErrorWithExtra('Video.error: ' + video.error.message, () => ({ error: video.error }))\n        );\n        return;\n      }\n\n      video.addEventListener(\n        'error',\n        event => reject(new ErrorWithExtra('Video received \"error\" event', () => ({ event }))),\n        true\n      );\n\n      if ('requestVideoFrameCallback' in video) {\n        video.requestVideoFrameCallback(() => {\n          callbackAndResolve();\n        });\n      } else {\n        // If requestVideoFrameCallback isn't available, check each frame if the video has advanced.\n        const timeWatcher = () => {\n          if (video.currentTime > 0) {\n            callbackAndResolve();\n          } else {\n            requestAnimationFrame(timeWatcher);\n          }\n        };\n        timeWatcher();\n      }\n\n      video.loop = true;\n      video.muted = true;\n      video.preload = 'auto';\n      video.play().catch(reject);\n    }),\n    2000,\n    'Video never became ready'\n  );\n}\n\n/**\n * Fire a `callback` when the video reaches a new frame.\n * Returns a promise which resolves after `callback` (which may be async) completes.\n *\n * MAINTENANCE_TODO: Find a way to implement this for browsers without requestVideoFrameCallback as\n * well, similar to the timeWatcher path in startPlayingAndWaitForVideo. If that path is proven to\n * work well, we can consider getting rid of the requestVideoFrameCallback path.\n */\nexport function waitForNextFrame(\n  video: HTMLVideoElement,\n  callback: () => unknown | Promise<unknown>\n): Promise<void> {\n  const { promise, callbackAndResolve } = videoCallbackHelper(\n    callback,\n    'waitForNextFrame timed out'\n  );\n\n  if ('requestVideoFrameCallback' in video) {\n    video.requestVideoFrameCallback(() => {\n      callbackAndResolve();\n    });\n  } else {\n    throw new SkipTestCase('waitForNextFrame currently requires requestVideoFrameCallback');\n  }\n\n  return promise;\n}\n\nexport async function getVideoFrameFromVideoElement(\n  test: Fixture,\n  video: HTMLVideoElement\n): Promise<VideoFrame> {\n  if (video.captureStream === undefined) {\n    test.skip('HTMLVideoElement.captureStream is not supported');\n  }\n\n  return raceWithRejectOnTimeout(\n    new Promise<VideoFrame>((resolve, reject) => {\n      const videoTrack: MediaStreamVideoTrack = video.captureStream().getVideoTracks()[0];\n      const trackProcessor: MediaStreamTrackProcessor<VideoFrame> = new MediaStreamTrackProcessor({\n        track: videoTrack,\n      });\n      const transformer: TransformStream = new TransformStream({\n        transform(videoFrame, controller) {\n          videoTrack.stop();\n          resolve(videoFrame);\n        },\n        flush(controller) {\n          controller.terminate();\n        },\n      });\n      const trackGenerator: MediaStreamTrackGenerator<VideoFrame> = new MediaStreamTrackGenerator({\n        kind: 'video',\n      });\n      trackProcessor.readable\n        .pipeThrough(transformer)\n        .pipeTo(trackGenerator.writable)\n        .catch(() => {});\n    }),\n    2000,\n    'Video never became ready'\n  );\n}\n\n/**\n * Helper for doing something inside of a (possibly async) callback (directly, not in a following\n * microtask), and returning a promise when the callback is done.\n * MAINTENANCE_TODO: Use this in startPlayingAndWaitForVideo (and make sure it works).\n */\nfunction videoCallbackHelper(\n  callback: () => unknown | Promise<unknown>,\n  timeoutMessage: string\n): { promise: Promise<void>; callbackAndResolve: () => void } {\n  let callbackAndResolve: () => void;\n\n  const promiseWithoutTimeout = new Promise<void>((resolve, reject) => {\n    callbackAndResolve = () =>\n      void (async () => {\n        try {\n          await callback(); // catches both exceptions and rejections\n          resolve();\n        } catch (ex) {\n          reject(ex);\n        }\n      })();\n  });\n  const promise = raceWithRejectOnTimeout(promiseWithoutTimeout, 2000, timeoutMessage);\n  return { promise, callbackAndResolve: callbackAndResolve! };\n}\n"],"mappings":"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"}