{"version":3,"sources":["../../../src/stress/shaders/non_halting.spec.ts"],"names":["description","makeTestGroup","GPUTest","g","test","desc","fn","t","data","Uint32Array","buffer","makeBufferWithContents","GPUBufferUsage","STORAGE","COPY_SRC","module","device","createShaderModule","code","pipeline","createComputePipeline","layout","compute","entryPoint","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","setBindGroup","dispatch","end","queue","submit","finish","lost","createRenderPipeline","vertex","buffers","primitive","topology","fragment","targets","format","uniforms","UNIFORM","renderTarget","createTexture","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","beginRenderPass","colorAttachments","view","createView","clearValue","loadOp","storeOp","draw"],"mappings":"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","sourcesContent":["export const description = `\nStress tests covering robustness in the presence of non-halting shaders.\n`;\n\nimport { makeTestGroup } from '../../common/framework/test_group.js';\nimport { GPUTest } from '../../webgpu/gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('compute')\n  .desc(\n    `Tests execution of compute passes with non-halting dispatch operations.\n\nThis is expected to hang for a bit, but it should ultimately result in graceful\ndevice loss.`\n  )\n  .fn(async t => {\n    const data = new Uint32Array([0]);\n    const buffer = t.makeBufferWithContents(data, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);\n    const module = t.device.createShaderModule({\n      code: `\n        struct Buffer { data: u32; };\n        @group(0) @binding(0) var<storage, read_write> buffer: Buffer;\n        @stage(compute) @workgroup_size(1) fn main() {\n          loop {\n            if (buffer.data == 1u) {\n              break;\n            }\n            buffer.data = buffer.data + 2u;\n          }\n        }\n      `,\n    });\n    const pipeline = t.device.createComputePipeline({\n      layout: 'auto',\n      compute: { module, entryPoint: 'main' },\n    });\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    const bindGroup = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer } }],\n    });\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatch(1);\n    pass.end();\n    t.device.queue.submit([encoder.finish()]);\n    await t.device.lost;\n  });\n\ng.test('vertex')\n  .desc(\n    `Tests execution of render passes with a non-halting vertex stage.\n\nThis is expected to hang for a bit, but it should ultimately result in graceful\ndevice loss.`\n  )\n  .fn(async t => {\n    const module = t.device.createShaderModule({\n      code: `\n        struct Data { counter: u32; increment: u32; };\n        @group(0) @binding(0) var<uniform> data: Data;\n        @stage(vertex) fn vmain() -> @builtin(position) vec4<f32> {\n          var counter: u32 = data.counter;\n          loop {\n            if (counter % 2u == 1u) {\n              break;\n            }\n            counter = counter + data.increment;\n          }\n          return vec4<f32>(1.0, 1.0, 0.0, f32(counter));\n        }\n        @stage(fragment) fn fmain() -> @location(0) vec4<f32> {\n          return vec4<f32>(1.0);\n        }\n      `,\n    });\n\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module, entryPoint: 'vmain', buffers: [] },\n      primitive: { topology: 'point-list' },\n      fragment: {\n        targets: [{ format: 'rgba8unorm' }],\n        module,\n        entryPoint: 'fmain',\n      },\n    });\n    const uniforms = t.makeBufferWithContents(new Uint32Array([0, 2]), GPUBufferUsage.UNIFORM);\n    const bindGroup = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: uniforms },\n        },\n      ],\n    });\n    const renderTarget = t.device.createTexture({\n      size: [1, 1],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n    });\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          clearValue: [0, 0, 0, 0],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.draw(1);\n    pass.end();\n    t.device.queue.submit([encoder.finish()]);\n    await t.device.lost;\n  });\n\ng.test('fragment')\n  .desc(\n    `Tests execution of render passes with a non-halting fragment stage.\n\nThis is expected to hang for a bit, but it should ultimately result in graceful\ndevice loss.`\n  )\n  .fn(async t => {\n    const module = t.device.createShaderModule({\n      code: `\n        struct Data { counter: u32; increment: u32; };\n        @group(0) @binding(0) var<uniform> data: Data;\n        @stage(vertex) fn vmain() -> @builtin(position) vec4<f32> {\n          return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n        }\n        @stage(fragment) fn fmain() -> @location(0) vec4<f32> {\n          var counter: u32 = data.counter;\n          loop {\n            if (counter % 2u == 1u) {\n              break;\n            }\n            counter = counter + data.increment;\n          }\n          return vec4<f32>(1.0 / f32(counter), 0.0, 0.0, 1.0);\n        }\n      `,\n    });\n\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module, entryPoint: 'vmain', buffers: [] },\n      primitive: { topology: 'point-list' },\n      fragment: {\n        targets: [{ format: 'rgba8unorm' }],\n        module,\n        entryPoint: 'fmain',\n      },\n    });\n    const uniforms = t.makeBufferWithContents(new Uint32Array([0, 2]), GPUBufferUsage.UNIFORM);\n    const bindGroup = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: uniforms },\n        },\n      ],\n    });\n    const renderTarget = t.device.createTexture({\n      size: [1, 1],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n    });\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          clearValue: [0, 0, 0, 0],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.draw(1);\n    pass.end();\n    t.device.queue.submit([encoder.finish()]);\n    await t.device.lost;\n  });\n"],"file":"non_halting.spec.js"}