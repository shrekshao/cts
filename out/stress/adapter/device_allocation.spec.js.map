{"version":3,"sources":["../../../src/stress/adapter/device_allocation.spec.ts"],"names":["description","Fixture","makeTestGroup","attemptGarbageCollection","keysOf","getGPU","assert","iterRange","DefaultLimits","kAdapterTypeOptions","powerPreference","forceFallbackAdapter","undefined","kAdapterTypes","DeviceAllocationTests","createDeviceAndComputeCommands","adapter","kNumPipelines","kNumBindgroups","kNumBufferElements","maxComputeWorkgroupSizeX","maxComputeWorkgroupSizeY","kBufferSize","kBufferData","Uint32Array","x","device","requestDevice","commands","pipelineIndex","pipeline","createComputePipeline","compute","module","createShaderModule","code","entryPoint","bindgroupIndex","buffer","createBuffer","size","usage","GPUBufferUsage","STORAGE","COPY_DST","COPY_SRC","queue","writeBuffer","length","bindgroup","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatch","endPass","push","finish","objects","createDeviceAndRenderCommands","kSize","createRenderPipeline","createPipelineLayout","bindGroupLayouts","createBindGroupLayout","visibility","GPUShaderStage","VERTEX","type","vertex","buffers","primitive","topology","fragment","targets","format","UNIFORM","texture","createTexture","GPUTextureUsage","RENDER_ATTACHMENT","beginRenderPass","colorAttachments","view","createView","loadValue","storeOp","draw","createDeviceAndBuffers","kTotalMemorySize","kMemoryBlockSize","kMemoryBlockData","Uint8Array","memory","g","test","desc","params","u","combine","fn","t","adapterType","requestAdapter","kNumDevices","devices","i","kFunctions","deviceList","objectLists","expect","destroy"],"mappings":"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","sourcesContent":["export const description = `\nStress tests for GPUAdapter.requestDevice.\n`;\n\nimport { Fixture } from '../../common/framework/fixture.js';\nimport { makeTestGroup } from '../../common/framework/test_group.js';\nimport { attemptGarbageCollection } from '../../common/util/collect_garbage.js';\nimport { keysOf } from '../../common/util/data_tables.js';\nimport { getGPU } from '../../common/util/navigator_gpu.js';\nimport { assert, iterRange } from '../../common/util/util.js';\nimport { DefaultLimits } from '../../webgpu/constants.js';\n\n/** Adapter preference identifier to option. */\nconst kAdapterTypeOptions: {\n  readonly [k in GPUPowerPreference | 'fallback']: GPURequestAdapterOptions;\n} = /* prettier-ignore */ {\n  'low-power':        { powerPreference:        'low-power', forceFallbackAdapter: false },\n  'high-performance': { powerPreference: 'high-performance', forceFallbackAdapter: false },\n  'fallback':         { powerPreference:          undefined, forceFallbackAdapter:  true },\n};\n/** List of all adapter hint types. */\nconst kAdapterTypes = keysOf(kAdapterTypeOptions);\n\nclass DeviceAllocationTests extends Fixture {\n  /**\n   * Creates a device, a valid compute pipeline, valid resources for the pipeline, and\n   * ties them together into a set of compute commands ready to be submitted to the GPU\n   * queue. Does not submit the commands in order to make sure that all resources are\n   * kept alive until the device is destroyed.\n   */\n  async createDeviceAndComputeCommands(adapter: GPUAdapter) {\n    // Constants are computed such that per run, this function should allocate roughly 2G\n    // worth of data. This should be sufficient as we run these creation functions many\n    // times. If the data backing the created objects is not recycled we should OOM.\n    const kNumPipelines = 64;\n    const kNumBindgroups = 128;\n    const kNumBufferElements =\n      DefaultLimits.maxComputeWorkgroupSizeX * DefaultLimits.maxComputeWorkgroupSizeY;\n    const kBufferSize = kNumBufferElements * 4;\n    const kBufferData = new Uint32Array([...iterRange(kNumBufferElements, x => x)]);\n\n    const device: GPUDevice = await adapter.requestDevice();\n    const commands = [];\n\n    for (let pipelineIndex = 0; pipelineIndex < kNumPipelines; ++pipelineIndex) {\n      const pipeline = device.createComputePipeline({\n        compute: {\n          module: device.createShaderModule({\n            code: `\n              struct Buffer { data: array<u32>; };\n\n              @group(0) @binding(0) var<storage, read_write> buffer: Buffer;\n              @stage(compute) @workgroup_size(1) fn main(\n                  @builtin(global_invocation_id) id: vec3<u32>) {\n                buffer.data[id.x * ${DefaultLimits.maxComputeWorkgroupSizeX}u + id.y] =\n                  buffer.data[id.x * ${DefaultLimits.maxComputeWorkgroupSizeX}u + id.y] +\n                    ${pipelineIndex}u;\n              }\n            `,\n          }),\n          entryPoint: 'main',\n        },\n      });\n      for (let bindgroupIndex = 0; bindgroupIndex < kNumBindgroups; ++bindgroupIndex) {\n        const buffer = device.createBuffer({\n          size: kBufferSize,\n          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n        });\n        device.queue.writeBuffer(buffer, 0, kBufferData, 0, kBufferData.length);\n        const bindgroup = device.createBindGroup({\n          layout: pipeline.getBindGroupLayout(0),\n          entries: [{ binding: 0, resource: { buffer } }],\n        });\n\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginComputePass();\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.dispatch(\n          DefaultLimits.maxComputeWorkgroupSizeX,\n          DefaultLimits.maxComputeWorkgroupSizeY\n        );\n        pass.endPass();\n        commands.push(encoder.finish());\n      }\n    }\n    return { device, objects: commands };\n  }\n\n  /**\n   * Creates a device, a valid render pipeline, valid resources for the pipeline, and\n   * ties them together into a set of render commands ready to be submitted to the GPU\n   * queue. Does not submit the commands in order to make sure that all resources are\n   * kept alive until the device is destroyed.\n   */\n  async createDeviceAndRenderCommands(adapter: GPUAdapter) {\n    // Constants are computed such that per run, this function should allocate roughly 2G\n    // worth of data. This should be sufficient as we run these creation functions many\n    // times. If the data backing the created objects is not recycled we should OOM.\n    const kNumPipelines = 128;\n    const kNumBindgroups = 128;\n    const kSize = 128;\n    const kBufferData = new Uint32Array([...iterRange(kSize * kSize, x => x)]);\n\n    const device: GPUDevice = await adapter.requestDevice();\n    const commands = [];\n\n    for (let pipelineIndex = 0; pipelineIndex < kNumPipelines; ++pipelineIndex) {\n      const module = device.createShaderModule({\n        code: `\n          struct Buffer { data: array<vec4<u32>, ${(kSize * kSize) / 4}>; };\n\n          @group(0) @binding(0) var<uniform> buffer: Buffer;\n          @stage(vertex) fn vmain(\n            @builtin(vertex_index) vertexIndex: u32\n          ) -> @builtin(position) vec4<f32> {\n            let index = buffer.data[vertexIndex / 4u][vertexIndex % 4u];\n            let position = vec2<f32>(f32(index % ${kSize}u), f32(index / ${kSize}u));\n            let r = vec2<f32>(1.0 / f32(${kSize}));\n            let a = 2.0 * r;\n            let b = r - vec2<f32>(1.0);\n            return vec4<f32>(fma(position, a, b), 0.0, 1.0);\n          }\n\n          @stage(fragment) fn fmain() -> @location(0) vec4<f32> {\n            return vec4<f32>(${pipelineIndex}.0 / ${kNumPipelines}.0, 0.0, 0.0, 1.0);\n          }\n        `,\n      });\n      const pipeline = device.createRenderPipeline({\n        layout: device.createPipelineLayout({\n          bindGroupLayouts: [\n            device.createBindGroupLayout({\n              entries: [\n                {\n                  binding: 0,\n                  visibility: GPUShaderStage.VERTEX,\n                  buffer: { type: 'uniform' },\n                },\n              ],\n            }),\n          ],\n        }),\n        vertex: { module, entryPoint: 'vmain', buffers: [] },\n        primitive: { topology: 'point-list' },\n        fragment: {\n          targets: [{ format: 'rgba8unorm' }],\n          module,\n          entryPoint: 'fmain',\n        },\n      });\n      for (let bindgroupIndex = 0; bindgroupIndex < kNumBindgroups; ++bindgroupIndex) {\n        const buffer = device.createBuffer({\n          size: kSize * kSize * 4,\n          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        });\n        device.queue.writeBuffer(buffer, 0, kBufferData, 0, kBufferData.length);\n        const bindgroup = device.createBindGroup({\n          layout: pipeline.getBindGroupLayout(0),\n          entries: [{ binding: 0, resource: { buffer } }],\n        });\n        const texture = device.createTexture({\n          size: [kSize, kSize],\n          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n          format: 'rgba8unorm',\n        });\n\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n          colorAttachments: [\n            {\n              view: texture.createView(),\n              loadValue: 'load',\n              storeOp: 'store',\n            },\n          ],\n        });\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(kSize * kSize);\n        pass.endPass();\n        commands.push(encoder.finish());\n      }\n    }\n    return { device, objects: commands };\n  }\n\n  /**\n   * Creates a device and a large number of buffers which are immediately written to. The\n   * buffers are expected to be kept alive until they or the device are destroyed.\n   */\n  async createDeviceAndBuffers(adapter: GPUAdapter) {\n    // Currently we just allocate 2G of memory using 512MB blocks. We may be able to\n    // increase this to hit OOM instead, but on integrated GPUs on Metal, this can cause\n    // kernel panics at the moment, and it can greatly increase the time needed.\n    const kTotalMemorySize = 2 * 1024 * 1024 * 1024;\n    const kMemoryBlockSize = 512 * 1024 * 1024;\n    const kMemoryBlockData = new Uint8Array(kMemoryBlockSize);\n\n    const device: GPUDevice = await adapter.requestDevice();\n    const buffers = [];\n    for (let memory = 0; memory < kTotalMemorySize; memory += kMemoryBlockSize) {\n      const buffer = device.createBuffer({\n        size: kMemoryBlockSize,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n      });\n\n      // Write out to the buffer to make sure that it has backing memory.\n      device.queue.writeBuffer(buffer, 0, kMemoryBlockData, 0, kMemoryBlockData.length);\n      buffers.push(buffer);\n    }\n    return { device, objects: buffers };\n  }\n}\n\nexport const g = makeTestGroup(DeviceAllocationTests);\n\ng.test('coexisting')\n  .desc(`Tests allocation of many coexisting GPUDevice objects.`)\n  .params(u => u.combine('adapterType', kAdapterTypes))\n  .fn(async t => {\n    const { adapterType } = t.params;\n    const adapter = await getGPU().requestAdapter(kAdapterTypeOptions[adapterType]);\n    assert(adapter !== null, 'Failed to get adapter.');\n\n    // Based on Vulkan comformance test requirement to be able to create multiple devices.\n    const kNumDevices = 5;\n\n    const devices = [];\n    for (let i = 0; i < kNumDevices; ++i) {\n      const device: GPUDevice = await adapter.requestDevice();\n      devices.push(device);\n    }\n  });\n\ng.test('continuous,with_destroy')\n  .desc(\n    `Tests allocation and destruction of many GPUDevice objects over time. Device objects\nare sequentially requested with a series of device allocated objects created on each\ndevice. The devices are then destroyed to verify that the device and the device allocated\nobjects are recycled over a very large number of iterations.`\n  )\n  .params(u => u.combine('adapterType', kAdapterTypes))\n  .fn(async t => {\n    const { adapterType } = t.params;\n    const adapter = await getGPU().requestAdapter(kAdapterTypeOptions[adapterType]);\n    assert(adapter !== null, 'Failed to get adapter.');\n\n    // Since devices are being destroyed, we should be able to create many devices.\n    const kNumDevices = 100;\n    const kFunctions = [\n      t.createDeviceAndBuffers,\n      t.createDeviceAndComputeCommands,\n      t.createDeviceAndRenderCommands,\n    ];\n\n    const deviceList = [];\n    const objectLists = [];\n    for (let i = 0; i < kNumDevices; ++i) {\n      const { device, objects } = await kFunctions[i % kFunctions.length](adapter);\n      t.expect(objects.length > 0, 'unable to allocate any objects');\n      deviceList.push(device);\n      objectLists.push(objects);\n      device.destroy();\n    }\n  });\n\ng.test('continuous,no_destroy')\n  .desc(\n    `Tests allocation and implicit GC of many GPUDevice objects over time. Objects are\nsequentially requested and dropped for GC over a very large number of iterations. Note\nthat without destroy, we do not create device allocated objects because that will\nimplicitly keep the device in scope.`\n  )\n  .params(u => u.combine('adapterType', kAdapterTypes))\n  .fn(async t => {\n    const { adapterType } = t.params;\n    const adapter = await getGPU().requestAdapter(kAdapterTypeOptions[adapterType]);\n    assert(adapter !== null, 'Failed to get adapter.');\n\n    const kNumDevices = 10_000;\n    for (let i = 1; i <= kNumDevices; ++i) {\n      await (async () => {\n        t.expect((await adapter.requestDevice()) !== null, 'unexpected null device');\n      })();\n      if (i % 10 === 0) {\n        // We need to occassionally wait for GC to clear out stale devices.\n        await attemptGarbageCollection();\n      }\n    }\n  });\n"],"file":"device_allocation.spec.js"}