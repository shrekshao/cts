{"version":3,"sources":["../../../src/stress/adapter/device_allocation.spec.ts"],"names":["description","Fixture","makeTestGroup","attemptGarbageCollection","keysOf","getGPU","assert","iterRange","kLimitInfo","g","kAdapterTypeOptions","powerPreference","forceFallbackAdapter","undefined","kAdapterTypes","createDeviceAndComputeCommands","adapter","kNumPipelines","kNumBindgroups","kNumBufferElements","maxComputeWorkgroupSizeX","default","maxComputeWorkgroupSizeY","kBufferSize","kBufferData","Uint32Array","x","device","requestDevice","commands","pipelineIndex","pipeline","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","bindgroupIndex","buffer","createBuffer","size","usage","GPUBufferUsage","STORAGE","COPY_DST","COPY_SRC","queue","writeBuffer","length","bindgroup","createBindGroup","getBindGroupLayout","entries","binding","resource","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatch","end","push","finish","objects","createDeviceAndRenderCommands","kSize","createRenderPipeline","createPipelineLayout","bindGroupLayouts","createBindGroupLayout","visibility","GPUShaderStage","VERTEX","type","vertex","buffers","primitive","topology","fragment","targets","format","UNIFORM","texture","createTexture","GPUTextureUsage","RENDER_ATTACHMENT","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","draw","createDeviceAndBuffers","kTotalMemorySize","kMemoryBlockSize","kMemoryBlockData","Uint8Array","memory","test","desc","params","u","combine","fn","t","adapterType","requestAdapter","kNumDevices","devices","i","kFunctions","deviceList","objectLists","expect","destroy"],"mappings":"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","sourcesContent":["export const description = `\nStress tests for GPUAdapter.requestDevice.\n`;\n\nimport { Fixture } from '../../common/framework/fixture.js';\nimport { makeTestGroup } from '../../common/framework/test_group.js';\nimport { attemptGarbageCollection } from '../../common/util/collect_garbage.js';\nimport { keysOf } from '../../common/util/data_tables.js';\nimport { getGPU } from '../../common/util/navigator_gpu.js';\nimport { assert, iterRange } from '../../common/util/util.js';\nimport { kLimitInfo } from '../../webgpu/capability_info.js';\n\nexport const g = makeTestGroup(Fixture);\n\n/** Adapter preference identifier to option. */\nconst kAdapterTypeOptions: {\n  readonly [k in GPUPowerPreference | 'fallback']: GPURequestAdapterOptions;\n} = /* prettier-ignore */ {\n  'low-power':        { powerPreference:        'low-power', forceFallbackAdapter: false },\n  'high-performance': { powerPreference: 'high-performance', forceFallbackAdapter: false },\n  'fallback':         { powerPreference:          undefined, forceFallbackAdapter:  true },\n};\n/** List of all adapter hint types. */\nconst kAdapterTypes = keysOf(kAdapterTypeOptions);\n\n/**\n * Creates a device, a valid compute pipeline, valid resources for the pipeline, and\n * ties them together into a set of compute commands ready to be submitted to the GPU\n * queue. Does not submit the commands in order to make sure that all resources are\n * kept alive until the device is destroyed.\n */\nasync function createDeviceAndComputeCommands(adapter: GPUAdapter) {\n  // Constants are computed such that per run, this function should allocate roughly 2G\n  // worth of data. This should be sufficient as we run these creation functions many\n  // times. If the data backing the created objects is not recycled we should OOM.\n  const kNumPipelines = 64;\n  const kNumBindgroups = 128;\n  const kNumBufferElements =\n    kLimitInfo.maxComputeWorkgroupSizeX.default * kLimitInfo.maxComputeWorkgroupSizeY.default;\n  const kBufferSize = kNumBufferElements * 4;\n  const kBufferData = new Uint32Array([...iterRange(kNumBufferElements, x => x)]);\n\n  const device: GPUDevice = await adapter.requestDevice();\n  const commands = [];\n\n  for (let pipelineIndex = 0; pipelineIndex < kNumPipelines; ++pipelineIndex) {\n    const pipeline = device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: device.createShaderModule({\n          code: `\n              struct Buffer { data: array<u32>; };\n\n              @group(0) @binding(0) var<storage, read_write> buffer: Buffer;\n              @stage(compute) @workgroup_size(1) fn main(\n                  @builtin(global_invocation_id) id: vec3<u32>) {\n                buffer.data[id.x * ${kLimitInfo.maxComputeWorkgroupSizeX.default}u + id.y] =\n                  buffer.data[id.x * ${kLimitInfo.maxComputeWorkgroupSizeX.default}u + id.y] +\n                    ${pipelineIndex}u;\n              }\n            `,\n        }),\n        entryPoint: 'main',\n      },\n    });\n    for (let bindgroupIndex = 0; bindgroupIndex < kNumBindgroups; ++bindgroupIndex) {\n      const buffer = device.createBuffer({\n        size: kBufferSize,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n      });\n      device.queue.writeBuffer(buffer, 0, kBufferData, 0, kBufferData.length);\n      const bindgroup = device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [{ binding: 0, resource: { buffer } }],\n      });\n\n      const encoder = device.createCommandEncoder();\n      const pass = encoder.beginComputePass();\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindgroup);\n      pass.dispatch(\n        kLimitInfo.maxComputeWorkgroupSizeX.default,\n        kLimitInfo.maxComputeWorkgroupSizeY.default\n      );\n      pass.end();\n      commands.push(encoder.finish());\n    }\n  }\n  return { device, objects: commands };\n}\n\n/**\n * Creates a device, a valid render pipeline, valid resources for the pipeline, and\n * ties them together into a set of render commands ready to be submitted to the GPU\n * queue. Does not submit the commands in order to make sure that all resources are\n * kept alive until the device is destroyed.\n */\nasync function createDeviceAndRenderCommands(adapter: GPUAdapter) {\n  // Constants are computed such that per run, this function should allocate roughly 2G\n  // worth of data. This should be sufficient as we run these creation functions many\n  // times. If the data backing the created objects is not recycled we should OOM.\n  const kNumPipelines = 128;\n  const kNumBindgroups = 128;\n  const kSize = 128;\n  const kBufferData = new Uint32Array([...iterRange(kSize * kSize, x => x)]);\n\n  const device: GPUDevice = await adapter.requestDevice();\n  const commands = [];\n\n  for (let pipelineIndex = 0; pipelineIndex < kNumPipelines; ++pipelineIndex) {\n    const module = device.createShaderModule({\n      code: `\n          struct Buffer { data: array<vec4<u32>, ${(kSize * kSize) / 4}>; };\n\n          @group(0) @binding(0) var<uniform> buffer: Buffer;\n          @stage(vertex) fn vmain(\n            @builtin(vertex_index) vertexIndex: u32\n          ) -> @builtin(position) vec4<f32> {\n            let index = buffer.data[vertexIndex / 4u][vertexIndex % 4u];\n            let position = vec2<f32>(f32(index % ${kSize}u), f32(index / ${kSize}u));\n            let r = vec2<f32>(1.0 / f32(${kSize}));\n            let a = 2.0 * r;\n            let b = r - vec2<f32>(1.0);\n            return vec4<f32>(fma(position, a, b), 0.0, 1.0);\n          }\n\n          @stage(fragment) fn fmain() -> @location(0) vec4<f32> {\n            return vec4<f32>(${pipelineIndex}.0 / ${kNumPipelines}.0, 0.0, 0.0, 1.0);\n          }\n        `,\n    });\n    const pipeline = device.createRenderPipeline({\n      layout: device.createPipelineLayout({\n        bindGroupLayouts: [\n          device.createBindGroupLayout({\n            entries: [\n              {\n                binding: 0,\n                visibility: GPUShaderStage.VERTEX,\n                buffer: { type: 'uniform' },\n              },\n            ],\n          }),\n        ],\n      }),\n      vertex: { module, entryPoint: 'vmain', buffers: [] },\n      primitive: { topology: 'point-list' },\n      fragment: {\n        targets: [{ format: 'rgba8unorm' }],\n        module,\n        entryPoint: 'fmain',\n      },\n    });\n    for (let bindgroupIndex = 0; bindgroupIndex < kNumBindgroups; ++bindgroupIndex) {\n      const buffer = device.createBuffer({\n        size: kSize * kSize * 4,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n      });\n      device.queue.writeBuffer(buffer, 0, kBufferData, 0, kBufferData.length);\n      const bindgroup = device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [{ binding: 0, resource: { buffer } }],\n      });\n      const texture = device.createTexture({\n        size: [kSize, kSize],\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n        format: 'rgba8unorm',\n      });\n\n      const encoder = device.createCommandEncoder();\n      const pass = encoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: texture.createView(),\n            loadOp: 'load',\n            storeOp: 'store',\n          },\n        ],\n      });\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindgroup);\n      pass.draw(kSize * kSize);\n      pass.end();\n      commands.push(encoder.finish());\n    }\n  }\n  return { device, objects: commands };\n}\n\n/**\n * Creates a device and a large number of buffers which are immediately written to. The\n * buffers are expected to be kept alive until they or the device are destroyed.\n */\nasync function createDeviceAndBuffers(adapter: GPUAdapter) {\n  // Currently we just allocate 2G of memory using 512MB blocks. We may be able to\n  // increase this to hit OOM instead, but on integrated GPUs on Metal, this can cause\n  // kernel panics at the moment, and it can greatly increase the time needed.\n  const kTotalMemorySize = 2 * 1024 * 1024 * 1024;\n  const kMemoryBlockSize = 512 * 1024 * 1024;\n  const kMemoryBlockData = new Uint8Array(kMemoryBlockSize);\n\n  const device: GPUDevice = await adapter.requestDevice();\n  const buffers = [];\n  for (let memory = 0; memory < kTotalMemorySize; memory += kMemoryBlockSize) {\n    const buffer = device.createBuffer({\n      size: kMemoryBlockSize,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n\n    // Write out to the buffer to make sure that it has backing memory.\n    device.queue.writeBuffer(buffer, 0, kMemoryBlockData, 0, kMemoryBlockData.length);\n    buffers.push(buffer);\n  }\n  return { device, objects: buffers };\n}\n\ng.test('coexisting')\n  .desc(`Tests allocation of many coexisting GPUDevice objects.`)\n  .params(u => u.combine('adapterType', kAdapterTypes))\n  .fn(async t => {\n    const { adapterType } = t.params;\n    const adapter = await getGPU().requestAdapter(kAdapterTypeOptions[adapterType]);\n    assert(adapter !== null, 'Failed to get adapter.');\n\n    // Based on Vulkan conformance test requirement to be able to create multiple devices.\n    const kNumDevices = 5;\n\n    const devices = [];\n    for (let i = 0; i < kNumDevices; ++i) {\n      const device: GPUDevice = await adapter.requestDevice();\n      devices.push(device);\n    }\n  });\n\ng.test('continuous,with_destroy')\n  .desc(\n    `Tests allocation and destruction of many GPUDevice objects over time. Device objects\nare sequentially requested with a series of device allocated objects created on each\ndevice. The devices are then destroyed to verify that the device and the device allocated\nobjects are recycled over a very large number of iterations.`\n  )\n  .params(u => u.combine('adapterType', kAdapterTypes))\n  .fn(async t => {\n    const { adapterType } = t.params;\n    const adapter = await getGPU().requestAdapter(kAdapterTypeOptions[adapterType]);\n    assert(adapter !== null, 'Failed to get adapter.');\n\n    // Since devices are being destroyed, we should be able to create many devices.\n    const kNumDevices = 100;\n    const kFunctions = [\n      createDeviceAndBuffers,\n      createDeviceAndComputeCommands,\n      createDeviceAndRenderCommands,\n    ];\n\n    const deviceList = [];\n    const objectLists = [];\n    for (let i = 0; i < kNumDevices; ++i) {\n      const { device, objects } = await kFunctions[i % kFunctions.length](adapter);\n      t.expect(objects.length > 0, 'unable to allocate any objects');\n      deviceList.push(device);\n      objectLists.push(objects);\n      device.destroy();\n    }\n  });\n\ng.test('continuous,no_destroy')\n  .desc(\n    `Tests allocation and implicit GC of many GPUDevice objects over time. Objects are\nsequentially requested and dropped for GC over a very large number of iterations. Note\nthat without destroy, we do not create device allocated objects because that will\nimplicitly keep the device in scope.`\n  )\n  .params(u => u.combine('adapterType', kAdapterTypes))\n  .fn(async t => {\n    const { adapterType } = t.params;\n    const adapter = await getGPU().requestAdapter(kAdapterTypeOptions[adapterType]);\n    assert(adapter !== null, 'Failed to get adapter.');\n\n    const kNumDevices = 10_000;\n    for (let i = 1; i <= kNumDevices; ++i) {\n      await (async () => {\n        t.expect((await adapter.requestDevice()) !== null, 'unexpected null device');\n      })();\n      if (i % 10 === 0) {\n        // We need to occasionally wait for GC to clear out stale devices.\n        await attemptGarbageCollection();\n      }\n    }\n  });\n"],"file":"device_allocation.spec.js"}