{"version":3,"sources":["../../../src/stress/render/vertex_buffers.spec.ts"],"names":["description","makeTestGroup","GPUTest","g","createHugeVertexBuffer","t","size","kBufferSize","buffer","device","createBuffer","usage","GPUBufferUsage","STORAGE","COPY_SRC","pipeline","createComputePipeline","compute","module","createShaderModule","code","entryPoint","bindGroup","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatch","endPass","vertexBuffer","VERTEX","COPY_DST","copyBufferToBuffer","queue","submit","finish","test","desc","fn","kSize","createRenderPipeline","vertex","buffers","arrayStride","attributes","format","offset","shaderLocation","primitive","topology","fragment","targets","renderTarget","createTexture","GPUTextureUsage","RENDER_ATTACHMENT","renderPassDescriptor","colorAttachments","view","createView","loadValue","storeOp","beginRenderPass","setVertexBuffer","draw","expectSingleColor","exp","R","G","B","A"],"mappings":"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","sourcesContent":["export const description = `\nStress tests covering vertex buffer usage.\n`;\n\nimport { makeTestGroup } from '../../common/framework/test_group.js';\nimport { GPUTest } from '../../webgpu/gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\nfunction createHugeVertexBuffer(t: GPUTest, size: number) {\n  const kBufferSize = size * size * 8;\n  const buffer = t.device.createBuffer({\n    size: kBufferSize,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n  });\n  const pipeline = t.device.createComputePipeline({\n    compute: {\n      module: t.device.createShaderModule({\n        code: `\n        struct Buffer { data: array<vec2<u32>>; };\n        @group(0) @binding(0) var<storage, read_write> buffer: Buffer;\n        @stage(compute) @workgroup_size(1) fn main(\n            @builtin(global_invocation_id) id: vec3<u32>) {\n          let base = id.x * ${size}u;\n          for (var x: u32 = 0u; x < ${size}u; x = x + 1u) {\n            buffer.data[base + x] = vec2<u32>(x, id.x);\n          }\n        }\n        `,\n      }),\n      entryPoint: 'main',\n    },\n  });\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n      {\n        binding: 0,\n        resource: { buffer },\n      },\n    ],\n  });\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.dispatch(size);\n  pass.endPass();\n\n  const vertexBuffer = t.device.createBuffer({\n    size: kBufferSize,\n    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n  });\n  encoder.copyBufferToBuffer(buffer, 0, vertexBuffer, 0, kBufferSize);\n  t.device.queue.submit([encoder.finish()]);\n  return vertexBuffer;\n}\n\ng.test('many')\n  .desc(`Tests execution of draw calls using a huge vertex buffer.`)\n  .fn(async t => {\n    const kSize = 4096;\n    const buffer = createHugeVertexBuffer(t, kSize);\n    const module = t.device.createShaderModule({\n      code: `\n    @stage(vertex) fn vmain(@location(0) position: vec2<u32>)\n        -> @builtin(position) vec4<f32> {\n      let r = vec2<f32>(1.0 / f32(${kSize}));\n      let a = 2.0 * r;\n      let b = r - vec2<f32>(1.0);\n      return vec4<f32>(fma(vec2<f32>(position), a, b), 0.0, 1.0);\n    }\n    @stage(fragment) fn fmain() -> @location(0) vec4<f32> {\n      return vec4<f32>(1.0, 0.0, 1.0, 1.0);\n    }\n    `,\n    });\n    const pipeline = t.device.createRenderPipeline({\n      vertex: {\n        module,\n        entryPoint: 'vmain',\n        buffers: [\n          {\n            arrayStride: 8,\n            attributes: [\n              {\n                format: 'uint32x2',\n                offset: 0,\n                shaderLocation: 0,\n              },\n            ],\n          },\n        ],\n      },\n      primitive: { topology: 'point-list' },\n      fragment: {\n        targets: [{ format: 'rgba8unorm' }],\n        module,\n        entryPoint: 'fmain',\n      },\n    });\n    const renderTarget = t.device.createTexture({\n      size: [kSize, kSize],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n    });\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          loadValue: 'load',\n          storeOp: 'store',\n        },\n      ],\n    };\n\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass(renderPassDescriptor);\n    pass.setPipeline(pipeline);\n    pass.setVertexBuffer(0, buffer);\n    pass.draw(kSize * kSize);\n    pass.endPass();\n    t.device.queue.submit([encoder.finish()]);\n    t.expectSingleColor(renderTarget, 'rgba8unorm', {\n      size: [kSize, kSize, 1],\n      exp: { R: 1, G: 0, B: 1, A: 1 },\n    });\n  });\n"],"file":"vertex_buffers.spec.js"}