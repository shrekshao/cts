{"version":3,"sources":["../../../src/stress/render/render_pass.spec.ts"],"names":["description","makeTestGroup","range","GPUTest","g","test","desc","fn","t","kSize","module","device","createShaderModule","code","pipeline","createRenderPipeline","vertex","entryPoint","buffers","primitive","topology","fragment","targets","format","renderTarget","createTexture","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","COPY_SRC","renderPassDescriptor","colorAttachments","view","createView","loadValue","storeOp","encoder","createCommandEncoder","i","pass","beginRenderPass","setPipeline","draw","endPass","queue","submit","finish","expectSingleColor","exp","R","G","B","A","kWidth","kHeight","depthTarget","depthStencilAttachment","depthLoadValue","depthStoreOp","stencilLoadValue","stencilStoreOp","depthStencil","depthBias","layout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","VERTEX","buffer","type","createPipelineLayout","bindGroupLayouts","createBuffer","GPUBufferUsage","UNIFORM","mappedAtCreation","Uint32Array","getMappedRange","unmap","setBindGroup","createBindGroup","resource","kTextureSize","kVertsPerFragment"],"mappings":"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","sourcesContent":["export const description = `\nStress tests covering GPURenderPassEncoder usage.\n`;\n\nimport { makeTestGroup } from '../../common/framework/test_group.js';\nimport { range } from '../../common/util/util.js';\nimport { GPUTest } from '../../webgpu/gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('many')\n  .desc(\n    `Tests execution of a huge number of render passes using the same GPURenderPipeline. This uses\na single render pass for every output fragment, with each pass executing a one-vertex draw call.`\n  )\n  .fn(async t => {\n    const kSize = 1024;\n    const module = t.device.createShaderModule({\n      code: `\n    @stage(vertex) fn vmain(@builtin(vertex_index) index: u32)\n        -> @builtin(position) vec4<f32> {\n      let position = vec2<f32>(f32(index % ${kSize}u), f32(index / ${kSize}u));\n      let r = vec2<f32>(1.0 / f32(${kSize}));\n      let a = 2.0 * r;\n      let b = r - vec2<f32>(1.0);\n      return vec4<f32>(fma(position, a, b), 0.0, 1.0);\n    }\n    @stage(fragment) fn fmain() -> @location(0) vec4<f32> {\n      return vec4<f32>(1.0, 0.0, 1.0, 1.0);\n    }\n    `,\n    });\n    const pipeline = t.device.createRenderPipeline({\n      vertex: { module, entryPoint: 'vmain', buffers: [] },\n      primitive: { topology: 'point-list' },\n      fragment: {\n        targets: [{ format: 'rgba8unorm' }],\n        module,\n        entryPoint: 'fmain',\n      },\n    });\n    const renderTarget = t.device.createTexture({\n      size: [kSize, kSize],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n    });\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          loadValue: 'load',\n          storeOp: 'store',\n        },\n      ],\n    };\n    const encoder = t.device.createCommandEncoder();\n    range(kSize * kSize, i => {\n      const pass = encoder.beginRenderPass(renderPassDescriptor);\n      pass.setPipeline(pipeline);\n      pass.draw(1, 1, i);\n      pass.endPass();\n    });\n    t.device.queue.submit([encoder.finish()]);\n    t.expectSingleColor(renderTarget, 'rgba8unorm', {\n      size: [kSize, kSize, 1],\n      exp: { R: 1, G: 0, B: 1, A: 1 },\n    });\n  });\n\ng.test('pipeline_churn')\n  .desc(\n    `Tests execution of a large number of render pipelines, each within its own render pass. Each\npass does a single draw call, with one pass per output fragment.`\n  )\n  .fn(async t => {\n    const kWidth = 64;\n    const kHeight = 8;\n    const module = t.device.createShaderModule({\n      code: `\n    @stage(vertex) fn vmain(@builtin(vertex_index) index: u32)\n        -> @builtin(position) vec4<f32> {\n      let position = vec2<f32>(f32(index % ${kWidth}u), f32(index / ${kWidth}u));\n      let size = vec2<f32>(f32(${kWidth}), f32(${kHeight}));\n      let r = vec2<f32>(1.0) / size;\n      let a = 2.0 * r;\n      let b = r - vec2<f32>(1.0);\n      return vec4<f32>(fma(position, a, b), 0.0, 1.0);\n    }\n    @stage(fragment) fn fmain() -> @location(0) vec4<f32> {\n      return vec4<f32>(1.0, 0.0, 1.0, 1.0);\n    }\n    `,\n    });\n    const renderTarget = t.device.createTexture({\n      size: [kWidth, kHeight],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n    });\n    const depthTarget = t.device.createTexture({\n      size: [kWidth, kHeight],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n      format: 'depth24plus-stencil8',\n    });\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          loadValue: 'load',\n          storeOp: 'store',\n        },\n      ],\n      depthStencilAttachment: {\n        view: depthTarget.createView(),\n        depthLoadValue: 'load',\n        depthStoreOp: 'store',\n        stencilLoadValue: 'load',\n        stencilStoreOp: 'discard',\n      },\n    };\n    const encoder = t.device.createCommandEncoder();\n    range(kWidth * kHeight, i => {\n      const pipeline = t.device.createRenderPipeline({\n        vertex: { module, entryPoint: 'vmain', buffers: [] },\n        primitive: { topology: 'point-list' },\n        depthStencil: {\n          format: 'depth24plus-stencil8',\n\n          // Not really used, but it ensures that each pipeline is unique.\n          depthBias: i,\n        },\n        fragment: {\n          targets: [{ format: 'rgba8unorm' }],\n          module,\n          entryPoint: 'fmain',\n        },\n      });\n      const pass = encoder.beginRenderPass(renderPassDescriptor);\n      pass.setPipeline(pipeline);\n      pass.draw(1, 1, i);\n      pass.endPass();\n    });\n    t.device.queue.submit([encoder.finish()]);\n    t.expectSingleColor(renderTarget, 'rgba8unorm', {\n      size: [kWidth, kHeight, 1],\n      exp: { R: 1, G: 0, B: 1, A: 1 },\n    });\n  });\n\ng.test('bind_group_churn')\n  .desc(\n    `Tests execution of render passes which switch between a huge number of bind groups. This uses\na single render pass with a single pipeline, and one draw call per fragment of the output texture.\nEach draw call is made with a unique bind group 0, with binding 0 referencing a unique uniform\nbuffer.`\n  )\n  .fn(async t => {\n    const kSize = 128;\n    const module = t.device.createShaderModule({\n      code: `\n    struct Uniforms { index: u32; };\n    @group(0) @binding(0) var<uniform> uniforms: Uniforms;\n    @stage(vertex) fn vmain() -> @builtin(position) vec4<f32> {\n      let index = uniforms.index;\n      let position = vec2<f32>(f32(index % ${kSize}u), f32(index / ${kSize}u));\n      let r = vec2<f32>(1.0 / f32(${kSize}));\n      let a = 2.0 * r;\n      let b = r - vec2<f32>(1.0);\n      return vec4<f32>(fma(position, a, b), 0.0, 1.0);\n    }\n    @stage(fragment) fn fmain() -> @location(0) vec4<f32> {\n      return vec4<f32>(1.0, 0.0, 1.0, 1.0);\n    }\n    `,\n    });\n    const layout = t.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.VERTEX,\n          buffer: { type: 'uniform' },\n        },\n      ],\n    });\n    const pipeline = t.device.createRenderPipeline({\n      layout: t.device.createPipelineLayout({ bindGroupLayouts: [layout] }),\n      vertex: { module, entryPoint: 'vmain', buffers: [] },\n      primitive: { topology: 'point-list' },\n      fragment: {\n        targets: [{ format: 'rgba8unorm' }],\n        module,\n        entryPoint: 'fmain',\n      },\n    });\n    const renderTarget = t.device.createTexture({\n      size: [kSize, kSize],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n    });\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          loadValue: 'load',\n          storeOp: 'store',\n        },\n      ],\n    };\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass(renderPassDescriptor);\n    pass.setPipeline(pipeline);\n    range(kSize * kSize, i => {\n      const buffer = t.device.createBuffer({\n        size: 4,\n        usage: GPUBufferUsage.UNIFORM,\n        mappedAtCreation: true,\n      });\n      new Uint32Array(buffer.getMappedRange())[0] = i;\n      buffer.unmap();\n      pass.setBindGroup(\n        0,\n        t.device.createBindGroup({ layout, entries: [{ binding: 0, resource: { buffer } }] })\n      );\n      pass.draw(1, 1);\n    });\n    pass.endPass();\n    t.device.queue.submit([encoder.finish()]);\n    t.expectSingleColor(renderTarget, 'rgba8unorm', {\n      size: [kSize, kSize, 1],\n      exp: { R: 1, G: 0, B: 1, A: 1 },\n    });\n  });\n\ng.test('many_draws')\n  .desc(\n    `Tests execution of render passes with a huge number of draw calls. This uses a single\nrender pass with a single pipeline, and one draw call per fragment of the output texture.`\n  )\n  .fn(async t => {\n    const kSize = 4096;\n    const module = t.device.createShaderModule({\n      code: `\n    @stage(vertex) fn vmain(@builtin(vertex_index) index: u32)\n        -> @builtin(position) vec4<f32> {\n      let position = vec2<f32>(f32(index % ${kSize}u), f32(index / ${kSize}u));\n      let r = vec2<f32>(1.0 / f32(${kSize}));\n      let a = 2.0 * r;\n      let b = r - vec2<f32>(1.0);\n      return vec4<f32>(fma(position, a, b), 0.0, 1.0);\n    }\n    @stage(fragment) fn fmain() -> @location(0) vec4<f32> {\n      return vec4<f32>(1.0, 0.0, 1.0, 1.0);\n    }\n    `,\n    });\n    const pipeline = t.device.createRenderPipeline({\n      vertex: { module, entryPoint: 'vmain', buffers: [] },\n      primitive: { topology: 'point-list' },\n      fragment: {\n        targets: [{ format: 'rgba8unorm' }],\n        module,\n        entryPoint: 'fmain',\n      },\n    });\n    const renderTarget = t.device.createTexture({\n      size: [kSize, kSize],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n    });\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          loadValue: 'load',\n          storeOp: 'store',\n        },\n      ],\n    };\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass(renderPassDescriptor);\n    pass.setPipeline(pipeline);\n    range(kSize * kSize, i => pass.draw(1, 1, i));\n    pass.endPass();\n    t.device.queue.submit([encoder.finish()]);\n    t.expectSingleColor(renderTarget, 'rgba8unorm', {\n      size: [kSize, kSize, 1],\n      exp: { R: 1, G: 0, B: 1, A: 1 },\n    });\n  });\n\ng.test('huge_draws')\n  .desc(\n    `Tests execution of several render passes with huge draw calls. Each pass uses a single draw\ncall which draws multiple vertices for each fragment of a large output texture.`\n  )\n  .fn(async t => {\n    const kSize = 32768;\n    const kTextureSize = 4096;\n    const kVertsPerFragment = (kSize * kSize) / (kTextureSize * kTextureSize);\n    const module = t.device.createShaderModule({\n      code: `\n    @stage(vertex) fn vmain(@builtin(vertex_index) vert_index: u32)\n        -> @builtin(position) vec4<f32> {\n      let index = vert_index / ${kVertsPerFragment}u;\n      let position = vec2<f32>(f32(index % ${kTextureSize}u), f32(index / ${kTextureSize}u));\n      let r = vec2<f32>(1.0 / f32(${kTextureSize}));\n      let a = 2.0 * r;\n      let b = r - vec2<f32>(1.0);\n      return vec4<f32>(fma(position, a, b), 0.0, 1.0);\n    }\n    @stage(fragment) fn fmain() -> @location(0) vec4<f32> {\n      return vec4<f32>(1.0, 0.0, 1.0, 1.0);\n    }\n    `,\n    });\n    const pipeline = t.device.createRenderPipeline({\n      vertex: { module, entryPoint: 'vmain', buffers: [] },\n      primitive: { topology: 'point-list' },\n      fragment: {\n        targets: [{ format: 'rgba8unorm' }],\n        module,\n        entryPoint: 'fmain',\n      },\n    });\n    const renderTarget = t.device.createTexture({\n      size: [kTextureSize, kTextureSize],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n    });\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          loadValue: 'load',\n          storeOp: 'store',\n        },\n      ],\n    };\n\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass(renderPassDescriptor);\n    pass.setPipeline(pipeline);\n    pass.draw(kSize * kSize);\n    pass.endPass();\n    t.device.queue.submit([encoder.finish()]);\n    t.expectSingleColor(renderTarget, 'rgba8unorm', {\n      size: [kTextureSize, kTextureSize, 1],\n      exp: { R: 1, G: 0, B: 1, A: 1 },\n    });\n  });\n"],"file":"render_pass.spec.js"}