{"version":3,"sources":["../../../src/stress/render/render_pass.spec.ts"],"names":["description","makeTestGroup","range","GPUTest","g","test","desc","fn","t","kSize","module","device","createShaderModule","code","pipeline","createRenderPipeline","layout","vertex","entryPoint","buffers","primitive","topology","fragment","targets","format","renderTarget","createTexture","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","COPY_SRC","renderPassDescriptor","colorAttachments","view","createView","loadOp","storeOp","encoder","createCommandEncoder","i","pass","beginRenderPass","setPipeline","draw","end","queue","submit","finish","expectSingleColor","exp","R","G","B","A","kWidth","kHeight","depthTarget","depthStencilAttachment","depthLoadOp","depthStoreOp","stencilLoadOp","stencilStoreOp","depthStencil","depthBias","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","VERTEX","buffer","type","createPipelineLayout","bindGroupLayouts","createBuffer","GPUBufferUsage","UNIFORM","mappedAtCreation","Uint32Array","getMappedRange","unmap","setBindGroup","createBindGroup","resource","kTextureSize","kVertsPerFragment"],"mappings":"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","sourcesContent":["export const description = `\nStress tests covering GPURenderPassEncoder usage.\n`;\n\nimport { makeTestGroup } from '../../common/framework/test_group.js';\nimport { range } from '../../common/util/util.js';\nimport { GPUTest } from '../../webgpu/gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('many')\n  .desc(\n    `Tests execution of a huge number of render passes using the same GPURenderPipeline. This uses\na single render pass for every output fragment, with each pass executing a one-vertex draw call.`\n  )\n  .fn(async t => {\n    const kSize = 1024;\n    const module = t.device.createShaderModule({\n      code: `\n    @vertex fn vmain(@builtin(vertex_index) index: u32)\n        -> @builtin(position) vec4<f32> {\n      let position = vec2<f32>(f32(index % ${kSize}u), f32(index / ${kSize}u));\n      let r = vec2<f32>(1.0 / f32(${kSize}));\n      let a = 2.0 * r;\n      let b = r - vec2<f32>(1.0);\n      return vec4<f32>(fma(position, a, b), 0.0, 1.0);\n    }\n    @fragment fn fmain() -> @location(0) vec4<f32> {\n      return vec4<f32>(1.0, 0.0, 1.0, 1.0);\n    }\n    `,\n    });\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module, entryPoint: 'vmain', buffers: [] },\n      primitive: { topology: 'point-list' },\n      fragment: {\n        targets: [{ format: 'rgba8unorm' }],\n        module,\n        entryPoint: 'fmain',\n      },\n    });\n    const renderTarget = t.device.createTexture({\n      size: [kSize, kSize],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n    });\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          loadOp: 'load',\n          storeOp: 'store',\n        },\n      ],\n    };\n    const encoder = t.device.createCommandEncoder();\n    range(kSize * kSize, i => {\n      const pass = encoder.beginRenderPass(renderPassDescriptor);\n      pass.setPipeline(pipeline);\n      pass.draw(1, 1, i);\n      pass.end();\n    });\n    t.device.queue.submit([encoder.finish()]);\n    t.expectSingleColor(renderTarget, 'rgba8unorm', {\n      size: [kSize, kSize, 1],\n      exp: { R: 1, G: 0, B: 1, A: 1 },\n    });\n  });\n\ng.test('pipeline_churn')\n  .desc(\n    `Tests execution of a large number of render pipelines, each within its own render pass. Each\npass does a single draw call, with one pass per output fragment.`\n  )\n  .fn(async t => {\n    const kWidth = 64;\n    const kHeight = 8;\n    const module = t.device.createShaderModule({\n      code: `\n    @vertex fn vmain(@builtin(vertex_index) index: u32)\n        -> @builtin(position) vec4<f32> {\n      let position = vec2<f32>(f32(index % ${kWidth}u), f32(index / ${kWidth}u));\n      let size = vec2<f32>(f32(${kWidth}), f32(${kHeight}));\n      let r = vec2<f32>(1.0) / size;\n      let a = 2.0 * r;\n      let b = r - vec2<f32>(1.0);\n      return vec4<f32>(fma(position, a, b), 0.0, 1.0);\n    }\n    @fragment fn fmain() -> @location(0) vec4<f32> {\n      return vec4<f32>(1.0, 0.0, 1.0, 1.0);\n    }\n    `,\n    });\n    const renderTarget = t.device.createTexture({\n      size: [kWidth, kHeight],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n    });\n    const depthTarget = t.device.createTexture({\n      size: [kWidth, kHeight],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n      format: 'depth24plus-stencil8',\n    });\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          loadOp: 'load',\n          storeOp: 'store',\n        },\n      ],\n      depthStencilAttachment: {\n        view: depthTarget.createView(),\n        depthLoadOp: 'load',\n        depthStoreOp: 'store',\n        stencilLoadOp: 'load',\n        stencilStoreOp: 'discard',\n      },\n    };\n    const encoder = t.device.createCommandEncoder();\n    range(kWidth * kHeight, i => {\n      const pipeline = t.device.createRenderPipeline({\n        layout: 'auto',\n        vertex: { module, entryPoint: 'vmain', buffers: [] },\n        primitive: { topology: 'point-list' },\n        depthStencil: {\n          format: 'depth24plus-stencil8',\n\n          // Not really used, but it ensures that each pipeline is unique.\n          depthBias: i,\n        },\n        fragment: {\n          targets: [{ format: 'rgba8unorm' }],\n          module,\n          entryPoint: 'fmain',\n        },\n      });\n      const pass = encoder.beginRenderPass(renderPassDescriptor);\n      pass.setPipeline(pipeline);\n      pass.draw(1, 1, i);\n      pass.end();\n    });\n    t.device.queue.submit([encoder.finish()]);\n    t.expectSingleColor(renderTarget, 'rgba8unorm', {\n      size: [kWidth, kHeight, 1],\n      exp: { R: 1, G: 0, B: 1, A: 1 },\n    });\n  });\n\ng.test('bind_group_churn')\n  .desc(\n    `Tests execution of render passes which switch between a huge number of bind groups. This uses\na single render pass with a single pipeline, and one draw call per fragment of the output texture.\nEach draw call is made with a unique bind group 0, with binding 0 referencing a unique uniform\nbuffer.`\n  )\n  .fn(async t => {\n    const kSize = 128;\n    const module = t.device.createShaderModule({\n      code: `\n    struct Uniforms { index: u32, };\n    @group(0) @binding(0) var<uniform> uniforms: Uniforms;\n    @vertex fn vmain() -> @builtin(position) vec4<f32> {\n      let index = uniforms.index;\n      let position = vec2<f32>(f32(index % ${kSize}u), f32(index / ${kSize}u));\n      let r = vec2<f32>(1.0 / f32(${kSize}));\n      let a = 2.0 * r;\n      let b = r - vec2<f32>(1.0);\n      return vec4<f32>(fma(position, a, b), 0.0, 1.0);\n    }\n    @fragment fn fmain() -> @location(0) vec4<f32> {\n      return vec4<f32>(1.0, 0.0, 1.0, 1.0);\n    }\n    `,\n    });\n    const layout = t.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.VERTEX,\n          buffer: { type: 'uniform' },\n        },\n      ],\n    });\n    const pipeline = t.device.createRenderPipeline({\n      layout: t.device.createPipelineLayout({ bindGroupLayouts: [layout] }),\n      vertex: { module, entryPoint: 'vmain', buffers: [] },\n      primitive: { topology: 'point-list' },\n      fragment: {\n        targets: [{ format: 'rgba8unorm' }],\n        module,\n        entryPoint: 'fmain',\n      },\n    });\n    const renderTarget = t.device.createTexture({\n      size: [kSize, kSize],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n    });\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          loadOp: 'load',\n          storeOp: 'store',\n        },\n      ],\n    };\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass(renderPassDescriptor);\n    pass.setPipeline(pipeline);\n    range(kSize * kSize, i => {\n      const buffer = t.device.createBuffer({\n        size: 4,\n        usage: GPUBufferUsage.UNIFORM,\n        mappedAtCreation: true,\n      });\n      new Uint32Array(buffer.getMappedRange())[0] = i;\n      buffer.unmap();\n      pass.setBindGroup(\n        0,\n        t.device.createBindGroup({ layout, entries: [{ binding: 0, resource: { buffer } }] })\n      );\n      pass.draw(1, 1);\n    });\n    pass.end();\n    t.device.queue.submit([encoder.finish()]);\n    t.expectSingleColor(renderTarget, 'rgba8unorm', {\n      size: [kSize, kSize, 1],\n      exp: { R: 1, G: 0, B: 1, A: 1 },\n    });\n  });\n\ng.test('many_draws')\n  .desc(\n    `Tests execution of render passes with a huge number of draw calls. This uses a single\nrender pass with a single pipeline, and one draw call per fragment of the output texture.`\n  )\n  .fn(async t => {\n    const kSize = 4096;\n    const module = t.device.createShaderModule({\n      code: `\n    @vertex fn vmain(@builtin(vertex_index) index: u32)\n        -> @builtin(position) vec4<f32> {\n      let position = vec2<f32>(f32(index % ${kSize}u), f32(index / ${kSize}u));\n      let r = vec2<f32>(1.0 / f32(${kSize}));\n      let a = 2.0 * r;\n      let b = r - vec2<f32>(1.0);\n      return vec4<f32>(fma(position, a, b), 0.0, 1.0);\n    }\n    @fragment fn fmain() -> @location(0) vec4<f32> {\n      return vec4<f32>(1.0, 0.0, 1.0, 1.0);\n    }\n    `,\n    });\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module, entryPoint: 'vmain', buffers: [] },\n      primitive: { topology: 'point-list' },\n      fragment: {\n        targets: [{ format: 'rgba8unorm' }],\n        module,\n        entryPoint: 'fmain',\n      },\n    });\n    const renderTarget = t.device.createTexture({\n      size: [kSize, kSize],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n    });\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          loadOp: 'load',\n          storeOp: 'store',\n        },\n      ],\n    };\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass(renderPassDescriptor);\n    pass.setPipeline(pipeline);\n    range(kSize * kSize, i => pass.draw(1, 1, i));\n    pass.end();\n    t.device.queue.submit([encoder.finish()]);\n    t.expectSingleColor(renderTarget, 'rgba8unorm', {\n      size: [kSize, kSize, 1],\n      exp: { R: 1, G: 0, B: 1, A: 1 },\n    });\n  });\n\ng.test('huge_draws')\n  .desc(\n    `Tests execution of several render passes with huge draw calls. Each pass uses a single draw\ncall which draws multiple vertices for each fragment of a large output texture.`\n  )\n  .fn(async t => {\n    const kSize = 32768;\n    const kTextureSize = 4096;\n    const kVertsPerFragment = (kSize * kSize) / (kTextureSize * kTextureSize);\n    const module = t.device.createShaderModule({\n      code: `\n    @vertex fn vmain(@builtin(vertex_index) vert_index: u32)\n        -> @builtin(position) vec4<f32> {\n      let index = vert_index / ${kVertsPerFragment}u;\n      let position = vec2<f32>(f32(index % ${kTextureSize}u), f32(index / ${kTextureSize}u));\n      let r = vec2<f32>(1.0 / f32(${kTextureSize}));\n      let a = 2.0 * r;\n      let b = r - vec2<f32>(1.0);\n      return vec4<f32>(fma(position, a, b), 0.0, 1.0);\n    }\n    @fragment fn fmain() -> @location(0) vec4<f32> {\n      return vec4<f32>(1.0, 0.0, 1.0, 1.0);\n    }\n    `,\n    });\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module, entryPoint: 'vmain', buffers: [] },\n      primitive: { topology: 'point-list' },\n      fragment: {\n        targets: [{ format: 'rgba8unorm' }],\n        module,\n        entryPoint: 'fmain',\n      },\n    });\n    const renderTarget = t.device.createTexture({\n      size: [kTextureSize, kTextureSize],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n    });\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          loadOp: 'load',\n          storeOp: 'store',\n        },\n      ],\n    };\n\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass(renderPassDescriptor);\n    pass.setPipeline(pipeline);\n    pass.draw(kSize * kSize);\n    pass.end();\n    t.device.queue.submit([encoder.finish()]);\n    t.expectSingleColor(renderTarget, 'rgba8unorm', {\n      size: [kTextureSize, kTextureSize, 1],\n      exp: { R: 1, G: 0, B: 1, A: 1 },\n    });\n  });\n"],"file":"render_pass.spec.js"}